import React from 'react';
import { Button, InputGroup, Input, Popover, PopoverHeader, PopoverBody, InputGroupAddon, InputGroupText } from 'reactstrap';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

var ReactPropTypesSecret_1 = ReactPropTypesSecret;

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

var factoryWithThrowingShims = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret_1) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  }  shim.isRequired = shim;
  function getShim() {
    return shim;
  }  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

var propTypes = createCommonjsModule(function (module) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

{
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = factoryWithThrowingShims();
}
});

class DatePickerHeader extends React.Component {
  constructor(props) {
    super(props);
  }

  displayingMinMonth() {
    if (!this.props.minDate) return false;
    var displayDate = new Date(this.props.displayDate);
    var minDate = new Date(this.props.minDate);
    return minDate.getFullYear() == displayDate.getFullYear() && minDate.getMonth() == displayDate.getMonth();
  }

  displayingMaxMonth() {
    if (!this.props.maxDate) return false;
    var displayDate = new Date(this.props.displayDate);
    var maxDate = new Date(this.props.maxDate);
    return maxDate.getFullYear() == displayDate.getFullYear() && maxDate.getMonth() == displayDate.getMonth();
  }

  handleClickPrevious() {
    var newDisplayDate = new Date(this.props.displayDate);
    newDisplayDate.setDate(1);
    newDisplayDate.setMonth(newDisplayDate.getMonth() - 1);
    this.props.onChange(newDisplayDate);
  }

  handleClickNext() {
    var newDisplayDate = new Date(this.props.displayDate);
    newDisplayDate.setDate(1);
    newDisplayDate.setMonth(newDisplayDate.getMonth() + 1);
    this.props.onChange(newDisplayDate);
  }

  render() {
    return /*#__PURE__*/React.createElement("div", {
      className: "rdp-header text-center"
    }, /*#__PURE__*/React.createElement("div", {
      className: "text-muted float-left rdp-header-previous-wrapper",
      onClick: () => this.handleClickPrevious(),
      style: {
        cursor: 'pointer'
      }
    }, this.displayingMinMonth() ? null : this.props.previousButtonElement), /*#__PURE__*/React.createElement("span", null, this.props.monthLabels[this.props.displayDate.getMonth()], " ", this.props.displayDate.getFullYear()), /*#__PURE__*/React.createElement("div", {
      className: "text-muted float-right rdp-header-next-wrapper",
      onClick: () => this.handleClickNext(),
      style: {
        cursor: 'pointer'
      }
    }, this.displayingMaxMonth() ? null : this.props.nextButtonElement));
  }

}

DatePickerHeader.propTypes = {
  displayDate: propTypes.object.isRequired,
  minDate: propTypes.string,
  maxDate: propTypes.string,
  onChange: propTypes.func.isRequired,
  monthLabels: propTypes.array.isRequired,
  previousButtonElement: propTypes.oneOfType([propTypes.string, propTypes.object]).isRequired,
  nextButtonElement: propTypes.oneOfType([propTypes.string, propTypes.object]).isRequired
};

var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

class DatePickerCalendar extends React.Component {
  constructor(props) {
    super(props);
  }

  handleClick(e) {
    var day = e.currentTarget.getAttribute('data-day');
    var newSelectedDate = this.setTimeToNoon(new Date(this.props.displayDate));
    newSelectedDate.setDate(day);
    this.props.onChange(newSelectedDate);
  }

  handleClickToday() {
    var newSelectedDate = this.setTimeToNoon(new Date());
    this.props.onChange(newSelectedDate);
  }

  setTimeToNoon(date) {
    date.setHours(12);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date;
  }

  getWeekNumber(date) {
    var target = new Date(date.valueOf());
    var dayNr = (date.getDay() + 6) % 7;
    target.setDate(target.getDate() - dayNr + 3);
    var firstThursday = target.valueOf();
    target.setMonth(0, 1);

    if (target.getDay() !== 4) {
      target.setMonth(0, 1 + (4 - target.getDay() + 7) % 7);
    }

    return 1 + Math.ceil((firstThursday - target) / 604800000);
  }

  render() {
    var currentDate = this.setTimeToNoon(new Date());
    var selectedDate = this.props.selectedDate ? this.setTimeToNoon(new Date(this.props.selectedDate)) : null;
    var minDate = this.props.minDate ? this.setTimeToNoon(new Date(this.props.minDate)) : null;
    var maxDate = this.props.maxDate ? this.setTimeToNoon(new Date(this.props.maxDate)) : null;
    var year = this.props.displayDate.getFullYear();
    var month = this.props.displayDate.getMonth();
    var firstDay = new Date(year, month, 1);
    var startingDay = this.props.weekStartsOn > 1 ? firstDay.getDay() - this.props.weekStartsOn + 7 : this.props.weekStartsOn === 1 ? firstDay.getDay() === 0 ? 6 : firstDay.getDay() - 1 : firstDay.getDay();
    var showWeeks = this.props.showWeeks;
    var monthLength = daysInMonth[month];

    if (month == 1) {
      if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {
        monthLength = 29;
      }
    }

    var weeks = [];
    var day = 1;

    for (var i = 0; i < 9; i++) {
      var week = [];

      for (var j = 0; j <= 6; j++) {
        if (day <= monthLength && (i > 0 || j >= startingDay)) {
          var className = null;
          var date = new Date(year, month, day, 12, 0, 0, 0).toISOString();
          var beforeMinDate = minDate && Date.parse(date) < Date.parse(minDate);
          var afterMinDate = maxDate && Date.parse(date) > Date.parse(maxDate);

          var clickHandler = ev => this.handleClick(ev);

          var style = {
            cursor: 'pointer',
            padding: this.props.cellPadding,
            borderRadius: this.props.roundedCorners ? 5 : 0
          };

          if (beforeMinDate || afterMinDate) {
            className = 'text-muted';
            clickHandler = null;
            style.cursor = 'default';
          } else if (Date.parse(date) === Date.parse(selectedDate)) {
            className = 'bg-primary';
          } else if (Date.parse(date) === Date.parse(currentDate)) {
            className = 'text-primary';
          }

          week.push( /*#__PURE__*/React.createElement("td", {
            key: j,
            "data-day": day,
            onClick: clickHandler,
            style: style,
            className: className
          }, day));
          day++;
        } else {
          week.push( /*#__PURE__*/React.createElement("td", {
            key: j
          }));
        }
      }

      if (showWeeks) {
        var weekNum = this.getWeekNumber(new Date(year, month, day - 1, 12, 0, 0, 0));
        week.unshift( /*#__PURE__*/React.createElement("td", {
          key: 7,
          style: {
            padding: this.props.cellPadding,
            fontSize: '0.8em',
            color: 'darkgrey'
          },
          className: "text-muted"
        }, weekNum));
      }

      weeks.push( /*#__PURE__*/React.createElement("tr", {
        key: i
      }, week));

      if (day > monthLength) {
        break;
      }
    }

    var weekColumn = showWeeks ? /*#__PURE__*/React.createElement("td", {
      className: "text-muted current-week",
      style: {
        padding: this.props.cellPadding
      }
    }) : null;
    return /*#__PURE__*/React.createElement("table", {
      className: "rdp-calendar text-center"
    }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, weekColumn, this.props.dayLabels.map((label, index) => {
      return /*#__PURE__*/React.createElement("td", {
        key: index,
        className: "text-muted",
        style: {
          padding: this.props.cellPadding
        }
      }, /*#__PURE__*/React.createElement("small", null, label));
    }))), /*#__PURE__*/React.createElement("tbody", null, weeks), this.props.showTodayButton && /*#__PURE__*/React.createElement("tfoot", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("td", {
      colSpan: this.props.dayLabels.length,
      style: {
        paddingTop: '9px'
      }
    }, /*#__PURE__*/React.createElement(Button, {
      block: true,
      size: "sm",
      className: "u-today-button",
      onClick: () => this.handleClickToday()
    }, this.props.todayButtonLabel)))));
  }

}

DatePickerCalendar.propTypes = {
  selectedDate: propTypes.object,
  displayDate: propTypes.object.isRequired,
  minDate: propTypes.string,
  maxDate: propTypes.string,
  onChange: propTypes.func.isRequired,
  dayLabels: propTypes.array.isRequired,
  cellPadding: propTypes.string.isRequired,
  weekStartsOn: propTypes.number,
  showTodayButton: propTypes.bool,
  todayButtonLabel: propTypes.string,
  roundedCorners: propTypes.bool,
  showWeeks: propTypes.bool
};

var getInstanceCount = () => {
  if (typeof window === 'object') {
    if (window._reactstrapDatePickerInstance == undefined) {
      window._reactstrapDatePickerInstance = 0;
    }

    var next = window._reactstrapDatePickerInstance + 1;
    window._reactstrapDatePickerInstance = next;
    return next;
  } else if (typeof process === 'object') {
    if (process._reactstrapDatePickerInstance == undefined) {
      process._reactstrapDatePickerInstance = 0;
    }

    var _next = process._reactstrapDatePickerInstance + 1;

    process._reactstrapDatePickerInstance = _next;
    return _next;
  } else {
    console.error("Reactstrap Date Picker cannot determine environment (it is neither browser's <window> nor Node's <process>).");
    return 1;
  }
};

class DatePicker extends React.Component {
  constructor(props) {
    super(props);

    if (this.props.value && this.props.defaultValue) {
      throw new Error('Conflicting DatePicker properties \'value\' and \'defaultValue\'');
    }

    this._inputRef = /*#__PURE__*/React.createRef();
    this.hiddenInputRef = /*#__PURE__*/React.createRef();
    this.overlayContainerRef = /*#__PURE__*/React.createRef();
    this.state = this.getInitialState();
    this.idSuffix = this.makeIdSuffix();
  }

  getInitialState() {
    var state = this.makeDateValues(this.props.value || this.props.defaultValue);

    if (this.props.weekStartsOn > 1) {
      state.dayLabels = this.props.dayLabels.slice(this.props.weekStartsOn).concat(this.props.dayLabels.slice(0, this.props.weekStartsOn));
    } else if (this.props.weekStartsOn === 1) {
      state.dayLabels = this.props.dayLabels.slice(1).concat(this.props.dayLabels.slice(0, 1));
    } else {
      state.dayLabels = this.props.dayLabels;
    }

    state.focused = false;
    state.inputFocused = false;
    state.placeholder = this.props.placeholder || this.props.dateFormat;
    state.separator = this.props.dateFormat.match(/[^A-Z]/)[0];
    return state;
  }

  makeIdSuffix() {
    // Try <id> or <name> props to determine elements' id suffix
    if (this.props.id != undefined && this.props.id != '') return this.props.id;
    if (this.props.name != undefined && this.props.name != '') return this.props.name; // If none was passed, use global vars

    var iCount = getInstanceCount();
    return iCount.toString();
  }

  get inputRef() {
    return this.props.inputRef || this._inputRef;
  }

  componentDidMount() {
    document.addEventListener('mousedown', this.onClickOutside.bind(this));
  }

  componentWillUnmount() {
    document.removeEventListener('mousedown', this.onClickOutside.bind(this));
  }

  onClickOutside(event) {
    event.stopPropagation();

    if (this.overlayContainerRef && this.overlayContainerRef.current && !this.overlayContainerRef.current.contains(event.target)) {
      var inputFocused = this.inputRef && this.inputRef.current && this.inputRef.current.contains(event.target);
      this.setState({
        focused: false,
        inputFocused: inputFocused
      });

      if (this.props.onBlur) {
        var _event = document.createEvent('CustomEvent');

        _event.initEvent('Change Date', true, false);

        this.hiddenInputRef.current.dispatchEvent(_event);
        this.props.onBlur(_event);
      }
    }
  }

  makeDateValues(isoString) {
    var displayDate;
    var selectedDate = isoString ? new Date("".concat(isoString.slice(0, 10), "T12:00:00.000Z")) : null;
    var minDate = this.props.minDate ? new Date("".concat(this.props.minDate.slice(0, 10), "T12:00:00.000Z")) : null;
    var maxDate = this.props.maxDate ? new Date("".concat(this.props.maxDate.slice(0, 10), "T12:00:00.000Z")) : null;
    var inputValue = isoString ? this.makeInputValueString(selectedDate) : null;

    if (selectedDate) {
      displayDate = new Date(selectedDate);
    } else {
      var today = new Date("".concat(new Date().toISOString().slice(0, 10), "T12:00:00.000Z"));

      if (minDate && Date.parse(minDate) >= Date.parse(today)) {
        displayDate = minDate;
      } else if (maxDate && Date.parse(maxDate) <= Date.parse(today)) {
        displayDate = maxDate;
      } else {
        displayDate = today;
      }
    }

    return {
      value: selectedDate ? selectedDate.toISOString() : null,
      displayDate: displayDate,
      selectedDate: selectedDate,
      inputValue: inputValue
    };
  }

  clear() {
    if (this.props.onClear) {
      this.props.onClear();
    } else {
      this.setState(this.makeDateValues(null));
    }

    if (this.props.onChange) {
      this.props.onChange(null, null);
    }
  }

  handleHide() {
    if (this.state.inputFocused) {
      return;
    }

    this.setState({
      focused: false
    });

    if (this.props.onBlur) {
      var event = document.createEvent('CustomEvent');
      event.initEvent('Change Date', true, false);
      this.hiddenInputRef.current.dispatchEvent(event);
      this.props.onBlur(event);
    }
  }

  handleKeyDown(e) {
    if (e.which === 9 && this.state.inputFocused) {
      this.setState({
        focused: false
      });

      if (this.props.onBlur) {
        var event = document.createEvent('CustomEvent');
        event.initEvent('Change Date', true, false);
        this.hiddenInputRef.current.dispatchEvent(event);
        this.props.onBlur(event);
      }
    }
  }

  handleFocus() {
    if (this.state.focused === true) {
      return;
    }

    var placement = this.getCalendarPlacement();
    this.setState({
      inputFocused: true,
      focused: true,
      calendarPlacement: placement
    });

    if (this.props.onFocus) {
      var event = document.createEvent('CustomEvent');
      event.initEvent('Change Date', true, false);
      this.hiddenInputRef.current.dispatchEvent(event);
      this.props.onFocus(event);
    }
  }

  handleBlur() {
    this.setState({
      inputFocused: false
    });
  }

  shouldComponentUpdate(nextProps, nextState) {
    return !(this.state.inputFocused === true && nextState.inputFocused === false);
  }

  getValue() {
    return this.state.selectedDate ? this.state.selectedDate.toISOString() : null;
  }

  getFormattedValue() {
    return this.state.displayDate ? this.state.inputValue : null;
  }

  getCalendarPlacement() {
    var tag = Object.prototype.toString.call(this.props.calendarPlacement);
    var isFunction = tag === '[object AsyncFunction]' || tag === '[object Function]' || tag === '[object GeneratorFunction]' || tag === '[object Proxy]';

    if (isFunction) {
      return this.props.calendarPlacement();
    } else {
      return this.props.calendarPlacement;
    }
  }

  makeInputValueString(date) {
    var month = date.getMonth() + 1;
    var day = date.getDate(); //this method is executed during intialState setup... handle a missing state properly

    var separator = this.state ? this.state.separator : this.props.dateFormat.match(/[^A-Z]/)[0];

    if (this.props.dateFormat.match(/MM.DD.YYYY/)) {
      return (month > 9 ? month : "0".concat(month)) + separator + (day > 9 ? day : "0".concat(day)) + separator + date.getFullYear();
    } else if (this.props.dateFormat.match(/DD.MM.YYYY/)) {
      return (day > 9 ? day : "0".concat(day)) + separator + (month > 9 ? month : "0".concat(month)) + separator + date.getFullYear();
    } else {
      return date.getFullYear() + separator + (month > 9 ? month : "0".concat(month)) + separator + (day > 9 ? day : "0".concat(day));
    }
  }

  handleBadInput(originalValue) {
    var parts = originalValue.replace(new RegExp("[^0-9".concat(this.state.separator, "]")), '').split(this.state.separator);

    if (this.props.dateFormat.match(/MM.DD.YYYY/) || this.props.dateFormat.match(/DD.MM.YYYY/)) {
      if (parts[0] && parts[0].length > 2) {
        parts[1] = parts[0].slice(2) + (parts[1] || '');
        parts[0] = parts[0].slice(0, 2);
      }

      if (parts[1] && parts[1].length > 2) {
        parts[2] = parts[1].slice(2) + (parts[2] || '');
        parts[1] = parts[1].slice(0, 2);
      }

      if (parts[2]) {
        parts[2] = parts[2].slice(0, 4);
      }
    } else {
      if (parts[0] && parts[0].length > 4) {
        parts[1] = parts[0].slice(4) + (parts[1] || '');
        parts[0] = parts[0].slice(0, 4);
      }

      if (parts[1] && parts[1].length > 2) {
        parts[2] = parts[1].slice(2) + (parts[2] || '');
        parts[1] = parts[1].slice(0, 2);
      }

      if (parts[2]) {
        parts[2] = parts[2].slice(0, 2);
      }
    }

    this.setState({
      inputValue: parts.join(this.state.separator)
    });
  }

  handleInputChange() {
    var originalValue = this.inputRef.current.value;
    var inputValue = originalValue.replace(/(-|\/\/)/g, this.state.separator).slice(0, 10);

    if (!inputValue) {
      this.clear();
      return;
    }

    var month, day, year;

    if (this.props.dateFormat.match(/MM.DD.YYYY/)) {
      if (!inputValue.match(/[0-1][0-9].[0-3][0-9].[1-2][0-9][0-9][0-9]/)) {
        return this.handleBadInput(originalValue);
      }

      month = inputValue.slice(0, 2).replace(/[^0-9]/g, '');
      day = inputValue.slice(3, 5).replace(/[^0-9]/g, '');
      year = inputValue.slice(6, 10).replace(/[^0-9]/g, '');
    } else if (this.props.dateFormat.match(/DD.MM.YYYY/)) {
      if (!inputValue.match(/[0-3][0-9].[0-1][0-9].[1-2][0-9][0-9][0-9]/)) {
        return this.handleBadInput(originalValue);
      }

      day = inputValue.slice(0, 2).replace(/[^0-9]/g, '');
      month = inputValue.slice(3, 5).replace(/[^0-9]/g, '');
      year = inputValue.slice(6, 10).replace(/[^0-9]/g, '');
    } else {
      if (!inputValue.match(/[1-2][0-9][0-9][0-9].[0-1][0-9].[0-3][0-9]/)) {
        return this.handleBadInput(originalValue);
      }

      year = inputValue.slice(0, 4).replace(/[^0-9]/g, '');
      month = inputValue.slice(5, 7).replace(/[^0-9]/g, '');
      day = inputValue.slice(8, 10).replace(/[^0-9]/g, '');
    }

    var monthInteger = parseInt(month, 10);
    var dayInteger = parseInt(day, 10);
    var yearInteger = parseInt(year, 10);

    if (monthInteger > 12 || dayInteger > 31) {
      return this.handleBadInput(originalValue);
    }

    if (!isNaN(monthInteger) && !isNaN(dayInteger) && !isNaN(yearInteger) && monthInteger <= 12 && dayInteger <= 31 && yearInteger > 999) {
      var selectedDate = new Date(yearInteger, monthInteger - 1, dayInteger, 12, 0, 0, 0);
      this.setState({
        selectedDate: selectedDate,
        displayDate: selectedDate,
        value: selectedDate.toISOString()
      });

      if (this.props.onChange) {
        this.props.onChange(selectedDate.toISOString(), inputValue);
      }
    }

    this.setState({
      inputValue: inputValue
    });
  }

  onChangeMonth(newDisplayDate) {
    this.setState({
      displayDate: newDisplayDate
    });
  }

  onChangeDate(newSelectedDate) {
    var inputValue = this.makeInputValueString(newSelectedDate);
    this.setState({
      inputValue: inputValue,
      selectedDate: newSelectedDate,
      displayDate: newSelectedDate,
      value: newSelectedDate.toISOString(),
      focused: false
    });

    if (this.props.onBlur) {
      var event = document.createEvent('CustomEvent');
      event.initEvent('Change Date', true, false);
      this.hiddenInputRef.current.dispatchEvent(event);
      this.props.onBlur(event);
    }

    if (this.props.onChange) {
      this.props.onChange(newSelectedDate.toISOString(), inputValue);
    }
  }

  UNSAFE_componentWillReceiveProps(newProps) {
    var value = newProps.value;

    if (this.getValue() !== value) {
      this.setState(this.makeDateValues(value));
    }
  }

  renderInputGroup(children) {
    if (this.props.customInputGroup != undefined) return /*#__PURE__*/React.cloneElement(this.props.customInputGroup, {
      children: children
    });
    return /*#__PURE__*/React.createElement(InputGroup, {
      size: this.props.size,
      id: "rdp-input-group-".concat(this.idSuffix),
      className: "rdp-input-group".concat(this.props.invalid ? ' is-invalid' : '').concat(this.props.valid ? ' is-valid' : '')
    }, children);
  }

  render() {
    var calendarHeader = /*#__PURE__*/React.createElement(DatePickerHeader, {
      previousButtonElement: this.props.previousButtonElement,
      nextButtonElement: this.props.nextButtonElement,
      displayDate: this.state.displayDate,
      minDate: this.props.minDate,
      maxDate: this.props.maxDate,
      onChange: newDisplayDate => this.onChangeMonth(newDisplayDate),
      monthLabels: this.props.monthLabels,
      dateFormat: this.props.dateFormat
    });
    var calendar = /*#__PURE__*/React.createElement(DatePickerCalendar, {
      cellPadding: this.props.cellPadding,
      selectedDate: this.state.selectedDate,
      displayDate: this.state.displayDate,
      onChange: newSelectedDate => this.onChangeDate(newSelectedDate),
      dayLabels: this.state.dayLabels,
      weekStartsOn: this.props.weekStartsOn,
      showTodayButton: this.props.showTodayButton,
      todayButtonLabel: this.props.todayButtonLabel,
      minDate: this.props.minDate,
      maxDate: this.props.maxDate,
      roundedCorners: this.props.roundedCorners,
      showWeeks: this.props.showWeeks
    });
    var controlId = "rdp-form-control-".concat(this.idSuffix);

    if (this.props.customControl != undefined && this.props.customControl.props.id) {
      controlId = this.props.customControl.props.id;
    }

    var control = this.props.customControl ? /*#__PURE__*/React.cloneElement(this.props.customControl, {
      id: controlId,
      onKeyDown: e => this.handleKeyDown(e),
      value: this.state.inputValue || '',
      required: this.props.required,
      placeholder: this.state.focused ? this.props.dateFormat : this.state.placeholder,
      ref: this.inputRef,
      disabled: this.props.disabled,
      onFocus: () => this.handleFocus(),
      onBlur: () => this.handleBlur(),
      onChange: () => this.handleInputChange(),
      className: "rdp-form-control ".concat(this.props.className || '', " ").concat(this.props.customControl.props.className || ''),
      style: _objectSpread2(_objectSpread2({}, this.props.customControl.props.style || {}), this.props.style || {}),
      autoComplete: this.props.autoComplete,
      onInvalid: this.props.onInvalid,
      noValidate: this.props.noValidate
    }) : /*#__PURE__*/React.createElement(Input, {
      id: controlId,
      onKeyDown: e => this.handleKeyDown(e),
      value: this.state.inputValue || '',
      required: this.props.required,
      innerRef: this.inputRef,
      type: "text",
      className: "rdp-form-control ".concat(this.props.className || ''),
      style: this.props.style,
      autoFocus: this.props.autoFocus,
      disabled: this.props.disabled,
      placeholder: this.state.focused ? this.props.dateFormat : this.state.placeholder,
      onFocus: () => this.handleFocus(),
      onBlur: () => this.handleBlur(),
      onChange: () => this.handleInputChange(),
      autoComplete: this.props.autoComplete,
      onInvalid: this.props.onInvalid,
      noValidate: this.props.noValidate
    });
    return this.renderInputGroup( /*#__PURE__*/React.createElement(React.Fragment, null, control, /*#__PURE__*/React.createElement(Popover, {
      className: "rdp-popover ".concat(this.state.calendarPlacement),
      toggle: () => this.handleHide(),
      isOpen: this.state.focused,
      container: this.props.calendarContainer || this.overlayContainerRef.current,
      target: controlId,
      placement: this.state.calendarPlacement,
      delay: 200
    }, /*#__PURE__*/React.createElement(PopoverHeader, {
      tag: "div"
    }, calendarHeader), /*#__PURE__*/React.createElement(PopoverBody, null, calendar)), /*#__PURE__*/React.createElement("div", {
      ref: this.overlayContainerRef,
      className: "rdp-overlay"
    }), /*#__PURE__*/React.createElement("input", {
      ref: this.hiddenInputRef,
      type: "hidden",
      className: "rdp-hidden",
      id: this.props.id != undefined ? this.props.id : "rdp-hidden-".concat(this.idSuffix),
      name: this.props.name,
      value: this.state.value || '',
      "data-formattedvalue": this.state.value ? this.state.inputValue : ''
    }), this.props.showClearButton && !this.props.customControl && /*#__PURE__*/React.createElement(InputGroupAddon, {
      onClick: () => this.props.disabled ? null : this.clear(),
      style: {
        cursor: this.state.inputValue && !this.props.disabled ? 'pointer' : 'not-allowed'
      },
      addonType: "append",
      className: "rdp-addon"
    }, /*#__PURE__*/React.createElement(InputGroupText, {
      style: {
        opacity: this.state.inputValue && !this.props.disabled ? 1 : 0.5
      }
    }, this.props.clearButtonElement)), this.props.children));
  }

}

DatePicker.propTypes = {
  defaultValue: propTypes.string,
  value: propTypes.string,
  required: propTypes.bool,
  className: propTypes.string,
  style: propTypes.object,
  minDate: propTypes.string,
  maxDate: propTypes.string,
  cellPadding: propTypes.string,
  autoComplete: propTypes.string,
  placeholder: propTypes.string,
  dayLabels: propTypes.array,
  monthLabels: propTypes.array,
  onChange: propTypes.func,
  onClear: propTypes.func,
  onBlur: propTypes.func,
  onFocus: propTypes.func,
  autoFocus: propTypes.bool,
  disabled: propTypes.bool,
  weekStartsOn: propTypes.number,
  clearButtonElement: propTypes.oneOfType([propTypes.string, propTypes.object]),
  showClearButton: propTypes.bool,
  previousButtonElement: propTypes.oneOfType([propTypes.string, propTypes.object]),
  nextButtonElement: propTypes.oneOfType([propTypes.string, propTypes.object]),
  calendarPlacement: propTypes.oneOfType([propTypes.string, propTypes.func]),
  dateFormat: propTypes.string,
  // 'MM/DD/YYYY', 'DD/MM/YYYY', 'YYYY/MM/DD', 'DD-MM-YYYY'
  size: propTypes.string,
  calendarContainer: propTypes.object,
  id: propTypes.string,
  name: propTypes.string,
  showTodayButton: propTypes.bool,
  todayButtonLabel: propTypes.string,
  customControl: propTypes.object,
  roundedCorners: propTypes.bool,
  showWeeks: propTypes.bool,
  children: propTypes.oneOfType([propTypes.arrayOf(propTypes.node), propTypes.node]),
  onInvalid: propTypes.func,
  noValidate: propTypes.bool,
  valid: propTypes.bool,
  invalid: propTypes.bool,
  customInputGroup: propTypes.object
};

var defaultDateFormat = () => {
  var language = typeof window !== 'undefined' && window.navigator ? (window.navigator.userLanguage || window.navigator.language || '').toLowerCase() : '';
  var dateFormat = !language || language === 'en-us' ? 'MM/DD/YYYY' : 'DD/MM/YYYY';
  return dateFormat;
};

DatePicker.defaultProps = {
  cellPadding: '5px',
  dayLabels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  monthLabels: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
  clearButtonElement: '×',
  previousButtonElement: '<',
  nextButtonElement: '>',
  calendarPlacement: 'bottom',
  dateFormat: defaultDateFormat(),
  showClearButton: true,
  autoFocus: false,
  disabled: false,
  showTodayButton: false,
  todayButtonLabel: 'Today',
  autoComplete: 'on',
  showWeeks: false,

  /*style: {
    width: '100%'
  },*/
  roundedCorners: false,
  noValidate: false
};

export default DatePicker;
