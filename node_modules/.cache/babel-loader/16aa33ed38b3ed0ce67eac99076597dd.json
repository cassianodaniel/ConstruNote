{"ast":null,"code":"'use strict';\n\nconst resolve = require('./resolve');\n\nconst {\n  promise\n} = require('@xmpp/events');\n\nasync function fetchURIs(domain) {\n  return [// Remove duplicates\n  ...new Set((await resolve(domain, {\n    srv: [{\n      service: 'xmpps-client',\n      protocol: 'tcp'\n    }, {\n      service: 'xmpp-client',\n      protocol: 'tcp'\n    }]\n  })).map(record => record.uri))];\n}\n\nfunction filterSupportedURIs(entity, uris) {\n  return uris.filter(uri => entity._findTransport(uri));\n}\n\nasync function fallbackConnect(entity, uris) {\n  if (uris.length === 0) {\n    throw new Error(\"Couldn't connect\");\n  }\n\n  const uri = uris.shift();\n\n  const Transport = entity._findTransport(uri);\n\n  if (!Transport) {\n    return fallbackConnect(entity, uris);\n  }\n\n  entity._status('connecting', uri);\n\n  const params = Transport.prototype.socketParameters(uri);\n  const socket = new Transport.prototype.Socket();\n\n  try {\n    socket.connect(params);\n    await promise(socket, 'connect'); // eslint-disable-next-line no-unused-vars\n  } catch (err) {\n    return fallbackConnect(entity, uris);\n  }\n\n  entity._attachSocket(socket);\n\n  socket.emit('connect');\n  entity.Transport = Transport;\n  entity.Socket = Transport.prototype.Socket;\n  entity.Parser = Transport.prototype.Parser;\n}\n\nmodule.exports = function ({\n  entity\n}) {\n  const _connect = entity.connect;\n\n  entity.connect = async function connect(service) {\n    if (!service || service.match(/:\\/\\//)) {\n      return _connect.call(this, service);\n    }\n\n    const uris = filterSupportedURIs(entity, await fetchURIs(service));\n\n    if (uris.length === 0) {\n      throw new Error('No compatible transport found.');\n    }\n\n    try {\n      await fallbackConnect(entity, uris);\n    } catch (err) {\n      entity._reset();\n\n      entity._status('disconnect');\n\n      throw err;\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/resolve/index.js"],"names":["resolve","require","promise","fetchURIs","domain","Set","srv","service","protocol","map","record","uri","filterSupportedURIs","entity","uris","filter","_findTransport","fallbackConnect","length","Error","shift","Transport","_status","params","prototype","socketParameters","socket","Socket","connect","err","_attachSocket","emit","Parser","module","exports","_connect","match","call","_reset"],"mappings":"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","sourcesContent":["'use strict'\n\nconst resolve = require('./resolve')\nconst {promise} = require('@xmpp/events')\n\nasync function fetchURIs(domain) {\n  return [\n    // Remove duplicates\n    ...new Set(\n      (\n        await resolve(domain, {\n          srv: [\n            {\n              service: 'xmpps-client',\n              protocol: 'tcp',\n            },\n            {\n              service: 'xmpp-client',\n              protocol: 'tcp',\n            },\n          ],\n        })\n      ).map(record => record.uri)\n    ),\n  ]\n}\n\nfunction filterSupportedURIs(entity, uris) {\n  return uris.filter(uri => entity._findTransport(uri))\n}\n\nasync function fallbackConnect(entity, uris) {\n  if (uris.length === 0) {\n    throw new Error(\"Couldn't connect\")\n  }\n\n  const uri = uris.shift()\n  const Transport = entity._findTransport(uri)\n\n  if (!Transport) {\n    return fallbackConnect(entity, uris)\n  }\n\n  entity._status('connecting', uri)\n  const params = Transport.prototype.socketParameters(uri)\n  const socket = new Transport.prototype.Socket()\n\n  try {\n    socket.connect(params)\n    await promise(socket, 'connect')\n    // eslint-disable-next-line no-unused-vars\n  } catch (err) {\n    return fallbackConnect(entity, uris)\n  }\n\n  entity._attachSocket(socket)\n  socket.emit('connect')\n  entity.Transport = Transport\n  entity.Socket = Transport.prototype.Socket\n  entity.Parser = Transport.prototype.Parser\n}\n\nmodule.exports = function({entity}) {\n  const _connect = entity.connect\n  entity.connect = async function connect(service) {\n    if (!service || service.match(/:\\/\\//)) {\n      return _connect.call(this, service)\n    }\n\n    const uris = filterSupportedURIs(entity, await fetchURIs(service))\n\n    if (uris.length === 0) {\n      throw new Error('No compatible transport found.')\n    }\n\n    try {\n      await fallbackConnect(entity, uris)\n    } catch (err) {\n      entity._reset()\n      entity._status('disconnect')\n      throw err\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}