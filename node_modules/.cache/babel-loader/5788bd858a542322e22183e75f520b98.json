{"ast":null,"code":"import { __assign } from \"tslib\";\n/**\n * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js\n * with some tweaks\n */\n\nvar DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g; // trim patterns after transformations\n\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\nfunction matchSkeletonPattern(match, result) {\n  var len = match.length;\n\n  switch (match[0]) {\n    // Era\n    case 'G':\n      result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n      return '{era}';\n    // Year\n\n    case 'y':\n    case 'Y':\n    case 'u':\n    case 'U':\n    case 'r':\n      result.year = len === 2 ? '2-digit' : 'numeric';\n      return '{year}';\n    // Quarter\n\n    case 'q':\n    case 'Q':\n      throw new RangeError('`w/Q` (quarter) patterns are not supported');\n    // Month\n\n    case 'M':\n    case 'L':\n      result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];\n      return '{month}';\n    // Week\n\n    case 'w':\n    case 'W':\n      throw new RangeError('`w/W` (week of year) patterns are not supported');\n\n    case 'd':\n      result.day = ['numeric', '2-digit'][len - 1];\n      return '{day}';\n\n    case 'D':\n    case 'F':\n    case 'g':\n      result.day = 'numeric';\n      return '{day}';\n    // Weekday\n\n    case 'E':\n      result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n      return '{weekday}';\n\n    case 'e':\n      result.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][len - 1];\n      return '{weekday}';\n\n    case 'c':\n      result.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][len - 1];\n      return '{weekday}';\n    // Period\n\n    case 'a': // AM, PM\n\n    case 'b': // am, pm, noon, midnight\n\n    case 'B':\n      // flexible day periods\n      result.hour12 = true;\n      return '{ampm}';\n    // Hour\n\n    case 'h':\n      result.hour = ['numeric', '2-digit'][len - 1];\n      result.hour12 = true;\n      return '{hour}';\n\n    case 'H':\n      result.hour = ['numeric', '2-digit'][len - 1];\n      return '{hour}';\n\n    case 'K':\n      result.hour = ['numeric', '2-digit'][len - 1];\n      result.hour12 = true;\n      return '{hour}';\n\n    case 'k':\n      result.hour = ['numeric', '2-digit'][len - 1];\n      return '{hour}';\n\n    case 'j':\n    case 'J':\n    case 'C':\n      throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');\n    // Minute\n\n    case 'm':\n      result.minute = ['numeric', '2-digit'][len - 1];\n      return '{minute}';\n    // Second\n\n    case 's':\n      result.second = ['numeric', '2-digit'][len - 1];\n      return '{second}';\n\n    case 'S':\n    case 'A':\n      result.second = 'numeric';\n      return '{second}';\n    // Zone\n\n    case 'z': // 1..3, 4: specific non-location format\n\n    case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n\n    case 'O': // 1, 4: miliseconds in day short, long\n\n    case 'v': // 1, 4: generic non-location format\n\n    case 'V': // 1, 2, 3, 4: time zone ID or city\n\n    case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n\n    case 'x':\n      // 1, 2, 3, 4: The ISO8601 varios formats\n      result.timeZoneName = len < 4 ? 'short' : 'long';\n      return '{timeZoneName}';\n  }\n\n  return '';\n}\n\nfunction skeletonTokenToTable2(c) {\n  switch (c) {\n    // Era\n    case 'G':\n      return 'era';\n    // Year\n\n    case 'y':\n    case 'Y':\n    case 'u':\n    case 'U':\n    case 'r':\n      return 'year';\n    // Month\n\n    case 'M':\n    case 'L':\n      return 'month';\n    // Day\n\n    case 'd':\n    case 'D':\n    case 'F':\n    case 'g':\n      return 'day';\n    // Period\n\n    case 'a': // AM, PM\n\n    case 'b': // am, pm, noon, midnight\n\n    case 'B':\n      // flexible day periods\n      return 'ampm';\n    // Hour\n\n    case 'h':\n    case 'H':\n    case 'K':\n    case 'k':\n      return 'hour';\n    // Minute\n\n    case 'm':\n      return 'minute';\n    // Second\n\n    case 's':\n    case 'S':\n    case 'A':\n      return 'second';\n\n    default:\n      throw new RangeError('Invalid range pattern token');\n  }\n}\n\nexport function processDateTimePattern(pattern, result) {\n  var literals = []; // Use skeleton to populate result, but use mapped pattern to populate pattern\n\n  var pattern12 = pattern // Double apostrophe\n  .replace(/'{2}/g, '{apostrophe}') // Apostrophe-escaped\n  .replace(/'(.*?)'/g, function (_, literal) {\n    literals.push(literal);\n    return \"$$\" + (literals.length - 1) + \"$$\";\n  }).replace(DATE_TIME_REGEX, function (m) {\n    return matchSkeletonPattern(m, result || {});\n  }); //Restore literals\n\n  if (literals.length) {\n    pattern12 = pattern12.replace(/\\$\\$(\\d+)\\$\\$/g, function (_, i) {\n      return literals[+i];\n    }).replace(/\\{apostrophe\\}/g, \"'\");\n  } // Handle apostrophe-escaped things\n\n\n  return [pattern12.replace(/([\\s\\uFEFF\\xA0])\\{ampm\\}([\\s\\uFEFF\\xA0])/, '$1').replace('{ampm}', '').replace(expPatternTrimmer, ''), pattern12];\n}\n/**\n * Parse Date time skeleton into Intl.DateTimeFormatOptions\n * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * @public\n * @param skeleton skeleton string\n */\n\nexport function parseDateTimeSkeleton(skeleton, rawPattern, rangePatterns, intervalFormatFallback) {\n  if (rawPattern === void 0) {\n    rawPattern = skeleton;\n  }\n\n  var result = {\n    pattern: '',\n    pattern12: '',\n    skeleton: skeleton,\n    rawPattern: rawPattern,\n    rangePatterns: {},\n    rangePatterns12: {}\n  };\n\n  if (rangePatterns) {\n    for (var k in rangePatterns) {\n      var key = skeletonTokenToTable2(k);\n      var rawPattern_1 = rangePatterns[k];\n      var intervalResult = {\n        patternParts: []\n      };\n\n      var _a = processDateTimePattern(rawPattern_1, intervalResult),\n          pattern_1 = _a[0],\n          pattern12_1 = _a[1];\n\n      result.rangePatterns[key] = __assign(__assign({}, intervalResult), {\n        patternParts: splitRangePattern(pattern_1)\n      });\n      result.rangePatterns12[key] = __assign(__assign({}, intervalResult), {\n        patternParts: splitRangePattern(pattern12_1)\n      });\n    }\n  } else if (intervalFormatFallback) {\n    var patternParts = splitFallbackRangePattern(intervalFormatFallback);\n    result.rangePatterns.default = {\n      patternParts: patternParts\n    };\n    result.rangePatterns12.default = {\n      patternParts: patternParts\n    };\n  } // Process skeleton\n\n\n  skeleton.replace(DATE_TIME_REGEX, function (m) {\n    return matchSkeletonPattern(m, result);\n  });\n\n  var _b = processDateTimePattern(rawPattern),\n      pattern = _b[0],\n      pattern12 = _b[1];\n\n  result.pattern = pattern;\n  result.pattern12 = pattern12;\n  return result;\n}\nexport function splitFallbackRangePattern(pattern) {\n  var parts = pattern.split(/(\\{[0|1]\\})/g).filter(Boolean);\n  return parts.map(function (pattern) {\n    switch (pattern) {\n      case '{0}':\n        return {\n          source: \"startRange\"\n          /* startRange */\n          ,\n          pattern: pattern\n        };\n\n      case '{1}':\n        return {\n          source: \"endRange\"\n          /* endRange */\n          ,\n          pattern: pattern\n        };\n\n      default:\n        return {\n          source: \"shared\"\n          /* shared */\n          ,\n          pattern: pattern\n        };\n    }\n  });\n}\nexport function splitRangePattern(pattern) {\n  var PART_REGEX = /\\{(.*?)\\}/g; // Map of part and index within the string\n\n  var parts = {};\n  var match;\n  var splitIndex = 0;\n\n  while (match = PART_REGEX.exec(pattern)) {\n    if (!(match[0] in parts)) {\n      parts[match[0]] = match.index;\n    } else {\n      splitIndex = match.index;\n      break;\n    }\n  }\n\n  if (!splitIndex) {\n    return [{\n      source: \"startRange\"\n      /* startRange */\n      ,\n      pattern: pattern\n    }];\n  }\n\n  return [{\n    source: \"startRange\"\n    /* startRange */\n    ,\n    pattern: pattern.slice(0, splitIndex)\n  }, {\n    source: \"endRange\"\n    /* endRange */\n    ,\n    pattern: pattern.slice(splitIndex)\n  }];\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@formatjs/ecma402-abstract/lib/src/DateTimeFormat/skeleton.js"],"names":["__assign","DATE_TIME_REGEX","expPatternTrimmer","matchSkeletonPattern","match","result","len","length","era","year","RangeError","month","day","weekday","undefined","hour12","hour","minute","second","timeZoneName","skeletonTokenToTable2","c","processDateTimePattern","pattern","literals","pattern12","replace","_","literal","push","m","i","parseDateTimeSkeleton","skeleton","rawPattern","rangePatterns","intervalFormatFallback","rangePatterns12","k","key","rawPattern_1","intervalResult","patternParts","_a","pattern_1","pattern12_1","splitRangePattern","splitFallbackRangePattern","default","_b","parts","split","filter","Boolean","map","source","PART_REGEX","splitIndex","exec","index","slice"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\n/**\n * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js\n * with some tweaks\n */\nvar DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nfunction matchSkeletonPattern(match, result) {\n    var len = match.length;\n    switch (match[0]) {\n        // Era\n        case 'G':\n            result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n            return '{era}';\n        // Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            result.year = len === 2 ? '2-digit' : 'numeric';\n            return '{year}';\n        // Quarter\n        case 'q':\n        case 'Q':\n            throw new RangeError('`w/Q` (quarter) patterns are not supported');\n        // Month\n        case 'M':\n        case 'L':\n            result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];\n            return '{month}';\n        // Week\n        case 'w':\n        case 'W':\n            throw new RangeError('`w/W` (week of year) patterns are not supported');\n        case 'd':\n            result.day = ['numeric', '2-digit'][len - 1];\n            return '{day}';\n        case 'D':\n        case 'F':\n        case 'g':\n            result.day = 'numeric';\n            return '{day}';\n        // Weekday\n        case 'E':\n            result.weekday = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n            return '{weekday}';\n        case 'e':\n            result.weekday = [\n                'numeric',\n                '2-digit',\n                'short',\n                'long',\n                'narrow',\n                'short',\n            ][len - 1];\n            return '{weekday}';\n        case 'c':\n            result.weekday = [\n                'numeric',\n                undefined,\n                'short',\n                'long',\n                'narrow',\n                'short',\n            ][len - 1];\n            return '{weekday}';\n        // Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B': // flexible day periods\n            result.hour12 = true;\n            return '{ampm}';\n        // Hour\n        case 'h':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            result.hour12 = true;\n            return '{hour}';\n        case 'H':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            return '{hour}';\n        case 'K':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            result.hour12 = true;\n            return '{hour}';\n        case 'k':\n            result.hour = ['numeric', '2-digit'][len - 1];\n            return '{hour}';\n        case 'j':\n        case 'J':\n        case 'C':\n            throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');\n        // Minute\n        case 'm':\n            result.minute = ['numeric', '2-digit'][len - 1];\n            return '{minute}';\n        // Second\n        case 's':\n            result.second = ['numeric', '2-digit'][len - 1];\n            return '{second}';\n        case 'S':\n        case 'A':\n            result.second = 'numeric';\n            return '{second}';\n        // Zone\n        case 'z': // 1..3, 4: specific non-location format\n        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n        case 'O': // 1, 4: miliseconds in day short, long\n        case 'v': // 1, 4: generic non-location format\n        case 'V': // 1, 2, 3, 4: time zone ID or city\n        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n        case 'x': // 1, 2, 3, 4: The ISO8601 varios formats\n            result.timeZoneName = len < 4 ? 'short' : 'long';\n            return '{timeZoneName}';\n    }\n    return '';\n}\nfunction skeletonTokenToTable2(c) {\n    switch (c) {\n        // Era\n        case 'G':\n            return 'era';\n        // Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            return 'year';\n        // Month\n        case 'M':\n        case 'L':\n            return 'month';\n        // Day\n        case 'd':\n        case 'D':\n        case 'F':\n        case 'g':\n            return 'day';\n        // Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B': // flexible day periods\n            return 'ampm';\n        // Hour\n        case 'h':\n        case 'H':\n        case 'K':\n        case 'k':\n            return 'hour';\n        // Minute\n        case 'm':\n            return 'minute';\n        // Second\n        case 's':\n        case 'S':\n        case 'A':\n            return 'second';\n        default:\n            throw new RangeError('Invalid range pattern token');\n    }\n}\nexport function processDateTimePattern(pattern, result) {\n    var literals = [];\n    // Use skeleton to populate result, but use mapped pattern to populate pattern\n    var pattern12 = pattern\n        // Double apostrophe\n        .replace(/'{2}/g, '{apostrophe}')\n        // Apostrophe-escaped\n        .replace(/'(.*?)'/g, function (_, literal) {\n        literals.push(literal);\n        return \"$$\" + (literals.length - 1) + \"$$\";\n    })\n        .replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result || {}); });\n    //Restore literals\n    if (literals.length) {\n        pattern12 = pattern12\n            .replace(/\\$\\$(\\d+)\\$\\$/g, function (_, i) {\n            return literals[+i];\n        })\n            .replace(/\\{apostrophe\\}/g, \"'\");\n    }\n    // Handle apostrophe-escaped things\n    return [\n        pattern12\n            .replace(/([\\s\\uFEFF\\xA0])\\{ampm\\}([\\s\\uFEFF\\xA0])/, '$1')\n            .replace('{ampm}', '')\n            .replace(expPatternTrimmer, ''),\n        pattern12,\n    ];\n}\n/**\n * Parse Date time skeleton into Intl.DateTimeFormatOptions\n * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * @public\n * @param skeleton skeleton string\n */\nexport function parseDateTimeSkeleton(skeleton, rawPattern, rangePatterns, intervalFormatFallback) {\n    if (rawPattern === void 0) { rawPattern = skeleton; }\n    var result = {\n        pattern: '',\n        pattern12: '',\n        skeleton: skeleton,\n        rawPattern: rawPattern,\n        rangePatterns: {},\n        rangePatterns12: {},\n    };\n    if (rangePatterns) {\n        for (var k in rangePatterns) {\n            var key = skeletonTokenToTable2(k);\n            var rawPattern_1 = rangePatterns[k];\n            var intervalResult = {\n                patternParts: [],\n            };\n            var _a = processDateTimePattern(rawPattern_1, intervalResult), pattern_1 = _a[0], pattern12_1 = _a[1];\n            result.rangePatterns[key] = __assign(__assign({}, intervalResult), { patternParts: splitRangePattern(pattern_1) });\n            result.rangePatterns12[key] = __assign(__assign({}, intervalResult), { patternParts: splitRangePattern(pattern12_1) });\n        }\n    }\n    else if (intervalFormatFallback) {\n        var patternParts = splitFallbackRangePattern(intervalFormatFallback);\n        result.rangePatterns.default = {\n            patternParts: patternParts,\n        };\n        result.rangePatterns12.default = {\n            patternParts: patternParts,\n        };\n    }\n    // Process skeleton\n    skeleton.replace(DATE_TIME_REGEX, function (m) { return matchSkeletonPattern(m, result); });\n    var _b = processDateTimePattern(rawPattern), pattern = _b[0], pattern12 = _b[1];\n    result.pattern = pattern;\n    result.pattern12 = pattern12;\n    return result;\n}\nexport function splitFallbackRangePattern(pattern) {\n    var parts = pattern.split(/(\\{[0|1]\\})/g).filter(Boolean);\n    return parts.map(function (pattern) {\n        switch (pattern) {\n            case '{0}':\n                return {\n                    source: \"startRange\" /* startRange */,\n                    pattern: pattern,\n                };\n            case '{1}':\n                return {\n                    source: \"endRange\" /* endRange */,\n                    pattern: pattern,\n                };\n            default:\n                return {\n                    source: \"shared\" /* shared */,\n                    pattern: pattern,\n                };\n        }\n    });\n}\nexport function splitRangePattern(pattern) {\n    var PART_REGEX = /\\{(.*?)\\}/g;\n    // Map of part and index within the string\n    var parts = {};\n    var match;\n    var splitIndex = 0;\n    while ((match = PART_REGEX.exec(pattern))) {\n        if (!(match[0] in parts)) {\n            parts[match[0]] = match.index;\n        }\n        else {\n            splitIndex = match.index;\n            break;\n        }\n    }\n    if (!splitIndex) {\n        return [\n            {\n                source: \"startRange\" /* startRange */,\n                pattern: pattern,\n            },\n        ];\n    }\n    return [\n        {\n            source: \"startRange\" /* startRange */,\n            pattern: pattern.slice(0, splitIndex),\n        },\n        {\n            source: \"endRange\" /* endRange */,\n            pattern: pattern.slice(splitIndex),\n        },\n    ];\n}\n"]},"metadata":{},"sourceType":"module"}