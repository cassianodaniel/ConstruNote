{"ast":null,"code":"import { C, NameAddrHeader } from \"../messages\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { ReSubscribeUserAgentClient } from \"../user-agents/re-subscribe-user-agent-client\";\nimport { Dialog } from \"./dialog\";\n/**\n * Subscription Dialog.\n * @remarks\n * SIP-Specific Event Notification\n *\n * Abstract\n *\n *    This document describes an extension to the Session Initiation\n *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n *    to provide an extensible framework by which SIP nodes can request\n *    notification from remote nodes indicating that certain events have\n *    occurred.\n *\n *    Note that the event notification mechanisms defined herein are NOT\n *    intended to be a general-purpose infrastructure for all classes of\n *    event subscription and notification.\n *\n *    This document represents a backwards-compatible improvement on the\n *    original mechanism described by RFC 3265, taking into account several\n *    years of implementation experience.  Accordingly, this document\n *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to\n *    accommodate some small changes to the mechanism that were discussed\n *    in that document.\n *\n *  https://tools.ietf.org/html/rfc6665\n * @public\n */\n\nexport class SubscriptionDialog extends Dialog {\n  constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {\n    super(core, state);\n    this.delegate = delegate;\n    this._autoRefresh = false;\n    this._subscriptionEvent = subscriptionEvent;\n    this._subscriptionExpires = subscriptionExpires;\n    this._subscriptionExpiresInitial = subscriptionExpires;\n    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n    this._subscriptionRefresh = undefined;\n    this._subscriptionRefreshLastSet = undefined;\n    this._subscriptionState = subscriptionState;\n    this.logger = core.loggerFactory.getLogger(\"sip.subscribe-dialog\");\n    this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);\n  }\n  /**\n   * When a UAC receives a response that establishes a dialog, it\n   * constructs the state of the dialog.  This state MUST be maintained\n   * for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.2\n   * @param outgoingRequestMessage - Outgoing request message for dialog.\n   * @param incomingResponseMessage - Incoming response message creating dialog.\n   */\n\n\n  static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {\n    // If the request was sent over TLS, and the Request-URI contained a\n    // SIPS URI, the \"secure\" flag is set to TRUE.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n    const secure = false; // FIXME: Currently no support for TLS.\n    // The route set MUST be set to the list of URIs in the Record-Route\n    // header field from the response, taken in reverse order and preserving\n    // all URI parameters.  If no Record-Route header field is present in\n    // the response, the route set MUST be set to the empty set.  This route\n    // set, even if empty, overrides any pre-existing route set for future\n    // requests in this dialog.  The remote target MUST be set to the URI\n    // from the Contact header field of the response.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const routeSet = incomingNotifyRequestMessage.getHeaders(\"record-route\");\n    const contact = incomingNotifyRequestMessage.parseHeader(\"contact\");\n\n    if (!contact) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Contact undefined.\");\n    }\n\n    if (!(contact instanceof NameAddrHeader)) {\n      throw new Error(\"Contact not instance of NameAddrHeader.\");\n    }\n\n    const remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence\n    // number in the CSeq header field of the request.  The remote sequence\n    // number MUST be empty (it is established when the remote UA sends a\n    // request within the dialog).  The call identifier component of the\n    // dialog ID MUST be set to the value of the Call-ID in the request.\n    // The local tag component of the dialog ID MUST be set to the tag in\n    // the From field in the request, and the remote tag component of the\n    // dialog ID MUST be set to the tag in the To field of the response.  A\n    // UAC MUST be prepared to receive a response without a tag in the To\n    // field, in which case the tag is considered to have a value of null.\n    //\n    //    This is to maintain backwards compatibility with RFC 2543, which\n    //    did not mandate To tags.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;\n    const remoteSequenceNumber = undefined;\n    const callId = outgoingSubscribeRequestMessage.callId;\n    const localTag = outgoingSubscribeRequestMessage.fromTag;\n    const remoteTag = incomingNotifyRequestMessage.fromTag;\n\n    if (!callId) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Call id undefined.\");\n    }\n\n    if (!localTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From tag undefined.\");\n    }\n\n    if (!remoteTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n    } // The remote URI MUST be set to the URI in the To field, and the local\n    // URI MUST be set to the URI in the From field.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n\n    if (!outgoingSubscribeRequestMessage.from) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From undefined.\");\n    }\n\n    if (!outgoingSubscribeRequestMessage.to) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To undefined.\");\n    }\n\n    const localURI = outgoingSubscribeRequestMessage.from.uri;\n    const remoteURI = outgoingSubscribeRequestMessage.to.uri; // A dialog can also be in the \"early\" state, which occurs when it is\n    // created with a provisional response, and then transition to the\n    // \"confirmed\" state when a 2xx final response arrives.\n    // https://tools.ietf.org/html/rfc3261#section-12\n\n    const early = false;\n    const dialogState = {\n      id: callId + localTag + remoteTag,\n      early,\n      callId,\n      localTag,\n      remoteTag,\n      localSequenceNumber,\n      remoteSequenceNumber,\n      localURI,\n      remoteURI,\n      remoteTarget,\n      routeSet,\n      secure\n    };\n    return dialogState;\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    }\n\n    this.refreshTimerClear();\n    this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);\n  }\n\n  get autoRefresh() {\n    return this._autoRefresh;\n  }\n\n  set autoRefresh(autoRefresh) {\n    this._autoRefresh = true;\n    this.refreshTimerSet();\n  }\n\n  get subscriptionEvent() {\n    return this._subscriptionEvent;\n  }\n  /** Number of seconds until subscription expires. */\n\n\n  get subscriptionExpires() {\n    const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;\n\n    const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;\n    return Math.max(secondsUntilExpires, 0);\n  }\n\n  set subscriptionExpires(expires) {\n    if (expires < 0) {\n      throw new Error(\"Expires must be greater than or equal to zero.\");\n    }\n\n    this._subscriptionExpires = expires;\n    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n\n    if (this.autoRefresh) {\n      const refresh = this.subscriptionRefresh;\n\n      if (refresh === undefined || refresh >= expires) {\n        this.refreshTimerSet();\n      }\n    }\n  }\n\n  get subscriptionExpiresInitial() {\n    return this._subscriptionExpiresInitial;\n  }\n  /** Number of seconds until subscription auto refresh. */\n\n\n  get subscriptionRefresh() {\n    if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {\n      return undefined;\n    }\n\n    const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;\n\n    const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;\n    return Math.max(secondsUntilExpires, 0);\n  }\n\n  get subscriptionState() {\n    return this._subscriptionState;\n  }\n  /**\n   * Receive in dialog request message from transport.\n   * @param message -  The incoming request message.\n   */\n\n\n  receiveRequest(message) {\n    this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message.method} request`); // Request within a dialog out of sequence guard.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n    if (!this.sequenceGuard(message)) {\n      this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message.method} request.`);\n      return;\n    } // Request within a dialog common processing.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    super.receiveRequest(message); // Switch on method and then delegate.\n\n    switch (message.method) {\n      case C.NOTIFY:\n        this.onNotify(message);\n        break;\n\n      default:\n        this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message.method} request`);\n        this.core.replyStateless(message, {\n          statusCode: 501\n        });\n        break;\n    }\n  }\n  /**\n   * 4.1.2.2.  Refreshing of Subscriptions\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   */\n\n\n  refresh() {\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const options = {};\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n    options.extraHeaders.push(\"Expires: \" + this.subscriptionExpiresInitial);\n    options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    return this.subscribe(undefined, options);\n  }\n  /**\n   * 4.1.2.2.  Refreshing of Subscriptions\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   * @param delegate - Delegate to handle responses.\n   * @param options - Options bucket.\n   */\n\n\n  subscribe(delegate, options = {}) {\n    if (this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n      // FIXME: This needs to be a proper exception\n      throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state \"pending\" or \"active\".`);\n    }\n\n    this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);\n    const uac = new ReSubscribeUserAgentClient(this, delegate, options); // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    } // When refreshing a subscription, a subscriber starts Timer N, set to\n    // 64*T1, when it sends the SUBSCRIBE request.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n\n\n    this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n    return uac;\n  }\n  /**\n   * 4.4.1.  Dialog Creation and Termination\n   * A subscription is destroyed after a notifier sends a NOTIFY request\n   * with a \"Subscription-State\" of \"terminated\", or in certain error\n   * situations described elsewhere in this document.\n   * https://tools.ietf.org/html/rfc6665#section-4.4.1\n   */\n\n\n  terminate() {\n    this.stateTransition(SubscriptionState.Terminated);\n    this.onTerminated();\n  }\n  /**\n   * 4.1.2.3.  Unsubscribing\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.3\n   */\n\n\n  unsubscribe() {\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const options = {};\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n    options.extraHeaders.push(\"Expires: 0\");\n    options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    return this.subscribe(undefined, options);\n  }\n  /**\n   * Handle in dialog NOTIFY requests.\n   * This does not include the first NOTIFY which created the dialog.\n   * @param message - The incoming NOTIFY request message.\n   */\n\n\n  onNotify(message) {\n    // If, for some reason, the event package designated in the \"Event\"\n    // header field of the NOTIFY request is not supported, the subscriber\n    // will respond with a 489 (Bad Event) response.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n    const event = message.parseHeader(\"Event\").event;\n\n    if (!event || event !== this.subscriptionEvent) {\n      this.core.replyStateless(message, {\n        statusCode: 489\n      });\n      return;\n    } // In the state diagram, \"Re-subscription times out\" means that an\n    // attempt to refresh or update the subscription using a new SUBSCRIBE\n    // request does not result in a NOTIFY request before the corresponding\n    // Timer N expires.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.2\n\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    } // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n    // indicate the status of the subscription.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    const subscriptionState = message.parseHeader(\"Subscription-State\");\n\n    if (!subscriptionState || !subscriptionState.state) {\n      this.core.replyStateless(message, {\n        statusCode: 489\n      });\n      return;\n    }\n\n    const state = subscriptionState.state;\n    const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined; // Update our state and expiration.\n\n    switch (state) {\n      case \"pending\":\n        this.stateTransition(SubscriptionState.Pending, expires);\n        break;\n\n      case \"active\":\n        this.stateTransition(SubscriptionState.Active, expires);\n        break;\n\n      case \"terminated\":\n        this.stateTransition(SubscriptionState.Terminated, expires);\n        break;\n\n      default:\n        this.logger.warn(\"Unrecognized subscription state.\");\n        break;\n    } // Delegate remainder of NOTIFY handling.\n\n\n    const uas = new NotifyUserAgentServer(this, message);\n\n    if (this.delegate && this.delegate.onNotify) {\n      this.delegate.onNotify(uas);\n    } else {\n      uas.accept();\n    }\n  }\n\n  onRefresh(request) {\n    if (this.delegate && this.delegate.onRefresh) {\n      this.delegate.onRefresh(request);\n    }\n  }\n\n  onTerminated() {\n    if (this.delegate && this.delegate.onTerminated) {\n      this.delegate.onTerminated();\n    }\n  }\n\n  refreshTimerClear() {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = undefined;\n    }\n  }\n\n  refreshTimerSet() {\n    this.refreshTimerClear();\n\n    if (this.autoRefresh && this.subscriptionExpires > 0) {\n      const refresh = this.subscriptionExpires * 900;\n      this._subscriptionRefresh = Math.floor(refresh / 1000);\n      this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);\n      this.refreshTimer = setTimeout(() => {\n        this.refreshTimer = undefined;\n        this._subscriptionRefresh = undefined;\n        this._subscriptionRefreshLastSet = undefined;\n        this.onRefresh(this.refresh());\n      }, refresh);\n    }\n  }\n\n  stateTransition(newState, newExpires) {\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);\n    };\n\n    switch (newState) {\n      case SubscriptionState.Initial:\n        invalidStateTransition();\n        return;\n\n      case SubscriptionState.NotifyWait:\n        invalidStateTransition();\n        return;\n\n      case SubscriptionState.Pending:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      case SubscriptionState.Active:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      case SubscriptionState.Terminated:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n        return;\n    } // If the \"Subscription-State\" value is \"pending\", the subscription has\n    // been received by the notifier, but there is insufficient policy\n    // information to grant or deny the subscription yet.  If the header\n    // field also contains an \"expires\" parameter, the subscriber SHOULD\n    // take it as the authoritative subscription duration and adjust\n    // accordingly.  No further action is necessary on the part of the\n    // subscriber.  The \"retry-after\" and \"reason\" parameters have no\n    // semantics for \"pending\".\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    if (newState === SubscriptionState.Pending) {\n      if (newExpires) {\n        this.subscriptionExpires = newExpires;\n      }\n    } // If the \"Subscription-State\" header field value is \"active\", it means\n    // that the subscription has been accepted and (in general) has been\n    // authorized.  If the header field also contains an \"expires\"\n    // parameter, the subscriber SHOULD take it as the authoritative\n    // subscription duration and adjust accordingly.  The \"retry-after\" and\n    // \"reason\" parameters have no semantics for \"active\".\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    if (newState === SubscriptionState.Active) {\n      if (newExpires) {\n        this.subscriptionExpires = newExpires;\n      }\n    } // If the \"Subscription-State\" value is \"terminated\", the subscriber\n    // MUST consider the subscription terminated.  The \"expires\" parameter\n    // has no semantics for \"terminated\" -- notifiers SHOULD NOT include an\n    // \"expires\" parameter on a \"Subscription-State\" header field with a\n    // value of \"terminated\", and subscribers MUST ignore any such\n    // parameter, if present.\n\n\n    if (newState === SubscriptionState.Terminated) {\n      this.dispose();\n    }\n\n    this._subscriptionState = newState;\n  }\n  /**\n   * When refreshing a subscription, a subscriber starts Timer N, set to\n   * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires\n   * prior to the receipt of a NOTIFY request, the subscriber considers\n   * the subscription terminated.  If the subscriber receives a success\n   * response to the SUBSCRIBE request that indicates that no NOTIFY\n   * request will be generated -- such as the 204 response defined for use\n   * with the optional extension described in [RFC5839] -- then it MUST\n   * cancel Timer N.\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   */\n\n\n  timerN() {\n    this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);\n\n    if (this.subscriptionState !== SubscriptionState.Terminated) {\n      this.stateTransition(SubscriptionState.Terminated);\n      this.onTerminated();\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"],"names":["C","NameAddrHeader","SubscriptionState","Timers","AllowedMethods","NotifyUserAgentServer","ReSubscribeUserAgentClient","Dialog","SubscriptionDialog","constructor","subscriptionEvent","subscriptionExpires","subscriptionState","core","state","delegate","_autoRefresh","_subscriptionEvent","_subscriptionExpires","_subscriptionExpiresInitial","_subscriptionExpiresLastSet","Math","floor","Date","now","_subscriptionRefresh","undefined","_subscriptionRefreshLastSet","_subscriptionState","logger","loggerFactory","getLogger","log","id","initialDialogStateForSubscription","outgoingSubscribeRequestMessage","incomingNotifyRequestMessage","secure","routeSet","getHeaders","contact","parseHeader","Error","remoteTarget","uri","localSequenceNumber","cseq","remoteSequenceNumber","callId","localTag","fromTag","remoteTag","from","to","localURI","remoteURI","early","dialogState","dispose","N","clearTimeout","refreshTimerClear","autoRefresh","refreshTimerSet","secondsSinceLastSet","secondsUntilExpires","max","expires","refresh","subscriptionRefresh","subscriptionExpiresInitial","receiveRequest","message","method","sequenceGuard","NOTIFY","onNotify","replyStateless","statusCode","allowHeader","toString","options","extraHeaders","slice","push","configuration","subscribe","Pending","Active","uac","setTimeout","timerN","TIMER_N","terminate","stateTransition","Terminated","onTerminated","unsubscribe","event","warn","uas","accept","onRefresh","request","refreshTimer","newState","newExpires","invalidStateTransition","Initial","NotifyWait"],"mappings":"AAAA,SAASA,CAAT,EAAYC,cAAZ,QAAkC,aAAlC;AACA,SAASC,iBAAT,QAAkC,iBAAlC;AACA,SAASC,MAAT,QAAuB,WAAvB;AACA,SAASC,cAAT,QAA+B,oCAA/B;AACA,SAASC,qBAAT,QAAsC,yCAAtC;AACA,SAASC,0BAAT,QAA2C,+CAA3C;AACA,SAASC,MAAT,QAAuB,UAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,kBAAN,SAAiCD,MAAjC,CAAwC;AAC3CE,EAAAA,WAAW,CAACC,iBAAD,EAAoBC,mBAApB,EAAyCC,iBAAzC,EAA4DC,IAA5D,EAAkEC,KAAlE,EAAyEC,QAAzE,EAAmF;AAC1F,UAAMF,IAAN,EAAYC,KAAZ;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,YAAL,GAAoB,KAApB;AACA,SAAKC,kBAAL,GAA0BP,iBAA1B;AACA,SAAKQ,oBAAL,GAA4BP,mBAA5B;AACA,SAAKQ,2BAAL,GAAmCR,mBAAnC;AACA,SAAKS,2BAAL,GAAmCC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAnC;AACA,SAAKC,oBAAL,GAA4BC,SAA5B;AACA,SAAKC,2BAAL,GAAmCD,SAAnC;AACA,SAAKE,kBAAL,GAA0BhB,iBAA1B;AACA,SAAKiB,MAAL,GAAchB,IAAI,CAACiB,aAAL,CAAmBC,SAAnB,CAA6B,sBAA7B,CAAd;AACA,SAAKF,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,cAA5C;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI,SAAOC,iCAAP,CAAyCC,+BAAzC,EAA0EC,4BAA1E,EAAwG;AACpG;AACA;AACA;AACA,UAAMC,MAAM,GAAG,KAAf,CAJoG,CAI9E;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,QAAQ,GAAGF,4BAA4B,CAACG,UAA7B,CAAwC,cAAxC,CAAjB;AACA,UAAMC,OAAO,GAAGJ,4BAA4B,CAACK,WAA7B,CAAyC,SAAzC,CAAhB;;AACA,QAAI,CAACD,OAAL,EAAc;AACV;AACA,YAAM,IAAIE,KAAJ,CAAU,oBAAV,CAAN;AACH;;AACD,QAAI,EAAEF,OAAO,YAAYvC,cAArB,CAAJ,EAA0C;AACtC,YAAM,IAAIyC,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,UAAMC,YAAY,GAAGH,OAAO,CAACI,GAA7B,CAtBoG,CAuBpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,mBAAmB,GAAGV,+BAA+B,CAACW,IAA5D;AACA,UAAMC,oBAAoB,GAAGrB,SAA7B;AACA,UAAMsB,MAAM,GAAGb,+BAA+B,CAACa,MAA/C;AACA,UAAMC,QAAQ,GAAGd,+BAA+B,CAACe,OAAjD;AACA,UAAMC,SAAS,GAAGf,4BAA4B,CAACc,OAA/C;;AACA,QAAI,CAACF,MAAL,EAAa;AACT;AACA,YAAM,IAAIN,KAAJ,CAAU,oBAAV,CAAN;AACH;;AACD,QAAI,CAACO,QAAL,EAAe;AACX;AACA,YAAM,IAAIP,KAAJ,CAAU,qBAAV,CAAN;AACH;;AACD,QAAI,CAACS,SAAL,EAAgB;AACZ;AACA,YAAM,IAAIT,KAAJ,CAAU,mBAAV,CAAN,CAFY,CAE0B;AACzC,KAtDmG,CAuDpG;AACA;AACA;;;AACA,QAAI,CAACP,+BAA+B,CAACiB,IAArC,EAA2C;AACvC;AACA,YAAM,IAAIV,KAAJ,CAAU,iBAAV,CAAN;AACH;;AACD,QAAI,CAACP,+BAA+B,CAACkB,EAArC,EAAyC;AACrC;AACA,YAAM,IAAIX,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,UAAMY,QAAQ,GAAGnB,+BAA+B,CAACiB,IAAhC,CAAqCR,GAAtD;AACA,UAAMW,SAAS,GAAGpB,+BAA+B,CAACkB,EAAhC,CAAmCT,GAArD,CAnEoG,CAoEpG;AACA;AACA;AACA;;AACA,UAAMY,KAAK,GAAG,KAAd;AACA,UAAMC,WAAW,GAAG;AAChBxB,MAAAA,EAAE,EAAEe,MAAM,GAAGC,QAAT,GAAoBE,SADR;AAEhBK,MAAAA,KAFgB;AAGhBR,MAAAA,MAHgB;AAIhBC,MAAAA,QAJgB;AAKhBE,MAAAA,SALgB;AAMhBN,MAAAA,mBANgB;AAOhBE,MAAAA,oBAPgB;AAQhBO,MAAAA,QARgB;AAShBC,MAAAA,SATgB;AAUhBZ,MAAAA,YAVgB;AAWhBL,MAAAA,QAXgB;AAYhBD,MAAAA;AAZgB,KAApB;AAcA,WAAOoB,WAAP;AACH;;AACDC,EAAAA,OAAO,GAAG;AACN,UAAMA,OAAN;;AACA,QAAI,KAAKC,CAAT,EAAY;AACRC,MAAAA,YAAY,CAAC,KAAKD,CAAN,CAAZ;AACA,WAAKA,CAAL,GAASjC,SAAT;AACH;;AACD,SAAKmC,iBAAL;AACA,SAAKhC,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,YAA5C;AACH;;AACD,MAAI6B,WAAJ,GAAkB;AACd,WAAO,KAAK9C,YAAZ;AACH;;AACD,MAAI8C,WAAJ,CAAgBA,WAAhB,EAA6B;AACzB,SAAK9C,YAAL,GAAoB,IAApB;AACA,SAAK+C,eAAL;AACH;;AACD,MAAIrD,iBAAJ,GAAwB;AACpB,WAAO,KAAKO,kBAAZ;AACH;AACD;;;AACA,MAAIN,mBAAJ,GAA0B;AACtB,UAAMqD,mBAAmB,GAAG3C,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgC,KAAKJ,2BAAjE;;AACA,UAAM6C,mBAAmB,GAAG,KAAK/C,oBAAL,GAA4B8C,mBAAxD;AACA,WAAO3C,IAAI,CAAC6C,GAAL,CAASD,mBAAT,EAA8B,CAA9B,CAAP;AACH;;AACD,MAAItD,mBAAJ,CAAwBwD,OAAxB,EAAiC;AAC7B,QAAIA,OAAO,GAAG,CAAd,EAAiB;AACb,YAAM,IAAIzB,KAAJ,CAAU,gDAAV,CAAN;AACH;;AACD,SAAKxB,oBAAL,GAA4BiD,OAA5B;AACA,SAAK/C,2BAAL,GAAmCC,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAnC;;AACA,QAAI,KAAKsC,WAAT,EAAsB;AAClB,YAAMM,OAAO,GAAG,KAAKC,mBAArB;;AACA,UAAID,OAAO,KAAK1C,SAAZ,IAAyB0C,OAAO,IAAID,OAAxC,EAAiD;AAC7C,aAAKJ,eAAL;AACH;AACJ;AACJ;;AACD,MAAIO,0BAAJ,GAAiC;AAC7B,WAAO,KAAKnD,2BAAZ;AACH;AACD;;;AACA,MAAIkD,mBAAJ,GAA0B;AACtB,QAAI,KAAK5C,oBAAL,KAA8BC,SAA9B,IAA2C,KAAKC,2BAAL,KAAqCD,SAApF,EAA+F;AAC3F,aAAOA,SAAP;AACH;;AACD,UAAMsC,mBAAmB,GAAG3C,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,IAAgC,KAAKG,2BAAjE;;AACA,UAAMsC,mBAAmB,GAAG,KAAKxC,oBAAL,GAA4BuC,mBAAxD;AACA,WAAO3C,IAAI,CAAC6C,GAAL,CAASD,mBAAT,EAA8B,CAA9B,CAAP;AACH;;AACD,MAAIrD,iBAAJ,GAAwB;AACpB,WAAO,KAAKgB,kBAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACI2C,EAAAA,cAAc,CAACC,OAAD,EAAU;AACpB,SAAK3C,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,aAAYuC,OAAO,CAACC,MAAO,UAAvE,EADoB,CAEpB;AACA;;AACA,QAAI,CAAC,KAAKC,aAAL,CAAmBF,OAAnB,CAAL,EAAkC;AAC9B,WAAK3C,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,0BAAyBuC,OAAO,CAACC,MAAO,WAApF;AACA;AACH,KAPmB,CAQpB;AACA;;;AACA,UAAMF,cAAN,CAAqBC,OAArB,EAVoB,CAWpB;;AACA,YAAQA,OAAO,CAACC,MAAhB;AACI,WAAKzE,CAAC,CAAC2E,MAAP;AACI,aAAKC,QAAL,CAAcJ,OAAd;AACA;;AACJ;AACI,aAAK3C,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,2BAA0BuC,OAAO,CAACC,MAAO,UAArF;AACA,aAAK5D,IAAL,CAAUgE,cAAV,CAAyBL,OAAzB,EAAkC;AAAEM,UAAAA,UAAU,EAAE;AAAd,SAAlC;AACA;AAPR;AASH;AACD;AACJ;AACA;AACA;;;AACIV,EAAAA,OAAO,GAAG;AACN,UAAMW,WAAW,GAAG,YAAY3E,cAAc,CAAC4E,QAAf,EAAhC;AACA,UAAMC,OAAO,GAAG,EAAhB;AACAA,IAAAA,OAAO,CAACC,YAAR,GAAuB,CAACD,OAAO,CAACC,YAAR,IAAwB,EAAzB,EAA6BC,KAA7B,EAAvB;AACAF,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0BL,WAA1B;AACAE,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,YAAY,KAAK1E,iBAA3C;AACAuE,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,cAAc,KAAKd,0BAA7C;AACAW,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,cAAc,KAAKvE,IAAL,CAAUwE,aAAV,CAAwB7C,OAAxB,CAAgCwC,QAAhC,EAAxC;AACA,WAAO,KAAKM,SAAL,CAAe5D,SAAf,EAA0BuD,OAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,SAAS,CAACvE,QAAD,EAAWkE,OAAO,GAAG,EAArB,EAAyB;AAC9B,QAAI,KAAKrE,iBAAL,KAA2BV,iBAAiB,CAACqF,OAA7C,IAAwD,KAAK3E,iBAAL,KAA2BV,iBAAiB,CAACsF,MAAzG,EAAiH;AAC7G;AACA,YAAM,IAAI9C,KAAJ,CAAW,iBAAgB,KAAK9B,iBAAkB,+DAAlD,CAAN;AACH;;AACD,SAAKiB,MAAL,CAAYG,GAAZ,CAAiB,oBAAmB,KAAKC,EAAG,4BAA5C;AACA,UAAMwD,GAAG,GAAG,IAAInF,0BAAJ,CAA+B,IAA/B,EAAqCS,QAArC,EAA+CkE,OAA/C,CAAZ,CAN8B,CAO9B;;AACA,QAAI,KAAKtB,CAAT,EAAY;AACRC,MAAAA,YAAY,CAAC,KAAKD,CAAN,CAAZ;AACA,WAAKA,CAAL,GAASjC,SAAT;AACH,KAX6B,CAY9B;AACA;AACA;;;AACA,SAAKiC,CAAL,GAAS+B,UAAU,CAAC,MAAM,KAAKC,MAAL,EAAP,EAAsBxF,MAAM,CAACyF,OAA7B,CAAnB;AACA,WAAOH,GAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACII,EAAAA,SAAS,GAAG;AACR,SAAKC,eAAL,CAAqB5F,iBAAiB,CAAC6F,UAAvC;AACA,SAAKC,YAAL;AACH;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,UAAMlB,WAAW,GAAG,YAAY3E,cAAc,CAAC4E,QAAf,EAAhC;AACA,UAAMC,OAAO,GAAG,EAAhB;AACAA,IAAAA,OAAO,CAACC,YAAR,GAAuB,CAACD,OAAO,CAACC,YAAR,IAAwB,EAAzB,EAA6BC,KAA7B,EAAvB;AACAF,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0BL,WAA1B;AACAE,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,YAAY,KAAK1E,iBAA3C;AACAuE,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,YAA1B;AACAH,IAAAA,OAAO,CAACC,YAAR,CAAqBE,IAArB,CAA0B,cAAc,KAAKvE,IAAL,CAAUwE,aAAV,CAAwB7C,OAAxB,CAAgCwC,QAAhC,EAAxC;AACA,WAAO,KAAKM,SAAL,CAAe5D,SAAf,EAA0BuD,OAA1B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIL,EAAAA,QAAQ,CAACJ,OAAD,EAAU;AACd;AACA;AACA;AACA;AACA,UAAM0B,KAAK,GAAG1B,OAAO,CAAC/B,WAAR,CAAoB,OAApB,EAA6ByD,KAA3C;;AACA,QAAI,CAACA,KAAD,IAAUA,KAAK,KAAK,KAAKxF,iBAA7B,EAAgD;AAC5C,WAAKG,IAAL,CAAUgE,cAAV,CAAyBL,OAAzB,EAAkC;AAAEM,QAAAA,UAAU,EAAE;AAAd,OAAlC;AACA;AACH,KATa,CAUd;AACA;AACA;AACA;AACA;;;AACA,QAAI,KAAKnB,CAAT,EAAY;AACRC,MAAAA,YAAY,CAAC,KAAKD,CAAN,CAAZ;AACA,WAAKA,CAAL,GAASjC,SAAT;AACH,KAlBa,CAmBd;AACA;AACA;;;AACA,UAAMd,iBAAiB,GAAG4D,OAAO,CAAC/B,WAAR,CAAoB,oBAApB,CAA1B;;AACA,QAAI,CAAC7B,iBAAD,IAAsB,CAACA,iBAAiB,CAACE,KAA7C,EAAoD;AAChD,WAAKD,IAAL,CAAUgE,cAAV,CAAyBL,OAAzB,EAAkC;AAAEM,QAAAA,UAAU,EAAE;AAAd,OAAlC;AACA;AACH;;AACD,UAAMhE,KAAK,GAAGF,iBAAiB,CAACE,KAAhC;AACA,UAAMqD,OAAO,GAAGvD,iBAAiB,CAACuD,OAAlB,GAA4B9C,IAAI,CAAC6C,GAAL,CAAStD,iBAAiB,CAACuD,OAA3B,EAAoC,CAApC,CAA5B,GAAqEzC,SAArF,CA5Bc,CA6Bd;;AACA,YAAQZ,KAAR;AACI,WAAK,SAAL;AACI,aAAKgF,eAAL,CAAqB5F,iBAAiB,CAACqF,OAAvC,EAAgDpB,OAAhD;AACA;;AACJ,WAAK,QAAL;AACI,aAAK2B,eAAL,CAAqB5F,iBAAiB,CAACsF,MAAvC,EAA+CrB,OAA/C;AACA;;AACJ,WAAK,YAAL;AACI,aAAK2B,eAAL,CAAqB5F,iBAAiB,CAAC6F,UAAvC,EAAmD5B,OAAnD;AACA;;AACJ;AACI,aAAKtC,MAAL,CAAYsE,IAAZ,CAAiB,kCAAjB;AACA;AAZR,KA9Bc,CA4Cd;;;AACA,UAAMC,GAAG,GAAG,IAAI/F,qBAAJ,CAA0B,IAA1B,EAAgCmE,OAAhC,CAAZ;;AACA,QAAI,KAAKzD,QAAL,IAAiB,KAAKA,QAAL,CAAc6D,QAAnC,EAA6C;AACzC,WAAK7D,QAAL,CAAc6D,QAAd,CAAuBwB,GAAvB;AACH,KAFD,MAGK;AACDA,MAAAA,GAAG,CAACC,MAAJ;AACH;AACJ;;AACDC,EAAAA,SAAS,CAACC,OAAD,EAAU;AACf,QAAI,KAAKxF,QAAL,IAAiB,KAAKA,QAAL,CAAcuF,SAAnC,EAA8C;AAC1C,WAAKvF,QAAL,CAAcuF,SAAd,CAAwBC,OAAxB;AACH;AACJ;;AACDP,EAAAA,YAAY,GAAG;AACX,QAAI,KAAKjF,QAAL,IAAiB,KAAKA,QAAL,CAAciF,YAAnC,EAAiD;AAC7C,WAAKjF,QAAL,CAAciF,YAAd;AACH;AACJ;;AACDnC,EAAAA,iBAAiB,GAAG;AAChB,QAAI,KAAK2C,YAAT,EAAuB;AACnB5C,MAAAA,YAAY,CAAC,KAAK4C,YAAN,CAAZ;AACA,WAAKA,YAAL,GAAoB9E,SAApB;AACH;AACJ;;AACDqC,EAAAA,eAAe,GAAG;AACd,SAAKF,iBAAL;;AACA,QAAI,KAAKC,WAAL,IAAoB,KAAKnD,mBAAL,GAA2B,CAAnD,EAAsD;AAClD,YAAMyD,OAAO,GAAG,KAAKzD,mBAAL,GAA2B,GAA3C;AACA,WAAKc,oBAAL,GAA4BJ,IAAI,CAACC,KAAL,CAAW8C,OAAO,GAAG,IAArB,CAA5B;AACA,WAAKzC,2BAAL,GAAmCN,IAAI,CAACC,KAAL,CAAWC,IAAI,CAACC,GAAL,KAAa,IAAxB,CAAnC;AACA,WAAKgF,YAAL,GAAoBd,UAAU,CAAC,MAAM;AACjC,aAAKc,YAAL,GAAoB9E,SAApB;AACA,aAAKD,oBAAL,GAA4BC,SAA5B;AACA,aAAKC,2BAAL,GAAmCD,SAAnC;AACA,aAAK4E,SAAL,CAAe,KAAKlC,OAAL,EAAf;AACH,OAL6B,EAK3BA,OAL2B,CAA9B;AAMH;AACJ;;AACD0B,EAAAA,eAAe,CAACW,QAAD,EAAWC,UAAX,EAAuB;AAClC;AACA,UAAMC,sBAAsB,GAAG,MAAM;AACjC,WAAK9E,MAAL,CAAYsE,IAAZ,CAAkB,8CAA6C,KAAKvF,iBAAkB,OAAM6F,QAAS,EAArG;AACH,KAFD;;AAGA,YAAQA,QAAR;AACI,WAAKvG,iBAAiB,CAAC0G,OAAvB;AACID,QAAAA,sBAAsB;AACtB;;AACJ,WAAKzG,iBAAiB,CAAC2G,UAAvB;AACIF,QAAAA,sBAAsB;AACtB;;AACJ,WAAKzG,iBAAiB,CAACqF,OAAvB;AACI,YAAI,KAAK3E,iBAAL,KAA2BV,iBAAiB,CAAC2G,UAA7C,IACA,KAAKjG,iBAAL,KAA2BV,iBAAiB,CAACqF,OADjD,EAC0D;AACtDoB,UAAAA,sBAAsB;AACtB;AACH;;AACD;;AACJ,WAAKzG,iBAAiB,CAACsF,MAAvB;AACI,YAAI,KAAK5E,iBAAL,KAA2BV,iBAAiB,CAAC2G,UAA7C,IACA,KAAKjG,iBAAL,KAA2BV,iBAAiB,CAACqF,OAD7C,IAEA,KAAK3E,iBAAL,KAA2BV,iBAAiB,CAACsF,MAFjD,EAEyD;AACrDmB,UAAAA,sBAAsB;AACtB;AACH;;AACD;;AACJ,WAAKzG,iBAAiB,CAAC6F,UAAvB;AACI,YAAI,KAAKnF,iBAAL,KAA2BV,iBAAiB,CAAC2G,UAA7C,IACA,KAAKjG,iBAAL,KAA2BV,iBAAiB,CAACqF,OAD7C,IAEA,KAAK3E,iBAAL,KAA2BV,iBAAiB,CAACsF,MAFjD,EAEyD;AACrDmB,UAAAA,sBAAsB;AACtB;AACH;;AACD;;AACJ;AACIA,QAAAA,sBAAsB;AACtB;AAhCR,KALkC,CAuClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIF,QAAQ,KAAKvG,iBAAiB,CAACqF,OAAnC,EAA4C;AACxC,UAAImB,UAAJ,EAAgB;AACZ,aAAK/F,mBAAL,GAA2B+F,UAA3B;AACH;AACJ,KApDiC,CAqDlC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAID,QAAQ,KAAKvG,iBAAiB,CAACsF,MAAnC,EAA2C;AACvC,UAAIkB,UAAJ,EAAgB;AACZ,aAAK/F,mBAAL,GAA2B+F,UAA3B;AACH;AACJ,KAhEiC,CAiElC;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAID,QAAQ,KAAKvG,iBAAiB,CAAC6F,UAAnC,EAA+C;AAC3C,WAAKrC,OAAL;AACH;;AACD,SAAK9B,kBAAL,GAA0B6E,QAA1B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACId,EAAAA,MAAM,GAAG;AACL,SAAK9D,MAAL,CAAYsE,IAAZ,CAAkB,qEAAlB;;AACA,QAAI,KAAKvF,iBAAL,KAA2BV,iBAAiB,CAAC6F,UAAjD,EAA6D;AACzD,WAAKD,eAAL,CAAqB5F,iBAAiB,CAAC6F,UAAvC;AACA,WAAKC,YAAL;AACH;AACJ;;AAnb0C","sourcesContent":["import { C, NameAddrHeader } from \"../messages\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { ReSubscribeUserAgentClient } from \"../user-agents/re-subscribe-user-agent-client\";\nimport { Dialog } from \"./dialog\";\n/**\n * Subscription Dialog.\n * @remarks\n * SIP-Specific Event Notification\n *\n * Abstract\n *\n *    This document describes an extension to the Session Initiation\n *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n *    to provide an extensible framework by which SIP nodes can request\n *    notification from remote nodes indicating that certain events have\n *    occurred.\n *\n *    Note that the event notification mechanisms defined herein are NOT\n *    intended to be a general-purpose infrastructure for all classes of\n *    event subscription and notification.\n *\n *    This document represents a backwards-compatible improvement on the\n *    original mechanism described by RFC 3265, taking into account several\n *    years of implementation experience.  Accordingly, this document\n *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to\n *    accommodate some small changes to the mechanism that were discussed\n *    in that document.\n *\n *  https://tools.ietf.org/html/rfc6665\n * @public\n */\nexport class SubscriptionDialog extends Dialog {\n    constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {\n        super(core, state);\n        this.delegate = delegate;\n        this._autoRefresh = false;\n        this._subscriptionEvent = subscriptionEvent;\n        this._subscriptionExpires = subscriptionExpires;\n        this._subscriptionExpiresInitial = subscriptionExpires;\n        this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n        this._subscriptionRefresh = undefined;\n        this._subscriptionRefreshLastSet = undefined;\n        this._subscriptionState = subscriptionState;\n        this.logger = core.loggerFactory.getLogger(\"sip.subscribe-dialog\");\n        this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);\n    }\n    /**\n     * When a UAC receives a response that establishes a dialog, it\n     * constructs the state of the dialog.  This state MUST be maintained\n     * for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.2\n     * @param outgoingRequestMessage - Outgoing request message for dialog.\n     * @param incomingResponseMessage - Incoming response message creating dialog.\n     */\n    static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {\n        // If the request was sent over TLS, and the Request-URI contained a\n        // SIPS URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the response, taken in reverse order and preserving\n        // all URI parameters.  If no Record-Route header field is present in\n        // the response, the route set MUST be set to the empty set.  This route\n        // set, even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const routeSet = incomingNotifyRequestMessage.getHeaders(\"record-route\");\n        const contact = incomingNotifyRequestMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The local sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The remote sequence\n        // number MUST be empty (it is established when the remote UA sends a\n        // request within the dialog).  The call identifier component of the\n        // dialog ID MUST be set to the value of the Call-ID in the request.\n        // The local tag component of the dialog ID MUST be set to the tag in\n        // the From field in the request, and the remote tag component of the\n        // dialog ID MUST be set to the tag in the To field of the response.  A\n        // UAC MUST be prepared to receive a response without a tag in the To\n        // field, in which case the tag is considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate To tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;\n        const remoteSequenceNumber = undefined;\n        const callId = outgoingSubscribeRequestMessage.callId;\n        const localTag = outgoingSubscribeRequestMessage.fromTag;\n        const remoteTag = incomingNotifyRequestMessage.fromTag;\n        if (!callId) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Call id undefined.\");\n        }\n        if (!localTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From tag undefined.\");\n        }\n        if (!remoteTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n        }\n        // The remote URI MUST be set to the URI in the To field, and the local\n        // URI MUST be set to the URI in the From field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        if (!outgoingSubscribeRequestMessage.from) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From undefined.\");\n        }\n        if (!outgoingSubscribeRequestMessage.to) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To undefined.\");\n        }\n        const localURI = outgoingSubscribeRequestMessage.from.uri;\n        const remoteURI = outgoingSubscribeRequestMessage.to.uri;\n        // A dialog can also be in the \"early\" state, which occurs when it is\n        // created with a provisional response, and then transition to the\n        // \"confirmed\" state when a 2xx final response arrives.\n        // https://tools.ietf.org/html/rfc3261#section-12\n        const early = false;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    dispose() {\n        super.dispose();\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        this.refreshTimerClear();\n        this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);\n    }\n    get autoRefresh() {\n        return this._autoRefresh;\n    }\n    set autoRefresh(autoRefresh) {\n        this._autoRefresh = true;\n        this.refreshTimerSet();\n    }\n    get subscriptionEvent() {\n        return this._subscriptionEvent;\n    }\n    /** Number of seconds until subscription expires. */\n    get subscriptionExpires() {\n        const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;\n        const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;\n        return Math.max(secondsUntilExpires, 0);\n    }\n    set subscriptionExpires(expires) {\n        if (expires < 0) {\n            throw new Error(\"Expires must be greater than or equal to zero.\");\n        }\n        this._subscriptionExpires = expires;\n        this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n        if (this.autoRefresh) {\n            const refresh = this.subscriptionRefresh;\n            if (refresh === undefined || refresh >= expires) {\n                this.refreshTimerSet();\n            }\n        }\n    }\n    get subscriptionExpiresInitial() {\n        return this._subscriptionExpiresInitial;\n    }\n    /** Number of seconds until subscription auto refresh. */\n    get subscriptionRefresh() {\n        if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {\n            return undefined;\n        }\n        const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;\n        const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;\n        return Math.max(secondsUntilExpires, 0);\n    }\n    get subscriptionState() {\n        return this._subscriptionState;\n    }\n    /**\n     * Receive in dialog request message from transport.\n     * @param message -  The incoming request message.\n     */\n    receiveRequest(message) {\n        this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message.method} request`);\n        // Request within a dialog out of sequence guard.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.sequenceGuard(message)) {\n            this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message.method} request.`);\n            return;\n        }\n        // Request within a dialog common processing.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        super.receiveRequest(message);\n        // Switch on method and then delegate.\n        switch (message.method) {\n            case C.NOTIFY:\n                this.onNotify(message);\n                break;\n            default:\n                this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message.method} request`);\n                this.core.replyStateless(message, { statusCode: 501 });\n                break;\n        }\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n    refresh() {\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const options = {};\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n        options.extraHeaders.push(\"Expires: \" + this.subscriptionExpiresInitial);\n        options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        return this.subscribe(undefined, options);\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     * @param delegate - Delegate to handle responses.\n     * @param options - Options bucket.\n     */\n    subscribe(delegate, options = {}) {\n        if (this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n            // FIXME: This needs to be a proper exception\n            throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state \"pending\" or \"active\".`);\n        }\n        this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);\n        const uac = new ReSubscribeUserAgentClient(this, delegate, options);\n        // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        // When refreshing a subscription, a subscriber starts Timer N, set to\n        // 64*T1, when it sends the SUBSCRIBE request.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n        this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n        return uac;\n    }\n    /**\n     * 4.4.1.  Dialog Creation and Termination\n     * A subscription is destroyed after a notifier sends a NOTIFY request\n     * with a \"Subscription-State\" of \"terminated\", or in certain error\n     * situations described elsewhere in this document.\n     * https://tools.ietf.org/html/rfc6665#section-4.4.1\n     */\n    terminate() {\n        this.stateTransition(SubscriptionState.Terminated);\n        this.onTerminated();\n    }\n    /**\n     * 4.1.2.3.  Unsubscribing\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3\n     */\n    unsubscribe() {\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const options = {};\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n        options.extraHeaders.push(\"Expires: 0\");\n        options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        return this.subscribe(undefined, options);\n    }\n    /**\n     * Handle in dialog NOTIFY requests.\n     * This does not include the first NOTIFY which created the dialog.\n     * @param message - The incoming NOTIFY request message.\n     */\n    onNotify(message) {\n        // If, for some reason, the event package designated in the \"Event\"\n        // header field of the NOTIFY request is not supported, the subscriber\n        // will respond with a 489 (Bad Event) response.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const event = message.parseHeader(\"Event\").event;\n        if (!event || event !== this.subscriptionEvent) {\n            this.core.replyStateless(message, { statusCode: 489 });\n            return;\n        }\n        // In the state diagram, \"Re-subscription times out\" means that an\n        // attempt to refresh or update the subscription using a new SUBSCRIBE\n        // request does not result in a NOTIFY request before the corresponding\n        // Timer N expires.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n        // indicate the status of the subscription.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const subscriptionState = message.parseHeader(\"Subscription-State\");\n        if (!subscriptionState || !subscriptionState.state) {\n            this.core.replyStateless(message, { statusCode: 489 });\n            return;\n        }\n        const state = subscriptionState.state;\n        const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined;\n        // Update our state and expiration.\n        switch (state) {\n            case \"pending\":\n                this.stateTransition(SubscriptionState.Pending, expires);\n                break;\n            case \"active\":\n                this.stateTransition(SubscriptionState.Active, expires);\n                break;\n            case \"terminated\":\n                this.stateTransition(SubscriptionState.Terminated, expires);\n                break;\n            default:\n                this.logger.warn(\"Unrecognized subscription state.\");\n                break;\n        }\n        // Delegate remainder of NOTIFY handling.\n        const uas = new NotifyUserAgentServer(this, message);\n        if (this.delegate && this.delegate.onNotify) {\n            this.delegate.onNotify(uas);\n        }\n        else {\n            uas.accept();\n        }\n    }\n    onRefresh(request) {\n        if (this.delegate && this.delegate.onRefresh) {\n            this.delegate.onRefresh(request);\n        }\n    }\n    onTerminated() {\n        if (this.delegate && this.delegate.onTerminated) {\n            this.delegate.onTerminated();\n        }\n    }\n    refreshTimerClear() {\n        if (this.refreshTimer) {\n            clearTimeout(this.refreshTimer);\n            this.refreshTimer = undefined;\n        }\n    }\n    refreshTimerSet() {\n        this.refreshTimerClear();\n        if (this.autoRefresh && this.subscriptionExpires > 0) {\n            const refresh = this.subscriptionExpires * 900;\n            this._subscriptionRefresh = Math.floor(refresh / 1000);\n            this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);\n            this.refreshTimer = setTimeout(() => {\n                this.refreshTimer = undefined;\n                this._subscriptionRefresh = undefined;\n                this._subscriptionRefreshLastSet = undefined;\n                this.onRefresh(this.refresh());\n            }, refresh);\n        }\n    }\n    stateTransition(newState, newExpires) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);\n        };\n        switch (newState) {\n            case SubscriptionState.Initial:\n                invalidStateTransition();\n                return;\n            case SubscriptionState.NotifyWait:\n                invalidStateTransition();\n                return;\n            case SubscriptionState.Pending:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            case SubscriptionState.Active:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending &&\n                    this.subscriptionState !== SubscriptionState.Active) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            case SubscriptionState.Terminated:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending &&\n                    this.subscriptionState !== SubscriptionState.Active) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            default:\n                invalidStateTransition();\n                return;\n        }\n        // If the \"Subscription-State\" value is \"pending\", the subscription has\n        // been received by the notifier, but there is insufficient policy\n        // information to grant or deny the subscription yet.  If the header\n        // field also contains an \"expires\" parameter, the subscriber SHOULD\n        // take it as the authoritative subscription duration and adjust\n        // accordingly.  No further action is necessary on the part of the\n        // subscriber.  The \"retry-after\" and \"reason\" parameters have no\n        // semantics for \"pending\".\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        if (newState === SubscriptionState.Pending) {\n            if (newExpires) {\n                this.subscriptionExpires = newExpires;\n            }\n        }\n        // If the \"Subscription-State\" header field value is \"active\", it means\n        // that the subscription has been accepted and (in general) has been\n        // authorized.  If the header field also contains an \"expires\"\n        // parameter, the subscriber SHOULD take it as the authoritative\n        // subscription duration and adjust accordingly.  The \"retry-after\" and\n        // \"reason\" parameters have no semantics for \"active\".\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        if (newState === SubscriptionState.Active) {\n            if (newExpires) {\n                this.subscriptionExpires = newExpires;\n            }\n        }\n        // If the \"Subscription-State\" value is \"terminated\", the subscriber\n        // MUST consider the subscription terminated.  The \"expires\" parameter\n        // has no semantics for \"terminated\" -- notifiers SHOULD NOT include an\n        // \"expires\" parameter on a \"Subscription-State\" header field with a\n        // value of \"terminated\", and subscribers MUST ignore any such\n        // parameter, if present.\n        if (newState === SubscriptionState.Terminated) {\n            this.dispose();\n        }\n        this._subscriptionState = newState;\n    }\n    /**\n     * When refreshing a subscription, a subscriber starts Timer N, set to\n     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires\n     * prior to the receipt of a NOTIFY request, the subscriber considers\n     * the subscription terminated.  If the subscriber receives a success\n     * response to the SUBSCRIBE request that indicates that no NOTIFY\n     * request will be generated -- such as the 204 response defined for use\n     * with the optional extension described in [RFC5839] -- then it MUST\n     * cancel Timer N.\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n    timerN() {\n        this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);\n        if (this.subscriptionState !== SubscriptionState.Terminated) {\n            this.stateTransition(SubscriptionState.Terminated);\n            this.onTerminated();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}