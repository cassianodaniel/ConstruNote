{"ast":null,"code":"import { C, fromBodyLegacy, SubscriptionState as SubscriptionDialogState } from \"../core\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Notification } from \"./notification\";\nimport { Subscription } from \"./subscription\";\nimport { SubscriptionState } from \"./subscription-state\";\n/**\n * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).\n *\n * @remarks\n * This is (more or less) an implementation of a \"subscriber\" as\n * defined in RFC 6665 \"SIP-Specific Event Notifications\".\n * https://tools.ietf.org/html/rfc6665\n *\n * @example\n * ```ts\n * // Create a new subscriber.\n * const targetURI = new URI(\"sip\", \"alice\", \"example.com\");\n * const eventType = \"example-name\"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml\n * const subscriber = new Subscriber(userAgent, targetURI, eventType);\n *\n * // Add delegate to handle event notifications.\n * subscriber.delegate = {\n *   onNotify: (notification: Notification) => {\n *     // handle notification here\n *   }\n * };\n *\n * // Monitor subscription state changes.\n * subscriber.stateChange.addListener((newState: SubscriptionState) => {\n *   if (newState === SubscriptionState.Terminated) {\n *     // handle state change here\n *   }\n * });\n *\n * // Attempt to establish the subscription\n * subscriber.subscribe();\n *\n * // Sometime later when done with subscription\n * subscriber.unsubscribe();\n * ```\n *\n * @public\n */\n\nexport class Subscriber extends Subscription {\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - The request URI identifying the subscribed event.\n   * @param eventType - The event type identifying the subscribed event.\n   * @param options - Options bucket. See {@link SubscriberOptions} for details.\n   */\n  constructor(userAgent, targetURI, eventType, options = {}) {\n    super(userAgent, options);\n    this.body = undefined;\n    this.logger = userAgent.getLogger(\"sip.Subscriber\");\n\n    if (options.body) {\n      this.body = {\n        body: options.body,\n        contentType: options.contentType ? options.contentType : \"application/sdp\"\n      };\n    }\n\n    this.targetURI = targetURI; // Subscription event\n\n    this.event = eventType; // Subscription expires\n\n    if (options.expires === undefined) {\n      this.expires = 3600;\n    } else if (typeof options.expires !== \"number\") {\n      // pre-typescript type guard\n      this.logger.warn(`Option \"expires\" must be a number. Using default of 3600.`);\n      this.expires = 3600;\n    } else {\n      this.expires = options.expires;\n    } // Subscription extra headers\n\n\n    this.extraHeaders = (options.extraHeaders || []).slice(); // Subscription context.\n\n    this.subscriberRequest = this.initSubscriberRequest();\n    this.outgoingRequestMessage = this.subscriberRequest.message; // Add to UserAgent's collection\n\n    this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event;\n    this._userAgent._subscriptions[this.id] = this;\n  }\n  /**\n   * Destructor.\n   * @internal\n   */\n\n\n  dispose() {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`); // Remove from the user agent's subscription collection\n\n    delete this._userAgent._subscriptions[this.id]; // Clear timers\n\n    if (this.retryAfterTimer) {\n      clearTimeout(this.retryAfterTimer);\n      this.retryAfterTimer = undefined;\n    } // Dispose subscriber request\n\n\n    this.subscriberRequest.dispose(); // Make sure to dispose of our parent, then unsubscribe the\n    // subscription dialog (if need be) and resolve when it has terminated.\n\n    return super.dispose().then(() => {\n      // If we have never subscribed there is nothing to wait on.\n      // If we are already transitioned to terminated there is no need to unsubscribe again.\n      if (this.state !== SubscriptionState.Subscribed) {\n        return;\n      }\n\n      if (!this._dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      if (this._dialog.subscriptionState === SubscriptionDialogState.Pending || this._dialog.subscriptionState === SubscriptionDialogState.Active) {\n        const dialog = this._dialog; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n        return new Promise((resolve, reject) => {\n          dialog.delegate = {\n            onTerminated: () => resolve()\n          };\n          dialog.unsubscribe();\n        });\n      }\n    });\n  }\n  /**\n   * Subscribe to event notifications.\n   *\n   * @remarks\n   * Send an initial SUBSCRIBE request if no subscription as been established.\n   * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  subscribe(options = {}) {\n    switch (this.subscriberRequest.state) {\n      case SubscriptionDialogState.Initial:\n        // we can end up here when retrying so only state transition if in SubscriptionState.Initial state\n        if (this.state === SubscriptionState.Initial) {\n          this.stateTransition(SubscriptionState.NotifyWait);\n        }\n\n        this.subscriberRequest.subscribe().then(result => {\n          if (result.success) {\n            if (result.success.subscription) {\n              this._dialog = result.success.subscription;\n              this._dialog.delegate = {\n                onNotify: request => this.onNotify(request),\n                onRefresh: request => this.onRefresh(request),\n                onTerminated: () => {\n                  // If a call to unsubscribe will state transition to SubscriptionState.Terminated,\n                  // but we can end up here after that if the NOTIFY never arrives and timer N fires.\n                  if (this.state !== SubscriptionState.Terminated) {\n                    this.stateTransition(SubscriptionState.Terminated);\n                  }\n                }\n              };\n            }\n\n            this.onNotify(result.success.request);\n          } else if (result.failure) {\n            this.unsubscribe();\n          }\n        });\n        break;\n\n      case SubscriptionDialogState.NotifyWait:\n        break;\n\n      case SubscriptionDialogState.Pending:\n        break;\n\n      case SubscriptionDialogState.Active:\n        if (this._dialog) {\n          const request = this._dialog.refresh();\n\n          request.delegate = {\n            onAccept: response => this.onAccepted(response),\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onRedirect: response => this.unsubscribe(),\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onReject: response => this.unsubscribe()\n          };\n        }\n\n        break;\n\n      case SubscriptionDialogState.Terminated:\n        break;\n\n      default:\n        break;\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * {@inheritDoc Subscription.unsubscribe}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  unsubscribe(options = {}) {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    switch (this.subscriberRequest.state) {\n      case SubscriptionDialogState.Initial:\n        break;\n\n      case SubscriptionDialogState.NotifyWait:\n        break;\n\n      case SubscriptionDialogState.Pending:\n        if (this._dialog) {\n          this._dialog.unsubscribe(); // responses intentionally ignored\n\n        }\n\n        break;\n\n      case SubscriptionDialogState.Active:\n        if (this._dialog) {\n          this._dialog.unsubscribe(); // responses intentionally ignored\n\n        }\n\n        break;\n\n      case SubscriptionDialogState.Terminated:\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n\n    this.stateTransition(SubscriptionState.Terminated);\n    return Promise.resolve();\n  }\n  /**\n   * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n   * @deprecated Use `subscribe` instead.\n   * @internal\n   */\n\n\n  _refresh() {\n    if (this.subscriberRequest.state === SubscriptionDialogState.Active) {\n      return this.subscribe();\n    }\n\n    return Promise.resolve();\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onAccepted(response) {// NOTE: If you think you should do something with this response,\n    // please make sure you understand what it is you are doing and why.\n    // Per the RFC, the first NOTIFY is all that actually matters.\n  }\n  /** @internal */\n\n\n  onNotify(request) {\n    // If we've set state to done, no further processing should take place\n    // and we are only interested in cleaning up after the appropriate NOTIFY.\n    if (this.disposed) {\n      request.accept();\n      return;\n    } // State transition if needed.\n\n\n    if (this.state !== SubscriptionState.Subscribed) {\n      this.stateTransition(SubscriptionState.Subscribed);\n    } // Delegate notification.\n\n\n    if (this.delegate && this.delegate.onNotify) {\n      const notification = new Notification(request);\n      this.delegate.onNotify(notification);\n    } else {\n      request.accept();\n    } //  If the \"Subscription-State\" value is SubscriptionState.Terminated, the subscriber\n    //  MUST consider the subscription terminated.  The \"expires\" parameter\n    //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an\n    //  \"expires\" parameter on a \"Subscription-State\" header field with a\n    //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such\n    //  parameter, if present.  If a reason code is present, the client\n    //  should behave as described below.  If no reason code or an unknown\n    //  reason code is present, the client MAY attempt to re-subscribe at any\n    //  time (unless a \"retry-after\" parameter is present, in which case the\n    //  client SHOULD NOT attempt re-subscription until after the number of\n    //  seconds specified by the \"retry-after\" parameter).  The reason codes\n    //  defined by this document are:\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    const subscriptionState = request.message.parseHeader(\"Subscription-State\");\n\n    if (subscriptionState && subscriptionState.state) {\n      switch (subscriptionState.state) {\n        case \"terminated\":\n          if (subscriptionState.reason) {\n            this.logger.log(`Terminated subscription with reason ${subscriptionState.reason}`);\n\n            switch (subscriptionState.reason) {\n              case \"deactivated\":\n              case \"timeout\":\n                this.initSubscriberRequest();\n                this.subscribe();\n                return;\n\n              case \"probation\":\n              case \"giveup\":\n                this.initSubscriberRequest();\n\n                if (subscriptionState.params && subscriptionState.params[\"retry-after\"]) {\n                  this.retryAfterTimer = setTimeout(() => {\n                    this.subscribe();\n                  }, subscriptionState.params[\"retry-after\"]);\n                } else {\n                  this.subscribe();\n                }\n\n                return;\n\n              case \"rejected\":\n              case \"noresource\":\n              case \"invariant\":\n                break;\n            }\n          }\n\n          this.unsubscribe();\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n  /** @internal */\n\n\n  onRefresh(request) {\n    request.delegate = {\n      onAccept: response => this.onAccepted(response)\n    };\n  }\n\n  initSubscriberRequest() {\n    const options = {\n      extraHeaders: this.extraHeaders,\n      body: this.body ? fromBodyLegacy(this.body) : undefined\n    }; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);\n    this.subscriberRequest.delegate = {\n      onAccept: response => this.onAccepted(response)\n    };\n    return this.subscriberRequest;\n  }\n\n}\n\nclass SubscriberRequest {\n  constructor(core, target, event, expires, options, delegate) {\n    this.core = core;\n    this.target = target;\n    this.event = event;\n    this.expires = expires;\n    this.subscribed = false;\n    this.logger = core.loggerFactory.getLogger(\"sip.Subscriber\");\n    this.delegate = delegate;\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const extraHeaders = (options && options.extraHeaders || []).slice();\n    extraHeaders.push(allowHeader);\n    extraHeaders.push(\"Event: \" + this.event);\n    extraHeaders.push(\"Expires: \" + this.expires);\n    extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    const body = options && options.body;\n    this.message = core.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    if (this.request) {\n      this.request.waitNotifyStop();\n      this.request.dispose();\n      this.request = undefined;\n    }\n  }\n  /** Subscription state. */\n\n\n  get state() {\n    if (this.subscription) {\n      return this.subscription.subscriptionState;\n    } else if (this.subscribed) {\n      return SubscriptionDialogState.NotifyWait;\n    } else {\n      return SubscriptionDialogState.Initial;\n    }\n  }\n  /**\n   * Establish subscription.\n   * @param options Options bucket.\n   */\n\n\n  subscribe() {\n    if (this.subscribed) {\n      return Promise.reject(new Error(\"Not in initial state. Did you call subscribe more than once?\"));\n    }\n\n    this.subscribed = true;\n    return new Promise(resolve => {\n      if (!this.message) {\n        throw new Error(\"Message undefined.\");\n      }\n\n      this.request = this.core.subscribe(this.message, {\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // 200-class responses indicate that the subscription has been accepted\n        // and that a NOTIFY request will be sent immediately.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onAccept: response => {\n          if (this.delegate && this.delegate.onAccept) {\n            this.delegate.onAccept(response);\n          }\n        },\n        // Due to the potential for out-of-order messages, packet loss, and\n        // forking, the subscriber MUST be prepared to receive NOTIFY requests\n        // before the SUBSCRIBE transaction has completed.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n        onNotify: requestWithSubscription => {\n          this.subscription = requestWithSubscription.subscription;\n\n          if (this.subscription) {\n            this.subscription.autoRefresh = true;\n          }\n\n          resolve({\n            success: requestWithSubscription\n          });\n        },\n        // If this Timer N expires prior to the receipt of a NOTIFY request,\n        // the subscriber considers the subscription failed, and cleans up\n        // any state associated with the subscription attempt.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n        onNotifyTimeout: () => {\n          resolve({\n            failure: {}\n          });\n        },\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // Non-200-class final responses indicate that no subscription or new\n        // dialog usage has been created, and no subsequent NOTIFY request will\n        // be sent.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onRedirect: response => {\n          resolve({\n            failure: {\n              response\n            }\n          });\n        },\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // Non-200-class final responses indicate that no subscription or new\n        // dialog usage has been created, and no subsequent NOTIFY request will\n        // be sent.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onReject: response => {\n          resolve({\n            failure: {\n              response\n            }\n          });\n        }\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/subscriber.js"],"names":["C","fromBodyLegacy","SubscriptionState","SubscriptionDialogState","AllowedMethods","Notification","Subscription","Subscriber","constructor","userAgent","targetURI","eventType","options","body","undefined","logger","getLogger","contentType","event","expires","warn","extraHeaders","slice","subscriberRequest","initSubscriberRequest","outgoingRequestMessage","message","id","callId","from","parameters","tag","_userAgent","_subscriptions","dispose","disposed","Promise","resolve","log","state","retryAfterTimer","clearTimeout","then","Subscribed","_dialog","Error","subscriptionState","Pending","Active","dialog","reject","delegate","onTerminated","unsubscribe","subscribe","Initial","stateTransition","NotifyWait","result","success","subscription","onNotify","request","onRefresh","Terminated","failure","refresh","onAccept","response","onAccepted","onRedirect","onReject","_refresh","accept","notification","parseHeader","reason","params","setTimeout","SubscriberRequest","userAgentCore","core","target","subscribed","loggerFactory","allowHeader","toString","push","configuration","contact","makeOutgoingRequestMessage","SUBSCRIBE","aor","waitNotifyStop","requestWithSubscription","autoRefresh","onNotifyTimeout"],"mappings":"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","sourcesContent":["import { C, fromBodyLegacy, SubscriptionState as SubscriptionDialogState } from \"../core\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Notification } from \"./notification\";\nimport { Subscription } from \"./subscription\";\nimport { SubscriptionState } from \"./subscription-state\";\n/**\n * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).\n *\n * @remarks\n * This is (more or less) an implementation of a \"subscriber\" as\n * defined in RFC 6665 \"SIP-Specific Event Notifications\".\n * https://tools.ietf.org/html/rfc6665\n *\n * @example\n * ```ts\n * // Create a new subscriber.\n * const targetURI = new URI(\"sip\", \"alice\", \"example.com\");\n * const eventType = \"example-name\"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml\n * const subscriber = new Subscriber(userAgent, targetURI, eventType);\n *\n * // Add delegate to handle event notifications.\n * subscriber.delegate = {\n *   onNotify: (notification: Notification) => {\n *     // handle notification here\n *   }\n * };\n *\n * // Monitor subscription state changes.\n * subscriber.stateChange.addListener((newState: SubscriptionState) => {\n *   if (newState === SubscriptionState.Terminated) {\n *     // handle state change here\n *   }\n * });\n *\n * // Attempt to establish the subscription\n * subscriber.subscribe();\n *\n * // Sometime later when done with subscription\n * subscriber.unsubscribe();\n * ```\n *\n * @public\n */\nexport class Subscriber extends Subscription {\n    /**\n     * Constructor.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param targetURI - The request URI identifying the subscribed event.\n     * @param eventType - The event type identifying the subscribed event.\n     * @param options - Options bucket. See {@link SubscriberOptions} for details.\n     */\n    constructor(userAgent, targetURI, eventType, options = {}) {\n        super(userAgent, options);\n        this.body = undefined;\n        this.logger = userAgent.getLogger(\"sip.Subscriber\");\n        if (options.body) {\n            this.body = {\n                body: options.body,\n                contentType: options.contentType ? options.contentType : \"application/sdp\"\n            };\n        }\n        this.targetURI = targetURI;\n        // Subscription event\n        this.event = eventType;\n        // Subscription expires\n        if (options.expires === undefined) {\n            this.expires = 3600;\n        }\n        else if (typeof options.expires !== \"number\") {\n            // pre-typescript type guard\n            this.logger.warn(`Option \"expires\" must be a number. Using default of 3600.`);\n            this.expires = 3600;\n        }\n        else {\n            this.expires = options.expires;\n        }\n        // Subscription extra headers\n        this.extraHeaders = (options.extraHeaders || []).slice();\n        // Subscription context.\n        this.subscriberRequest = this.initSubscriberRequest();\n        this.outgoingRequestMessage = this.subscriberRequest.message;\n        // Add to UserAgent's collection\n        this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event;\n        this._userAgent._subscriptions[this.id] = this;\n    }\n    /**\n     * Destructor.\n     * @internal\n     */\n    dispose() {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`);\n        // Remove from the user agent's subscription collection\n        delete this._userAgent._subscriptions[this.id];\n        // Clear timers\n        if (this.retryAfterTimer) {\n            clearTimeout(this.retryAfterTimer);\n            this.retryAfterTimer = undefined;\n        }\n        // Dispose subscriber request\n        this.subscriberRequest.dispose();\n        // Make sure to dispose of our parent, then unsubscribe the\n        // subscription dialog (if need be) and resolve when it has terminated.\n        return super.dispose().then(() => {\n            // If we have never subscribed there is nothing to wait on.\n            // If we are already transitioned to terminated there is no need to unsubscribe again.\n            if (this.state !== SubscriptionState.Subscribed) {\n                return;\n            }\n            if (!this._dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            if (this._dialog.subscriptionState === SubscriptionDialogState.Pending ||\n                this._dialog.subscriptionState === SubscriptionDialogState.Active) {\n                const dialog = this._dialog;\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                return new Promise((resolve, reject) => {\n                    dialog.delegate = {\n                        onTerminated: () => resolve()\n                    };\n                    dialog.unsubscribe();\n                });\n            }\n        });\n    }\n    /**\n     * Subscribe to event notifications.\n     *\n     * @remarks\n     * Send an initial SUBSCRIBE request if no subscription as been established.\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    subscribe(options = {}) {\n        switch (this.subscriberRequest.state) {\n            case SubscriptionDialogState.Initial:\n                // we can end up here when retrying so only state transition if in SubscriptionState.Initial state\n                if (this.state === SubscriptionState.Initial) {\n                    this.stateTransition(SubscriptionState.NotifyWait);\n                }\n                this.subscriberRequest.subscribe().then((result) => {\n                    if (result.success) {\n                        if (result.success.subscription) {\n                            this._dialog = result.success.subscription;\n                            this._dialog.delegate = {\n                                onNotify: (request) => this.onNotify(request),\n                                onRefresh: (request) => this.onRefresh(request),\n                                onTerminated: () => {\n                                    // If a call to unsubscribe will state transition to SubscriptionState.Terminated,\n                                    // but we can end up here after that if the NOTIFY never arrives and timer N fires.\n                                    if (this.state !== SubscriptionState.Terminated) {\n                                        this.stateTransition(SubscriptionState.Terminated);\n                                    }\n                                }\n                            };\n                        }\n                        this.onNotify(result.success.request);\n                    }\n                    else if (result.failure) {\n                        this.unsubscribe();\n                    }\n                });\n                break;\n            case SubscriptionDialogState.NotifyWait:\n                break;\n            case SubscriptionDialogState.Pending:\n                break;\n            case SubscriptionDialogState.Active:\n                if (this._dialog) {\n                    const request = this._dialog.refresh();\n                    request.delegate = {\n                        onAccept: (response) => this.onAccepted(response),\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        onRedirect: (response) => this.unsubscribe(),\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        onReject: (response) => this.unsubscribe()\n                    };\n                }\n                break;\n            case SubscriptionDialogState.Terminated:\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve();\n    }\n    /**\n     * {@inheritDoc Subscription.unsubscribe}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    unsubscribe(options = {}) {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        switch (this.subscriberRequest.state) {\n            case SubscriptionDialogState.Initial:\n                break;\n            case SubscriptionDialogState.NotifyWait:\n                break;\n            case SubscriptionDialogState.Pending:\n                if (this._dialog) {\n                    this._dialog.unsubscribe();\n                    // responses intentionally ignored\n                }\n                break;\n            case SubscriptionDialogState.Active:\n                if (this._dialog) {\n                    this._dialog.unsubscribe();\n                    // responses intentionally ignored\n                }\n                break;\n            case SubscriptionDialogState.Terminated:\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        this.stateTransition(SubscriptionState.Terminated);\n        return Promise.resolve();\n    }\n    /**\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     * @deprecated Use `subscribe` instead.\n     * @internal\n     */\n    _refresh() {\n        if (this.subscriberRequest.state === SubscriptionDialogState.Active) {\n            return this.subscribe();\n        }\n        return Promise.resolve();\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onAccepted(response) {\n        // NOTE: If you think you should do something with this response,\n        // please make sure you understand what it is you are doing and why.\n        // Per the RFC, the first NOTIFY is all that actually matters.\n    }\n    /** @internal */\n    onNotify(request) {\n        // If we've set state to done, no further processing should take place\n        // and we are only interested in cleaning up after the appropriate NOTIFY.\n        if (this.disposed) {\n            request.accept();\n            return;\n        }\n        // State transition if needed.\n        if (this.state !== SubscriptionState.Subscribed) {\n            this.stateTransition(SubscriptionState.Subscribed);\n        }\n        // Delegate notification.\n        if (this.delegate && this.delegate.onNotify) {\n            const notification = new Notification(request);\n            this.delegate.onNotify(notification);\n        }\n        else {\n            request.accept();\n        }\n        //  If the \"Subscription-State\" value is SubscriptionState.Terminated, the subscriber\n        //  MUST consider the subscription terminated.  The \"expires\" parameter\n        //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an\n        //  \"expires\" parameter on a \"Subscription-State\" header field with a\n        //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such\n        //  parameter, if present.  If a reason code is present, the client\n        //  should behave as described below.  If no reason code or an unknown\n        //  reason code is present, the client MAY attempt to re-subscribe at any\n        //  time (unless a \"retry-after\" parameter is present, in which case the\n        //  client SHOULD NOT attempt re-subscription until after the number of\n        //  seconds specified by the \"retry-after\" parameter).  The reason codes\n        //  defined by this document are:\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const subscriptionState = request.message.parseHeader(\"Subscription-State\");\n        if (subscriptionState && subscriptionState.state) {\n            switch (subscriptionState.state) {\n                case \"terminated\":\n                    if (subscriptionState.reason) {\n                        this.logger.log(`Terminated subscription with reason ${subscriptionState.reason}`);\n                        switch (subscriptionState.reason) {\n                            case \"deactivated\":\n                            case \"timeout\":\n                                this.initSubscriberRequest();\n                                this.subscribe();\n                                return;\n                            case \"probation\":\n                            case \"giveup\":\n                                this.initSubscriberRequest();\n                                if (subscriptionState.params && subscriptionState.params[\"retry-after\"]) {\n                                    this.retryAfterTimer = setTimeout(() => {\n                                        this.subscribe();\n                                    }, subscriptionState.params[\"retry-after\"]);\n                                }\n                                else {\n                                    this.subscribe();\n                                }\n                                return;\n                            case \"rejected\":\n                            case \"noresource\":\n                            case \"invariant\":\n                                break;\n                        }\n                    }\n                    this.unsubscribe();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    /** @internal */\n    onRefresh(request) {\n        request.delegate = {\n            onAccept: (response) => this.onAccepted(response)\n        };\n    }\n    initSubscriberRequest() {\n        const options = {\n            extraHeaders: this.extraHeaders,\n            body: this.body ? fromBodyLegacy(this.body) : undefined\n        };\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);\n        this.subscriberRequest.delegate = {\n            onAccept: (response) => this.onAccepted(response)\n        };\n        return this.subscriberRequest;\n    }\n}\nclass SubscriberRequest {\n    constructor(core, target, event, expires, options, delegate) {\n        this.core = core;\n        this.target = target;\n        this.event = event;\n        this.expires = expires;\n        this.subscribed = false;\n        this.logger = core.loggerFactory.getLogger(\"sip.Subscriber\");\n        this.delegate = delegate;\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const extraHeaders = ((options && options.extraHeaders) || []).slice();\n        extraHeaders.push(allowHeader);\n        extraHeaders.push(\"Event: \" + this.event);\n        extraHeaders.push(\"Expires: \" + this.expires);\n        extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        const body = options && options.body;\n        this.message = core.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);\n    }\n    /** Destructor. */\n    dispose() {\n        if (this.request) {\n            this.request.waitNotifyStop();\n            this.request.dispose();\n            this.request = undefined;\n        }\n    }\n    /** Subscription state. */\n    get state() {\n        if (this.subscription) {\n            return this.subscription.subscriptionState;\n        }\n        else if (this.subscribed) {\n            return SubscriptionDialogState.NotifyWait;\n        }\n        else {\n            return SubscriptionDialogState.Initial;\n        }\n    }\n    /**\n     * Establish subscription.\n     * @param options Options bucket.\n     */\n    subscribe() {\n        if (this.subscribed) {\n            return Promise.reject(new Error(\"Not in initial state. Did you call subscribe more than once?\"));\n        }\n        this.subscribed = true;\n        return new Promise((resolve) => {\n            if (!this.message) {\n                throw new Error(\"Message undefined.\");\n            }\n            this.request = this.core.subscribe(this.message, {\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // 200-class responses indicate that the subscription has been accepted\n                // and that a NOTIFY request will be sent immediately.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onAccept: (response) => {\n                    if (this.delegate && this.delegate.onAccept) {\n                        this.delegate.onAccept(response);\n                    }\n                },\n                // Due to the potential for out-of-order messages, packet loss, and\n                // forking, the subscriber MUST be prepared to receive NOTIFY requests\n                // before the SUBSCRIBE transaction has completed.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n                onNotify: (requestWithSubscription) => {\n                    this.subscription = requestWithSubscription.subscription;\n                    if (this.subscription) {\n                        this.subscription.autoRefresh = true;\n                    }\n                    resolve({ success: requestWithSubscription });\n                },\n                // If this Timer N expires prior to the receipt of a NOTIFY request,\n                // the subscriber considers the subscription failed, and cleans up\n                // any state associated with the subscription attempt.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n                onNotifyTimeout: () => {\n                    resolve({ failure: {} });\n                },\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // Non-200-class final responses indicate that no subscription or new\n                // dialog usage has been created, and no subsequent NOTIFY request will\n                // be sent.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onRedirect: (response) => {\n                    resolve({ failure: { response } });\n                },\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // Non-200-class final responses indicate that no subscription or new\n                // dialog usage has been created, and no subsequent NOTIFY request will\n                // be sent.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onReject: (response) => {\n                    resolve({ failure: { response } });\n                }\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}