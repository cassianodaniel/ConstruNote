{"ast":null,"code":"import { fromBodyLegacy, getBody, Grammar, SignalingState, Timers, TransactionStateError } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { ContentTypeUnsupportedError, SessionDescriptionHandlerError, SessionTerminatedError } from \"./exceptions\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An invitation is an offer to establish a {@link Session} (incoming INVITE).\n * @public\n */\n\nexport class Invitation extends Session {\n  /** @internal */\n  constructor(userAgent, incomingInviteRequest) {\n    super(userAgent);\n    this.incomingInviteRequest = incomingInviteRequest;\n    /** True if dispose() has been called. */\n\n    this.disposed = false;\n    /** INVITE will be rejected if not accepted within a certain period time. */\n\n    this.expiresTimer = undefined;\n    /** True if this Session has been Terminated due to a CANCEL request. */\n\n    this.isCanceled = false;\n    /** Are reliable provisional responses required or supported. */\n\n    this.rel100 = \"none\";\n    /** The current RSeq header value. */\n\n    this.rseq = Math.floor(Math.random() * 10000);\n    /** INVITE will be rejected if final response not sent in a certain period time. */\n\n    this.userNoAnswerTimer = undefined;\n    /** True if waiting for a PRACK before sending a 200 Ok. */\n\n    this.waitingForPrack = false;\n    this.logger = userAgent.getLogger(\"sip.Invitation\");\n    const incomingRequestMessage = this.incomingInviteRequest.message; // Set 100rel if necessary\n\n    const requireHeader = incomingRequestMessage.getHeader(\"require\");\n\n    if (requireHeader && requireHeader.toLowerCase().includes(\"100rel\")) {\n      this.rel100 = \"required\";\n    }\n\n    const supportedHeader = incomingRequestMessage.getHeader(\"supported\");\n\n    if (supportedHeader && supportedHeader.toLowerCase().includes(\"100rel\")) {\n      this.rel100 = \"supported\";\n    } // FIXME: HACK: This is a hack to port an existing behavior.\n    // Set the toTag on the incoming request message to the toTag which\n    // will be used in the response to the incoming request!!!\n    // The behavior being ported appears to be a hack itself,\n    // so this is a hack to port a hack. At least one test spec\n    // relies on it (which is yet another hack).\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    incomingRequestMessage.toTag = incomingInviteRequest.toTag;\n\n    if (typeof incomingRequestMessage.toTag !== \"string\") {\n      throw new TypeError(\"toTag should have been a string.\");\n    } // The following mapping values are RECOMMENDED:\n    // ...\n    // 19 no answer from the user              480 Temporarily unavailable\n    // https://tools.ietf.org/html/rfc3398#section-7.2.4.1\n\n\n    this.userNoAnswerTimer = setTimeout(() => {\n      incomingInviteRequest.reject({\n        statusCode: 480\n      });\n      this.stateTransition(SessionState.Terminated);\n    }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1000 : 60000); // 1. If the request is an INVITE that contains an Expires header\n    // field, the UAS core sets a timer for the number of seconds\n    // indicated in the header field value.  When the timer fires, the\n    // invitation is considered to be expired.  If the invitation\n    // expires before the UAS has generated a final response, a 487\n    // (Request Terminated) response SHOULD be generated.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1\n\n    if (incomingRequestMessage.hasHeader(\"expires\")) {\n      const expires = Number(incomingRequestMessage.getHeader(\"expires\") || 0) * 1000;\n      this.expiresTimer = setTimeout(() => {\n        if (this.state === SessionState.Initial) {\n          incomingInviteRequest.reject({\n            statusCode: 487\n          });\n          this.stateTransition(SessionState.Terminated);\n        }\n      }, expires);\n    } // Session parent properties\n\n\n    const assertedIdentity = this.request.getHeader(\"P-Asserted-Identity\");\n\n    if (assertedIdentity) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);\n    }\n\n    this._contact = this.userAgent.contact.toString();\n    const contentDisposition = incomingRequestMessage.parseHeader(\"Content-Disposition\");\n\n    if (contentDisposition && contentDisposition.type === \"render\") {\n      this._renderbody = incomingRequestMessage.body;\n      this._rendertype = incomingRequestMessage.getHeader(\"Content-Type\");\n    } // Identifier\n\n\n    this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag; // Add to the user agent's session collection.\n\n    this.userAgent._sessions[this._id] = this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    // Only run through this once. It can and does get called multiple times\n    // depending on the what the sessions state is when first called.\n    // For example, if called when \"establishing\" it will be called again\n    // at least once when the session transitions to \"terminated\".\n    // Regardless, running through this more than once is pointless.\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true; // Clear timers\n\n    if (this.expiresTimer) {\n      clearTimeout(this.expiresTimer);\n      this.expiresTimer = undefined;\n    }\n\n    if (this.userNoAnswerTimer) {\n      clearTimeout(this.userNoAnswerTimer);\n      this.userNoAnswerTimer = undefined;\n    } // If accept() is still waiting for a PRACK, make sure it rejects\n\n\n    this.prackNeverArrived(); // If the final response for the initial INVITE not yet been sent, reject it\n\n    switch (this.state) {\n      case SessionState.Initial:\n        return this.reject().then(() => super.dispose());\n\n      case SessionState.Establishing:\n        return this.reject().then(() => super.dispose());\n\n      case SessionState.Established:\n        return super.dispose();\n\n      case SessionState.Terminating:\n        return super.dispose();\n\n      case SessionState.Terminated:\n        return super.dispose();\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n  }\n  /**\n   * If true, a first provisional response after the 100 Trying\n   * will be sent automatically. This is false it the UAC required\n   * reliable provisional responses (100rel in Require header),\n   * otherwise it is true. The provisional is sent by calling\n   * `progress()` without any options.\n   *\n   * FIXME: TODO: It seems reasonable that the ISC user should\n   * be able to optionally disable this behavior. As the provisional\n   * is sent prior to the \"invite\" event being emitted, it's a known\n   * issue that the ISC user cannot register listeners or do any other\n   * setup prior to the call to `progress()`. As an example why this is\n   * an issue, setting `ua.configuration.rel100` to REQUIRED will result\n   * in an attempt by `progress()` to send a 183 with SDP produced by\n   * calling `getDescription()` on a session description handler, but\n   * the ISC user cannot perform any potentially required session description\n   * handler initialization (thus preventing the utilization of setting\n   * `ua.configuration.rel100` to REQUIRED). That begs the question of\n   * why this behavior is disabled when the UAC requires 100rel but not\n   * when the UAS requires 100rel? But ignoring that, it's just one example\n   * of a class of cases where the ISC user needs to do something prior\n   * to the first call to `progress()` and is unable to do so.\n   * @internal\n   */\n\n\n  get autoSendAnInitialProvisionalResponse() {\n    return this.rel100 === \"required\" ? false : true;\n  }\n  /**\n   * Initial incoming INVITE request message body.\n   */\n\n\n  get body() {\n    return this.incomingInviteRequest.message.body;\n  }\n  /**\n   * The identity of the local user.\n   */\n\n\n  get localIdentity() {\n    return this.request.to;\n  }\n  /**\n   * The identity of the remote user.\n   */\n\n\n  get remoteIdentity() {\n    return this.request.from;\n  }\n  /**\n   * Initial incoming INVITE request message.\n   */\n\n\n  get request() {\n    return this.incomingInviteRequest.message;\n  }\n  /**\n   * Accept the invitation.\n   *\n   * @remarks\n   * Accept the incoming INVITE request to start a Session.\n   * Replies to the INVITE request with a 200 Ok response.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * This method may reject for a variety of reasons including\n   * the receipt of a CANCEL request before `accept` is able\n   * to construct a response.\n   * @param options - Options bucket.\n   */\n\n\n  accept(options = {}) {\n    this.logger.log(\"Invitation.accept\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Establishing);\n    return this.sendAccept() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    .then(({\n      message,\n      session\n    }) => {\n      session.delegate = {\n        onAck: ackRequest => this.onAckRequest(ackRequest),\n        onAckTimeout: () => this.onAckTimeout(),\n        onBye: byeRequest => this.onByeRequest(byeRequest),\n        onInfo: infoRequest => this.onInfoRequest(infoRequest),\n        onInvite: inviteRequest => this.onInviteRequest(inviteRequest),\n        onMessage: messageRequest => this.onMessageRequest(messageRequest),\n        onNotify: notifyRequest => this.onNotifyRequest(notifyRequest),\n        onPrack: prackRequest => this.onPrackRequest(prackRequest),\n        onRefer: referRequest => this.onReferRequest(referRequest)\n      };\n      this._dialog = session;\n      this.stateTransition(SessionState.Established); // TODO: Reconsider this \"automagic\" send of a BYE to replacee behavior.\n      // This behavior has been ported forward from legacy versions.\n\n      if (this._replacee) {\n        this._replacee._bye();\n      }\n    }).catch(error => this.handleResponseError(error));\n  }\n  /**\n   * Indicate progress processing the invitation.\n   *\n   * @remarks\n   * Report progress to the the caller.\n   * Replies to the INVITE request with a 1xx provisional response.\n   * Resolves once the response sent, otherwise rejects.\n   * @param options - Options bucket.\n   */\n\n\n  progress(options = {}) {\n    this.logger.log(\"Invitation.progress\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // Ported\n\n\n    const statusCode = options.statusCode || 180;\n\n    if (statusCode < 100 || statusCode > 199) {\n      throw new TypeError(\"Invalid statusCode: \" + statusCode);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // After the first reliable provisional response for a request has been\n    // acknowledged, the UAS MAY send additional reliable provisional\n    // responses.  The UAS MUST NOT send a second reliable provisional\n    // response until the first is acknowledged.  After the first, it is\n    // RECOMMENDED that the UAS not send an additional reliable provisional\n    // response until the previous is acknowledged.  The first reliable\n    // provisional response receives special treatment because it conveys\n    // the initial sequence number.  If additional reliable provisional\n    // responses were sent before the first was acknowledged, the UAS could\n    // not be certain these were received in order.\n    // https://tools.ietf.org/html/rfc3262#section-3\n\n\n    if (this.waitingForPrack) {\n      this.logger.warn(\"Unexpected call for progress while waiting for prack, ignoring\");\n      return Promise.resolve();\n    } // Trying provisional response\n\n\n    if (options.statusCode === 100) {\n      return this.sendProgressTrying().then(() => {\n        return;\n      }).catch(error => this.handleResponseError(error));\n    } // Standard provisional response\n\n\n    if (!(this.rel100 === \"required\") && !(this.rel100 === \"supported\" && options.rel100) && !(this.rel100 === \"supported\" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {\n      return this.sendProgress(options).then(() => {\n        return;\n      }).catch(error => this.handleResponseError(error));\n    } // Reliable provisional response\n\n\n    return this.sendProgressReliableWaitForPrack(options).then(() => {\n      return;\n    }).catch(error => this.handleResponseError(error));\n  }\n  /**\n   * Reject the invitation.\n   *\n   * @remarks\n   * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * The expectation is that this method is used to reject an INVITE request.\n   * That is indeed the case - a call to `progress` followed by `reject` is\n   * a typical way to \"decline\" an incoming INVITE request. However it may\n   * also be called after calling `accept` (but only before it completes)\n   * which will reject the call and cause `accept` to reject.\n   * @param options - Options bucket.\n   */\n\n\n  reject(options = {}) {\n    this.logger.log(\"Invitation.reject\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    }\n\n    const statusCode = options.statusCode || 480;\n    const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);\n    const extraHeaders = options.extraHeaders || [];\n\n    if (statusCode < 300 || statusCode > 699) {\n      throw new TypeError(\"Invalid statusCode: \" + statusCode);\n    }\n\n    const body = options.body ? fromBodyLegacy(options.body) : undefined; // FIXME: Need to redirect to someplace\n\n    statusCode < 400 ? this.incomingInviteRequest.redirect([], {\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    }) : this.incomingInviteRequest.reject({\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    });\n    this.stateTransition(SessionState.Terminated);\n    return Promise.resolve();\n  }\n  /**\n   * Handle CANCEL request.\n   *\n   * @param message - CANCEL message.\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _onCancel(message) {\n    this.logger.log(\"Invitation._onCancel\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);\n      return;\n    } // flag canceled\n\n\n    this.isCanceled = true; // reject INVITE with 487 status code\n\n    this.incomingInviteRequest.reject({\n      statusCode: 487\n    });\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Helper function to handle offer/answer in a PRACK.\n   */\n\n\n  handlePrackOfferAnswer(request) {\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    } // If the PRACK doesn't have an offer/answer, nothing to be done.\n\n\n    const body = getBody(request.message);\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return Promise.resolve(undefined);\n    }\n\n    const options = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    }; // If the UAC receives a reliable provisional response with an offer\n    // (this would occur if the UAC sent an INVITE without an offer, in\n    // which case the first reliable provisional response will contain the\n    // offer), it MUST generate an answer in the PRACK.  If the UAC receives\n    // a reliable provisional response with an answer, it MAY generate an\n    // additional offer in the PRACK.  If the UAS receives a PRACK with an\n    // offer, it MUST place the answer in the 2xx to the PRACK.\n    // https://tools.ietf.org/html/rfc3262#section-5\n\n    switch (this.dialog.signalingState) {\n      case SignalingState.Initial:\n        // State should never be reached as first reliable provisional response must have answer/offer.\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      case SignalingState.Stable:\n        // Receved answer.\n        return this.setAnswer(body, options).then(() => undefined);\n\n      case SignalingState.HaveLocalOffer:\n        // State should never be reached as local offer would be answered by this PRACK\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      case SignalingState.HaveRemoteOffer:\n        // Received offer, generate answer.\n        return this.setOfferAndGetAnswer(body, options);\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n    }\n  }\n  /**\n   * A handler for errors which occur while attempting to send 1xx and 2xx responses.\n   * In all cases, an attempt is made to reject the request if it is still outstanding.\n   * And while there are a variety of things which can go wrong and we log something here\n   * for all errors, there are a handful of common exceptions we pay some extra attention to.\n   * @param error - The error which occurred.\n   */\n\n\n  handleResponseError(error) {\n    let statusCode = 480; // \"Temporarily Unavailable\"\n    // Log Error message\n\n    if (error instanceof Error) {\n      this.logger.error(error.message);\n    } else {\n      // We don't actually know what a session description handler implementation might throw our way,\n      // and more generally as a last resort catch all, just assume we are getting an \"unknown\" and log it.\n      this.logger.error(error);\n    } // Log Exception message\n\n\n    if (error instanceof ContentTypeUnsupportedError) {\n      this.logger.error(\"A session description handler occurred while sending response (content type unsupported\");\n      statusCode = 415; // \"Unsupported Media Type\"\n    } else if (error instanceof SessionDescriptionHandlerError) {\n      this.logger.error(\"A session description handler occurred while sending response\");\n    } else if (error instanceof SessionTerminatedError) {\n      this.logger.error(\"Session ended before response could be formulated and sent (while waiting for PRACK)\");\n    } else if (error instanceof TransactionStateError) {\n      this.logger.error(\"Session changed state before response could be formulated and sent\");\n    } // Reject if still in \"initial\" or \"establishing\" state.\n\n\n    if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {\n      try {\n        this.incomingInviteRequest.reject({\n          statusCode\n        });\n        this.stateTransition(SessionState.Terminated);\n      } catch (e) {\n        this.logger.error(\"An error occurred attempting to reject the request while handling another error\");\n        throw e; // This is not a good place to be...\n      }\n    } // FIXME: TODO:\n    // Here we are squelching the throwing of errors due to an race condition.\n    // We have an internal race between calling `accept()` and handling an incoming\n    // CANCEL request. As there is no good way currently to delegate the handling of\n    // these race errors to the caller of `accept()`, we are squelching the throwing\n    // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know\n    // is a \"normal\" exceptional condition. While this is a completely reasonable approach,\n    // the decision should be left up to the library user. Furthermore, as we are eating\n    // ALL errors in this case, we are potentially (likely) hiding \"real\" errors which occur.\n    //\n    // Only rethrow error if the session has not been canceled.\n\n\n    if (this.isCanceled) {\n      this.logger.warn(\"An error occurred while attempting to formulate and send a response to an incoming INVITE.\" + \" However a CANCEL was received and processed while doing so which can (and often does) result\" + \" in errors occurring as the session terminates in the meantime. Said error is being ignored.\");\n      return;\n    }\n\n    throw error;\n  }\n  /**\n   * Callback for when ACK for a 2xx response is never received.\n   * @param session - Session the ACK never arrived for.\n   */\n\n\n  onAckTimeout() {\n    this.logger.log(\"Invitation.onAckTimeout\");\n\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    }\n\n    this.logger.log(\"No ACK received for an extended period of time, terminating session\");\n    this.dialog.bye();\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * A version of `accept` which resolves a session when the 200 Ok response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendAccept() {\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    }; // The UAS MAY send a final response to the initial request before\n    // having received PRACKs for all unacknowledged reliable provisional\n    // responses, unless the final response is 2xx and any of the\n    // unacknowledged reliable provisional responses contained a session\n    // description.  In that case, it MUST NOT send a final response until\n    // those provisional responses are acknowledged.  If the UAS does send a\n    // final response when reliable responses are still unacknowledged, it\n    // SHOULD NOT continue to retransmit the unacknowledged reliable\n    // provisional responses, but it MUST be prepared to process PRACK\n    // requests for those outstanding responses.  A UAS MUST NOT send new\n    // reliable provisional responses (as opposed to retransmissions of\n    // unacknowledged ones) after sending a final response to a request.\n    // https://tools.ietf.org/html/rfc3262#section-3\n\n    if (this.waitingForPrack) {\n      return this.waitForArrivalOfPrack().then(() => clearTimeout(this.userNoAnswerTimer)) // Ported\n      .then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)).then(body => this.incomingInviteRequest.accept({\n        statusCode: 200,\n        body\n      }));\n    }\n\n    clearTimeout(this.userNoAnswerTimer); // Ported\n\n    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(body => this.incomingInviteRequest.accept({\n      statusCode: 200,\n      body\n    }));\n  }\n  /**\n   * A version of `progress` which resolves when the provisional response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgress(options = {}) {\n    const statusCode = options.statusCode || 180;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice();\n    const body = options.body ? fromBodyLegacy(options.body) : undefined; // The 183 (Session Progress) response is used to convey information\n    // about the progress of the call that is not otherwise classified.  The\n    // Reason-Phrase, header fields, or message body MAY be used to convey\n    // more details about the call progress.\n    // https://tools.ietf.org/html/rfc3261#section-21.1.5\n    // It is the de facto industry standard to utilize 183 with SDP to provide \"early media\".\n    // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.\n\n    if (statusCode === 183 && !body) {\n      return this.sendProgressWithSDP(options);\n    }\n\n    try {\n      const progressResponse = this.incomingInviteRequest.progress({\n        statusCode,\n        reasonPhrase,\n        extraHeaders,\n        body\n      });\n      this._dialog = progressResponse.session;\n      return Promise.resolve(progressResponse);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * A version of `progress` which resolves when the provisional response with sdp is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressWithSDP(options = {}) {\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    };\n    const statusCode = options.statusCode || 183;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice(); // Get an offer/answer and send a reply.\n\n    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(body => this.incomingInviteRequest.progress({\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    })).then(progressResponse => {\n      this._dialog = progressResponse.session;\n      return progressResponse;\n    });\n  }\n  /**\n   * A version of `progress` which resolves when the reliable provisional response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressReliable(options = {}) {\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(\"Require: 100rel\");\n    options.extraHeaders.push(\"RSeq: \" + Math.floor(Math.random() * 10000));\n    return this.sendProgressWithSDP(options);\n  }\n  /**\n   * A version of `progress` which resolves when the reliable provisional response is acknowledged.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressReliableWaitForPrack(options = {}) {\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    };\n    const statusCode = options.statusCode || 183;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice();\n    extraHeaders.push(\"Require: 100rel\");\n    extraHeaders.push(\"RSeq: \" + this.rseq++);\n    let body;\n    return new Promise((resolve, reject) => {\n      this.waitingForPrack = true;\n      this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(offerAnswer => {\n        body = offerAnswer;\n        return this.incomingInviteRequest.progress({\n          statusCode,\n          reasonPhrase,\n          extraHeaders,\n          body\n        });\n      }).then(progressResponse => {\n        this._dialog = progressResponse.session;\n        let prackRequest;\n        let prackResponse;\n        progressResponse.session.delegate = {\n          onPrack: request => {\n            prackRequest = request; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n            clearTimeout(prackWaitTimeoutTimer); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n            clearTimeout(rel1xxRetransmissionTimer);\n\n            if (!this.waitingForPrack) {\n              return;\n            }\n\n            this.waitingForPrack = false;\n            this.handlePrackOfferAnswer(prackRequest).then(prackResponseBody => {\n              try {\n                prackResponse = prackRequest.accept({\n                  statusCode: 200,\n                  body: prackResponseBody\n                });\n                this.prackArrived();\n                resolve({\n                  prackRequest,\n                  prackResponse,\n                  progressResponse\n                });\n              } catch (error) {\n                reject(error);\n              }\n            }).catch(error => reject(error));\n          }\n        }; // https://tools.ietf.org/html/rfc3262#section-3\n\n        const prackWaitTimeout = () => {\n          if (!this.waitingForPrack) {\n            return;\n          }\n\n          this.waitingForPrack = false;\n          this.logger.warn(\"No PRACK received, rejecting INVITE.\"); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n          clearTimeout(rel1xxRetransmissionTimer);\n          this.reject({\n            statusCode: 504\n          }).then(() => reject(new SessionTerminatedError())).catch(error => reject(error));\n        };\n\n        const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64); // https://tools.ietf.org/html/rfc3262#section-3\n\n        const rel1xxRetransmission = () => {\n          try {\n            this.incomingInviteRequest.progress({\n              statusCode,\n              reasonPhrase,\n              extraHeaders,\n              body\n            });\n          } catch (error) {\n            this.waitingForPrack = false;\n            reject(error);\n            return;\n          } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n          rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);\n        };\n\n        let timeout = Timers.T1;\n        let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);\n      }).catch(error => {\n        this.waitingForPrack = false;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * A version of `progress` which resolves when a 100 Trying provisional response is sent.\n   */\n\n\n  sendProgressTrying() {\n    try {\n      const progressResponse = this.incomingInviteRequest.trying();\n      return Promise.resolve(progressResponse);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * When attempting to accept the INVITE, an invitation waits\n   * for any outstanding PRACK to arrive before sending the 200 Ok.\n   * It will be waiting on this Promise to resolve which lets it know\n   * the PRACK has arrived and it may proceed to send the 200 Ok.\n   */\n\n\n  waitForArrivalOfPrack() {\n    if (this.waitingForPrackPromise) {\n      throw new Error(\"Already waiting for PRACK\");\n    }\n\n    this.waitingForPrackPromise = new Promise((resolve, reject) => {\n      this.waitingForPrackResolve = resolve;\n      this.waitingForPrackReject = reject;\n    });\n    return this.waitingForPrackPromise;\n  }\n  /**\n   * Here we are resolving the promise which in turn will cause\n   * the accept to proceed (it may still fail for other reasons, but...).\n   */\n\n\n  prackArrived() {\n    if (this.waitingForPrackResolve) {\n      this.waitingForPrackResolve();\n    }\n\n    this.waitingForPrackPromise = undefined;\n    this.waitingForPrackResolve = undefined;\n    this.waitingForPrackReject = undefined;\n  }\n  /**\n   * Here we are rejecting the promise which in turn will cause\n   * the accept to fail and the session to transition to \"terminated\".\n   */\n\n\n  prackNeverArrived() {\n    if (this.waitingForPrackReject) {\n      this.waitingForPrackReject(new SessionTerminatedError());\n    }\n\n    this.waitingForPrackPromise = undefined;\n    this.waitingForPrackResolve = undefined;\n    this.waitingForPrackReject = undefined;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/invitation.js"],"names":["fromBodyLegacy","getBody","Grammar","SignalingState","Timers","TransactionStateError","getReasonPhrase","ContentTypeUnsupportedError","SessionDescriptionHandlerError","SessionTerminatedError","Session","SessionState","SIPExtension","Invitation","constructor","userAgent","incomingInviteRequest","disposed","expiresTimer","undefined","isCanceled","rel100","rseq","Math","floor","random","userNoAnswerTimer","waitingForPrack","logger","getLogger","incomingRequestMessage","message","requireHeader","getHeader","toLowerCase","includes","supportedHeader","toTag","TypeError","setTimeout","reject","statusCode","stateTransition","Terminated","configuration","noAnswerTimeout","hasHeader","expires","Number","state","Initial","assertedIdentity","request","_assertedIdentity","nameAddrHeaderParse","_contact","contact","toString","contentDisposition","parseHeader","type","_renderbody","body","_rendertype","_id","callId","fromTag","_sessions","dispose","Promise","resolve","clearTimeout","prackNeverArrived","then","Establishing","Established","Terminating","Error","autoSendAnInitialProvisionalResponse","localIdentity","to","remoteIdentity","from","accept","options","log","error","sessionDescriptionHandlerModifiers","sessionDescriptionHandlerOptions","sendAccept","session","delegate","onAck","ackRequest","onAckRequest","onAckTimeout","onBye","byeRequest","onByeRequest","onInfo","infoRequest","onInfoRequest","onInvite","inviteRequest","onInviteRequest","onMessage","messageRequest","onMessageRequest","onNotify","notifyRequest","onNotifyRequest","onPrack","prackRequest","onPrackRequest","onRefer","referRequest","onReferRequest","_dialog","_replacee","_bye","catch","handleResponseError","progress","warn","sendProgressTrying","sipExtension100rel","Required","sendProgress","sendProgressReliableWaitForPrack","reasonPhrase","extraHeaders","redirect","_onCancel","handlePrackOfferAnswer","dialog","signalingState","Stable","setAnswer","HaveLocalOffer","HaveRemoteOffer","setOfferAndGetAnswer","Closed","e","bye","responseOptions","waitForArrivalOfPrack","generateResponseOfferAnswer","slice","sendProgressWithSDP","progressResponse","sendProgressReliable","push","offerAnswer","prackResponse","prackWaitTimeoutTimer","rel1xxRetransmissionTimer","prackResponseBody","prackArrived","prackWaitTimeout","T1","rel1xxRetransmission","timeout","trying","waitingForPrackPromise","waitingForPrackResolve","waitingForPrackReject"],"mappings":"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","sourcesContent":["import { fromBodyLegacy, getBody, Grammar, SignalingState, Timers, TransactionStateError } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { ContentTypeUnsupportedError, SessionDescriptionHandlerError, SessionTerminatedError } from \"./exceptions\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An invitation is an offer to establish a {@link Session} (incoming INVITE).\n * @public\n */\nexport class Invitation extends Session {\n    /** @internal */\n    constructor(userAgent, incomingInviteRequest) {\n        super(userAgent);\n        this.incomingInviteRequest = incomingInviteRequest;\n        /** True if dispose() has been called. */\n        this.disposed = false;\n        /** INVITE will be rejected if not accepted within a certain period time. */\n        this.expiresTimer = undefined;\n        /** True if this Session has been Terminated due to a CANCEL request. */\n        this.isCanceled = false;\n        /** Are reliable provisional responses required or supported. */\n        this.rel100 = \"none\";\n        /** The current RSeq header value. */\n        this.rseq = Math.floor(Math.random() * 10000);\n        /** INVITE will be rejected if final response not sent in a certain period time. */\n        this.userNoAnswerTimer = undefined;\n        /** True if waiting for a PRACK before sending a 200 Ok. */\n        this.waitingForPrack = false;\n        this.logger = userAgent.getLogger(\"sip.Invitation\");\n        const incomingRequestMessage = this.incomingInviteRequest.message;\n        // Set 100rel if necessary\n        const requireHeader = incomingRequestMessage.getHeader(\"require\");\n        if (requireHeader && requireHeader.toLowerCase().includes(\"100rel\")) {\n            this.rel100 = \"required\";\n        }\n        const supportedHeader = incomingRequestMessage.getHeader(\"supported\");\n        if (supportedHeader && supportedHeader.toLowerCase().includes(\"100rel\")) {\n            this.rel100 = \"supported\";\n        }\n        // FIXME: HACK: This is a hack to port an existing behavior.\n        // Set the toTag on the incoming request message to the toTag which\n        // will be used in the response to the incoming request!!!\n        // The behavior being ported appears to be a hack itself,\n        // so this is a hack to port a hack. At least one test spec\n        // relies on it (which is yet another hack).\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        incomingRequestMessage.toTag = incomingInviteRequest.toTag;\n        if (typeof incomingRequestMessage.toTag !== \"string\") {\n            throw new TypeError(\"toTag should have been a string.\");\n        }\n        // The following mapping values are RECOMMENDED:\n        // ...\n        // 19 no answer from the user              480 Temporarily unavailable\n        // https://tools.ietf.org/html/rfc3398#section-7.2.4.1\n        this.userNoAnswerTimer = setTimeout(() => {\n            incomingInviteRequest.reject({ statusCode: 480 });\n            this.stateTransition(SessionState.Terminated);\n        }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1000 : 60000);\n        // 1. If the request is an INVITE that contains an Expires header\n        // field, the UAS core sets a timer for the number of seconds\n        // indicated in the header field value.  When the timer fires, the\n        // invitation is considered to be expired.  If the invitation\n        // expires before the UAS has generated a final response, a 487\n        // (Request Terminated) response SHOULD be generated.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1\n        if (incomingRequestMessage.hasHeader(\"expires\")) {\n            const expires = Number(incomingRequestMessage.getHeader(\"expires\") || 0) * 1000;\n            this.expiresTimer = setTimeout(() => {\n                if (this.state === SessionState.Initial) {\n                    incomingInviteRequest.reject({ statusCode: 487 });\n                    this.stateTransition(SessionState.Terminated);\n                }\n            }, expires);\n        }\n        // Session parent properties\n        const assertedIdentity = this.request.getHeader(\"P-Asserted-Identity\");\n        if (assertedIdentity) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);\n        }\n        this._contact = this.userAgent.contact.toString();\n        const contentDisposition = incomingRequestMessage.parseHeader(\"Content-Disposition\");\n        if (contentDisposition && contentDisposition.type === \"render\") {\n            this._renderbody = incomingRequestMessage.body;\n            this._rendertype = incomingRequestMessage.getHeader(\"Content-Type\");\n        }\n        // Identifier\n        this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag;\n        // Add to the user agent's session collection.\n        this.userAgent._sessions[this._id] = this;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        // Only run through this once. It can and does get called multiple times\n        // depending on the what the sessions state is when first called.\n        // For example, if called when \"establishing\" it will be called again\n        // at least once when the session transitions to \"terminated\".\n        // Regardless, running through this more than once is pointless.\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        // Clear timers\n        if (this.expiresTimer) {\n            clearTimeout(this.expiresTimer);\n            this.expiresTimer = undefined;\n        }\n        if (this.userNoAnswerTimer) {\n            clearTimeout(this.userNoAnswerTimer);\n            this.userNoAnswerTimer = undefined;\n        }\n        // If accept() is still waiting for a PRACK, make sure it rejects\n        this.prackNeverArrived();\n        // If the final response for the initial INVITE not yet been sent, reject it\n        switch (this.state) {\n            case SessionState.Initial:\n                return this.reject().then(() => super.dispose());\n            case SessionState.Establishing:\n                return this.reject().then(() => super.dispose());\n            case SessionState.Established:\n                return super.dispose();\n            case SessionState.Terminating:\n                return super.dispose();\n            case SessionState.Terminated:\n                return super.dispose();\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n    }\n    /**\n     * If true, a first provisional response after the 100 Trying\n     * will be sent automatically. This is false it the UAC required\n     * reliable provisional responses (100rel in Require header),\n     * otherwise it is true. The provisional is sent by calling\n     * `progress()` without any options.\n     *\n     * FIXME: TODO: It seems reasonable that the ISC user should\n     * be able to optionally disable this behavior. As the provisional\n     * is sent prior to the \"invite\" event being emitted, it's a known\n     * issue that the ISC user cannot register listeners or do any other\n     * setup prior to the call to `progress()`. As an example why this is\n     * an issue, setting `ua.configuration.rel100` to REQUIRED will result\n     * in an attempt by `progress()` to send a 183 with SDP produced by\n     * calling `getDescription()` on a session description handler, but\n     * the ISC user cannot perform any potentially required session description\n     * handler initialization (thus preventing the utilization of setting\n     * `ua.configuration.rel100` to REQUIRED). That begs the question of\n     * why this behavior is disabled when the UAC requires 100rel but not\n     * when the UAS requires 100rel? But ignoring that, it's just one example\n     * of a class of cases where the ISC user needs to do something prior\n     * to the first call to `progress()` and is unable to do so.\n     * @internal\n     */\n    get autoSendAnInitialProvisionalResponse() {\n        return this.rel100 === \"required\" ? false : true;\n    }\n    /**\n     * Initial incoming INVITE request message body.\n     */\n    get body() {\n        return this.incomingInviteRequest.message.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n    get localIdentity() {\n        return this.request.to;\n    }\n    /**\n     * The identity of the remote user.\n     */\n    get remoteIdentity() {\n        return this.request.from;\n    }\n    /**\n     * Initial incoming INVITE request message.\n     */\n    get request() {\n        return this.incomingInviteRequest.message;\n    }\n    /**\n     * Accept the invitation.\n     *\n     * @remarks\n     * Accept the incoming INVITE request to start a Session.\n     * Replies to the INVITE request with a 200 Ok response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * This method may reject for a variety of reasons including\n     * the receipt of a CANCEL request before `accept` is able\n     * to construct a response.\n     * @param options - Options bucket.\n     */\n    accept(options = {}) {\n        this.logger.log(\"Invitation.accept\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // transition state\n        this.stateTransition(SessionState.Establishing);\n        return (this.sendAccept()\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .then(({ message, session }) => {\n            session.delegate = {\n                onAck: (ackRequest) => this.onAckRequest(ackRequest),\n                onAckTimeout: () => this.onAckTimeout(),\n                onBye: (byeRequest) => this.onByeRequest(byeRequest),\n                onInfo: (infoRequest) => this.onInfoRequest(infoRequest),\n                onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),\n                onMessage: (messageRequest) => this.onMessageRequest(messageRequest),\n                onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),\n                onPrack: (prackRequest) => this.onPrackRequest(prackRequest),\n                onRefer: (referRequest) => this.onReferRequest(referRequest)\n            };\n            this._dialog = session;\n            this.stateTransition(SessionState.Established);\n            // TODO: Reconsider this \"automagic\" send of a BYE to replacee behavior.\n            // This behavior has been ported forward from legacy versions.\n            if (this._replacee) {\n                this._replacee._bye();\n            }\n        })\n            .catch((error) => this.handleResponseError(error)));\n    }\n    /**\n     * Indicate progress processing the invitation.\n     *\n     * @remarks\n     * Report progress to the the caller.\n     * Replies to the INVITE request with a 1xx provisional response.\n     * Resolves once the response sent, otherwise rejects.\n     * @param options - Options bucket.\n     */\n    progress(options = {}) {\n        this.logger.log(\"Invitation.progress\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // Ported\n        const statusCode = options.statusCode || 180;\n        if (statusCode < 100 || statusCode > 199) {\n            throw new TypeError(\"Invalid statusCode: \" + statusCode);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // After the first reliable provisional response for a request has been\n        // acknowledged, the UAS MAY send additional reliable provisional\n        // responses.  The UAS MUST NOT send a second reliable provisional\n        // response until the first is acknowledged.  After the first, it is\n        // RECOMMENDED that the UAS not send an additional reliable provisional\n        // response until the previous is acknowledged.  The first reliable\n        // provisional response receives special treatment because it conveys\n        // the initial sequence number.  If additional reliable provisional\n        // responses were sent before the first was acknowledged, the UAS could\n        // not be certain these were received in order.\n        // https://tools.ietf.org/html/rfc3262#section-3\n        if (this.waitingForPrack) {\n            this.logger.warn(\"Unexpected call for progress while waiting for prack, ignoring\");\n            return Promise.resolve();\n        }\n        // Trying provisional response\n        if (options.statusCode === 100) {\n            return this.sendProgressTrying()\n                .then(() => {\n                return;\n            })\n                .catch((error) => this.handleResponseError(error));\n        }\n        // Standard provisional response\n        if (!(this.rel100 === \"required\") &&\n            !(this.rel100 === \"supported\" && options.rel100) &&\n            !(this.rel100 === \"supported\" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {\n            return this.sendProgress(options)\n                .then(() => {\n                return;\n            })\n                .catch((error) => this.handleResponseError(error));\n        }\n        // Reliable provisional response\n        return this.sendProgressReliableWaitForPrack(options)\n            .then(() => {\n            return;\n        })\n            .catch((error) => this.handleResponseError(error));\n    }\n    /**\n     * Reject the invitation.\n     *\n     * @remarks\n     * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * The expectation is that this method is used to reject an INVITE request.\n     * That is indeed the case - a call to `progress` followed by `reject` is\n     * a typical way to \"decline\" an incoming INVITE request. However it may\n     * also be called after calling `accept` (but only before it completes)\n     * which will reject the call and cause `accept` to reject.\n     * @param options - Options bucket.\n     */\n    reject(options = {}) {\n        this.logger.log(\"Invitation.reject\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        const statusCode = options.statusCode || 480;\n        const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);\n        const extraHeaders = options.extraHeaders || [];\n        if (statusCode < 300 || statusCode > 699) {\n            throw new TypeError(\"Invalid statusCode: \" + statusCode);\n        }\n        const body = options.body ? fromBodyLegacy(options.body) : undefined;\n        // FIXME: Need to redirect to someplace\n        statusCode < 400\n            ? this.incomingInviteRequest.redirect([], { statusCode, reasonPhrase, extraHeaders, body })\n            : this.incomingInviteRequest.reject({ statusCode, reasonPhrase, extraHeaders, body });\n        this.stateTransition(SessionState.Terminated);\n        return Promise.resolve();\n    }\n    /**\n     * Handle CANCEL request.\n     *\n     * @param message - CANCEL message.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _onCancel(message) {\n        this.logger.log(\"Invitation._onCancel\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // flag canceled\n        this.isCanceled = true;\n        // reject INVITE with 487 status code\n        this.incomingInviteRequest.reject({ statusCode: 487 });\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Helper function to handle offer/answer in a PRACK.\n     */\n    handlePrackOfferAnswer(request) {\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        // If the PRACK doesn't have an offer/answer, nothing to be done.\n        const body = getBody(request.message);\n        if (!body || body.contentDisposition !== \"session\") {\n            return Promise.resolve(undefined);\n        }\n        const options = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        // If the UAC receives a reliable provisional response with an offer\n        // (this would occur if the UAC sent an INVITE without an offer, in\n        // which case the first reliable provisional response will contain the\n        // offer), it MUST generate an answer in the PRACK.  If the UAC receives\n        // a reliable provisional response with an answer, it MAY generate an\n        // additional offer in the PRACK.  If the UAS receives a PRACK with an\n        // offer, it MUST place the answer in the 2xx to the PRACK.\n        // https://tools.ietf.org/html/rfc3262#section-5\n        switch (this.dialog.signalingState) {\n            case SignalingState.Initial:\n                // State should never be reached as first reliable provisional response must have answer/offer.\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            case SignalingState.Stable:\n                // Receved answer.\n                return this.setAnswer(body, options).then(() => undefined);\n            case SignalingState.HaveLocalOffer:\n                // State should never be reached as local offer would be answered by this PRACK\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            case SignalingState.HaveRemoteOffer:\n                // Received offer, generate answer.\n                return this.setOfferAndGetAnswer(body, options);\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n        }\n    }\n    /**\n     * A handler for errors which occur while attempting to send 1xx and 2xx responses.\n     * In all cases, an attempt is made to reject the request if it is still outstanding.\n     * And while there are a variety of things which can go wrong and we log something here\n     * for all errors, there are a handful of common exceptions we pay some extra attention to.\n     * @param error - The error which occurred.\n     */\n    handleResponseError(error) {\n        let statusCode = 480; // \"Temporarily Unavailable\"\n        // Log Error message\n        if (error instanceof Error) {\n            this.logger.error(error.message);\n        }\n        else {\n            // We don't actually know what a session description handler implementation might throw our way,\n            // and more generally as a last resort catch all, just assume we are getting an \"unknown\" and log it.\n            this.logger.error(error);\n        }\n        // Log Exception message\n        if (error instanceof ContentTypeUnsupportedError) {\n            this.logger.error(\"A session description handler occurred while sending response (content type unsupported\");\n            statusCode = 415; // \"Unsupported Media Type\"\n        }\n        else if (error instanceof SessionDescriptionHandlerError) {\n            this.logger.error(\"A session description handler occurred while sending response\");\n        }\n        else if (error instanceof SessionTerminatedError) {\n            this.logger.error(\"Session ended before response could be formulated and sent (while waiting for PRACK)\");\n        }\n        else if (error instanceof TransactionStateError) {\n            this.logger.error(\"Session changed state before response could be formulated and sent\");\n        }\n        // Reject if still in \"initial\" or \"establishing\" state.\n        if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {\n            try {\n                this.incomingInviteRequest.reject({ statusCode });\n                this.stateTransition(SessionState.Terminated);\n            }\n            catch (e) {\n                this.logger.error(\"An error occurred attempting to reject the request while handling another error\");\n                throw e; // This is not a good place to be...\n            }\n        }\n        // FIXME: TODO:\n        // Here we are squelching the throwing of errors due to an race condition.\n        // We have an internal race between calling `accept()` and handling an incoming\n        // CANCEL request. As there is no good way currently to delegate the handling of\n        // these race errors to the caller of `accept()`, we are squelching the throwing\n        // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know\n        // is a \"normal\" exceptional condition. While this is a completely reasonable approach,\n        // the decision should be left up to the library user. Furthermore, as we are eating\n        // ALL errors in this case, we are potentially (likely) hiding \"real\" errors which occur.\n        //\n        // Only rethrow error if the session has not been canceled.\n        if (this.isCanceled) {\n            this.logger.warn(\"An error occurred while attempting to formulate and send a response to an incoming INVITE.\" +\n                \" However a CANCEL was received and processed while doing so which can (and often does) result\" +\n                \" in errors occurring as the session terminates in the meantime. Said error is being ignored.\");\n            return;\n        }\n        throw error;\n    }\n    /**\n     * Callback for when ACK for a 2xx response is never received.\n     * @param session - Session the ACK never arrived for.\n     */\n    onAckTimeout() {\n        this.logger.log(\"Invitation.onAckTimeout\");\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        this.logger.log(\"No ACK received for an extended period of time, terminating session\");\n        this.dialog.bye();\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * A version of `accept` which resolves a session when the 200 Ok response is sent.\n     * @param options - Options bucket.\n     */\n    sendAccept() {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        // The UAS MAY send a final response to the initial request before\n        // having received PRACKs for all unacknowledged reliable provisional\n        // responses, unless the final response is 2xx and any of the\n        // unacknowledged reliable provisional responses contained a session\n        // description.  In that case, it MUST NOT send a final response until\n        // those provisional responses are acknowledged.  If the UAS does send a\n        // final response when reliable responses are still unacknowledged, it\n        // SHOULD NOT continue to retransmit the unacknowledged reliable\n        // provisional responses, but it MUST be prepared to process PRACK\n        // requests for those outstanding responses.  A UAS MUST NOT send new\n        // reliable provisional responses (as opposed to retransmissions of\n        // unacknowledged ones) after sending a final response to a request.\n        // https://tools.ietf.org/html/rfc3262#section-3\n        if (this.waitingForPrack) {\n            return this.waitForArrivalOfPrack()\n                .then(() => clearTimeout(this.userNoAnswerTimer)) // Ported\n                .then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions))\n                .then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body }));\n        }\n        clearTimeout(this.userNoAnswerTimer); // Ported\n        return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body }));\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response is sent.\n     * @param options - Options bucket.\n     */\n    sendProgress(options = {}) {\n        const statusCode = options.statusCode || 180;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        const body = options.body ? fromBodyLegacy(options.body) : undefined;\n        // The 183 (Session Progress) response is used to convey information\n        // about the progress of the call that is not otherwise classified.  The\n        // Reason-Phrase, header fields, or message body MAY be used to convey\n        // more details about the call progress.\n        // https://tools.ietf.org/html/rfc3261#section-21.1.5\n        // It is the de facto industry standard to utilize 183 with SDP to provide \"early media\".\n        // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.\n        if (statusCode === 183 && !body) {\n            return this.sendProgressWithSDP(options);\n        }\n        try {\n            const progressResponse = this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n            this._dialog = progressResponse.session;\n            return Promise.resolve(progressResponse);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response with sdp is sent.\n     * @param options - Options bucket.\n     */\n    sendProgressWithSDP(options = {}) {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        const statusCode = options.statusCode || 183;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        // Get an offer/answer and send a reply.\n        return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)\n            .then((body) => this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body }))\n            .then((progressResponse) => {\n            this._dialog = progressResponse.session;\n            return progressResponse;\n        });\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is sent.\n     * @param options - Options bucket.\n     */\n    sendProgressReliable(options = {}) {\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(\"Require: 100rel\");\n        options.extraHeaders.push(\"RSeq: \" + Math.floor(Math.random() * 10000));\n        return this.sendProgressWithSDP(options);\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is acknowledged.\n     * @param options - Options bucket.\n     */\n    sendProgressReliableWaitForPrack(options = {}) {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        const statusCode = options.statusCode || 183;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        extraHeaders.push(\"Require: 100rel\");\n        extraHeaders.push(\"RSeq: \" + this.rseq++);\n        let body;\n        return new Promise((resolve, reject) => {\n            this.waitingForPrack = true;\n            this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)\n                .then((offerAnswer) => {\n                body = offerAnswer;\n                return this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n            })\n                .then((progressResponse) => {\n                this._dialog = progressResponse.session;\n                let prackRequest;\n                let prackResponse;\n                progressResponse.session.delegate = {\n                    onPrack: (request) => {\n                        prackRequest = request;\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                        clearTimeout(prackWaitTimeoutTimer);\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                        clearTimeout(rel1xxRetransmissionTimer);\n                        if (!this.waitingForPrack) {\n                            return;\n                        }\n                        this.waitingForPrack = false;\n                        this.handlePrackOfferAnswer(prackRequest)\n                            .then((prackResponseBody) => {\n                            try {\n                                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });\n                                this.prackArrived();\n                                resolve({ prackRequest, prackResponse, progressResponse });\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        })\n                            .catch((error) => reject(error));\n                    }\n                };\n                // https://tools.ietf.org/html/rfc3262#section-3\n                const prackWaitTimeout = () => {\n                    if (!this.waitingForPrack) {\n                        return;\n                    }\n                    this.waitingForPrack = false;\n                    this.logger.warn(\"No PRACK received, rejecting INVITE.\");\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    clearTimeout(rel1xxRetransmissionTimer);\n                    this.reject({ statusCode: 504 })\n                        .then(() => reject(new SessionTerminatedError()))\n                        .catch((error) => reject(error));\n                };\n                const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64);\n                // https://tools.ietf.org/html/rfc3262#section-3\n                const rel1xxRetransmission = () => {\n                    try {\n                        this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n                    }\n                    catch (error) {\n                        this.waitingForPrack = false;\n                        reject(error);\n                        return;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, (timeout *= 2));\n                };\n                let timeout = Timers.T1;\n                let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);\n            })\n                .catch((error) => {\n                this.waitingForPrack = false;\n                reject(error);\n            });\n        });\n    }\n    /**\n     * A version of `progress` which resolves when a 100 Trying provisional response is sent.\n     */\n    sendProgressTrying() {\n        try {\n            const progressResponse = this.incomingInviteRequest.trying();\n            return Promise.resolve(progressResponse);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * When attempting to accept the INVITE, an invitation waits\n     * for any outstanding PRACK to arrive before sending the 200 Ok.\n     * It will be waiting on this Promise to resolve which lets it know\n     * the PRACK has arrived and it may proceed to send the 200 Ok.\n     */\n    waitForArrivalOfPrack() {\n        if (this.waitingForPrackPromise) {\n            throw new Error(\"Already waiting for PRACK\");\n        }\n        this.waitingForPrackPromise = new Promise((resolve, reject) => {\n            this.waitingForPrackResolve = resolve;\n            this.waitingForPrackReject = reject;\n        });\n        return this.waitingForPrackPromise;\n    }\n    /**\n     * Here we are resolving the promise which in turn will cause\n     * the accept to proceed (it may still fail for other reasons, but...).\n     */\n    prackArrived() {\n        if (this.waitingForPrackResolve) {\n            this.waitingForPrackResolve();\n        }\n        this.waitingForPrackPromise = undefined;\n        this.waitingForPrackResolve = undefined;\n        this.waitingForPrackReject = undefined;\n    }\n    /**\n     * Here we are rejecting the promise which in turn will cause\n     * the accept to fail and the session to transition to \"terminated\".\n     */\n    prackNeverArrived() {\n        if (this.waitingForPrackReject) {\n            this.waitingForPrackReject(new SessionTerminatedError());\n        }\n        this.waitingForPrackPromise = undefined;\n        this.waitingForPrackResolve = undefined;\n        this.waitingForPrackReject = undefined;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}