{"ast":null,"code":"import { fromBodyLegacy, getBody, Grammar, SessionState as SessionDialogState, SignalingState, URI } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Bye } from \"./bye\";\nimport { EmitterImpl } from \"./emitter\";\nimport { ContentTypeUnsupportedError, RequestPendingError } from \"./exceptions\";\nimport { Info } from \"./info\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { Referral } from \"./referral\";\nimport { SessionState } from \"./session-state\";\n/**\n * A session provides real time communication between one or more participants.\n *\n * @remarks\n * The transport behaves in a deterministic manner according to the\n * the state defined in {@link SessionState}.\n * @public\n */\n\nexport class Session {\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @internal\n   */\n  constructor(userAgent, options = {}) {\n    /** True if there is an outgoing re-INVITE request outstanding. */\n    this.pendingReinvite = false;\n    /** True if there is an incoming re-INVITE ACK request outstanding. */\n\n    this.pendingReinviteAck = false;\n    /** Session state. */\n\n    this._state = SessionState.Initial;\n    this.delegate = options.delegate;\n    this._stateEventEmitter = new EmitterImpl();\n    this._userAgent = userAgent;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`); // Remove from the user agent's session collection\n\n    delete this.userAgent._sessions[this.id]; // Dispose of dialog media\n\n    if (this._sessionDescriptionHandler) {\n      this._sessionDescriptionHandler.close(); // TODO: The SDH needs to remain defined as it will be called after it is closed in cases\n      // where an answer/offer arrives while the session is being torn down. There are a variety\n      // of circumstances where this can happen - sending a BYE during a re-INVITE for example.\n      // The code is currently written such that it lazily makes a new SDH when it needs one\n      // and one is not yet defined. Thus if we undefined it here, it will currently make a\n      // new one which is out of sync and then never gets cleaned up.\n      //\n      // The downside of leaving it defined are that calls this closed SDH will continue to be\n      // made (think setDescription) and those should/will fail. These failures are handled, but\n      // it would be nice to have it all coded up in a way where having an undefined SDH where\n      // one is expected throws an error.\n      //\n      // this._sessionDescriptionHandler = undefined;\n\n    }\n\n    switch (this.state) {\n      case SessionState.Initial:\n        break;\n      // the Inviter/Invitation sub class dispose method handles this case\n\n      case SessionState.Establishing:\n        break;\n      // the Inviter/Invitation sub class dispose method handles this case\n\n      case SessionState.Established:\n        return new Promise(resolve => {\n          this._bye({\n            // wait for the response to the BYE before resolving\n            onAccept: () => resolve(),\n            onRedirect: () => resolve(),\n            onReject: () => resolve()\n          });\n        });\n\n      case SessionState.Terminating:\n        break;\n      // nothing to be done\n\n      case SessionState.Terminated:\n        break;\n      // nothing to be done\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * The asserted identity of the remote user.\n   */\n\n\n  get assertedIdentity() {\n    return this._assertedIdentity;\n  }\n  /**\n   * The confirmed session dialog.\n   */\n\n\n  get dialog() {\n    return this._dialog;\n  }\n  /**\n   * A unique identifier for this session.\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * The session being replace by this one.\n   */\n\n\n  get replacee() {\n    return this._replacee;\n  }\n  /**\n   * Session description handler.\n   * @remarks\n   * If `this` is an instance of `Invitation`,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n   * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"establishing\".\n   * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n   * Otherwise `undefined`.\n   */\n\n\n  get sessionDescriptionHandler() {\n    return this._sessionDescriptionHandler;\n  }\n  /**\n   * Session description handler factory.\n   */\n\n\n  get sessionDescriptionHandlerFactory() {\n    return this.userAgent.configuration.sessionDescriptionHandlerFactory;\n  }\n  /**\n   * SDH modifiers for the initial INVITE transaction.\n   * @remarks\n   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n   */\n\n\n  get sessionDescriptionHandlerModifiers() {\n    return this._sessionDescriptionHandlerModifiers || [];\n  }\n\n  set sessionDescriptionHandlerModifiers(modifiers) {\n    this._sessionDescriptionHandlerModifiers = modifiers.slice();\n  }\n  /**\n   * SDH options for the initial INVITE transaction.\n   * @remarks\n   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n   */\n\n\n  get sessionDescriptionHandlerOptions() {\n    return this._sessionDescriptionHandlerOptions || {};\n  }\n\n  set sessionDescriptionHandlerOptions(options) {\n    this._sessionDescriptionHandlerOptions = Object.assign({}, options);\n  }\n  /**\n   * SDH modifiers for re-INVITE transactions.\n   * @remarks\n   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Session.invite().\n   */\n\n\n  get sessionDescriptionHandlerModifiersReInvite() {\n    return this._sessionDescriptionHandlerModifiersReInvite || [];\n  }\n\n  set sessionDescriptionHandlerModifiersReInvite(modifiers) {\n    this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();\n  }\n  /**\n   * SDH options for re-INVITE transactions.\n   * @remarks\n   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Session.invite().\n   */\n\n\n  get sessionDescriptionHandlerOptionsReInvite() {\n    return this._sessionDescriptionHandlerOptionsReInvite || {};\n  }\n\n  set sessionDescriptionHandlerOptionsReInvite(options) {\n    this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);\n  }\n  /**\n   * Session state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * Session state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * The user agent.\n   */\n\n\n  get userAgent() {\n    return this._userAgent;\n  }\n  /**\n   * End the {@link Session}. Sends a BYE.\n   * @param options - Options bucket. See {@link SessionByeOptions} for details.\n   */\n\n\n  bye(options = {}) {\n    let message = \"Session.bye() may only be called if established session.\";\n\n    switch (this.state) {\n      case SessionState.Initial:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof this.cancel === \"function\") {\n          message += \" However Inviter.invite() has not yet been called.\";\n          message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" However Invitation.accept() has not yet been called.\";\n          message += \" Perhaps you should have called Invitation.reject()?\";\n        }\n\n        break;\n\n      case SessionState.Establishing:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof this.cancel === \"function\") {\n          message += \" However a dialog does not yet exist.\";\n          message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" However Invitation.accept() has not yet been called (or not yet resolved).\";\n          message += \" Perhaps you should have called Invitation.reject()?\";\n        }\n\n        break;\n\n      case SessionState.Established:\n        {\n          const requestDelegate = options.requestDelegate;\n          const requestOptions = this.copyRequestOptions(options.requestOptions);\n          return this._bye(requestDelegate, requestOptions);\n        }\n\n      case SessionState.Terminating:\n        message += \" However this session is already terminating.\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        if (typeof this.cancel === \"function\") {\n          message += \" Perhaps you have already called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" Perhaps you have already called Session.bye()?\";\n        }\n\n        break;\n\n      case SessionState.Terminated:\n        message += \" However this session is already terminated.\";\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    this.logger.error(message);\n    return Promise.reject(new Error(`Invalid session state ${this.state}`));\n  }\n  /**\n   * Share {@link Info} with peer. Sends an INFO.\n   * @param options - Options bucket. See {@link SessionInfoOptions} for details.\n   */\n\n\n  info(options = {}) {\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.info() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    return this._info(requestDelegate, requestOptions);\n  }\n  /**\n   * Renegotiate the session. Sends a re-INVITE.\n   * @param options - Options bucket. See {@link SessionInviteOptions} for details.\n   */\n\n\n  invite(options = {}) {\n    this.logger.log(\"Session.invite\");\n\n    if (this.state !== SessionState.Established) {\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    if (this.pendingReinvite) {\n      return Promise.reject(new RequestPendingError(\"Reinvite in progress. Please wait until complete, then try again.\"));\n    }\n\n    this.pendingReinvite = true; // Modifiers and options for initial INVITE transaction\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;\n    }\n\n    const delegate = {\n      onAccept: response => {\n        // A re-INVITE transaction has an offer/answer [RFC3264] exchange\n        // associated with it.  The UAC (User Agent Client) generating a given\n        // re-INVITE can act as the offerer or as the answerer.  A UAC willing\n        // to act as the offerer includes an offer in the re-INVITE.  The UAS\n        // (User Agent Server) then provides an answer in a response to the\n        // re-INVITE.  A UAC willing to act as answerer does not include an\n        // offer in the re-INVITE.  The UAS then provides an offer in a response\n        // to the re-INVITE becoming, thus, the offerer.\n        // https://tools.ietf.org/html/rfc6141#section-1\n        const body = getBody(response.message);\n\n        if (!body) {\n          // No way to recover, so terminate session and mark as failed.\n          this.logger.error(\"Received 2xx response to re-INVITE without a session description\");\n          this.ackAndBye(response, 400, \"Missing session description\");\n          this.stateTransition(SessionState.Terminated);\n          this.pendingReinvite = false;\n          return;\n        }\n\n        if (options.withoutSdp) {\n          // INVITE without SDP - set remote offer and send an answer in the ACK\n          const answerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n          };\n          this.setOfferAndGetAnswer(body, answerOptions).then(answerBody => {\n            response.ack({\n              body: answerBody\n            });\n          }).catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to handle offer in 2xx response to re-INVITE\");\n            this.logger.error(error.message);\n\n            if (this.state === SessionState.Terminated) {\n              // A BYE should not be sent if already terminated.\n              // For example, a BYE may be sent/received while re-INVITE is outstanding.\n              response.ack();\n            } else {\n              this.ackAndBye(response, 488, \"Bad Media Description\");\n              this.stateTransition(SessionState.Terminated);\n            }\n          }).then(() => {\n            this.pendingReinvite = false;\n\n            if (options.requestDelegate && options.requestDelegate.onAccept) {\n              options.requestDelegate.onAccept(response);\n            }\n          });\n        } else {\n          // INVITE with SDP - set remote answer and send an ACK\n          const answerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n          };\n          this.setAnswer(body, answerOptions).then(() => {\n            response.ack();\n          }).catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to handle answer in 2xx response to re-INVITE\");\n            this.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n            // The ACK needs to be sent regardless as it was not handled by the transaction.\n\n            if (this.state !== SessionState.Terminated) {\n              this.ackAndBye(response, 488, \"Bad Media Description\");\n              this.stateTransition(SessionState.Terminated);\n            } else {\n              response.ack();\n            }\n          }).then(() => {\n            this.pendingReinvite = false;\n\n            if (options.requestDelegate && options.requestDelegate.onAccept) {\n              options.requestDelegate.onAccept(response);\n            }\n          });\n        }\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onProgress: response => {\n        return;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onRedirect: response => {\n        return;\n      },\n      onReject: response => {\n        this.logger.warn(\"Received a non-2xx response to re-INVITE\");\n        this.pendingReinvite = false;\n\n        if (options.withoutSdp) {\n          if (options.requestDelegate && options.requestDelegate.onReject) {\n            options.requestDelegate.onReject(response);\n          }\n        } else {\n          this.rollbackOffer().catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to rollback offer on non-2xx response to re-INVITE\");\n            this.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n            // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n            if (this.state !== SessionState.Terminated) {\n              if (!this.dialog) {\n                throw new Error(\"Dialog undefined.\");\n              }\n\n              const extraHeaders = [];\n              extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n              this.dialog.bye(undefined, {\n                extraHeaders\n              });\n              this.stateTransition(SessionState.Terminated);\n            }\n          }).then(() => {\n            if (options.requestDelegate && options.requestDelegate.onReject) {\n              options.requestDelegate.onReject(response);\n            }\n          });\n        }\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onTrying: response => {\n        return;\n      }\n    };\n    const requestOptions = options.requestOptions || {};\n    requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();\n    requestOptions.extraHeaders.push(\"Allow: \" + AllowedMethods.toString());\n    requestOptions.extraHeaders.push(\"Contact: \" + this._contact); // Just send an INVITE with no sdp...\n\n    if (options.withoutSdp) {\n      if (!this.dialog) {\n        this.pendingReinvite = false;\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      return Promise.resolve(this.dialog.invite(delegate, requestOptions));\n    } // Get an offer and send it in an INVITE\n\n\n    const offerOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n    };\n    return this.getOffer(offerOptions).then(offerBody => {\n      if (!this.dialog) {\n        this.pendingReinvite = false;\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      requestOptions.body = offerBody;\n      return this.dialog.invite(delegate, requestOptions);\n    }).catch(error => {\n      this.logger.error(error.message);\n      this.logger.error(\"Failed to send re-INVITE\");\n      this.pendingReinvite = false;\n      throw error;\n    });\n  }\n  /**\n   * Deliver a {@link Message}. Sends a MESSAGE.\n   * @param options - Options bucket. See {@link SessionMessageOptions} for details.\n   */\n\n\n  message(options = {}) {\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.message() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    return this._message(requestDelegate, requestOptions);\n  }\n  /**\n   * Proffer a {@link Referral}. Send a REFER.\n   * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.\n   * @param options - Options bucket. See {@link SessionReferOptions} for details.\n   */\n\n\n  refer(referTo, options = {}) {\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.refer() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));\n    return this._refer(options.onNotify, requestDelegate, requestOptions);\n  }\n  /**\n   * Send BYE.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _bye(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    const dialog = this.dialog; // The caller's UA MAY send a BYE for either confirmed or early dialogs,\n    // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT\n    // send a BYE on early dialogs. However, the callee's UA MUST NOT send a\n    // BYE on a confirmed dialog until it has received an ACK for its 2xx\n    // response or until the server transaction times out.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n    switch (dialog.sessionState) {\n      case SessionDialogState.Initial:\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      case SessionDialogState.Early:\n        // Implementation choice - not sending BYE for early dialogs.\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      case SessionDialogState.AckWait:\n        {\n          // This state only occurs if we are the callee.\n          this.stateTransition(SessionState.Terminating); // We're terminating\n\n          return new Promise(resolve => {\n            dialog.delegate = {\n              // When ACK shows up, say BYE.\n              onAck: () => {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                resolve(request);\n                return Promise.resolve();\n              },\n              // Or the server transaction times out before the ACK arrives.\n              onAckTimeout: () => {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                resolve(request);\n              }\n            };\n          });\n        }\n\n      case SessionDialogState.Confirmed:\n        {\n          const request = dialog.bye(delegate, options);\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve(request);\n        }\n\n      case SessionDialogState.Terminated:\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    }\n  }\n  /**\n   * Send INFO.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _info(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    return Promise.resolve(this.dialog.info(delegate, options));\n  }\n  /**\n   * Send MESSAGE.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _message(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    return Promise.resolve(this.dialog.message(delegate, options));\n  }\n  /**\n   * Send REFER.\n   * @param onNotify - Notification callback.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _refer(onNotify, delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    } // If set, deliver any in-dialog NOTIFY requests here...\n\n\n    this.onNotify = onNotify;\n    return Promise.resolve(this.dialog.refer(delegate, options));\n  }\n  /**\n   * Send ACK and then BYE. There are unrecoverable errors which can occur\n   * while handling dialog forming and in-dialog INVITE responses and when\n   * they occur we ACK the response and send a BYE.\n   * Note that the BYE is sent in the dialog associated with the response\n   * which is not necessarily `this.dialog`. And, accordingly, the\n   * session state is not transitioned to terminated and session is not closed.\n   * @param inviteResponse - The response causing the error.\n   * @param statusCode - Status code for he reason phrase.\n   * @param reasonPhrase - Reason phrase for the BYE.\n   * @internal\n   */\n\n\n  ackAndBye(response, statusCode, reasonPhrase) {\n    response.ack();\n    const extraHeaders = [];\n\n    if (statusCode) {\n      extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(statusCode, reasonPhrase));\n    } // Using the dialog session associate with the response (which might not be this.dialog)\n\n\n    response.session.bye(undefined, {\n      extraHeaders\n    });\n  }\n  /**\n   * Handle in dialog ACK request.\n   * @internal\n   */\n\n\n  onAckRequest(request) {\n    this.logger.log(\"Session.onAckRequest\");\n\n    if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {\n      this.logger.error(`ACK received while in state ${this.state}, dropping request`);\n      return Promise.resolve();\n    }\n\n    const dialog = this.dialog;\n\n    if (!dialog) {\n      throw new Error(\"Dialog undefined.\");\n    } // if received answer in ACK.\n\n\n    const answerOptions = {\n      sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers\n    }; // reset pending ACK flag\n\n    this.pendingReinviteAck = false;\n\n    switch (dialog.signalingState) {\n      case SignalingState.Initial:\n        {\n          // State should never be reached as first reliable response must have answer/offer.\n          // So we must have never has sent an offer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.Stable:\n        {\n          // State we should be in.\n          // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.\n          const body = getBody(request.message); // If the ACK doesn't have an answer, nothing to be done.\n\n          if (!body) {\n            return Promise.resolve();\n          }\n\n          if (body.contentDisposition === \"render\") {\n            this._renderbody = body.content;\n            this._rendertype = body.contentType;\n            return Promise.resolve();\n          }\n\n          if (body.contentDisposition !== \"session\") {\n            return Promise.resolve();\n          }\n\n          return this.setAnswer(body, answerOptions).catch(error => {\n            this.logger.error(error.message);\n            const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n            dialog.bye(undefined, {\n              extraHeaders\n            });\n            this.stateTransition(SessionState.Terminated);\n          });\n        }\n\n      case SignalingState.HaveLocalOffer:\n        {\n          // State should never be reached as local offer would be answered by this ACK.\n          // So we must have received an ACK without an answer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.HaveRemoteOffer:\n        {\n          // State should never be reached as remote offer would be answered in first reliable response.\n          // So we must have never has sent an answer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n    }\n  }\n  /**\n   * Handle in dialog BYE request.\n   * @internal\n   */\n\n\n  onByeRequest(request) {\n    this.logger.log(\"Session.onByeRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`BYE received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onBye) {\n      const bye = new Bye(request);\n      this.delegate.onBye(bye);\n    } else {\n      request.accept();\n    }\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle in dialog INFO request.\n   * @internal\n   */\n\n\n  onInfoRequest(request) {\n    this.logger.log(\"Session.onInfoRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`INFO received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onInfo) {\n      const info = new Info(request);\n      this.delegate.onInfo(info);\n    } else {\n      // FIXME: TODO: We should reject request...\n      //\n      // If a UA receives an INFO request associated with an Info Package that\n      // the UA has not indicated willingness to receive, the UA MUST send a\n      // 469 (Bad Info Package) response (see Section 11.6), which contains a\n      // Recv-Info header field with Info Packages for which the UA is willing\n      // to receive INFO requests.\n      // https://tools.ietf.org/html/rfc6086#section-4.2.2\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog INVITE request.\n   * @internal\n   */\n\n\n  onInviteRequest(request) {\n    this.logger.log(\"Session.onInviteRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`INVITE received while in state ${this.state}, dropping request`);\n      return;\n    } // set pending ACK flag\n\n\n    this.pendingReinviteAck = true; // TODO: would be nice to have core track and set the Contact header,\n    // but currently the session which is setting it is holding onto it.\n\n    const extraHeaders = [\"Contact: \" + this._contact]; // Handle P-Asserted-Identity\n\n    if (request.message.hasHeader(\"P-Asserted-Identity\")) {\n      const header = request.message.getHeader(\"P-Asserted-Identity\");\n\n      if (!header) {\n        throw new Error(\"Header undefined.\");\n      }\n\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(header);\n    }\n\n    const options = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n    };\n    this.generateResponseOfferAnswerInDialog(options).then(body => {\n      const outgoingResponse = request.accept({\n        statusCode: 200,\n        extraHeaders,\n        body\n      });\n\n      if (this.delegate && this.delegate.onInvite) {\n        this.delegate.onInvite(request.message, outgoingResponse.message, 200);\n      }\n    }).catch(error => {\n      this.logger.error(error.message);\n      this.logger.error(\"Failed to handle to re-INVITE request\");\n\n      if (!this.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      this.logger.error(this.dialog.signalingState); // If we don't have a local/remote offer...\n\n      if (this.dialog.signalingState === SignalingState.Stable) {\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n\n        return;\n      } // Otherwise rollback\n\n\n      this.rollbackOffer().then(() => {\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n      }).catch(errorRollback => {\n        // No way to recover, so terminate session and mark as failed.\n        this.logger.error(errorRollback.message);\n        this.logger.error(\"Failed to rollback offer on re-INVITE request\");\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n        // A BYE should only be sent if session is not already terminated.\n        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n        // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n        if (this.state !== SessionState.Terminated) {\n          if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n          }\n\n          const extraHeadersBye = [];\n          extraHeadersBye.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n          this.dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n        }\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n      });\n    });\n  }\n  /**\n   * Handle in dialog MESSAGE request.\n   * @internal\n   */\n\n\n  onMessageRequest(request) {\n    this.logger.log(\"Session.onMessageRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onMessage) {\n      const message = new Message(request);\n      this.delegate.onMessage(message);\n    } else {\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog NOTIFY request.\n   * @internal\n   */\n\n\n  onNotifyRequest(request) {\n    this.logger.log(\"Session.onNotifyRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);\n      return;\n    } // If this a NOTIFY associated with the progress of a REFER,\n    // look to delegate handling to the associated callback.\n\n\n    if (this.onNotify) {\n      const notification = new Notification(request);\n      this.onNotify(notification);\n      return;\n    } // Otherwise accept the NOTIFY.\n\n\n    if (this.delegate && this.delegate.onNotify) {\n      const notification = new Notification(request);\n      this.delegate.onNotify(notification);\n    } else {\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog PRACK request.\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onPrackRequest(request) {\n    this.logger.log(\"Session.onPrackRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`PRACK received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    throw new Error(\"Unimplemented.\");\n  }\n  /**\n   * Handle in dialog REFER request.\n   * @internal\n   */\n\n\n  onReferRequest(request) {\n    this.logger.log(\"Session.onReferRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`REFER received while in state ${this.state}, dropping request`);\n      return;\n    } // REFER is a SIP request and is constructed as defined in [1].  A REFER\n    // request MUST contain exactly one Refer-To header field value.\n    // https://tools.ietf.org/html/rfc3515#section-2.4.1\n\n\n    if (!request.message.hasHeader(\"refer-to\")) {\n      this.logger.warn(\"Invalid REFER packet. A refer-to header is required. Rejecting.\");\n      request.reject();\n      return;\n    }\n\n    const referral = new Referral(request, this);\n\n    if (this.delegate && this.delegate.onRefer) {\n      this.delegate.onRefer(referral);\n    } else {\n      this.logger.log(\"No delegate available to handle REFER, automatically accepting and following.\");\n      referral.accept().then(() => referral.makeInviter(this._referralInviterOptions).invite()).catch(error => {\n        // FIXME: logging and eating error...\n        this.logger.error(error.message);\n      });\n    }\n  }\n  /**\n   * Generate an offer or answer for a response to an INVITE request.\n   * If a remote offer was provided in the request, set the remote\n   * description and get a local answer. If a remote offer was not\n   * provided, generates a local offer.\n   * @internal\n   */\n\n\n  generateResponseOfferAnswer(request, options) {\n    if (this.dialog) {\n      return this.generateResponseOfferAnswerInDialog(options);\n    }\n\n    const body = getBody(request.message);\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return this.getOffer(options);\n    } else {\n      return this.setOfferAndGetAnswer(body, options);\n    }\n  }\n  /**\n   * Generate an offer or answer for a response to an INVITE request\n   * when a dialog (early or otherwise) has already been established.\n   * This method may NOT be called if a dialog has yet to be established.\n   * @internal\n   */\n\n\n  generateResponseOfferAnswerInDialog(options) {\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    }\n\n    switch (this.dialog.signalingState) {\n      case SignalingState.Initial:\n        return this.getOffer(options);\n\n      case SignalingState.HaveLocalOffer:\n        // o  Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        return Promise.resolve(undefined);\n\n      case SignalingState.HaveRemoteOffer:\n        if (!this.dialog.offer) {\n          throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);\n        }\n\n        return this.setOfferAndGetAnswer(this.dialog.offer, options);\n\n      case SignalingState.Stable:\n        // o  Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        if (this.state !== SessionState.Established) {\n          return Promise.resolve(undefined);\n        } // In dialog INVITE without offer, get an offer for the response.\n\n\n        return this.getOffer(options);\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n    }\n  }\n  /**\n   * Get local offer.\n   * @internal\n   */\n\n\n  getOffer(options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      return sdh.getDescription(sdhOptions, sdhModifiers).then(bodyAndContentType => fromBodyLegacy(bodyAndContentType)).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.getOffer: SDH getDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.getOffer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.getOffer: SDH getDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Rollback local/remote offer.\n   * @internal\n   */\n\n\n  rollbackOffer() {\n    const sdh = this.setupSessionDescriptionHandler();\n\n    if (sdh.rollbackDescription === undefined) {\n      return Promise.resolve();\n    } // This is intentionally written very defensively. Don't trust SDH to behave.\n\n\n    try {\n      return sdh.rollbackDescription().catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.rollbackOffer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Set remote answer.\n   * @internal\n   */\n\n\n  setAnswer(answer, options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      if (!sdh.hasDescription(answer.contentType)) {\n        return Promise.reject(new ContentTypeUnsupportedError());\n      }\n    } catch (error) {\n      this.logger.error(\"Session.setAnswer: SDH hasDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n\n    try {\n      return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.setAnswer: SDH setDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.setAnswer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.setAnswer: SDH setDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Set remote offer and get local answer.\n   * @internal\n   */\n\n\n  setOfferAndGetAnswer(offer, options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      if (!sdh.hasDescription(offer.contentType)) {\n        return Promise.reject(new ContentTypeUnsupportedError());\n      }\n    } catch (error) {\n      this.logger.error(\"Session.setOfferAndGetAnswer: SDH hasDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n\n    try {\n      return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(() => sdh.getDescription(sdhOptions, sdhModifiers)).then(bodyAndContentType => fromBodyLegacy(bodyAndContentType)).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.setOfferAndGetAnswer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * SDH for confirmed dialog.\n   * @internal\n   */\n\n\n  setSessionDescriptionHandler(sdh) {\n    if (this._sessionDescriptionHandler) {\n      throw new Error(\"Session description handler defined.\");\n    }\n\n    this._sessionDescriptionHandler = sdh;\n  }\n  /**\n   * SDH for confirmed dialog.\n   * @internal\n   */\n\n\n  setupSessionDescriptionHandler() {\n    var _a;\n\n    if (this._sessionDescriptionHandler) {\n      return this._sessionDescriptionHandler;\n    }\n\n    this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);\n\n    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n      this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);\n    }\n\n    return this._sessionDescriptionHandler;\n  }\n  /**\n   * Transition session state.\n   * @internal\n   */\n\n\n  stateTransition(newState) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate transition\n\n\n    switch (this._state) {\n      case SessionState.Initial:\n        if (newState !== SessionState.Establishing && newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Establishing:\n        if (newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Established:\n        if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Terminating:\n        if (newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Terminated:\n        invalidTransition();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    } // Transition\n\n\n    this._state = newState;\n    this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); // Dispose\n\n\n    if (newState === SessionState.Terminated) {\n      this.dispose();\n    }\n  }\n\n  copyRequestOptions(requestOptions = {}) {\n    const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;\n    const body = requestOptions.body ? {\n      contentDisposition: requestOptions.body.contentDisposition || \"render\",\n      contentType: requestOptions.body.contentType || \"text/plain\",\n      content: requestOptions.body.content || \"\"\n    } : undefined;\n    return {\n      extraHeaders,\n      body\n    };\n  }\n\n  getReasonHeaderValue(code, reason) {\n    const cause = code;\n    let text = getReasonPhrase(code);\n\n    if (!text && reason) {\n      text = reason;\n    }\n\n    return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n  }\n\n  referExtraHeaders(referTo) {\n    const extraHeaders = [];\n    extraHeaders.push(\"Referred-By: <\" + this.userAgent.configuration.uri + \">\");\n    extraHeaders.push(\"Contact: \" + this._contact);\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n    extraHeaders.push(\"Refer-To: \" + referTo);\n    return extraHeaders;\n  }\n\n  referToString(target) {\n    let referTo;\n\n    if (target instanceof URI) {\n      // REFER without Replaces (Blind Transfer)\n      referTo = target.toString();\n    } else {\n      // REFER with Replaces (Attended Transfer)\n      if (!target.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      const displayName = target.remoteIdentity.friendlyName;\n      const remoteTarget = target.dialog.remoteTarget.toString();\n      const callId = target.dialog.callId;\n      const remoteTag = target.dialog.remoteTag;\n      const localTag = target.dialog.localTag;\n      const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);\n      referTo = `\"${displayName}\" <${remoteTarget}?Replaces=${replaces}>`;\n    }\n\n    return referTo;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/session.js"],"names":["fromBodyLegacy","getBody","Grammar","SessionState","SessionDialogState","SignalingState","URI","getReasonPhrase","AllowedMethods","Bye","EmitterImpl","ContentTypeUnsupportedError","RequestPendingError","Info","Message","Notification","Referral","Session","constructor","userAgent","options","pendingReinvite","pendingReinviteAck","_state","Initial","delegate","_stateEventEmitter","_userAgent","dispose","logger","log","id","_sessions","_sessionDescriptionHandler","close","state","Establishing","Established","Promise","resolve","_bye","onAccept","onRedirect","onReject","Terminating","Terminated","Error","assertedIdentity","_assertedIdentity","dialog","_dialog","_id","replacee","_replacee","sessionDescriptionHandler","sessionDescriptionHandlerFactory","configuration","sessionDescriptionHandlerModifiers","_sessionDescriptionHandlerModifiers","modifiers","slice","sessionDescriptionHandlerOptions","_sessionDescriptionHandlerOptions","Object","assign","sessionDescriptionHandlerModifiersReInvite","_sessionDescriptionHandlerModifiersReInvite","sessionDescriptionHandlerOptionsReInvite","_sessionDescriptionHandlerOptionsReInvite","stateChange","bye","message","cancel","reject","requestDelegate","requestOptions","copyRequestOptions","error","info","_info","invite","response","body","ackAndBye","stateTransition","withoutSdp","answerOptions","setOfferAndGetAnswer","then","answerBody","ack","catch","setAnswer","onProgress","warn","rollbackOffer","extraHeaders","push","getReasonHeaderValue","undefined","onTrying","toString","_contact","offerOptions","getOffer","offerBody","_message","refer","referTo","concat","referExtraHeaders","referToString","_refer","onNotify","sessionState","Early","AckWait","onAck","request","onAckTimeout","Confirmed","statusCode","reasonPhrase","session","onAckRequest","signalingState","Stable","contentDisposition","_renderbody","content","_rendertype","contentType","HaveLocalOffer","HaveRemoteOffer","Closed","onByeRequest","onBye","accept","onInfoRequest","onInfo","onInviteRequest","hasHeader","header","getHeader","nameAddrHeaderParse","generateResponseOfferAnswerInDialog","outgoingResponse","onInvite","errorRollback","extraHeadersBye","onMessageRequest","onMessage","onNotifyRequest","notification","onPrackRequest","onReferRequest","referral","onRefer","makeInviter","_referralInviterOptions","generateResponseOfferAnswer","offer","sdh","setupSessionDescriptionHandler","sdhOptions","sdhModifiers","getDescription","bodyAndContentType","e","rollbackDescription","answer","hasDescription","setDescription","setSessionDescriptionHandler","_a","sessionDescriptionHandlerFactoryOptions","onSessionDescriptionHandler","newState","invalidTransition","emit","code","reason","cause","text","uri","target","displayName","remoteIdentity","friendlyName","remoteTarget","callId","remoteTag","localTag","replaces","encodeURIComponent"],"mappings":"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","sourcesContent":["import { fromBodyLegacy, getBody, Grammar, SessionState as SessionDialogState, SignalingState, URI } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Bye } from \"./bye\";\nimport { EmitterImpl } from \"./emitter\";\nimport { ContentTypeUnsupportedError, RequestPendingError } from \"./exceptions\";\nimport { Info } from \"./info\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { Referral } from \"./referral\";\nimport { SessionState } from \"./session-state\";\n/**\n * A session provides real time communication between one or more participants.\n *\n * @remarks\n * The transport behaves in a deterministic manner according to the\n * the state defined in {@link SessionState}.\n * @public\n */\nexport class Session {\n    /**\n     * Constructor.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @internal\n     */\n    constructor(userAgent, options = {}) {\n        /** True if there is an outgoing re-INVITE request outstanding. */\n        this.pendingReinvite = false;\n        /** True if there is an incoming re-INVITE ACK request outstanding. */\n        this.pendingReinviteAck = false;\n        /** Session state. */\n        this._state = SessionState.Initial;\n        this.delegate = options.delegate;\n        this._stateEventEmitter = new EmitterImpl();\n        this._userAgent = userAgent;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`);\n        // Remove from the user agent's session collection\n        delete this.userAgent._sessions[this.id];\n        // Dispose of dialog media\n        if (this._sessionDescriptionHandler) {\n            this._sessionDescriptionHandler.close();\n            // TODO: The SDH needs to remain defined as it will be called after it is closed in cases\n            // where an answer/offer arrives while the session is being torn down. There are a variety\n            // of circumstances where this can happen - sending a BYE during a re-INVITE for example.\n            // The code is currently written such that it lazily makes a new SDH when it needs one\n            // and one is not yet defined. Thus if we undefined it here, it will currently make a\n            // new one which is out of sync and then never gets cleaned up.\n            //\n            // The downside of leaving it defined are that calls this closed SDH will continue to be\n            // made (think setDescription) and those should/will fail. These failures are handled, but\n            // it would be nice to have it all coded up in a way where having an undefined SDH where\n            // one is expected throws an error.\n            //\n            // this._sessionDescriptionHandler = undefined;\n        }\n        switch (this.state) {\n            case SessionState.Initial:\n                break; // the Inviter/Invitation sub class dispose method handles this case\n            case SessionState.Establishing:\n                break; // the Inviter/Invitation sub class dispose method handles this case\n            case SessionState.Established:\n                return new Promise((resolve) => {\n                    this._bye({\n                        // wait for the response to the BYE before resolving\n                        onAccept: () => resolve(),\n                        onRedirect: () => resolve(),\n                        onReject: () => resolve()\n                    });\n                });\n            case SessionState.Terminating:\n                break; // nothing to be done\n            case SessionState.Terminated:\n                break; // nothing to be done\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        return Promise.resolve();\n    }\n    /**\n     * The asserted identity of the remote user.\n     */\n    get assertedIdentity() {\n        return this._assertedIdentity;\n    }\n    /**\n     * The confirmed session dialog.\n     */\n    get dialog() {\n        return this._dialog;\n    }\n    /**\n     * A unique identifier for this session.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * The session being replace by this one.\n     */\n    get replacee() {\n        return this._replacee;\n    }\n    /**\n     * Session description handler.\n     * @remarks\n     * If `this` is an instance of `Invitation`,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"establishing\".\n     * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * Otherwise `undefined`.\n     */\n    get sessionDescriptionHandler() {\n        return this._sessionDescriptionHandler;\n    }\n    /**\n     * Session description handler factory.\n     */\n    get sessionDescriptionHandlerFactory() {\n        return this.userAgent.configuration.sessionDescriptionHandlerFactory;\n    }\n    /**\n     * SDH modifiers for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n    get sessionDescriptionHandlerModifiers() {\n        return this._sessionDescriptionHandlerModifiers || [];\n    }\n    set sessionDescriptionHandlerModifiers(modifiers) {\n        this._sessionDescriptionHandlerModifiers = modifiers.slice();\n    }\n    /**\n     * SDH options for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n    get sessionDescriptionHandlerOptions() {\n        return this._sessionDescriptionHandlerOptions || {};\n    }\n    set sessionDescriptionHandlerOptions(options) {\n        this._sessionDescriptionHandlerOptions = Object.assign({}, options);\n    }\n    /**\n     * SDH modifiers for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n    get sessionDescriptionHandlerModifiersReInvite() {\n        return this._sessionDescriptionHandlerModifiersReInvite || [];\n    }\n    set sessionDescriptionHandlerModifiersReInvite(modifiers) {\n        this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();\n    }\n    /**\n     * SDH options for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n    get sessionDescriptionHandlerOptionsReInvite() {\n        return this._sessionDescriptionHandlerOptionsReInvite || {};\n    }\n    set sessionDescriptionHandlerOptionsReInvite(options) {\n        this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);\n    }\n    /**\n     * Session state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Session state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * The user agent.\n     */\n    get userAgent() {\n        return this._userAgent;\n    }\n    /**\n     * End the {@link Session}. Sends a BYE.\n     * @param options - Options bucket. See {@link SessionByeOptions} for details.\n     */\n    bye(options = {}) {\n        let message = \"Session.bye() may only be called if established session.\";\n        switch (this.state) {\n            case SessionState.Initial:\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" However Inviter.invite() has not yet been called.\";\n                    message += \" Perhaps you should have called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" However Invitation.accept() has not yet been called.\";\n                    message += \" Perhaps you should have called Invitation.reject()?\";\n                }\n                break;\n            case SessionState.Establishing:\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" However a dialog does not yet exist.\";\n                    message += \" Perhaps you should have called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" However Invitation.accept() has not yet been called (or not yet resolved).\";\n                    message += \" Perhaps you should have called Invitation.reject()?\";\n                }\n                break;\n            case SessionState.Established: {\n                const requestDelegate = options.requestDelegate;\n                const requestOptions = this.copyRequestOptions(options.requestOptions);\n                return this._bye(requestDelegate, requestOptions);\n            }\n            case SessionState.Terminating:\n                message += \" However this session is already terminating.\";\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" Perhaps you have already called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" Perhaps you have already called Session.bye()?\";\n                }\n                break;\n            case SessionState.Terminated:\n                message += \" However this session is already terminated.\";\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        this.logger.error(message);\n        return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n    /**\n     * Share {@link Info} with peer. Sends an INFO.\n     * @param options - Options bucket. See {@link SessionInfoOptions} for details.\n     */\n    info(options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.info() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        return this._info(requestDelegate, requestOptions);\n    }\n    /**\n     * Renegotiate the session. Sends a re-INVITE.\n     * @param options - Options bucket. See {@link SessionInviteOptions} for details.\n     */\n    invite(options = {}) {\n        this.logger.log(\"Session.invite\");\n        if (this.state !== SessionState.Established) {\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        if (this.pendingReinvite) {\n            return Promise.reject(new RequestPendingError(\"Reinvite in progress. Please wait until complete, then try again.\"));\n        }\n        this.pendingReinvite = true;\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;\n        }\n        const delegate = {\n            onAccept: (response) => {\n                // A re-INVITE transaction has an offer/answer [RFC3264] exchange\n                // associated with it.  The UAC (User Agent Client) generating a given\n                // re-INVITE can act as the offerer or as the answerer.  A UAC willing\n                // to act as the offerer includes an offer in the re-INVITE.  The UAS\n                // (User Agent Server) then provides an answer in a response to the\n                // re-INVITE.  A UAC willing to act as answerer does not include an\n                // offer in the re-INVITE.  The UAS then provides an offer in a response\n                // to the re-INVITE becoming, thus, the offerer.\n                // https://tools.ietf.org/html/rfc6141#section-1\n                const body = getBody(response.message);\n                if (!body) {\n                    // No way to recover, so terminate session and mark as failed.\n                    this.logger.error(\"Received 2xx response to re-INVITE without a session description\");\n                    this.ackAndBye(response, 400, \"Missing session description\");\n                    this.stateTransition(SessionState.Terminated);\n                    this.pendingReinvite = false;\n                    return;\n                }\n                if (options.withoutSdp) {\n                    // INVITE without SDP - set remote offer and send an answer in the ACK\n                    const answerOptions = {\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n                    };\n                    this.setOfferAndGetAnswer(body, answerOptions)\n                        .then((answerBody) => {\n                        response.ack({ body: answerBody });\n                    })\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to handle offer in 2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        if (this.state === SessionState.Terminated) {\n                            // A BYE should not be sent if already terminated.\n                            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                            response.ack();\n                        }\n                        else {\n                            this.ackAndBye(response, 488, \"Bad Media Description\");\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                    })\n                        .then(() => {\n                        this.pendingReinvite = false;\n                        if (options.requestDelegate && options.requestDelegate.onAccept) {\n                            options.requestDelegate.onAccept(response);\n                        }\n                    });\n                }\n                else {\n                    // INVITE with SDP - set remote answer and send an ACK\n                    const answerOptions = {\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n                    };\n                    this.setAnswer(body, answerOptions)\n                        .then(() => {\n                        response.ack();\n                    })\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to handle answer in 2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        // A BYE should only be sent if session is not already terminated.\n                        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                        // The ACK needs to be sent regardless as it was not handled by the transaction.\n                        if (this.state !== SessionState.Terminated) {\n                            this.ackAndBye(response, 488, \"Bad Media Description\");\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                        else {\n                            response.ack();\n                        }\n                    })\n                        .then(() => {\n                        this.pendingReinvite = false;\n                        if (options.requestDelegate && options.requestDelegate.onAccept) {\n                            options.requestDelegate.onAccept(response);\n                        }\n                    });\n                }\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onProgress: (response) => {\n                return;\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onRedirect: (response) => {\n                return;\n            },\n            onReject: (response) => {\n                this.logger.warn(\"Received a non-2xx response to re-INVITE\");\n                this.pendingReinvite = false;\n                if (options.withoutSdp) {\n                    if (options.requestDelegate && options.requestDelegate.onReject) {\n                        options.requestDelegate.onReject(response);\n                    }\n                }\n                else {\n                    this.rollbackOffer()\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to rollback offer on non-2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        // A BYE should only be sent if session is not already terminated.\n                        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                        // Note that the ACK was already sent by the transaction, so just need to send BYE.\n                        if (this.state !== SessionState.Terminated) {\n                            if (!this.dialog) {\n                                throw new Error(\"Dialog undefined.\");\n                            }\n                            const extraHeaders = [];\n                            extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n                            this.dialog.bye(undefined, { extraHeaders });\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                    })\n                        .then(() => {\n                        if (options.requestDelegate && options.requestDelegate.onReject) {\n                            options.requestDelegate.onReject(response);\n                        }\n                    });\n                }\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onTrying: (response) => {\n                return;\n            }\n        };\n        const requestOptions = options.requestOptions || {};\n        requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();\n        requestOptions.extraHeaders.push(\"Allow: \" + AllowedMethods.toString());\n        requestOptions.extraHeaders.push(\"Contact: \" + this._contact);\n        // Just send an INVITE with no sdp...\n        if (options.withoutSdp) {\n            if (!this.dialog) {\n                this.pendingReinvite = false;\n                throw new Error(\"Dialog undefined.\");\n            }\n            return Promise.resolve(this.dialog.invite(delegate, requestOptions));\n        }\n        // Get an offer and send it in an INVITE\n        const offerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n        };\n        return this.getOffer(offerOptions)\n            .then((offerBody) => {\n            if (!this.dialog) {\n                this.pendingReinvite = false;\n                throw new Error(\"Dialog undefined.\");\n            }\n            requestOptions.body = offerBody;\n            return this.dialog.invite(delegate, requestOptions);\n        })\n            .catch((error) => {\n            this.logger.error(error.message);\n            this.logger.error(\"Failed to send re-INVITE\");\n            this.pendingReinvite = false;\n            throw error;\n        });\n    }\n    /**\n     * Deliver a {@link Message}. Sends a MESSAGE.\n     * @param options - Options bucket. See {@link SessionMessageOptions} for details.\n     */\n    message(options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.message() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        return this._message(requestDelegate, requestOptions);\n    }\n    /**\n     * Proffer a {@link Referral}. Send a REFER.\n     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.\n     * @param options - Options bucket. See {@link SessionReferOptions} for details.\n     */\n    refer(referTo, options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.refer() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        requestOptions.extraHeaders = requestOptions.extraHeaders\n            ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo)))\n            : this.referExtraHeaders(this.referToString(referTo));\n        return this._refer(options.onNotify, requestDelegate, requestOptions);\n    }\n    /**\n     * Send BYE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _bye(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        const dialog = this.dialog;\n        // The caller's UA MAY send a BYE for either confirmed or early dialogs,\n        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT\n        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a\n        // BYE on a confirmed dialog until it has received an ACK for its 2xx\n        // response or until the server transaction times out.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        switch (dialog.sessionState) {\n            case SessionDialogState.Initial:\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            case SessionDialogState.Early: // Implementation choice - not sending BYE for early dialogs.\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            case SessionDialogState.AckWait: {\n                // This state only occurs if we are the callee.\n                this.stateTransition(SessionState.Terminating); // We're terminating\n                return new Promise((resolve) => {\n                    dialog.delegate = {\n                        // When ACK shows up, say BYE.\n                        onAck: () => {\n                            const request = dialog.bye(delegate, options);\n                            this.stateTransition(SessionState.Terminated);\n                            resolve(request);\n                            return Promise.resolve();\n                        },\n                        // Or the server transaction times out before the ACK arrives.\n                        onAckTimeout: () => {\n                            const request = dialog.bye(delegate, options);\n                            this.stateTransition(SessionState.Terminated);\n                            resolve(request);\n                        }\n                    };\n                });\n            }\n            case SessionDialogState.Confirmed: {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve(request);\n            }\n            case SessionDialogState.Terminated:\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n    }\n    /**\n     * Send INFO.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _info(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        return Promise.resolve(this.dialog.info(delegate, options));\n    }\n    /**\n     * Send MESSAGE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _message(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        return Promise.resolve(this.dialog.message(delegate, options));\n    }\n    /**\n     * Send REFER.\n     * @param onNotify - Notification callback.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _refer(onNotify, delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        // If set, deliver any in-dialog NOTIFY requests here...\n        this.onNotify = onNotify;\n        return Promise.resolve(this.dialog.refer(delegate, options));\n    }\n    /**\n     * Send ACK and then BYE. There are unrecoverable errors which can occur\n     * while handling dialog forming and in-dialog INVITE responses and when\n     * they occur we ACK the response and send a BYE.\n     * Note that the BYE is sent in the dialog associated with the response\n     * which is not necessarily `this.dialog`. And, accordingly, the\n     * session state is not transitioned to terminated and session is not closed.\n     * @param inviteResponse - The response causing the error.\n     * @param statusCode - Status code for he reason phrase.\n     * @param reasonPhrase - Reason phrase for the BYE.\n     * @internal\n     */\n    ackAndBye(response, statusCode, reasonPhrase) {\n        response.ack();\n        const extraHeaders = [];\n        if (statusCode) {\n            extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(statusCode, reasonPhrase));\n        }\n        // Using the dialog session associate with the response (which might not be this.dialog)\n        response.session.bye(undefined, { extraHeaders });\n    }\n    /**\n     * Handle in dialog ACK request.\n     * @internal\n     */\n    onAckRequest(request) {\n        this.logger.log(\"Session.onAckRequest\");\n        if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {\n            this.logger.error(`ACK received while in state ${this.state}, dropping request`);\n            return Promise.resolve();\n        }\n        const dialog = this.dialog;\n        if (!dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        // if received answer in ACK.\n        const answerOptions = {\n            sessionDescriptionHandlerOptions: this.pendingReinviteAck\n                ? this.sessionDescriptionHandlerOptionsReInvite\n                : this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.pendingReinviteAck\n                ? this._sessionDescriptionHandlerModifiersReInvite\n                : this._sessionDescriptionHandlerModifiers\n        };\n        // reset pending ACK flag\n        this.pendingReinviteAck = false;\n        switch (dialog.signalingState) {\n            case SignalingState.Initial: {\n                // State should never be reached as first reliable response must have answer/offer.\n                // So we must have never has sent an offer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.Stable: {\n                // State we should be in.\n                // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.\n                const body = getBody(request.message);\n                // If the ACK doesn't have an answer, nothing to be done.\n                if (!body) {\n                    return Promise.resolve();\n                }\n                if (body.contentDisposition === \"render\") {\n                    this._renderbody = body.content;\n                    this._rendertype = body.contentType;\n                    return Promise.resolve();\n                }\n                if (body.contentDisposition !== \"session\") {\n                    return Promise.resolve();\n                }\n                return this.setAnswer(body, answerOptions).catch((error) => {\n                    this.logger.error(error.message);\n                    const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                    dialog.bye(undefined, { extraHeaders });\n                    this.stateTransition(SessionState.Terminated);\n                });\n            }\n            case SignalingState.HaveLocalOffer: {\n                // State should never be reached as local offer would be answered by this ACK.\n                // So we must have received an ACK without an answer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.HaveRemoteOffer: {\n                // State should never be reached as remote offer would be answered in first reliable response.\n                // So we must have never has sent an answer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n        }\n    }\n    /**\n     * Handle in dialog BYE request.\n     * @internal\n     */\n    onByeRequest(request) {\n        this.logger.log(\"Session.onByeRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`BYE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onBye) {\n            const bye = new Bye(request);\n            this.delegate.onBye(bye);\n        }\n        else {\n            request.accept();\n        }\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle in dialog INFO request.\n     * @internal\n     */\n    onInfoRequest(request) {\n        this.logger.log(\"Session.onInfoRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`INFO received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onInfo) {\n            const info = new Info(request);\n            this.delegate.onInfo(info);\n        }\n        else {\n            // FIXME: TODO: We should reject request...\n            //\n            // If a UA receives an INFO request associated with an Info Package that\n            // the UA has not indicated willingness to receive, the UA MUST send a\n            // 469 (Bad Info Package) response (see Section 11.6), which contains a\n            // Recv-Info header field with Info Packages for which the UA is willing\n            // to receive INFO requests.\n            // https://tools.ietf.org/html/rfc6086#section-4.2.2\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog INVITE request.\n     * @internal\n     */\n    onInviteRequest(request) {\n        this.logger.log(\"Session.onInviteRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`INVITE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // set pending ACK flag\n        this.pendingReinviteAck = true;\n        // TODO: would be nice to have core track and set the Contact header,\n        // but currently the session which is setting it is holding onto it.\n        const extraHeaders = [\"Contact: \" + this._contact];\n        // Handle P-Asserted-Identity\n        if (request.message.hasHeader(\"P-Asserted-Identity\")) {\n            const header = request.message.getHeader(\"P-Asserted-Identity\");\n            if (!header) {\n                throw new Error(\"Header undefined.\");\n            }\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(header);\n        }\n        const options = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n        };\n        this.generateResponseOfferAnswerInDialog(options)\n            .then((body) => {\n            const outgoingResponse = request.accept({ statusCode: 200, extraHeaders, body });\n            if (this.delegate && this.delegate.onInvite) {\n                this.delegate.onInvite(request.message, outgoingResponse.message, 200);\n            }\n        })\n            .catch((error) => {\n            this.logger.error(error.message);\n            this.logger.error(\"Failed to handle to re-INVITE request\");\n            if (!this.dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            this.logger.error(this.dialog.signalingState);\n            // If we don't have a local/remote offer...\n            if (this.dialog.signalingState === SignalingState.Stable) {\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n                return;\n            }\n            // Otherwise rollback\n            this.rollbackOffer()\n                .then(() => {\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n            })\n                .catch((errorRollback) => {\n                // No way to recover, so terminate session and mark as failed.\n                this.logger.error(errorRollback.message);\n                this.logger.error(\"Failed to rollback offer on re-INVITE request\");\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                // A BYE should only be sent if session is not already terminated.\n                // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                // Note that the ACK was already sent by the transaction, so just need to send BYE.\n                if (this.state !== SessionState.Terminated) {\n                    if (!this.dialog) {\n                        throw new Error(\"Dialog undefined.\");\n                    }\n                    const extraHeadersBye = [];\n                    extraHeadersBye.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n                    this.dialog.bye(undefined, { extraHeaders });\n                    this.stateTransition(SessionState.Terminated);\n                }\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n            });\n        });\n    }\n    /**\n     * Handle in dialog MESSAGE request.\n     * @internal\n     */\n    onMessageRequest(request) {\n        this.logger.log(\"Session.onMessageRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onMessage) {\n            const message = new Message(request);\n            this.delegate.onMessage(message);\n        }\n        else {\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog NOTIFY request.\n     * @internal\n     */\n    onNotifyRequest(request) {\n        this.logger.log(\"Session.onNotifyRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // If this a NOTIFY associated with the progress of a REFER,\n        // look to delegate handling to the associated callback.\n        if (this.onNotify) {\n            const notification = new Notification(request);\n            this.onNotify(notification);\n            return;\n        }\n        // Otherwise accept the NOTIFY.\n        if (this.delegate && this.delegate.onNotify) {\n            const notification = new Notification(request);\n            this.delegate.onNotify(notification);\n        }\n        else {\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog PRACK request.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onPrackRequest(request) {\n        this.logger.log(\"Session.onPrackRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`PRACK received while in state ${this.state}, dropping request`);\n            return;\n        }\n        throw new Error(\"Unimplemented.\");\n    }\n    /**\n     * Handle in dialog REFER request.\n     * @internal\n     */\n    onReferRequest(request) {\n        this.logger.log(\"Session.onReferRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`REFER received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // REFER is a SIP request and is constructed as defined in [1].  A REFER\n        // request MUST contain exactly one Refer-To header field value.\n        // https://tools.ietf.org/html/rfc3515#section-2.4.1\n        if (!request.message.hasHeader(\"refer-to\")) {\n            this.logger.warn(\"Invalid REFER packet. A refer-to header is required. Rejecting.\");\n            request.reject();\n            return;\n        }\n        const referral = new Referral(request, this);\n        if (this.delegate && this.delegate.onRefer) {\n            this.delegate.onRefer(referral);\n        }\n        else {\n            this.logger.log(\"No delegate available to handle REFER, automatically accepting and following.\");\n            referral\n                .accept()\n                .then(() => referral.makeInviter(this._referralInviterOptions).invite())\n                .catch((error) => {\n                // FIXME: logging and eating error...\n                this.logger.error(error.message);\n            });\n        }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request.\n     * If a remote offer was provided in the request, set the remote\n     * description and get a local answer. If a remote offer was not\n     * provided, generates a local offer.\n     * @internal\n     */\n    generateResponseOfferAnswer(request, options) {\n        if (this.dialog) {\n            return this.generateResponseOfferAnswerInDialog(options);\n        }\n        const body = getBody(request.message);\n        if (!body || body.contentDisposition !== \"session\") {\n            return this.getOffer(options);\n        }\n        else {\n            return this.setOfferAndGetAnswer(body, options);\n        }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request\n     * when a dialog (early or otherwise) has already been established.\n     * This method may NOT be called if a dialog has yet to be established.\n     * @internal\n     */\n    generateResponseOfferAnswerInDialog(options) {\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        switch (this.dialog.signalingState) {\n            case SignalingState.Initial:\n                return this.getOffer(options);\n            case SignalingState.HaveLocalOffer:\n                // o  Once the UAS has sent or received an answer to the initial\n                // offer, it MUST NOT generate subsequent offers in any responses\n                // to the initial INVITE.  This means that a UAS based on this\n                // specification alone can never generate subsequent offers until\n                // completion of the initial transaction.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                return Promise.resolve(undefined);\n            case SignalingState.HaveRemoteOffer:\n                if (!this.dialog.offer) {\n                    throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);\n                }\n                return this.setOfferAndGetAnswer(this.dialog.offer, options);\n            case SignalingState.Stable:\n                // o  Once the UAS has sent or received an answer to the initial\n                // offer, it MUST NOT generate subsequent offers in any responses\n                // to the initial INVITE.  This means that a UAS based on this\n                // specification alone can never generate subsequent offers until\n                // completion of the initial transaction.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                if (this.state !== SessionState.Established) {\n                    return Promise.resolve(undefined);\n                }\n                // In dialog INVITE without offer, get an offer for the response.\n                return this.getOffer(options);\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n        }\n    }\n    /**\n     * Get local offer.\n     * @internal\n     */\n    getOffer(options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            return sdh\n                .getDescription(sdhOptions, sdhModifiers)\n                .then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType))\n                .catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.getOffer: SDH getDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.getOffer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.getOffer: SDH getDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Rollback local/remote offer.\n     * @internal\n     */\n    rollbackOffer() {\n        const sdh = this.setupSessionDescriptionHandler();\n        if (sdh.rollbackDescription === undefined) {\n            return Promise.resolve();\n        }\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            return sdh.rollbackDescription().catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.rollbackOffer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Set remote answer.\n     * @internal\n     */\n    setAnswer(answer, options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            if (!sdh.hasDescription(answer.contentType)) {\n                return Promise.reject(new ContentTypeUnsupportedError());\n            }\n        }\n        catch (error) {\n            this.logger.error(\"Session.setAnswer: SDH hasDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n        try {\n            return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.setAnswer: SDH setDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.setAnswer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.setAnswer: SDH setDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Set remote offer and get local answer.\n     * @internal\n     */\n    setOfferAndGetAnswer(offer, options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            if (!sdh.hasDescription(offer.contentType)) {\n                return Promise.reject(new ContentTypeUnsupportedError());\n            }\n        }\n        catch (error) {\n            this.logger.error(\"Session.setOfferAndGetAnswer: SDH hasDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n        try {\n            return sdh\n                .setDescription(offer.content, sdhOptions, sdhModifiers)\n                .then(() => sdh.getDescription(sdhOptions, sdhModifiers))\n                .then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType))\n                .catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.setOfferAndGetAnswer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n    setSessionDescriptionHandler(sdh) {\n        if (this._sessionDescriptionHandler) {\n            throw new Error(\"Session description handler defined.\");\n        }\n        this._sessionDescriptionHandler = sdh;\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n    setupSessionDescriptionHandler() {\n        var _a;\n        if (this._sessionDescriptionHandler) {\n            return this._sessionDescriptionHandler;\n        }\n        this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);\n        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n            this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);\n        }\n        return this._sessionDescriptionHandler;\n    }\n    /**\n     * Transition session state.\n     * @internal\n     */\n    stateTransition(newState) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate transition\n        switch (this._state) {\n            case SessionState.Initial:\n                if (newState !== SessionState.Establishing &&\n                    newState !== SessionState.Established &&\n                    newState !== SessionState.Terminating &&\n                    newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Establishing:\n                if (newState !== SessionState.Established &&\n                    newState !== SessionState.Terminating &&\n                    newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Established:\n                if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Terminating:\n                if (newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Terminated:\n                invalidTransition();\n                break;\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n        // Transition\n        this._state = newState;\n        this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        // Dispose\n        if (newState === SessionState.Terminated) {\n            this.dispose();\n        }\n    }\n    copyRequestOptions(requestOptions = {}) {\n        const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;\n        const body = requestOptions.body\n            ? {\n                contentDisposition: requestOptions.body.contentDisposition || \"render\",\n                contentType: requestOptions.body.contentType || \"text/plain\",\n                content: requestOptions.body.content || \"\"\n            }\n            : undefined;\n        return {\n            extraHeaders,\n            body\n        };\n    }\n    getReasonHeaderValue(code, reason) {\n        const cause = code;\n        let text = getReasonPhrase(code);\n        if (!text && reason) {\n            text = reason;\n        }\n        return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n    }\n    referExtraHeaders(referTo) {\n        const extraHeaders = [];\n        extraHeaders.push(\"Referred-By: <\" + this.userAgent.configuration.uri + \">\");\n        extraHeaders.push(\"Contact: \" + this._contact);\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        extraHeaders.push(\"Refer-To: \" + referTo);\n        return extraHeaders;\n    }\n    referToString(target) {\n        let referTo;\n        if (target instanceof URI) {\n            // REFER without Replaces (Blind Transfer)\n            referTo = target.toString();\n        }\n        else {\n            // REFER with Replaces (Attended Transfer)\n            if (!target.dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            const displayName = target.remoteIdentity.friendlyName;\n            const remoteTarget = target.dialog.remoteTarget.toString();\n            const callId = target.dialog.callId;\n            const remoteTag = target.dialog.remoteTag;\n            const localTag = target.dialog.localTag;\n            const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);\n            referTo = `\"${displayName}\" <${remoteTarget}?Replaces=${replaces}>`;\n        }\n        return referTo;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}