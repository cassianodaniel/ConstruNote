{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar flow = _interopDefault(require('lodash.flow'));\n\nvar isFunction = _interopDefault(require('lodash.isfunction'));\n\nvar isArray = _interopDefault(require('lodash.isarray'));\n\nvar _hslToHex = _interopDefault(require('hsl-to-hex'));\n\nvar hexToHsl = _interopDefault(require('hex-to-hsl'));\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}; // Change an hsl object { hue: int, sat: int, lit: int } to an array [int, int, int]\n\n\nvar hslObjToArray = function hslObjToArray(_ref) {\n  var hue = _ref.hue;\n  var sat = _ref.sat;\n  var lit = _ref.lit;\n  return [hue, sat, lit];\n}; // Returns a boolean telling if this is a valid hsl array [int, int, int]\n\n\nvar isHSLArray = function isHSLArray(c) {\n  return isArray(c) && c.length === 3 && typeof c[0] === 'number' && c[0] >= 0 && c[0] <= 360 && typeof c[1] === 'number' && c[1] >= 0 && c[1] <= 100 && typeof c[2] === 'number' && c[2] >= 0 && c[2] <= 100;\n}; // Returns a boolean telling if this is a valid hsl object { hue: int, sat: int, lit: int }\n\n\nvar isHSLObject = function isHSLObject(c) {\n  return (typeof c === 'undefined' ? 'undefined' : _typeof(c)) === 'object' && isHSLArray(hslObjToArray(c));\n}; // Returns a boolean telling if this is a valid hex color '#000000'\n\n\nvar isHexColor = function isHexColor(c) {\n  return typeof c === 'string' && c[0] === '#' && (c.length === 7 || c.length === 4);\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // Return an HSL array whatever the color type is passed\n\n\nvar colorToHSL = function colorToHSL(c) {\n  if (isHSLArray(c)) {\n    return c;\n  }\n\n  if (isHSLObject(c)) {\n    return hslObjToArray(c);\n  }\n\n  if (isHexColor(c)) {\n    return hexToHsl(c);\n  }\n\n  return c;\n}; // Returns an hex string value, whatever color type is passed in argument\n\n\nvar colorToHex = function colorToHex(c) {\n  if (isArray(c)) {\n    return _hslToHex.apply(undefined, _toConsumableArray(c));\n  }\n\n  if (isHSLObject(c)) {\n    return _hslToHex(c.hue, c.sat, c.lit);\n  }\n\n  if (isHexColor(c)) {\n    return c;\n  }\n\n  return c;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}(); // Makes sure the function gets an HSL object\n\n\nvar withHSL = function withHSL(func) {\n  return function (c) {\n    return func(colorToHSL(c));\n  };\n};\n\nvar isValidColor = function isValidColor(col) {\n  return col && (isHSLArray(col) || isHSLObject(col) || isHexColor(col));\n}; // Return hex from a color\n\n\nvar color = function color(col) {\n  for (var _len = arguments.length, colAlts = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    colAlts[_key - 1] = arguments[_key];\n  } // If the color passed is a function, execute it\n\n\n  if (isFunction(col)) {\n    col = col();\n  } // If nothing is passed, return a black color by default\n\n\n  if (!col) {\n    return '#000000';\n  } // Validate\n\n\n  if (!isValidColor(col)) {\n    throw new Error('Color passed is not a valid color');\n  } // When alterations are passed, process the color and return an hex value\n\n\n  if (colAlts.length) {\n    var alteration = flow(colAlts);\n    return colorToHex(alteration(col));\n  } // If just a color is passed, return a function which takes alterations\n\n\n  return function () {\n    for (var _len2 = arguments.length, alts = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      alts[_key2] = arguments[_key2];\n    }\n\n    var firstArg = alts[0];\n\n    if (firstArg && isValidColor(firstArg)) {\n      return color(firstArg);\n    } // Return the altered color wrapper if alterations are passed\n\n\n    if (alts.length) {\n      var _alteration = flow(alts);\n\n      return color(_alteration(col));\n    } // If no argument is passed, return the hex color\n\n\n    return colorToHex(col);\n  };\n}; // British proxy\n\n\nvar colour = color; // Alter lightness of an hsl color\n\nvar lightness = function lightness(percent) {\n  return withHSL(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3);\n\n    var hue = _ref2[0];\n    var sat = _ref2[1];\n    var lit = _ref2[2];\n    return [hue, sat, lit + percent];\n  });\n}; // Alter saturation of an hsl color\n\n\nvar saturation = function saturation(percent) {\n  return withHSL(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 3);\n\n    var hue = _ref4[0];\n    var sat = _ref4[1];\n    var lit = _ref4[2];\n    return [hue, sat + percent, lit];\n  });\n}; // Alter hue of an hsl color\n\n\nvar hue = function hue(percent) {\n  return withHSL(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 3);\n\n    var hue = _ref6[0];\n    var sat = _ref6[1];\n    var lit = _ref6[2];\n    return [hue + percent, sat, lit];\n  });\n};\n\nexports.color = color;\nexports.colour = colour;\nexports.lightness = lightness;\nexports.saturation = saturation;\nexports.hue = hue;","map":{"version":3,"sources":["../src/validation.js","../src/transformers.js","../src/index.js"],"names":["hslObjToArray","hue","sat","lit","isHSLArray","isArray","c","isHSLObject","isHexColor","colorToHSL","hexToHsl","colorToHex","_hslToHex","withHSL","func","isValidColor","col","color","colAlts","isFunction","alteration","flow","alts","firstArg","colour","lightness","saturation"],"mappings":"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","sourcesContent":["\nimport isArray from 'lodash.isarray';\n\n// Change an hsl object { hue: int, sat: int, lit: int } to an array [int, int, int]\nexport const hslObjToArray = ({hue, sat, lit}) => [hue, sat, lit];\n\n// Returns a boolean telling if this is a valid hsl array [int, int, int]\nexport const isHSLArray = c =>\n\tisArray(c) && c.length === 3 &&\n\ttypeof c[0] === 'number' && c[0] >= 0 && c[0] <= 360 &&\n\ttypeof c[1] === 'number' && c[1] >= 0 && c[1] <= 100 &&\n\ttypeof c[2] === 'number' && c[2] >= 0 && c[2] <= 100;\n\n// Returns a boolean telling if this is a valid hsl object { hue: int, sat: int, lit: int }\nexport const isHSLObject = c =>\n\ttypeof c === 'object' && isHSLArray(hslObjToArray(c));\n\n// Returns a boolean telling if this is a valid hex color '#000000'\nexport const isHexColor = c => typeof c === 'string' && c[0] === '#' && (c.length === 7 || c.length === 4);\n","\nimport isArray from 'lodash.isarray';\nimport _hslToHex from 'hsl-to-hex';\nimport hexToHsl from 'hex-to-hsl';\n\nimport {isHSLArray, isHSLObject, isHexColor, hslObjToArray} from './validation';\n\n// Return an HSL array whatever the color type is passed\nexport const colorToHSL = c => {\n\tif (isHSLArray(c)) {\n\t\treturn c;\n\t}\n\n\tif (isHSLObject(c)) {\n\t\treturn hslObjToArray(c);\n\t}\n\n\tif (isHexColor(c)) {\n\t\treturn hexToHsl(c);\n\t}\n\n\treturn c;\n};\n\n// Returns an hex string value, whatever color type is passed in argument\nexport const colorToHex = c => {\n\tif (isArray(c)) {\n\t\treturn _hslToHex(...c);\n\t}\n\n\tif (isHSLObject(c)) {\n\t\treturn _hslToHex(c.hue, c.sat, c.lit);\n\t}\n\n\tif (isHexColor(c)) {\n\t\treturn c;\n\t}\n\n\treturn c;\n};\n","\nimport flow from 'lodash.flow';\nimport isFunction from 'lodash.isfunction';\nimport {colorToHSL, colorToHex} from './transformers';\nimport {isHSLArray, isHSLObject, isHexColor} from './validation';\n\n// Makes sure the function gets an HSL object\nconst withHSL = func => c => func(colorToHSL(c));\n\nconst isValidColor = col => col && (isHSLArray(col) || isHSLObject(col) || isHexColor(col));\n\n// Return hex from a color\nexport const color = (col, ...colAlts) => {\n\t// If the color passed is a function, execute it\n\tif (isFunction(col)) {\n\t\tcol = col();\n\t}\n\n\t// If nothing is passed, return a black color by default\n\tif (!col) {\n\t\treturn '#000000';\n\t}\n\n\t// Validate\n\tif (!isValidColor(col)) {\n\t\tthrow new Error('Color passed is not a valid color');\n\t}\n\n\t// When alterations are passed, process the color and return an hex value\n\tif (colAlts.length) {\n\t\tlet alteration = flow(colAlts);\n\t\treturn colorToHex(alteration(col));\n\t}\n\n\t// If just a color is passed, return a function which takes alterations\n\treturn (...alts) => {\n\t\tconst firstArg = alts[0];\n\t\tif (firstArg && isValidColor(firstArg)) {\n\t\t\treturn color(firstArg);\n\t\t}\n\n\t\t// Return the altered color wrapper if alterations are passed\n\t\tif (alts.length) {\n\t\t\tlet alteration = flow(alts);\n\t\t\treturn color(alteration(col));\n\t\t}\n\n\t\t// If no argument is passed, return the hex color\n\t\treturn colorToHex(col);\n\t};\n};\n\n// British proxy\nexport const colour = color;\n\n// Alter lightness of an hsl color\nexport const lightness = percent => withHSL(([hue, sat, lit]) => [hue, sat, lit + percent]);\n\n// Alter saturation of an hsl color\nexport const saturation = percent => withHSL(([hue, sat, lit]) => [hue, sat + percent, lit]);\n\n// Alter hue of an hsl color\nexport const hue = percent => withHSL(([hue, sat, lit]) => [hue + percent, sat, lit]);\n"]},"metadata":{},"sourceType":"script"}