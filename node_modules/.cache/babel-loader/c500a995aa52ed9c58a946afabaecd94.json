{"ast":null,"code":"import { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Client Transaction.\n * @remarks\n * The INVITE transaction consists of a three-way handshake.  The client\n * transaction sends an INVITE, the server transaction sends responses,\n * and the client transaction sends an ACK.\n * https://tools.ietf.org/html/rfc3261#section-17.1.1\n * @public\n */\n\nexport class InviteClientTransaction extends ClientTransaction {\n  /**\n   * Constructor.\n   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n   * Then `toString` is called on the outgoing request and the message is sent via the transport.\n   * After construction the transaction will be in the \"calling\" state and the transaction id\n   * will equal the branch parameter set in the Via header of the outgoing request.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1\n   * @param request - The outgoing INVITE request.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Calling, \"sip.transaction.ict\");\n    /**\n     * Map of 2xx to-tag to ACK.\n     * If value is not undefined, value is the ACK which was sent.\n     * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.\n     * Otherwise, a 2xx was not (yet) received for this transaction.\n     */\n\n    this.ackRetransmissionCache = new Map(); // FIXME: Timer A for unreliable transport not implemented\n    //\n    // If an unreliable transport is being used, the client transaction\n    // MUST start timer A with a value of T1. If a reliable transport is being used,\n    // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).\n    // For any transport, the client transaction MUST start timer B with a value\n    // of 64*T1 seconds (Timer B controls transaction timeouts).\n    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n    //\n    // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n    // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n    // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n    this.B = setTimeout(() => this.timerB(), Timers.TIMER_B);\n    this.send(request.toString()).catch(error => {\n      this.logTransportError(error, \"Failed to send initial outgoing request.\");\n    });\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    if (this.B) {\n      clearTimeout(this.B);\n      this.B = undefined;\n    }\n\n    if (this.D) {\n      clearTimeout(this.D);\n      this.D = undefined;\n    }\n\n    if (this.M) {\n      clearTimeout(this.M);\n      this.M = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"ict\";\n  }\n  /**\n   * ACK a 2xx final response.\n   *\n   * The transaction includes the ACK only if the final response was not a 2xx response (the\n   * transaction will generate and send the ACK to the transport automagically). If the\n   * final response was a 2xx, the ACK is not considered part of the transaction (the\n   * transaction user needs to generate and send the ACK).\n   *\n   * This library is not strictly RFC compliant with regard to ACK handling for 2xx final\n   * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled\n   * by the transaction layer (instead of the UAC core). The \"standard\" approach is for\n   * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to\n   * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses\n   * and any retransmissions of those ACKs as needed.\n   *\n   * @param ack - The outgoing ACK request.\n   */\n\n\n  ackResponse(ack) {\n    const toTag = ack.toTag;\n\n    if (!toTag) {\n      throw new Error(\"To tag undefined.\");\n    }\n\n    const id = \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n    ack.setViaHeader(id, this.transport.protocol);\n    this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache\n\n    this.send(ack.toString()).catch(error => {\n      this.logTransportError(error, \"Failed to send ACK to 2xx response.\");\n    });\n  }\n  /**\n   * Handler for incoming responses from the transport which match this transaction.\n   * @param response - The incoming response.\n   */\n\n\n  receiveResponse(response) {\n    const statusCode = response.statusCode;\n\n    if (!statusCode || statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    switch (this.state) {\n      case TransactionState.Calling:\n        // If the client transaction receives a provisional response while in\n        // the \"Calling\" state, it transitions to the \"Proceeding\" state. In the\n        // \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n        // request any longer. Furthermore, the provisional response MUST be\n        // passed to the TU.  Any further provisional responses MUST be passed\n        // up to the TU while in the \"Proceeding\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          this.stateTransition(TransactionState.Proceeding);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When a 2xx response is received while in either the \"Calling\" or\n        // \"Proceeding\" states, the client transaction MUST transition to\n        // the \"Accepted\" state... The 2xx response MUST be passed up to the TU.\n        // The client transaction MUST NOT generate an ACK to the 2xx response -- its\n        // handling is delegated to the TU. A UAC core will send an ACK to\n        // the 2xx response using a new transaction.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n          this.stateTransition(TransactionState.Accepted);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n        // a response with status code from 300-699 MUST cause the client\n        // transaction to transition to \"Completed\". The client transaction\n        // MUST pass the received response up to the TU, and the client\n        // transaction MUST generate an ACK request, even if the transport is\n        // reliable (guidelines for constructing the ACK from the response\n        // are given in Section 17.1.1.3), and then pass the ACK to the\n        // transport layer for transmission. The ACK MUST be sent to the\n        // same address, port, and transport to which the original request was sent.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.ack(response);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Proceeding:\n        // In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n        // request any longer. Furthermore, the provisional response MUST be\n        // passed to the TU.  Any further provisional responses MUST be passed\n        // up to the TU while in the \"Proceeding\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When a 2xx response is received while in either the \"Calling\" or \"Proceeding\" states,\n        // the client transaction MUST transition to the \"Accepted\" state...\n        // The 2xx response MUST be passed up to the TU. The client\n        // transaction MUST NOT generate an ACK to the 2xx response -- its\n        // handling is delegated to the TU. A UAC core will send an ACK to\n        // the 2xx response using a new transaction.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n          this.stateTransition(TransactionState.Accepted);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n        // a response with status code from 300-699 MUST cause the client\n        // transaction to transition to \"Completed\". The client transaction\n        // MUST pass the received response up to the TU, and the client\n        // transaction MUST generate an ACK request, even if the transport is\n        // reliable (guidelines for constructing the ACK from the response\n        // are given in Section 17.1.1.3), and then pass the ACK to the\n        // transport layer for transmission. The ACK MUST be sent to the\n        // same address, port, and transport to which the original request was sent.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.ack(response);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // The purpose of the \"Accepted\" state is to allow the client\n        // transaction to continue to exist to receive, and pass to the TU,\n        // any retransmissions of the 2xx response and any additional 2xx\n        // responses from other branches of the INVITE if it forked\n        // downstream. Timer M reflects the amount of time that the\n        // transaction user will wait for such messages.\n        //\n        // Any 2xx responses that match this client transaction and that are\n        // received while in the \"Accepted\" state MUST be passed up to the\n        // TU. The client transaction MUST NOT generate an ACK to the 2xx\n        // response. The client transaction takes no further action.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (statusCode >= 200 && statusCode <= 299) {\n          // NOTE: This implementation herein is intentionally not RFC compliant.\n          // While the first 2xx response for a given branch is passed up to the TU,\n          // retransmissions of 2xx responses are absorbed and the ACK associated\n          // with the original response is resent. This approach is taken because\n          // our current transaction users are not currently in a good position to\n          // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)\n          //\n          // If we don't have a cache hit, pass the response to the TU.\n          if (!this.ackRetransmissionCache.has(response.toTag)) {\n            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // If we have a cache hit, try pulling the ACK from cache and retransmitting it.\n\n\n          const ack = this.ackRetransmissionCache.get(response.toTag);\n\n          if (ack) {\n            this.send(ack.toString()).catch(error => {\n              this.logTransportError(error, \"Failed to send retransmission of ACK to 2xx response.\");\n            });\n            return;\n          } // If an ACK was not found in cache then we have received a retransmitted 2xx\n          // response before the TU responded to the original response (we don't have an ACK yet).\n          // So discard this response under the assumption that the TU will eventually\n          // get us a ACK for the original response.\n\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // Any retransmissions of a response with status code 300-699 that\n        // are received while in the \"Completed\" state MUST cause the ACK to\n        // be re-passed to the transport layer for retransmission, but the\n        // newly received response MUST NOT be passed up to the TU.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.ack(response);\n          return;\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    } // Any response received that does not match an existing client\n    // transaction state machine is simply dropped. (Implementations are,\n    // of course, free to log or do other implementation-specific things\n    // with such responses, but the implementer should be sure to consider\n    // the impact of large numbers of malicious stray responses.)\n    // https://tools.ietf.org/html/rfc6026#section-7.2\n\n\n    const message = `Received unexpected ${statusCode} response while in state ${this.state}.`;\n    this.logger.warn(message);\n    return;\n  }\n  /**\n   * The client transaction SHOULD inform the TU that a transport failure\n   * has occurred, and the client transaction SHOULD transition directly\n   * to the \"Terminated\" state.  The TU will handle the failover\n   * mechanisms described in [4].\n   * https://tools.ietf.org/html/rfc3261#section-17.1.4\n   * @param error - The error.\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n\n    this.stateTransition(TransactionState.Terminated, true);\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"INVITE client transaction\";\n  }\n\n  ack(response) {\n    // The ACK request constructed by the client transaction MUST contain\n    // values for the Call-ID, From, and Request-URI that are equal to the\n    // values of those header fields in the request passed to the transport\n    // by the client transaction (call this the \"original request\"). The To\n    // header field in the ACK MUST equal the To header field in the\n    // response being acknowledged, and therefore will usually differ from\n    // the To header field in the original request by the addition of the\n    // tag parameter. The ACK MUST contain a single Via header field, and\n    // this MUST be equal to the top Via header field of the original\n    // request. The CSeq header field in the ACK MUST contain the same\n    // value for the sequence number as was present in the original request,\n    // but the method parameter MUST be equal to \"ACK\".\n    //\n    // If the INVITE request whose response is being acknowledged had Route\n    // header fields, those header fields MUST appear in the ACK. This is\n    // to ensure that the ACK can be routed properly through any downstream\n    // stateless proxies.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.1.3\n    const ruri = this.request.ruri;\n    const callId = this.request.callId;\n    const cseq = this.request.cseq;\n    const from = this.request.getHeader(\"from\");\n    const to = response.getHeader(\"to\");\n    const via = this.request.getHeader(\"via\");\n    const route = this.request.getHeader(\"route\");\n\n    if (!from) {\n      throw new Error(\"From undefined.\");\n    }\n\n    if (!to) {\n      throw new Error(\"To undefined.\");\n    }\n\n    if (!via) {\n      throw new Error(\"Via undefined.\");\n    }\n\n    let ack = `ACK ${ruri} SIP/2.0\\r\\n`;\n\n    if (route) {\n      ack += `Route: ${route}\\r\\n`;\n    }\n\n    ack += `Via: ${via}\\r\\n`;\n    ack += `To: ${to}\\r\\n`;\n    ack += `From: ${from}\\r\\n`;\n    ack += `Call-ID: ${callId}\\r\\n`;\n    ack += `CSeq: ${cseq} ACK\\r\\n`;\n    ack += `Max-Forwards: 70\\r\\n`;\n    ack += `Content-Length: 0\\r\\n\\r\\n`; // TOOO: \"User-Agent\" header\n\n    this.send(ack).catch(error => {\n      this.logTransportError(error, \"Failed to send ACK to non-2xx response.\");\n    });\n    return;\n  }\n  /**\n   * Execute a state transition.\n   * @param newState - New state.\n   */\n\n\n  stateTransition(newState, dueToTransportError = false) {\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Calling:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Proceeding:\n        if (this.state !== TransactionState.Calling) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed) {\n          if (!dueToTransportError) {\n            invalidStateTransition();\n          }\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n    // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n    // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n\n    if (this.B) {\n      clearTimeout(this.B);\n      this.B = undefined;\n    }\n\n    if (newState === TransactionState.Proceeding) {// Timers have no effect on \"Proceeding\" state.\n      // In the \"Proceeding\" state, the client transaction\n      // SHOULD NOT retransmit the request any longer.\n      // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n    } // The client transaction MUST start Timer D when it enters the \"Completed\" state\n    // for any reason, with a value of at least 32 seconds for unreliable transports,\n    // and a value of zero seconds for reliable transports.\n    // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n    if (newState === TransactionState.Completed) {\n      this.D = setTimeout(() => this.timerD(), Timers.TIMER_D);\n    } // The client transaction MUST transition to the \"Accepted\" state,\n    // and Timer M MUST be started with a value of 64*T1.\n    // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n    if (newState === TransactionState.Accepted) {\n      this.M = setTimeout(() => this.timerM(), Timers.TIMER_M);\n    } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    } // Update state.\n\n\n    this.setState(newState);\n  }\n  /**\n   * When timer A fires, the client transaction MUST retransmit the\n   * request by passing it to the transport layer, and MUST reset the\n   * timer with a value of 2*T1.\n   * When timer A fires 2*T1 seconds later, the request MUST be\n   * retransmitted again (assuming the client transaction is still in this\n   * state). This process MUST continue so that the request is\n   * retransmitted with intervals that double after each transmission.\n   * These retransmissions SHOULD only be done while the client\n   * transaction is in the \"Calling\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n   */\n\n\n  timerA() {// TODO\n  }\n  /**\n   * If the client transaction is still in the \"Calling\" state when timer\n   * B fires, the client transaction SHOULD inform the TU that a timeout\n   * has occurred.  The client transaction MUST NOT generate an ACK.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n   */\n\n\n  timerB() {\n    this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Calling) {\n      this.onRequestTimeout();\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * If Timer D fires while the client transaction is in the \"Completed\" state,\n   * the client transaction MUST move to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc6026#section-8.4\n   */\n\n\n  timerD() {\n    this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Completed) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * If Timer M fires while the client transaction is in the \"Accepted\"\n   * state, the client transaction MUST move to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc6026#section-8.4\n   */\n\n\n  timerM() {\n    this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Accepted) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"],"names":["Timers","ClientTransaction","TransactionState","InviteClientTransaction","constructor","request","transport","user","Calling","ackRetransmissionCache","Map","B","setTimeout","timerB","TIMER_B","send","toString","catch","error","logTransportError","dispose","clearTimeout","undefined","D","M","kind","ackResponse","ack","toTag","Error","id","Math","floor","random","setViaHeader","protocol","set","receiveResponse","response","statusCode","state","stateTransition","Proceeding","Accepted","Completed","has","get","Terminated","message","logger","warn","onTransportError","typeToString","ruri","callId","cseq","from","getHeader","to","via","route","newState","dueToTransportError","invalidStateTransition","timerD","TIMER_D","timerM","TIMER_M","setState","timerA","debug","onRequestTimeout"],"mappings":"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","sourcesContent":["import { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Client Transaction.\n * @remarks\n * The INVITE transaction consists of a three-way handshake.  The client\n * transaction sends an INVITE, the server transaction sends responses,\n * and the client transaction sends an ACK.\n * https://tools.ietf.org/html/rfc3261#section-17.1.1\n * @public\n */\nexport class InviteClientTransaction extends ClientTransaction {\n    /**\n     * Constructor.\n     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n     * Then `toString` is called on the outgoing request and the message is sent via the transport.\n     * After construction the transaction will be in the \"calling\" state and the transaction id\n     * will equal the branch parameter set in the Via header of the outgoing request.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1\n     * @param request - The outgoing INVITE request.\n     * @param transport - The transport.\n     * @param user - The transaction user.\n     */\n    constructor(request, transport, user) {\n        super(request, transport, user, TransactionState.Calling, \"sip.transaction.ict\");\n        /**\n         * Map of 2xx to-tag to ACK.\n         * If value is not undefined, value is the ACK which was sent.\n         * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.\n         * Otherwise, a 2xx was not (yet) received for this transaction.\n         */\n        this.ackRetransmissionCache = new Map();\n        // FIXME: Timer A for unreliable transport not implemented\n        //\n        // If an unreliable transport is being used, the client transaction\n        // MUST start timer A with a value of T1. If a reliable transport is being used,\n        // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).\n        // For any transport, the client transaction MUST start timer B with a value\n        // of 64*T1 seconds (Timer B controls transaction timeouts).\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        //\n        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n        // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n        // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n        this.B = setTimeout(() => this.timerB(), Timers.TIMER_B);\n        this.send(request.toString()).catch((error) => {\n            this.logTransportError(error, \"Failed to send initial outgoing request.\");\n        });\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        if (this.B) {\n            clearTimeout(this.B);\n            this.B = undefined;\n        }\n        if (this.D) {\n            clearTimeout(this.D);\n            this.D = undefined;\n        }\n        if (this.M) {\n            clearTimeout(this.M);\n            this.M = undefined;\n        }\n        super.dispose();\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        return \"ict\";\n    }\n    /**\n     * ACK a 2xx final response.\n     *\n     * The transaction includes the ACK only if the final response was not a 2xx response (the\n     * transaction will generate and send the ACK to the transport automagically). If the\n     * final response was a 2xx, the ACK is not considered part of the transaction (the\n     * transaction user needs to generate and send the ACK).\n     *\n     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final\n     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled\n     * by the transaction layer (instead of the UAC core). The \"standard\" approach is for\n     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to\n     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses\n     * and any retransmissions of those ACKs as needed.\n     *\n     * @param ack - The outgoing ACK request.\n     */\n    ackResponse(ack) {\n        const toTag = ack.toTag;\n        if (!toTag) {\n            throw new Error(\"To tag undefined.\");\n        }\n        const id = \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n        ack.setViaHeader(id, this.transport.protocol);\n        this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache\n        this.send(ack.toString()).catch((error) => {\n            this.logTransportError(error, \"Failed to send ACK to 2xx response.\");\n        });\n    }\n    /**\n     * Handler for incoming responses from the transport which match this transaction.\n     * @param response - The incoming response.\n     */\n    receiveResponse(response) {\n        const statusCode = response.statusCode;\n        if (!statusCode || statusCode < 100 || statusCode > 699) {\n            throw new Error(`Invalid status code ${statusCode}`);\n        }\n        switch (this.state) {\n            case TransactionState.Calling:\n                // If the client transaction receives a provisional response while in\n                // the \"Calling\" state, it transitions to the \"Proceeding\" state. In the\n                // \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n                // request any longer. Furthermore, the provisional response MUST be\n                // passed to the TU.  Any further provisional responses MUST be passed\n                // up to the TU while in the \"Proceeding\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    this.stateTransition(TransactionState.Proceeding);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When a 2xx response is received while in either the \"Calling\" or\n                // \"Proceeding\" states, the client transaction MUST transition to\n                // the \"Accepted\" state... The 2xx response MUST be passed up to the TU.\n                // The client transaction MUST NOT generate an ACK to the 2xx response -- its\n                // handling is delegated to the TU. A UAC core will send an ACK to\n                // the 2xx response using a new transaction.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                    this.stateTransition(TransactionState.Accepted);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When in either the \"Calling\" or \"Proceeding\" states, reception of\n                // a response with status code from 300-699 MUST cause the client\n                // transaction to transition to \"Completed\". The client transaction\n                // MUST pass the received response up to the TU, and the client\n                // transaction MUST generate an ACK request, even if the transport is\n                // reliable (guidelines for constructing the ACK from the response\n                // are given in Section 17.1.1.3), and then pass the ACK to the\n                // transport layer for transmission. The ACK MUST be sent to the\n                // same address, port, and transport to which the original request was sent.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    this.ack(response);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Proceeding:\n                // In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n                // request any longer. Furthermore, the provisional response MUST be\n                // passed to the TU.  Any further provisional responses MUST be passed\n                // up to the TU while in the \"Proceeding\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When a 2xx response is received while in either the \"Calling\" or \"Proceeding\" states,\n                // the client transaction MUST transition to the \"Accepted\" state...\n                // The 2xx response MUST be passed up to the TU. The client\n                // transaction MUST NOT generate an ACK to the 2xx response -- its\n                // handling is delegated to the TU. A UAC core will send an ACK to\n                // the 2xx response using a new transaction.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                    this.stateTransition(TransactionState.Accepted);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When in either the \"Calling\" or \"Proceeding\" states, reception of\n                // a response with status code from 300-699 MUST cause the client\n                // transaction to transition to \"Completed\". The client transaction\n                // MUST pass the received response up to the TU, and the client\n                // transaction MUST generate an ACK request, even if the transport is\n                // reliable (guidelines for constructing the ACK from the response\n                // are given in Section 17.1.1.3), and then pass the ACK to the\n                // transport layer for transmission. The ACK MUST be sent to the\n                // same address, port, and transport to which the original request was sent.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    this.ack(response);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // The purpose of the \"Accepted\" state is to allow the client\n                // transaction to continue to exist to receive, and pass to the TU,\n                // any retransmissions of the 2xx response and any additional 2xx\n                // responses from other branches of the INVITE if it forked\n                // downstream. Timer M reflects the amount of time that the\n                // transaction user will wait for such messages.\n                //\n                // Any 2xx responses that match this client transaction and that are\n                // received while in the \"Accepted\" state MUST be passed up to the\n                // TU. The client transaction MUST NOT generate an ACK to the 2xx\n                // response. The client transaction takes no further action.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    // NOTE: This implementation herein is intentionally not RFC compliant.\n                    // While the first 2xx response for a given branch is passed up to the TU,\n                    // retransmissions of 2xx responses are absorbed and the ACK associated\n                    // with the original response is resent. This approach is taken because\n                    // our current transaction users are not currently in a good position to\n                    // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)\n                    //\n                    // If we don't have a cache hit, pass the response to the TU.\n                    if (!this.ackRetransmissionCache.has(response.toTag)) {\n                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                        if (this.user.receiveResponse) {\n                            this.user.receiveResponse(response);\n                        }\n                        return;\n                    }\n                    // If we have a cache hit, try pulling the ACK from cache and retransmitting it.\n                    const ack = this.ackRetransmissionCache.get(response.toTag);\n                    if (ack) {\n                        this.send(ack.toString()).catch((error) => {\n                            this.logTransportError(error, \"Failed to send retransmission of ACK to 2xx response.\");\n                        });\n                        return;\n                    }\n                    // If an ACK was not found in cache then we have received a retransmitted 2xx\n                    // response before the TU responded to the original response (we don't have an ACK yet).\n                    // So discard this response under the assumption that the TU will eventually\n                    // get us a ACK for the original response.\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                // Any retransmissions of a response with status code 300-699 that\n                // are received while in the \"Completed\" state MUST cause the ACK to\n                // be re-passed to the transport layer for retransmission, but the\n                // newly received response MUST NOT be passed up to the TU.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.ack(response);\n                    return;\n                }\n                break;\n            case TransactionState.Terminated:\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        // Any response received that does not match an existing client\n        // transaction state machine is simply dropped. (Implementations are,\n        // of course, free to log or do other implementation-specific things\n        // with such responses, but the implementer should be sure to consider\n        // the impact of large numbers of malicious stray responses.)\n        // https://tools.ietf.org/html/rfc6026#section-7.2\n        const message = `Received unexpected ${statusCode} response while in state ${this.state}.`;\n        this.logger.warn(message);\n        return;\n    }\n    /**\n     * The client transaction SHOULD inform the TU that a transport failure\n     * has occurred, and the client transaction SHOULD transition directly\n     * to the \"Terminated\" state.  The TU will handle the failover\n     * mechanisms described in [4].\n     * https://tools.ietf.org/html/rfc3261#section-17.1.4\n     * @param error - The error.\n     */\n    onTransportError(error) {\n        if (this.user.onTransportError) {\n            this.user.onTransportError(error);\n        }\n        this.stateTransition(TransactionState.Terminated, true);\n    }\n    /** For logging. */\n    typeToString() {\n        return \"INVITE client transaction\";\n    }\n    ack(response) {\n        // The ACK request constructed by the client transaction MUST contain\n        // values for the Call-ID, From, and Request-URI that are equal to the\n        // values of those header fields in the request passed to the transport\n        // by the client transaction (call this the \"original request\"). The To\n        // header field in the ACK MUST equal the To header field in the\n        // response being acknowledged, and therefore will usually differ from\n        // the To header field in the original request by the addition of the\n        // tag parameter. The ACK MUST contain a single Via header field, and\n        // this MUST be equal to the top Via header field of the original\n        // request. The CSeq header field in the ACK MUST contain the same\n        // value for the sequence number as was present in the original request,\n        // but the method parameter MUST be equal to \"ACK\".\n        //\n        // If the INVITE request whose response is being acknowledged had Route\n        // header fields, those header fields MUST appear in the ACK. This is\n        // to ensure that the ACK can be routed properly through any downstream\n        // stateless proxies.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.3\n        const ruri = this.request.ruri;\n        const callId = this.request.callId;\n        const cseq = this.request.cseq;\n        const from = this.request.getHeader(\"from\");\n        const to = response.getHeader(\"to\");\n        const via = this.request.getHeader(\"via\");\n        const route = this.request.getHeader(\"route\");\n        if (!from) {\n            throw new Error(\"From undefined.\");\n        }\n        if (!to) {\n            throw new Error(\"To undefined.\");\n        }\n        if (!via) {\n            throw new Error(\"Via undefined.\");\n        }\n        let ack = `ACK ${ruri} SIP/2.0\\r\\n`;\n        if (route) {\n            ack += `Route: ${route}\\r\\n`;\n        }\n        ack += `Via: ${via}\\r\\n`;\n        ack += `To: ${to}\\r\\n`;\n        ack += `From: ${from}\\r\\n`;\n        ack += `Call-ID: ${callId}\\r\\n`;\n        ack += `CSeq: ${cseq} ACK\\r\\n`;\n        ack += `Max-Forwards: 70\\r\\n`;\n        ack += `Content-Length: 0\\r\\n\\r\\n`;\n        // TOOO: \"User-Agent\" header\n        this.send(ack).catch((error) => {\n            this.logTransportError(error, \"Failed to send ACK to non-2xx response.\");\n        });\n        return;\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n    stateTransition(newState, dueToTransportError = false) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n        };\n        switch (newState) {\n            case TransactionState.Calling:\n                invalidStateTransition();\n                break;\n            case TransactionState.Proceeding:\n                if (this.state !== TransactionState.Calling) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Accepted:\n            case TransactionState.Completed:\n                if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Terminated:\n                if (this.state !== TransactionState.Calling &&\n                    this.state !== TransactionState.Accepted &&\n                    this.state !== TransactionState.Completed) {\n                    if (!dueToTransportError) {\n                        invalidStateTransition();\n                    }\n                }\n                break;\n            default:\n                invalidStateTransition();\n        }\n        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n        // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n        // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n        if (this.B) {\n            clearTimeout(this.B);\n            this.B = undefined;\n        }\n        if (newState === TransactionState.Proceeding) {\n            // Timers have no effect on \"Proceeding\" state.\n            // In the \"Proceeding\" state, the client transaction\n            // SHOULD NOT retransmit the request any longer.\n            // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        }\n        // The client transaction MUST start Timer D when it enters the \"Completed\" state\n        // for any reason, with a value of at least 32 seconds for unreliable transports,\n        // and a value of zero seconds for reliable transports.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (newState === TransactionState.Completed) {\n            this.D = setTimeout(() => this.timerD(), Timers.TIMER_D);\n        }\n        // The client transaction MUST transition to the \"Accepted\" state,\n        // and Timer M MUST be started with a value of 64*T1.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (newState === TransactionState.Accepted) {\n            this.M = setTimeout(() => this.timerM(), Timers.TIMER_M);\n        }\n        // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Terminated) {\n            this.dispose();\n        }\n        // Update state.\n        this.setState(newState);\n    }\n    /**\n     * When timer A fires, the client transaction MUST retransmit the\n     * request by passing it to the transport layer, and MUST reset the\n     * timer with a value of 2*T1.\n     * When timer A fires 2*T1 seconds later, the request MUST be\n     * retransmitted again (assuming the client transaction is still in this\n     * state). This process MUST continue so that the request is\n     * retransmitted with intervals that double after each transmission.\n     * These retransmissions SHOULD only be done while the client\n     * transaction is in the \"Calling\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n    timerA() {\n        // TODO\n    }\n    /**\n     * If the client transaction is still in the \"Calling\" state when timer\n     * B fires, the client transaction SHOULD inform the TU that a timeout\n     * has occurred.  The client transaction MUST NOT generate an ACK.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n    timerB() {\n        this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Calling) {\n            this.onRequestTimeout();\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * If Timer D fires while the client transaction is in the \"Completed\" state,\n     * the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n    timerD() {\n        this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Completed) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * If Timer M fires while the client transaction is in the \"Accepted\"\n     * state, the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n    timerM() {\n        this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Accepted) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}