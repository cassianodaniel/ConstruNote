{"ast":null,"code":"import { C, Grammar, URI } from \"../core\";\nimport { EmitterImpl } from \"./emitter\";\nimport { RequestPendingError } from \"./exceptions\";\nimport { RegistererState } from \"./registerer-state\";\n/**\n * A registerer registers a contact for an address of record (outgoing REGISTER).\n * @public\n */\n\nexport class Registerer {\n  /**\n   * Constructs a new instance of the `Registerer` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param options - Options bucket. See {@link RegistererOptions} for details.\n   */\n  constructor(userAgent, options = {}) {\n    this.disposed = false;\n    /** The contacts returned from the most recent accepted REGISTER request. */\n\n    this._contacts = [];\n    /** The number of seconds to wait before retrying to register. */\n\n    this._retryAfter = undefined;\n    /** The registration state. */\n\n    this._state = RegistererState.Initial;\n    /** True is waiting for final response to outstanding REGISTER request. */\n\n    this._waiting = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // waiting emitter\n\n    this._waitingEventEmitter = new EmitterImpl(); // Set user agent\n\n    this.userAgent = userAgent; // Default registrar is domain portion of user agent uri\n\n    const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();\n    defaultUserAgentRegistrar.user = undefined; // Initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), {\n      registrar: defaultUserAgentRegistrar\n    }), Registerer.stripUndefinedProperties(options)); // Make sure we are not using references to array options\n\n    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();\n    this.options.extraHeaders = (this.options.extraHeaders || []).slice(); // Make sure we are not using references to registrar uri\n\n    if (!this.options.registrar) {\n      throw new Error(\"Registrar undefined.\");\n    }\n\n    this.options.registrar = this.options.registrar.clone(); // Set instanceId and regId conditional defaults and validate\n\n    if (this.options.regId && !this.options.instanceId) {\n      this.options.instanceId = Registerer.newUUID();\n    } else if (!this.options.regId && this.options.instanceId) {\n      this.options.regId = 1;\n    }\n\n    if (this.options.instanceId && Grammar.parse(this.options.instanceId, \"uuid\") === -1) {\n      throw new Error(\"Invalid instanceId.\");\n    }\n\n    if (this.options.regId && this.options.regId < 0) {\n      throw new Error(\"Invalid regId.\");\n    }\n\n    const registrar = this.options.registrar;\n    const fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;\n    const toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;\n    const params = this.options.params || {};\n    const extraHeaders = (options.extraHeaders || []).slice(); // Build the request\n\n    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined); // Registration expires\n\n    this.expires = this.options.expires || Registerer.defaultExpires;\n\n    if (this.expires < 0) {\n      throw new Error(\"Invalid expires.\");\n    } // initialize logger\n\n\n    this.logger = userAgent.getLogger(\"sip.Registerer\");\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(key => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value = this.options[key];\n\n        switch (key) {\n          case \"registrar\":\n            this.logger.log(\"· \" + key + \": \" + value);\n            break;\n\n          default:\n            this.logger.log(\"· \" + key + \": \" + JSON.stringify(value));\n        }\n      });\n    } // Identifier\n\n\n    this.id = this.request.callId + this.request.from.parameters.tag; // Add to the user agent's session collection.\n\n    this.userAgent._registerers[this.id] = this;\n  }\n  /** Default registerer options. */\n\n\n  static defaultOptions() {\n    return {\n      expires: Registerer.defaultExpires,\n      extraContactHeaderParams: [],\n      extraHeaders: [],\n      logConfiguration: true,\n      instanceId: \"\",\n      params: {},\n      regId: 0,\n      registrar: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\")\n    };\n  } // http://stackoverflow.com/users/109538/broofa\n\n\n  static newUUID() {\n    const UUID = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, c => {\n      const r = Math.floor(Math.random() * 16);\n      const v = c === \"x\" ? r : r % 4 + 8;\n      return v.toString(16);\n    });\n    return UUID;\n  }\n  /**\n   * Strip properties with undefined values from options.\n   * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n   * https://github.com/Microsoft/TypeScript/issues/13195\n   * @param options - Options to reduce\n   */\n\n\n  static stripUndefinedProperties(options) {\n    return Object.keys(options).reduce((object, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (options[key] !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        object[key] = options[key];\n      }\n\n      return object;\n    }, {});\n  }\n  /** The registered contacts. */\n\n\n  get contacts() {\n    return this._contacts.slice();\n  }\n  /**\n   * The number of seconds to wait before retrying to register.\n   * @defaultValue `undefined`\n   * @remarks\n   * When the server rejects a registration request, if it provides a suggested\n   * duration to wait before retrying, that value is available here when and if\n   * the state transitions to `Unsubscribed`. It is also available during the\n   * callback to `onReject` after a call to `register`. (Note that if the state\n   * if already `Unsubscribed`, a rejected request created by `register` will\n   * not cause the state to transition to `Unsubscribed`. One way to avoid this\n   * case is to dispose of `Registerer` when unregistered and create a new\n   * `Registerer` for any attempts to retry registering.)\n   * @example\n   * ```ts\n   * // Checking for retry after on state change\n   * registerer.stateChange.addListener((newState) => {\n   *   switch (newState) {\n   *     case RegistererState.Unregistered:\n   *       const retryAfter = registerer.retryAfter;\n   *       break;\n   *   }\n   * });\n   *\n   * // Checking for retry after on request rejection\n   * registerer.register({\n   *   requestDelegate: {\n   *     onReject: () => {\n   *       const retryAfter = registerer.retryAfter;\n   *     }\n   *   }\n   * });\n   * ```\n   */\n\n\n  get retryAfter() {\n    return this._retryAfter;\n  }\n  /** The registration state. */\n\n\n  get state() {\n    return this._state;\n  }\n  /** Emits when the registerer state changes. */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true;\n    this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`); // Remove from the user agent's registerer collection\n\n    delete this.userAgent._registerers[this.id]; // If registered, unregisters and resolves after final response received.\n\n    return new Promise(resolve => {\n      const doClose = () => {\n        // If we are registered, unregister and resolve after our state changes\n        if (!this.waiting && this._state === RegistererState.Registered) {\n          this.stateChange.addListener(() => {\n            this.terminated();\n            resolve();\n          }, {\n            once: true\n          });\n          this.unregister();\n          return;\n        } // Otherwise just resolve\n\n\n        this.terminated();\n        resolve();\n      }; // If we are waiting for an outstanding request, wait for it to finish and then try closing.\n      // Otherwise just try closing.\n\n\n      if (this.waiting) {\n        this.waitingChange.addListener(() => {\n          doClose();\n        }, {\n          once: true\n        });\n      } else {\n        doClose();\n      }\n    });\n  }\n  /**\n   * Sends the REGISTER request.\n   * @remarks\n   * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.\n   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n   */\n\n\n  register(options = {}) {\n    if (this.state === RegistererState.Terminated) {\n      this.stateError();\n      throw new Error(\"Registerer terminated. Unable to register.\");\n    }\n\n    if (this.disposed) {\n      this.stateError();\n      throw new Error(\"Registerer disposed. Unable to register.\");\n    } // UAs MUST NOT send a new registration (that is, containing new Contact\n    // header field values, as opposed to a retransmission) until they have\n    // received a final response from the registrar for the previous one or\n    // the previous REGISTER request has timed out.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    if (this.waiting) {\n      this.waitingWarning();\n      const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n      return Promise.reject(error);\n    } // Options\n\n\n    if (options.requestOptions) {\n      this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);\n    } // Extra headers\n\n\n    const extraHeaders = (this.options.extraHeaders || []).slice();\n    extraHeaders.push(\"Contact: \" + this.generateContactHeader(this.expires)); // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency\n\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString()); // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n    // header field value for registrations sent to a particular\n    // registrar.\n    //\n    // CSeq: The CSeq value guarantees proper ordering of REGISTER\n    // requests.  A UA MUST increment the CSeq value by one for each\n    // REGISTER request with the same Call-ID.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n    this.request.cseq++;\n    this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n    this.request.extraHeaders = extraHeaders;\n    this.waitingToggle(true);\n    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n      onAccept: response => {\n        let expires; // FIXME: This does NOT appear to be to spec and should be removed.\n        // I haven't found anywhere that an Expires header may be used in a response.\n\n        if (response.message.hasHeader(\"expires\")) {\n          expires = Number(response.message.getHeader(\"expires\"));\n        } // 8. The registrar returns a 200 (OK) response.  The response MUST\n        // contain Contact header field values enumerating all current\n        // bindings.  Each Contact value MUST feature an \"expires\"\n        // parameter indicating its expiration interval chosen by the\n        // registrar.  The response SHOULD include a Date header field.\n        // https://tools.ietf.org/html/rfc3261#section-10.3\n\n\n        this._contacts = response.message.getHeaders(\"contact\");\n        let contacts = this._contacts.length;\n\n        if (!contacts) {\n          this.logger.error(\"No Contact header in response to REGISTER, dropping response.\");\n          this.unregistered();\n          return;\n        } // The 200 (OK) response from the registrar contains a list of Contact\n        // fields enumerating all current bindings.  The UA compares each\n        // contact address to see if it created the contact address, using\n        // comparison rules in Section 19.1.4.  If so, it updates the expiration\n        // time interval according to the expires parameter or, if absent, the\n        // Expires field value.  The UA then issues a REGISTER request for each\n        // of its bindings before the expiration interval has elapsed.\n        // https://tools.ietf.org/html/rfc3261#section-10.2.4\n\n\n        let contact;\n\n        while (contacts--) {\n          contact = response.message.parseHeader(\"contact\", contacts);\n\n          if (!contact) {\n            throw new Error(\"Contact undefined\");\n          }\n\n          if (contact.uri.user === this.userAgent.contact.uri.user) {\n            expires = Number(contact.getParam(\"expires\"));\n            break;\n          }\n\n          contact = undefined;\n        } // There must be a matching contact.\n\n\n        if (contact === undefined) {\n          this.logger.error(\"No Contact header pointing to us, dropping response\");\n          this.unregistered();\n          this.waitingToggle(false);\n          return;\n        } // The contact must have an expires.\n\n\n        if (expires === undefined) {\n          this.logger.error(\"Contact pointing to us is missing expires parameter, dropping response\");\n          this.unregistered();\n          this.waitingToggle(false);\n          return;\n        } // Save gruu values\n\n\n        if (contact.hasParam(\"temp-gruu\")) {\n          const gruu = contact.getParam(\"temp-gruu\");\n\n          if (gruu) {\n            this.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n          }\n        }\n\n        if (contact.hasParam(\"pub-gruu\")) {\n          const gruu = contact.getParam(\"pub-gruu\");\n\n          if (gruu) {\n            this.userAgent.contact.pubGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n          }\n        }\n\n        this.registered(expires);\n\n        if (options.requestDelegate && options.requestDelegate.onAccept) {\n          options.requestDelegate.onAccept(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onProgress: response => {\n        if (options.requestDelegate && options.requestDelegate.onProgress) {\n          options.requestDelegate.onProgress(response);\n        }\n      },\n      onRedirect: response => {\n        this.logger.error(\"Redirect received. Not supported.\");\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onReject: response => {\n        if (response.message.statusCode === 423) {\n          // If a UA receives a 423 (Interval Too Brief) response, it MAY retry\n          // the registration after making the expiration interval of all contact\n          // addresses in the REGISTER request equal to or greater than the\n          // expiration interval within the Min-Expires header field of the 423\n          // (Interval Too Brief) response.\n          // https://tools.ietf.org/html/rfc3261#section-10.2.8\n          //\n          // The registrar MAY choose an expiration less than the requested\n          // expiration interval.  If and only if the requested expiration\n          // interval is greater than zero AND smaller than one hour AND\n          // less than a registrar-configured minimum, the registrar MAY\n          // reject the registration with a response of 423 (Interval Too\n          // Brief).  This response MUST contain a Min-Expires header field\n          // that states the minimum expiration interval the registrar is\n          // willing to honor.  It then skips the remaining steps.\n          // https://tools.ietf.org/html/rfc3261#section-10.3\n          if (!response.message.hasHeader(\"min-expires\")) {\n            // This response MUST contain a Min-Expires header field\n            this.logger.error(\"423 response received for REGISTER without Min-Expires, dropping response\");\n            this.unregistered();\n            this.waitingToggle(false);\n            return;\n          } // Increase our registration interval to the suggested minimum\n\n\n          this.expires = Number(response.message.getHeader(\"min-expires\")); // Attempt the registration again immediately\n\n          this.waitingToggle(false);\n          this.register();\n          return;\n        }\n\n        this.logger.warn(`Failed to register, status code ${response.message.statusCode}`); // The Retry-After header field can be used with a 500 (Server Internal\n        // Error) or 503 (Service Unavailable) response to indicate how long the\n        // service is expected to be unavailable to the requesting client...\n        // https://tools.ietf.org/html/rfc3261#section-20.33\n\n        let retryAfterDuration = NaN;\n\n        if (response.message.statusCode === 500 || response.message.statusCode === 503) {\n          const header = response.message.getHeader(\"retry-after\");\n\n          if (header) {\n            retryAfterDuration = Number.parseInt(header, undefined);\n          }\n        } // Set for the state change (if any) and the delegate callback (if any)\n\n\n        this._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(response);\n        }\n\n        this._retryAfter = undefined;\n        this.waitingToggle(false);\n      },\n      onTrying: response => {\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(response);\n        }\n      }\n    });\n    return Promise.resolve(outgoingRegisterRequest);\n  }\n  /**\n   * Sends the REGISTER request with expires equal to zero.\n   * @remarks\n   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n   */\n\n\n  unregister(options = {}) {\n    if (this.state === RegistererState.Terminated) {\n      this.stateError();\n      throw new Error(\"Registerer terminated. Unable to register.\");\n    }\n\n    if (this.disposed) {\n      if (this.state !== RegistererState.Registered) {\n        // allows unregister while disposing and registered\n        this.stateError();\n        throw new Error(\"Registerer disposed. Unable to register.\");\n      }\n    } // UAs MUST NOT send a new registration (that is, containing new Contact\n    // header field values, as opposed to a retransmission) until they have\n    // received a final response from the registrar for the previous one or\n    // the previous REGISTER request has timed out.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    if (this.waiting) {\n      this.waitingWarning();\n      const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n      return Promise.reject(error);\n    }\n\n    if (this._state !== RegistererState.Registered && !options.all) {\n      this.logger.warn(\"Not currently registered, but sending an unregister anyway.\");\n    } // Extra headers\n\n\n    const extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();\n    this.request.extraHeaders = extraHeaders; // Registrations are soft state and expire unless refreshed, but can\n    // also be explicitly removed.  A client can attempt to influence the\n    // expiration interval selected by the registrar as described in Section\n    // 10.2.1.  A UA requests the immediate removal of a binding by\n    // specifying an expiration interval of \"0\" for that contact address in\n    // a REGISTER request.  UAs SHOULD support this mechanism so that\n    // bindings can be removed before their expiration interval has passed.\n    //\n    // The REGISTER-specific Contact header field value of \"*\" applies to\n    // all registrations, but it MUST NOT be used unless the Expires header\n    // field is present with a value of \"0\".\n    // https://tools.ietf.org/html/rfc3261#section-10.2.2\n\n    if (options.all) {\n      extraHeaders.push(\"Contact: *\");\n      extraHeaders.push(\"Expires: 0\");\n    } else {\n      extraHeaders.push(\"Contact: \" + this.generateContactHeader(0));\n    } // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n    // header field value for registrations sent to a particular\n    // registrar.\n    //\n    // CSeq: The CSeq value guarantees proper ordering of REGISTER\n    // requests.  A UA MUST increment the CSeq value by one for each\n    // REGISTER request with the same Call-ID.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    this.request.cseq++;\n    this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\"); // Pre-emptive clear the registration timer to avoid a race condition where\n    // this timer fires while waiting for a final response to the unsubscribe.\n\n    if (this.registrationTimer !== undefined) {\n      clearTimeout(this.registrationTimer);\n      this.registrationTimer = undefined;\n    }\n\n    this.waitingToggle(true);\n    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n      onAccept: response => {\n        this._contacts = response.message.getHeaders(\"contact\"); // Update contacts\n\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onAccept) {\n          options.requestDelegate.onAccept(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onProgress: response => {\n        if (options.requestDelegate && options.requestDelegate.onProgress) {\n          options.requestDelegate.onProgress(response);\n        }\n      },\n      onRedirect: response => {\n        this.logger.error(\"Unregister redirected. Not currently supported.\");\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onReject: response => {\n        this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onTrying: response => {\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(response);\n        }\n      }\n    });\n    return Promise.resolve(outgoingRegisterRequest);\n  }\n  /**\n   * Clear registration timers.\n   */\n\n\n  clearTimers() {\n    if (this.registrationTimer !== undefined) {\n      clearTimeout(this.registrationTimer);\n      this.registrationTimer = undefined;\n    }\n\n    if (this.registrationExpiredTimer !== undefined) {\n      clearTimeout(this.registrationExpiredTimer);\n      this.registrationExpiredTimer = undefined;\n    }\n  }\n  /**\n   * Generate Contact Header\n   */\n\n\n  generateContactHeader(expires) {\n    let contact = this.userAgent.contact.toString();\n\n    if (this.options.regId && this.options.instanceId) {\n      contact += \";reg-id=\" + this.options.regId;\n      contact += ';+sip.instance=\"<urn:uuid:' + this.options.instanceId + '>\"';\n    }\n\n    if (this.options.extraContactHeaderParams) {\n      this.options.extraContactHeaderParams.forEach(header => {\n        contact += \";\" + header;\n      });\n    }\n\n    contact += \";expires=\" + expires;\n    return contact;\n  }\n  /**\n   * Helper function, called when registered.\n   */\n\n\n  registered(expires) {\n    this.clearTimers(); // Re-Register before the expiration interval has elapsed.\n    // For that, decrease the expires value. ie: 3 seconds\n\n    this.registrationTimer = setTimeout(() => {\n      this.registrationTimer = undefined;\n      this.register();\n    }, expires * 1000 - 3000); // We are unregistered if the registration expires.\n\n    this.registrationExpiredTimer = setTimeout(() => {\n      this.logger.warn(\"Registration expired\");\n      this.unregistered();\n    }, expires * 1000);\n\n    if (this._state !== RegistererState.Registered) {\n      this.stateTransition(RegistererState.Registered);\n    }\n  }\n  /**\n   * Helper function, called when unregistered.\n   */\n\n\n  unregistered() {\n    this.clearTimers();\n\n    if (this._state !== RegistererState.Unregistered) {\n      this.stateTransition(RegistererState.Unregistered);\n    }\n  }\n  /**\n   * Helper function, called when terminated.\n   */\n\n\n  terminated() {\n    this.clearTimers();\n\n    if (this._state !== RegistererState.Terminated) {\n      this.stateTransition(RegistererState.Terminated);\n    }\n  }\n  /**\n   * Transition registration state.\n   */\n\n\n  stateTransition(newState) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate transition\n\n\n    switch (this._state) {\n      case RegistererState.Initial:\n        if (newState !== RegistererState.Registered && newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Registered:\n        if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Unregistered:\n        if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Terminated:\n        invalidTransition();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    } // Transition\n\n\n    this._state = newState;\n    this.logger.log(`Registration transitioned to state ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); // Dispose\n\n\n    if (newState === RegistererState.Terminated) {\n      this.dispose();\n    }\n  }\n  /** True if the registerer is currently waiting for final response to a REGISTER request. */\n\n\n  get waiting() {\n    return this._waiting;\n  }\n  /** Emits when the registerer waiting state changes. */\n\n\n  get waitingChange() {\n    return this._waitingEventEmitter;\n  }\n  /**\n   * Toggle waiting.\n   */\n\n\n  waitingToggle(waiting) {\n    if (this._waiting === waiting) {\n      throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting}`);\n    }\n\n    this._waiting = waiting;\n    this.logger.log(`Waiting toggled to ${this._waiting}`);\n\n    this._waitingEventEmitter.emit(this._waiting);\n  }\n  /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n\n  waitingWarning() {\n    let message = \"An attempt was made to send a REGISTER request while a prior one was still in progress.\";\n    message += \" RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response\";\n    message += \" from the registrar for the previous one or the previous REGISTER request has timed out.\";\n    message += \" Note that if the transport disconnects, you still must wait for the prior request to time out before\";\n    message += \" sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.\";\n    this.logger.warn(message);\n  }\n  /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n\n  stateError() {\n    const reason = this.state === RegistererState.Terminated ? \"is in 'Terminated' state\" : \"has been disposed\";\n    let message = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;\n    message += \" The Registerer transitions to 'Terminated' when Registerer.dispose() is called.\";\n    message += \" Perhaps you called UserAgent.stop() which dipsoses of all Registerers?\";\n    this.logger.error(message);\n  }\n\n}\nRegisterer.defaultExpires = 600;","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/registerer.js"],"names":["C","Grammar","URI","EmitterImpl","RequestPendingError","RegistererState","Registerer","constructor","userAgent","options","disposed","_contacts","_retryAfter","undefined","_state","Initial","_waiting","_stateEventEmitter","_waitingEventEmitter","defaultUserAgentRegistrar","configuration","uri","clone","user","Object","assign","defaultOptions","registrar","stripUndefinedProperties","extraContactHeaderParams","slice","extraHeaders","Error","regId","instanceId","newUUID","parse","fromURI","params","fromUri","userAgentCore","aor","toURI","toUri","request","makeOutgoingRequestMessage","REGISTER","expires","defaultExpires","logger","getLogger","logConfiguration","log","keys","forEach","key","value","JSON","stringify","id","callId","from","parameters","tag","_registerers","UUID","replace","c","r","Math","floor","random","v","toString","reduce","object","contacts","retryAfter","state","stateChange","dispose","Promise","resolve","doClose","waiting","Registered","addListener","terminated","once","unregister","waitingChange","register","Terminated","stateError","waitingWarning","error","reject","requestOptions","push","generateContactHeader","cseq","setHeader","waitingToggle","outgoingRegisterRequest","onAccept","response","message","hasHeader","Number","getHeader","getHeaders","length","unregistered","contact","parseHeader","getParam","hasParam","gruu","tempGruu","URIParse","pubGruu","registered","requestDelegate","onProgress","onRedirect","onReject","statusCode","warn","retryAfterDuration","NaN","header","parseInt","isNaN","onTrying","all","registrationTimer","clearTimeout","clearTimers","registrationExpiredTimer","setTimeout","stateTransition","Unregistered","newState","invalidTransition","emit","reason"],"mappings":"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","sourcesContent":["import { C, Grammar, URI } from \"../core\";\nimport { EmitterImpl } from \"./emitter\";\nimport { RequestPendingError } from \"./exceptions\";\nimport { RegistererState } from \"./registerer-state\";\n/**\n * A registerer registers a contact for an address of record (outgoing REGISTER).\n * @public\n */\nexport class Registerer {\n    /**\n     * Constructs a new instance of the `Registerer` class.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param options - Options bucket. See {@link RegistererOptions} for details.\n     */\n    constructor(userAgent, options = {}) {\n        this.disposed = false;\n        /** The contacts returned from the most recent accepted REGISTER request. */\n        this._contacts = [];\n        /** The number of seconds to wait before retrying to register. */\n        this._retryAfter = undefined;\n        /** The registration state. */\n        this._state = RegistererState.Initial;\n        /** True is waiting for final response to outstanding REGISTER request. */\n        this._waiting = false;\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // waiting emitter\n        this._waitingEventEmitter = new EmitterImpl();\n        // Set user agent\n        this.userAgent = userAgent;\n        // Default registrar is domain portion of user agent uri\n        const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();\n        defaultUserAgentRegistrar.user = undefined;\n        // Initialize configuration\n        this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), { registrar: defaultUserAgentRegistrar }), Registerer.stripUndefinedProperties(options));\n        // Make sure we are not using references to array options\n        this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();\n        this.options.extraHeaders = (this.options.extraHeaders || []).slice();\n        // Make sure we are not using references to registrar uri\n        if (!this.options.registrar) {\n            throw new Error(\"Registrar undefined.\");\n        }\n        this.options.registrar = this.options.registrar.clone();\n        // Set instanceId and regId conditional defaults and validate\n        if (this.options.regId && !this.options.instanceId) {\n            this.options.instanceId = Registerer.newUUID();\n        }\n        else if (!this.options.regId && this.options.instanceId) {\n            this.options.regId = 1;\n        }\n        if (this.options.instanceId && Grammar.parse(this.options.instanceId, \"uuid\") === -1) {\n            throw new Error(\"Invalid instanceId.\");\n        }\n        if (this.options.regId && this.options.regId < 0) {\n            throw new Error(\"Invalid regId.\");\n        }\n        const registrar = this.options.registrar;\n        const fromURI = (this.options.params && this.options.params.fromUri) || userAgent.userAgentCore.configuration.aor;\n        const toURI = (this.options.params && this.options.params.toUri) || userAgent.configuration.uri;\n        const params = this.options.params || {};\n        const extraHeaders = (options.extraHeaders || []).slice();\n        // Build the request\n        this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined);\n        // Registration expires\n        this.expires = this.options.expires || Registerer.defaultExpires;\n        if (this.expires < 0) {\n            throw new Error(\"Invalid expires.\");\n        }\n        // initialize logger\n        this.logger = userAgent.getLogger(\"sip.Registerer\");\n        if (this.options.logConfiguration) {\n            this.logger.log(\"Configuration:\");\n            Object.keys(this.options).forEach((key) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const value = this.options[key];\n                switch (key) {\n                    case \"registrar\":\n                        this.logger.log(\"· \" + key + \": \" + value);\n                        break;\n                    default:\n                        this.logger.log(\"· \" + key + \": \" + JSON.stringify(value));\n                }\n            });\n        }\n        // Identifier\n        this.id = this.request.callId + this.request.from.parameters.tag;\n        // Add to the user agent's session collection.\n        this.userAgent._registerers[this.id] = this;\n    }\n    /** Default registerer options. */\n    static defaultOptions() {\n        return {\n            expires: Registerer.defaultExpires,\n            extraContactHeaderParams: [],\n            extraHeaders: [],\n            logConfiguration: true,\n            instanceId: \"\",\n            params: {},\n            regId: 0,\n            registrar: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\")\n        };\n    }\n    // http://stackoverflow.com/users/109538/broofa\n    static newUUID() {\n        const UUID = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n            const r = Math.floor(Math.random() * 16);\n            const v = c === \"x\" ? r : (r % 4) + 8;\n            return v.toString(16);\n        });\n        return UUID;\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n    static stripUndefinedProperties(options) {\n        return Object.keys(options).reduce((object, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (options[key] !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                object[key] = options[key];\n            }\n            return object;\n        }, {});\n    }\n    /** The registered contacts. */\n    get contacts() {\n        return this._contacts.slice();\n    }\n    /**\n     * The number of seconds to wait before retrying to register.\n     * @defaultValue `undefined`\n     * @remarks\n     * When the server rejects a registration request, if it provides a suggested\n     * duration to wait before retrying, that value is available here when and if\n     * the state transitions to `Unsubscribed`. It is also available during the\n     * callback to `onReject` after a call to `register`. (Note that if the state\n     * if already `Unsubscribed`, a rejected request created by `register` will\n     * not cause the state to transition to `Unsubscribed`. One way to avoid this\n     * case is to dispose of `Registerer` when unregistered and create a new\n     * `Registerer` for any attempts to retry registering.)\n     * @example\n     * ```ts\n     * // Checking for retry after on state change\n     * registerer.stateChange.addListener((newState) => {\n     *   switch (newState) {\n     *     case RegistererState.Unregistered:\n     *       const retryAfter = registerer.retryAfter;\n     *       break;\n     *   }\n     * });\n     *\n     * // Checking for retry after on request rejection\n     * registerer.register({\n     *   requestDelegate: {\n     *     onReject: () => {\n     *       const retryAfter = registerer.retryAfter;\n     *     }\n     *   }\n     * });\n     * ```\n     */\n    get retryAfter() {\n        return this._retryAfter;\n    }\n    /** The registration state. */\n    get state() {\n        return this._state;\n    }\n    /** Emits when the registerer state changes. */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /** Destructor. */\n    dispose() {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`);\n        // Remove from the user agent's registerer collection\n        delete this.userAgent._registerers[this.id];\n        // If registered, unregisters and resolves after final response received.\n        return new Promise((resolve) => {\n            const doClose = () => {\n                // If we are registered, unregister and resolve after our state changes\n                if (!this.waiting && this._state === RegistererState.Registered) {\n                    this.stateChange.addListener(() => {\n                        this.terminated();\n                        resolve();\n                    }, { once: true });\n                    this.unregister();\n                    return;\n                }\n                // Otherwise just resolve\n                this.terminated();\n                resolve();\n            };\n            // If we are waiting for an outstanding request, wait for it to finish and then try closing.\n            // Otherwise just try closing.\n            if (this.waiting) {\n                this.waitingChange.addListener(() => {\n                    doClose();\n                }, { once: true });\n            }\n            else {\n                doClose();\n            }\n        });\n    }\n    /**\n     * Sends the REGISTER request.\n     * @remarks\n     * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n    register(options = {}) {\n        if (this.state === RegistererState.Terminated) {\n            this.stateError();\n            throw new Error(\"Registerer terminated. Unable to register.\");\n        }\n        if (this.disposed) {\n            this.stateError();\n            throw new Error(\"Registerer disposed. Unable to register.\");\n        }\n        // UAs MUST NOT send a new registration (that is, containing new Contact\n        // header field values, as opposed to a retransmission) until they have\n        // received a final response from the registrar for the previous one or\n        // the previous REGISTER request has timed out.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        if (this.waiting) {\n            this.waitingWarning();\n            const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n            return Promise.reject(error);\n        }\n        // Options\n        if (options.requestOptions) {\n            this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);\n        }\n        // Extra headers\n        const extraHeaders = (this.options.extraHeaders || []).slice();\n        extraHeaders.push(\"Contact: \" + this.generateContactHeader(this.expires));\n        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n        // header field value for registrations sent to a particular\n        // registrar.\n        //\n        // CSeq: The CSeq value guarantees proper ordering of REGISTER\n        // requests.  A UA MUST increment the CSeq value by one for each\n        // REGISTER request with the same Call-ID.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        this.request.cseq++;\n        this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n        this.request.extraHeaders = extraHeaders;\n        this.waitingToggle(true);\n        const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n            onAccept: (response) => {\n                let expires;\n                // FIXME: This does NOT appear to be to spec and should be removed.\n                // I haven't found anywhere that an Expires header may be used in a response.\n                if (response.message.hasHeader(\"expires\")) {\n                    expires = Number(response.message.getHeader(\"expires\"));\n                }\n                // 8. The registrar returns a 200 (OK) response.  The response MUST\n                // contain Contact header field values enumerating all current\n                // bindings.  Each Contact value MUST feature an \"expires\"\n                // parameter indicating its expiration interval chosen by the\n                // registrar.  The response SHOULD include a Date header field.\n                // https://tools.ietf.org/html/rfc3261#section-10.3\n                this._contacts = response.message.getHeaders(\"contact\");\n                let contacts = this._contacts.length;\n                if (!contacts) {\n                    this.logger.error(\"No Contact header in response to REGISTER, dropping response.\");\n                    this.unregistered();\n                    return;\n                }\n                // The 200 (OK) response from the registrar contains a list of Contact\n                // fields enumerating all current bindings.  The UA compares each\n                // contact address to see if it created the contact address, using\n                // comparison rules in Section 19.1.4.  If so, it updates the expiration\n                // time interval according to the expires parameter or, if absent, the\n                // Expires field value.  The UA then issues a REGISTER request for each\n                // of its bindings before the expiration interval has elapsed.\n                // https://tools.ietf.org/html/rfc3261#section-10.2.4\n                let contact;\n                while (contacts--) {\n                    contact = response.message.parseHeader(\"contact\", contacts);\n                    if (!contact) {\n                        throw new Error(\"Contact undefined\");\n                    }\n                    if (contact.uri.user === this.userAgent.contact.uri.user) {\n                        expires = Number(contact.getParam(\"expires\"));\n                        break;\n                    }\n                    contact = undefined;\n                }\n                // There must be a matching contact.\n                if (contact === undefined) {\n                    this.logger.error(\"No Contact header pointing to us, dropping response\");\n                    this.unregistered();\n                    this.waitingToggle(false);\n                    return;\n                }\n                // The contact must have an expires.\n                if (expires === undefined) {\n                    this.logger.error(\"Contact pointing to us is missing expires parameter, dropping response\");\n                    this.unregistered();\n                    this.waitingToggle(false);\n                    return;\n                }\n                // Save gruu values\n                if (contact.hasParam(\"temp-gruu\")) {\n                    const gruu = contact.getParam(\"temp-gruu\");\n                    if (gruu) {\n                        this.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n                    }\n                }\n                if (contact.hasParam(\"pub-gruu\")) {\n                    const gruu = contact.getParam(\"pub-gruu\");\n                    if (gruu) {\n                        this.userAgent.contact.pubGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n                    }\n                }\n                this.registered(expires);\n                if (options.requestDelegate && options.requestDelegate.onAccept) {\n                    options.requestDelegate.onAccept(response);\n                }\n                this.waitingToggle(false);\n            },\n            onProgress: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onProgress) {\n                    options.requestDelegate.onProgress(response);\n                }\n            },\n            onRedirect: (response) => {\n                this.logger.error(\"Redirect received. Not supported.\");\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(response);\n                }\n                this.waitingToggle(false);\n            },\n            onReject: (response) => {\n                if (response.message.statusCode === 423) {\n                    // If a UA receives a 423 (Interval Too Brief) response, it MAY retry\n                    // the registration after making the expiration interval of all contact\n                    // addresses in the REGISTER request equal to or greater than the\n                    // expiration interval within the Min-Expires header field of the 423\n                    // (Interval Too Brief) response.\n                    // https://tools.ietf.org/html/rfc3261#section-10.2.8\n                    //\n                    // The registrar MAY choose an expiration less than the requested\n                    // expiration interval.  If and only if the requested expiration\n                    // interval is greater than zero AND smaller than one hour AND\n                    // less than a registrar-configured minimum, the registrar MAY\n                    // reject the registration with a response of 423 (Interval Too\n                    // Brief).  This response MUST contain a Min-Expires header field\n                    // that states the minimum expiration interval the registrar is\n                    // willing to honor.  It then skips the remaining steps.\n                    // https://tools.ietf.org/html/rfc3261#section-10.3\n                    if (!response.message.hasHeader(\"min-expires\")) {\n                        // This response MUST contain a Min-Expires header field\n                        this.logger.error(\"423 response received for REGISTER without Min-Expires, dropping response\");\n                        this.unregistered();\n                        this.waitingToggle(false);\n                        return;\n                    }\n                    // Increase our registration interval to the suggested minimum\n                    this.expires = Number(response.message.getHeader(\"min-expires\"));\n                    // Attempt the registration again immediately\n                    this.waitingToggle(false);\n                    this.register();\n                    return;\n                }\n                this.logger.warn(`Failed to register, status code ${response.message.statusCode}`);\n                // The Retry-After header field can be used with a 500 (Server Internal\n                // Error) or 503 (Service Unavailable) response to indicate how long the\n                // service is expected to be unavailable to the requesting client...\n                // https://tools.ietf.org/html/rfc3261#section-20.33\n                let retryAfterDuration = NaN;\n                if (response.message.statusCode === 500 || response.message.statusCode === 503) {\n                    const header = response.message.getHeader(\"retry-after\");\n                    if (header) {\n                        retryAfterDuration = Number.parseInt(header, undefined);\n                    }\n                }\n                // Set for the state change (if any) and the delegate callback (if any)\n                this._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(response);\n                }\n                this._retryAfter = undefined;\n                this.waitingToggle(false);\n            },\n            onTrying: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(response);\n                }\n            }\n        });\n        return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Sends the REGISTER request with expires equal to zero.\n     * @remarks\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n    unregister(options = {}) {\n        if (this.state === RegistererState.Terminated) {\n            this.stateError();\n            throw new Error(\"Registerer terminated. Unable to register.\");\n        }\n        if (this.disposed) {\n            if (this.state !== RegistererState.Registered) {\n                // allows unregister while disposing and registered\n                this.stateError();\n                throw new Error(\"Registerer disposed. Unable to register.\");\n            }\n        }\n        // UAs MUST NOT send a new registration (that is, containing new Contact\n        // header field values, as opposed to a retransmission) until they have\n        // received a final response from the registrar for the previous one or\n        // the previous REGISTER request has timed out.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        if (this.waiting) {\n            this.waitingWarning();\n            const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n            return Promise.reject(error);\n        }\n        if (this._state !== RegistererState.Registered && !options.all) {\n            this.logger.warn(\"Not currently registered, but sending an unregister anyway.\");\n        }\n        // Extra headers\n        const extraHeaders = ((options.requestOptions && options.requestOptions.extraHeaders) || []).slice();\n        this.request.extraHeaders = extraHeaders;\n        // Registrations are soft state and expire unless refreshed, but can\n        // also be explicitly removed.  A client can attempt to influence the\n        // expiration interval selected by the registrar as described in Section\n        // 10.2.1.  A UA requests the immediate removal of a binding by\n        // specifying an expiration interval of \"0\" for that contact address in\n        // a REGISTER request.  UAs SHOULD support this mechanism so that\n        // bindings can be removed before their expiration interval has passed.\n        //\n        // The REGISTER-specific Contact header field value of \"*\" applies to\n        // all registrations, but it MUST NOT be used unless the Expires header\n        // field is present with a value of \"0\".\n        // https://tools.ietf.org/html/rfc3261#section-10.2.2\n        if (options.all) {\n            extraHeaders.push(\"Contact: *\");\n            extraHeaders.push(\"Expires: 0\");\n        }\n        else {\n            extraHeaders.push(\"Contact: \" + this.generateContactHeader(0));\n        }\n        // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n        // header field value for registrations sent to a particular\n        // registrar.\n        //\n        // CSeq: The CSeq value guarantees proper ordering of REGISTER\n        // requests.  A UA MUST increment the CSeq value by one for each\n        // REGISTER request with the same Call-ID.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        this.request.cseq++;\n        this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n        // Pre-emptive clear the registration timer to avoid a race condition where\n        // this timer fires while waiting for a final response to the unsubscribe.\n        if (this.registrationTimer !== undefined) {\n            clearTimeout(this.registrationTimer);\n            this.registrationTimer = undefined;\n        }\n        this.waitingToggle(true);\n        const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n            onAccept: (response) => {\n                this._contacts = response.message.getHeaders(\"contact\"); // Update contacts\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onAccept) {\n                    options.requestDelegate.onAccept(response);\n                }\n                this.waitingToggle(false);\n            },\n            onProgress: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onProgress) {\n                    options.requestDelegate.onProgress(response);\n                }\n            },\n            onRedirect: (response) => {\n                this.logger.error(\"Unregister redirected. Not currently supported.\");\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(response);\n                }\n                this.waitingToggle(false);\n            },\n            onReject: (response) => {\n                this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(response);\n                }\n                this.waitingToggle(false);\n            },\n            onTrying: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(response);\n                }\n            }\n        });\n        return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Clear registration timers.\n     */\n    clearTimers() {\n        if (this.registrationTimer !== undefined) {\n            clearTimeout(this.registrationTimer);\n            this.registrationTimer = undefined;\n        }\n        if (this.registrationExpiredTimer !== undefined) {\n            clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = undefined;\n        }\n    }\n    /**\n     * Generate Contact Header\n     */\n    generateContactHeader(expires) {\n        let contact = this.userAgent.contact.toString();\n        if (this.options.regId && this.options.instanceId) {\n            contact += \";reg-id=\" + this.options.regId;\n            contact += ';+sip.instance=\"<urn:uuid:' + this.options.instanceId + '>\"';\n        }\n        if (this.options.extraContactHeaderParams) {\n            this.options.extraContactHeaderParams.forEach((header) => {\n                contact += \";\" + header;\n            });\n        }\n        contact += \";expires=\" + expires;\n        return contact;\n    }\n    /**\n     * Helper function, called when registered.\n     */\n    registered(expires) {\n        this.clearTimers();\n        // Re-Register before the expiration interval has elapsed.\n        // For that, decrease the expires value. ie: 3 seconds\n        this.registrationTimer = setTimeout(() => {\n            this.registrationTimer = undefined;\n            this.register();\n        }, expires * 1000 - 3000);\n        // We are unregistered if the registration expires.\n        this.registrationExpiredTimer = setTimeout(() => {\n            this.logger.warn(\"Registration expired\");\n            this.unregistered();\n        }, expires * 1000);\n        if (this._state !== RegistererState.Registered) {\n            this.stateTransition(RegistererState.Registered);\n        }\n    }\n    /**\n     * Helper function, called when unregistered.\n     */\n    unregistered() {\n        this.clearTimers();\n        if (this._state !== RegistererState.Unregistered) {\n            this.stateTransition(RegistererState.Unregistered);\n        }\n    }\n    /**\n     * Helper function, called when terminated.\n     */\n    terminated() {\n        this.clearTimers();\n        if (this._state !== RegistererState.Terminated) {\n            this.stateTransition(RegistererState.Terminated);\n        }\n    }\n    /**\n     * Transition registration state.\n     */\n    stateTransition(newState) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate transition\n        switch (this._state) {\n            case RegistererState.Initial:\n                if (newState !== RegistererState.Registered &&\n                    newState !== RegistererState.Unregistered &&\n                    newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Registered:\n                if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Unregistered:\n                if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Terminated:\n                invalidTransition();\n                break;\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n        // Transition\n        this._state = newState;\n        this.logger.log(`Registration transitioned to state ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        // Dispose\n        if (newState === RegistererState.Terminated) {\n            this.dispose();\n        }\n    }\n    /** True if the registerer is currently waiting for final response to a REGISTER request. */\n    get waiting() {\n        return this._waiting;\n    }\n    /** Emits when the registerer waiting state changes. */\n    get waitingChange() {\n        return this._waitingEventEmitter;\n    }\n    /**\n     * Toggle waiting.\n     */\n    waitingToggle(waiting) {\n        if (this._waiting === waiting) {\n            throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting}`);\n        }\n        this._waiting = waiting;\n        this.logger.log(`Waiting toggled to ${this._waiting}`);\n        this._waitingEventEmitter.emit(this._waiting);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n    waitingWarning() {\n        let message = \"An attempt was made to send a REGISTER request while a prior one was still in progress.\";\n        message += \" RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response\";\n        message += \" from the registrar for the previous one or the previous REGISTER request has timed out.\";\n        message += \" Note that if the transport disconnects, you still must wait for the prior request to time out before\";\n        message +=\n            \" sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.\";\n        this.logger.warn(message);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n    stateError() {\n        const reason = this.state === RegistererState.Terminated ? \"is in 'Terminated' state\" : \"has been disposed\";\n        let message = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;\n        message += \" The Registerer transitions to 'Terminated' when Registerer.dispose() is called.\";\n        message += \" Perhaps you called UserAgent.stop() which dipsoses of all Registerers?\";\n        this.logger.error(message);\n    }\n}\nRegisterer.defaultExpires = 600;\n"]},"metadata":{},"sourceType":"module"}