{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { logger } from '@sentry/utils';\n/**\n * Express integration\n *\n * Provides an request and error handler for Express framework as well as tracing capabilities\n */\n\nvar Express =\n/** @class */\nfunction () {\n  /**\n   * @inheritDoc\n   */\n  function Express(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\n     * @inheritDoc\n     */\n\n\n    this.name = Express.id;\n    this._router = options.router || options.app;\n    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  Express.prototype.setupOnce = function () {\n    if (!this._router) {\n      logger.error('ExpressIntegration is missing an Express instance');\n      return;\n    }\n\n    instrumentMiddlewares(this._router, this._methods);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Express.id = 'Express';\n  return Express;\n}();\n\nexport { Express };\n/**\n * Wraps original middleware function in a tracing call, which stores the info about the call as a span,\n * and finishes it once the middleware is done invoking.\n *\n * Express middlewares have 3 various forms, thus we have to take care of all of them:\n * // sync\n * app.use(function (req, res) { ... })\n * // async\n * app.use(function (req, res, next) { ... })\n * // error handler\n * app.use(function (err, req, res, next) { ... })\n *\n * They all internally delegate to the `router[method]` of the given application instance.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\n\nfunction wrap(fn, method) {\n  var arity = fn.length;\n\n  switch (arity) {\n    case 2:\n      {\n        return function (req, res) {\n          var transaction = res.__sentry_transaction;\n\n          if (transaction) {\n            var span_1 = transaction.startChild({\n              description: fn.name,\n              op: \"middleware.\" + method\n            });\n            res.once('finish', function () {\n              span_1.finish();\n            });\n          }\n\n          return fn.call(this, req, res);\n        };\n      }\n\n    case 3:\n      {\n        return function (req, res, next) {\n          var _a;\n\n          var transaction = res.__sentry_transaction;\n          var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({\n            description: fn.name,\n            op: \"middleware.\" + method\n          });\n          fn.call(this, req, res, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            var _a;\n\n            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();\n            next.call.apply(next, __spread([this], args));\n          });\n        };\n      }\n\n    case 4:\n      {\n        return function (err, req, res, next) {\n          var _a;\n\n          var transaction = res.__sentry_transaction;\n          var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({\n            description: fn.name,\n            op: \"middleware.\" + method\n          });\n          fn.call(this, err, req, res, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            var _a;\n\n            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();\n            next.call.apply(next, __spread([this], args));\n          });\n        };\n      }\n\n    default:\n      {\n        throw new Error(\"Express middleware takes 2-4 arguments. Got: \" + arity);\n      }\n  }\n}\n/**\n * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`\n * and wraps every function, as well as array of functions with a call to our `wrap` method.\n * We have to take care of the arrays as well as iterate over all of the arguments,\n * as `app.use` can accept middlewares in few various forms.\n *\n * app.use([<path>], <fn>)\n * app.use([<path>], <fn>, ...<fn>)\n * app.use([<path>], ...<fn>[])\n */\n\n\nfunction wrapMiddlewareArgs(args, method) {\n  return args.map(function (arg) {\n    if (typeof arg === 'function') {\n      return wrap(arg, method);\n    }\n\n    if (Array.isArray(arg)) {\n      return arg.map(function (a) {\n        if (typeof a === 'function') {\n          return wrap(a, method);\n        }\n\n        return a;\n      });\n    }\n\n    return arg;\n  });\n}\n/**\n * Patches original router to utilize our tracing functionality\n */\n\n\nfunction patchMiddleware(router, method) {\n  var originalCallback = router[method];\n\n  router[method] = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return originalCallback.call.apply(originalCallback, __spread([this], wrapMiddlewareArgs(args, method)));\n  };\n\n  return router;\n}\n/**\n * Patches original router methods\n */\n\n\nfunction instrumentMiddlewares(router, methods) {\n  if (methods === void 0) {\n    methods = [];\n  }\n\n  methods.forEach(function (method) {\n    return patchMiddleware(router, method);\n  });\n}","map":{"version":3,"sources":["../../src/integrations/express.ts"],"names":[],"mappings":"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","sourcesContent":["import { Integration, Transaction } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\ntype Method =\n  | 'all'\n  | 'get'\n  | 'post'\n  | 'put'\n  | 'delete'\n  | 'patch'\n  | 'options'\n  | 'head'\n  | 'checkout'\n  | 'copy'\n  | 'lock'\n  | 'merge'\n  | 'mkactivity'\n  | 'mkcol'\n  | 'move'\n  | 'm-search'\n  | 'notify'\n  | 'purge'\n  | 'report'\n  | 'search'\n  | 'subscribe'\n  | 'trace'\n  | 'unlock'\n  | 'unsubscribe'\n  | 'use';\n\ntype Router = {\n  [method in Method]: (...args: any) => any; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\ninterface ExpressResponse {\n  once(name: string, callback: () => void): void;\n}\n\n/**\n * Internal helper for `__sentry_transaction`\n * @hidden\n */\ninterface SentryTracingResponse {\n  __sentry_transaction?: Transaction;\n}\n\n/**\n * Express integration\n *\n * Provides an request and error handler for Express framework as well as tracing capabilities\n */\nexport class Express implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Express';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Express.id;\n\n  /**\n   * Express App instance\n   */\n  private readonly _router?: Router;\n  private readonly _methods?: Method[];\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: { app?: Router; router?: Router; methods?: Method[] } = {}) {\n    this._router = options.router || options.app;\n    this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(): void {\n    if (!this._router) {\n      logger.error('ExpressIntegration is missing an Express instance');\n      return;\n    }\n    instrumentMiddlewares(this._router, this._methods);\n  }\n}\n\n/**\n * Wraps original middleware function in a tracing call, which stores the info about the call as a span,\n * and finishes it once the middleware is done invoking.\n *\n * Express middlewares have 3 various forms, thus we have to take care of all of them:\n * // sync\n * app.use(function (req, res) { ... })\n * // async\n * app.use(function (req, res, next) { ... })\n * // error handler\n * app.use(function (err, req, res, next) { ... })\n *\n * They all internally delegate to the `router[method]` of the given application instance.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nfunction wrap(fn: Function, method: Method): (...args: any[]) => void {\n  const arity = fn.length;\n\n  switch (arity) {\n    case 2: {\n      return function(this: NodeJS.Global, req: unknown, res: ExpressResponse & SentryTracingResponse): void {\n        const transaction = res.__sentry_transaction;\n        if (transaction) {\n          const span = transaction.startChild({\n            description: fn.name,\n            op: `middleware.${method}`,\n          });\n          res.once('finish', () => {\n            span.finish();\n          });\n        }\n        return fn.call(this, req, res);\n      };\n    }\n    case 3: {\n      return function(\n        this: NodeJS.Global,\n        req: unknown,\n        res: ExpressResponse & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.${method}`,\n        });\n        fn.call(this, req, res, function(this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    case 4: {\n      return function(\n        this: NodeJS.Global,\n        err: Error,\n        req: Request,\n        res: Response & SentryTracingResponse,\n        next: () => void,\n      ): void {\n        const transaction = res.__sentry_transaction;\n        const span = transaction?.startChild({\n          description: fn.name,\n          op: `middleware.${method}`,\n        });\n        fn.call(this, err, req, res, function(this: NodeJS.Global, ...args: unknown[]): void {\n          span?.finish();\n          next.call(this, ...args);\n        });\n      };\n    }\n    default: {\n      throw new Error(`Express middleware takes 2-4 arguments. Got: ${arity}`);\n    }\n  }\n}\n\n/**\n * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`\n * and wraps every function, as well as array of functions with a call to our `wrap` method.\n * We have to take care of the arrays as well as iterate over all of the arguments,\n * as `app.use` can accept middlewares in few various forms.\n *\n * app.use([<path>], <fn>)\n * app.use([<path>], <fn>, ...<fn>)\n * app.use([<path>], ...<fn>[])\n */\nfunction wrapMiddlewareArgs(args: unknown[], method: Method): unknown[] {\n  return args.map((arg: unknown) => {\n    if (typeof arg === 'function') {\n      return wrap(arg, method);\n    }\n\n    if (Array.isArray(arg)) {\n      return arg.map((a: unknown) => {\n        if (typeof a === 'function') {\n          return wrap(a, method);\n        }\n        return a;\n      });\n    }\n\n    return arg;\n  });\n}\n\n/**\n * Patches original router to utilize our tracing functionality\n */\nfunction patchMiddleware(router: Router, method: Method): Router {\n  const originalCallback = router[method];\n\n  router[method] = function(...args: unknown[]): void {\n    return originalCallback.call(this, ...wrapMiddlewareArgs(args, method));\n  };\n\n  return router;\n}\n\n/**\n * Patches original router methods\n */\nfunction instrumentMiddlewares(router: Router, methods: Method[] = []): void {\n  methods.forEach((method: Method) => patchMiddleware(router, method));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}