{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { fromBodyLegacy, getBody, Grammar, SignalingState, Timers, TransactionStateError } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { ContentTypeUnsupportedError, SessionDescriptionHandlerError, SessionTerminatedError } from \"./exceptions\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An invitation is an offer to establish a {@link Session} (incoming INVITE).\n * @public\n */\n\nexport var Invitation = /*#__PURE__*/function (_Session) {\n  _inherits(Invitation, _Session);\n\n  var _super = _createSuper(Invitation);\n\n  /** @internal */\n  function Invitation(userAgent, incomingInviteRequest) {\n    var _this;\n\n    _classCallCheck(this, Invitation);\n\n    _this = _super.call(this, userAgent);\n    _this.incomingInviteRequest = incomingInviteRequest;\n    /** True if dispose() has been called. */\n\n    _this.disposed = false;\n    /** INVITE will be rejected if not accepted within a certain period time. */\n\n    _this.expiresTimer = undefined;\n    /** True if this Session has been Terminated due to a CANCEL request. */\n\n    _this.isCanceled = false;\n    /** Are reliable provisional responses required or supported. */\n\n    _this.rel100 = \"none\";\n    /** The current RSeq header value. */\n\n    _this.rseq = Math.floor(Math.random() * 10000);\n    /** INVITE will be rejected if final response not sent in a certain period time. */\n\n    _this.userNoAnswerTimer = undefined;\n    /** True if waiting for a PRACK before sending a 200 Ok. */\n\n    _this.waitingForPrack = false;\n    _this.logger = userAgent.getLogger(\"sip.Invitation\");\n    var incomingRequestMessage = _this.incomingInviteRequest.message; // Set 100rel if necessary\n\n    var requireHeader = incomingRequestMessage.getHeader(\"require\");\n\n    if (requireHeader && requireHeader.toLowerCase().includes(\"100rel\")) {\n      _this.rel100 = \"required\";\n    }\n\n    var supportedHeader = incomingRequestMessage.getHeader(\"supported\");\n\n    if (supportedHeader && supportedHeader.toLowerCase().includes(\"100rel\")) {\n      _this.rel100 = \"supported\";\n    } // FIXME: HACK: This is a hack to port an existing behavior.\n    // Set the toTag on the incoming request message to the toTag which\n    // will be used in the response to the incoming request!!!\n    // The behavior being ported appears to be a hack itself,\n    // so this is a hack to port a hack. At least one test spec\n    // relies on it (which is yet another hack).\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    incomingRequestMessage.toTag = incomingInviteRequest.toTag;\n\n    if (typeof incomingRequestMessage.toTag !== \"string\") {\n      throw new TypeError(\"toTag should have been a string.\");\n    } // The following mapping values are RECOMMENDED:\n    // ...\n    // 19 no answer from the user              480 Temporarily unavailable\n    // https://tools.ietf.org/html/rfc3398#section-7.2.4.1\n\n\n    _this.userNoAnswerTimer = setTimeout(function () {\n      incomingInviteRequest.reject({\n        statusCode: 480\n      });\n\n      _this.stateTransition(SessionState.Terminated);\n    }, _this.userAgent.configuration.noAnswerTimeout ? _this.userAgent.configuration.noAnswerTimeout * 1000 : 60000); // 1. If the request is an INVITE that contains an Expires header\n    // field, the UAS core sets a timer for the number of seconds\n    // indicated in the header field value.  When the timer fires, the\n    // invitation is considered to be expired.  If the invitation\n    // expires before the UAS has generated a final response, a 487\n    // (Request Terminated) response SHOULD be generated.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1\n\n    if (incomingRequestMessage.hasHeader(\"expires\")) {\n      var expires = Number(incomingRequestMessage.getHeader(\"expires\") || 0) * 1000;\n      _this.expiresTimer = setTimeout(function () {\n        if (_this.state === SessionState.Initial) {\n          incomingInviteRequest.reject({\n            statusCode: 487\n          });\n\n          _this.stateTransition(SessionState.Terminated);\n        }\n      }, expires);\n    } // Session parent properties\n\n\n    var assertedIdentity = _this.request.getHeader(\"P-Asserted-Identity\");\n\n    if (assertedIdentity) {\n      _this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);\n    }\n\n    _this._contact = _this.userAgent.contact.toString();\n    var contentDisposition = incomingRequestMessage.parseHeader(\"Content-Disposition\");\n\n    if (contentDisposition && contentDisposition.type === \"render\") {\n      _this._renderbody = incomingRequestMessage.body;\n      _this._rendertype = incomingRequestMessage.getHeader(\"Content-Type\");\n    } // Identifier\n\n\n    _this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag; // Add to the user agent's session collection.\n\n    _this.userAgent._sessions[_this._id] = _assertThisInitialized(_this);\n    return _this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(Invitation, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _this2 = this;\n\n      // Only run through this once. It can and does get called multiple times\n      // depending on the what the sessions state is when first called.\n      // For example, if called when \"establishing\" it will be called again\n      // at least once when the session transitions to \"terminated\".\n      // Regardless, running through this more than once is pointless.\n      if (this.disposed) {\n        return Promise.resolve();\n      }\n\n      this.disposed = true; // Clear timers\n\n      if (this.expiresTimer) {\n        clearTimeout(this.expiresTimer);\n        this.expiresTimer = undefined;\n      }\n\n      if (this.userNoAnswerTimer) {\n        clearTimeout(this.userNoAnswerTimer);\n        this.userNoAnswerTimer = undefined;\n      } // If accept() is still waiting for a PRACK, make sure it rejects\n\n\n      this.prackNeverArrived(); // If the final response for the initial INVITE not yet been sent, reject it\n\n      switch (this.state) {\n        case SessionState.Initial:\n          return this.reject().then(function () {\n            return _get(_getPrototypeOf(Invitation.prototype), \"dispose\", _this2).call(_this2);\n          });\n\n        case SessionState.Establishing:\n          return this.reject().then(function () {\n            return _get(_getPrototypeOf(Invitation.prototype), \"dispose\", _this2).call(_this2);\n          });\n\n        case SessionState.Established:\n          return _get(_getPrototypeOf(Invitation.prototype), \"dispose\", this).call(this);\n\n        case SessionState.Terminating:\n          return _get(_getPrototypeOf(Invitation.prototype), \"dispose\", this).call(this);\n\n        case SessionState.Terminated:\n          return _get(_getPrototypeOf(Invitation.prototype), \"dispose\", this).call(this);\n\n        default:\n          throw new Error(\"Unknown state.\");\n      }\n    }\n    /**\n     * If true, a first provisional response after the 100 Trying\n     * will be sent automatically. This is false it the UAC required\n     * reliable provisional responses (100rel in Require header),\n     * otherwise it is true. The provisional is sent by calling\n     * `progress()` without any options.\n     *\n     * FIXME: TODO: It seems reasonable that the ISC user should\n     * be able to optionally disable this behavior. As the provisional\n     * is sent prior to the \"invite\" event being emitted, it's a known\n     * issue that the ISC user cannot register listeners or do any other\n     * setup prior to the call to `progress()`. As an example why this is\n     * an issue, setting `ua.configuration.rel100` to REQUIRED will result\n     * in an attempt by `progress()` to send a 183 with SDP produced by\n     * calling `getDescription()` on a session description handler, but\n     * the ISC user cannot perform any potentially required session description\n     * handler initialization (thus preventing the utilization of setting\n     * `ua.configuration.rel100` to REQUIRED). That begs the question of\n     * why this behavior is disabled when the UAC requires 100rel but not\n     * when the UAS requires 100rel? But ignoring that, it's just one example\n     * of a class of cases where the ISC user needs to do something prior\n     * to the first call to `progress()` and is unable to do so.\n     * @internal\n     */\n\n  }, {\n    key: \"accept\",\n\n    /**\n     * Accept the invitation.\n     *\n     * @remarks\n     * Accept the incoming INVITE request to start a Session.\n     * Replies to the INVITE request with a 200 Ok response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * This method may reject for a variety of reasons including\n     * the receipt of a CANCEL request before `accept` is able\n     * to construct a response.\n     * @param options - Options bucket.\n     */\n    value: function accept() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Invitation.accept\"); // validate state\n\n      if (this.state !== SessionState.Initial) {\n        var error = new Error(\"Invalid session state \".concat(this.state));\n        this.logger.error(error.message);\n        return Promise.reject(error);\n      } // Modifiers and options for initial INVITE transaction\n\n\n      if (options.sessionDescriptionHandlerModifiers) {\n        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n      }\n\n      if (options.sessionDescriptionHandlerOptions) {\n        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n      } // transition state\n\n\n      this.stateTransition(SessionState.Establishing);\n      return this.sendAccept() // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      .then(function (_ref) {\n        var message = _ref.message,\n            session = _ref.session;\n        session.delegate = {\n          onAck: function onAck(ackRequest) {\n            return _this3.onAckRequest(ackRequest);\n          },\n          onAckTimeout: function onAckTimeout() {\n            return _this3.onAckTimeout();\n          },\n          onBye: function onBye(byeRequest) {\n            return _this3.onByeRequest(byeRequest);\n          },\n          onInfo: function onInfo(infoRequest) {\n            return _this3.onInfoRequest(infoRequest);\n          },\n          onInvite: function onInvite(inviteRequest) {\n            return _this3.onInviteRequest(inviteRequest);\n          },\n          onMessage: function onMessage(messageRequest) {\n            return _this3.onMessageRequest(messageRequest);\n          },\n          onNotify: function onNotify(notifyRequest) {\n            return _this3.onNotifyRequest(notifyRequest);\n          },\n          onPrack: function onPrack(prackRequest) {\n            return _this3.onPrackRequest(prackRequest);\n          },\n          onRefer: function onRefer(referRequest) {\n            return _this3.onReferRequest(referRequest);\n          }\n        };\n        _this3._dialog = session;\n\n        _this3.stateTransition(SessionState.Established); // TODO: Reconsider this \"automagic\" send of a BYE to replacee behavior.\n        // This behavior has been ported forward from legacy versions.\n\n\n        if (_this3._replacee) {\n          _this3._replacee._bye();\n        }\n      }).catch(function (error) {\n        return _this3.handleResponseError(error);\n      });\n    }\n    /**\n     * Indicate progress processing the invitation.\n     *\n     * @remarks\n     * Report progress to the the caller.\n     * Replies to the INVITE request with a 1xx provisional response.\n     * Resolves once the response sent, otherwise rejects.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"progress\",\n    value: function progress() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Invitation.progress\"); // validate state\n\n      if (this.state !== SessionState.Initial) {\n        var error = new Error(\"Invalid session state \".concat(this.state));\n        this.logger.error(error.message);\n        return Promise.reject(error);\n      } // Ported\n\n\n      var statusCode = options.statusCode || 180;\n\n      if (statusCode < 100 || statusCode > 199) {\n        throw new TypeError(\"Invalid statusCode: \" + statusCode);\n      } // Modifiers and options for initial INVITE transaction\n\n\n      if (options.sessionDescriptionHandlerModifiers) {\n        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n      }\n\n      if (options.sessionDescriptionHandlerOptions) {\n        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n      } // After the first reliable provisional response for a request has been\n      // acknowledged, the UAS MAY send additional reliable provisional\n      // responses.  The UAS MUST NOT send a second reliable provisional\n      // response until the first is acknowledged.  After the first, it is\n      // RECOMMENDED that the UAS not send an additional reliable provisional\n      // response until the previous is acknowledged.  The first reliable\n      // provisional response receives special treatment because it conveys\n      // the initial sequence number.  If additional reliable provisional\n      // responses were sent before the first was acknowledged, the UAS could\n      // not be certain these were received in order.\n      // https://tools.ietf.org/html/rfc3262#section-3\n\n\n      if (this.waitingForPrack) {\n        this.logger.warn(\"Unexpected call for progress while waiting for prack, ignoring\");\n        return Promise.resolve();\n      } // Trying provisional response\n\n\n      if (options.statusCode === 100) {\n        return this.sendProgressTrying().then(function () {\n          return;\n        }).catch(function (error) {\n          return _this4.handleResponseError(error);\n        });\n      } // Standard provisional response\n\n\n      if (!(this.rel100 === \"required\") && !(this.rel100 === \"supported\" && options.rel100) && !(this.rel100 === \"supported\" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {\n        return this.sendProgress(options).then(function () {\n          return;\n        }).catch(function (error) {\n          return _this4.handleResponseError(error);\n        });\n      } // Reliable provisional response\n\n\n      return this.sendProgressReliableWaitForPrack(options).then(function () {\n        return;\n      }).catch(function (error) {\n        return _this4.handleResponseError(error);\n      });\n    }\n    /**\n     * Reject the invitation.\n     *\n     * @remarks\n     * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * The expectation is that this method is used to reject an INVITE request.\n     * That is indeed the case - a call to `progress` followed by `reject` is\n     * a typical way to \"decline\" an incoming INVITE request. However it may\n     * also be called after calling `accept` (but only before it completes)\n     * which will reject the call and cause `accept` to reject.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"reject\",\n    value: function reject() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Invitation.reject\"); // validate state\n\n      if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n        var error = new Error(\"Invalid session state \".concat(this.state));\n        this.logger.error(error.message);\n        return Promise.reject(error);\n      }\n\n      var statusCode = options.statusCode || 480;\n      var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);\n      var extraHeaders = options.extraHeaders || [];\n\n      if (statusCode < 300 || statusCode > 699) {\n        throw new TypeError(\"Invalid statusCode: \" + statusCode);\n      }\n\n      var body = options.body ? fromBodyLegacy(options.body) : undefined; // FIXME: Need to redirect to someplace\n\n      statusCode < 400 ? this.incomingInviteRequest.redirect([], {\n        statusCode: statusCode,\n        reasonPhrase: reasonPhrase,\n        extraHeaders: extraHeaders,\n        body: body\n      }) : this.incomingInviteRequest.reject({\n        statusCode: statusCode,\n        reasonPhrase: reasonPhrase,\n        extraHeaders: extraHeaders,\n        body: body\n      });\n      this.stateTransition(SessionState.Terminated);\n      return Promise.resolve();\n    }\n    /**\n     * Handle CANCEL request.\n     *\n     * @param message - CANCEL message.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"_onCancel\",\n    value: function _onCancel(message) {\n      this.logger.log(\"Invitation._onCancel\"); // validate state\n\n      if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n        this.logger.error(\"CANCEL received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      } // flag canceled\n\n\n      this.isCanceled = true; // reject INVITE with 487 status code\n\n      this.incomingInviteRequest.reject({\n        statusCode: 487\n      });\n      this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Helper function to handle offer/answer in a PRACK.\n     */\n\n  }, {\n    key: \"handlePrackOfferAnswer\",\n    value: function handlePrackOfferAnswer(request) {\n      if (!this.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      } // If the PRACK doesn't have an offer/answer, nothing to be done.\n\n\n      var body = getBody(request.message);\n\n      if (!body || body.contentDisposition !== \"session\") {\n        return Promise.resolve(undefined);\n      }\n\n      var options = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n      }; // If the UAC receives a reliable provisional response with an offer\n      // (this would occur if the UAC sent an INVITE without an offer, in\n      // which case the first reliable provisional response will contain the\n      // offer), it MUST generate an answer in the PRACK.  If the UAC receives\n      // a reliable provisional response with an answer, it MAY generate an\n      // additional offer in the PRACK.  If the UAS receives a PRACK with an\n      // offer, it MUST place the answer in the 2xx to the PRACK.\n      // https://tools.ietf.org/html/rfc3262#section-5\n\n      switch (this.dialog.signalingState) {\n        case SignalingState.Initial:\n          // State should never be reached as first reliable provisional response must have answer/offer.\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n\n        case SignalingState.Stable:\n          // Receved answer.\n          return this.setAnswer(body, options).then(function () {\n            return undefined;\n          });\n\n        case SignalingState.HaveLocalOffer:\n          // State should never be reached as local offer would be answered by this PRACK\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n\n        case SignalingState.HaveRemoteOffer:\n          // Received offer, generate answer.\n          return this.setOfferAndGetAnswer(body, options);\n\n        case SignalingState.Closed:\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n\n        default:\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n      }\n    }\n    /**\n     * A handler for errors which occur while attempting to send 1xx and 2xx responses.\n     * In all cases, an attempt is made to reject the request if it is still outstanding.\n     * And while there are a variety of things which can go wrong and we log something here\n     * for all errors, there are a handful of common exceptions we pay some extra attention to.\n     * @param error - The error which occurred.\n     */\n\n  }, {\n    key: \"handleResponseError\",\n    value: function handleResponseError(error) {\n      var statusCode = 480; // \"Temporarily Unavailable\"\n      // Log Error message\n\n      if (error instanceof Error) {\n        this.logger.error(error.message);\n      } else {\n        // We don't actually know what a session description handler implementation might throw our way,\n        // and more generally as a last resort catch all, just assume we are getting an \"unknown\" and log it.\n        this.logger.error(error);\n      } // Log Exception message\n\n\n      if (error instanceof ContentTypeUnsupportedError) {\n        this.logger.error(\"A session description handler occurred while sending response (content type unsupported\");\n        statusCode = 415; // \"Unsupported Media Type\"\n      } else if (error instanceof SessionDescriptionHandlerError) {\n        this.logger.error(\"A session description handler occurred while sending response\");\n      } else if (error instanceof SessionTerminatedError) {\n        this.logger.error(\"Session ended before response could be formulated and sent (while waiting for PRACK)\");\n      } else if (error instanceof TransactionStateError) {\n        this.logger.error(\"Session changed state before response could be formulated and sent\");\n      } // Reject if still in \"initial\" or \"establishing\" state.\n\n\n      if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {\n        try {\n          this.incomingInviteRequest.reject({\n            statusCode: statusCode\n          });\n          this.stateTransition(SessionState.Terminated);\n        } catch (e) {\n          this.logger.error(\"An error occurred attempting to reject the request while handling another error\");\n          throw e; // This is not a good place to be...\n        }\n      } // FIXME: TODO:\n      // Here we are squelching the throwing of errors due to an race condition.\n      // We have an internal race between calling `accept()` and handling an incoming\n      // CANCEL request. As there is no good way currently to delegate the handling of\n      // these race errors to the caller of `accept()`, we are squelching the throwing\n      // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know\n      // is a \"normal\" exceptional condition. While this is a completely reasonable approach,\n      // the decision should be left up to the library user. Furthermore, as we are eating\n      // ALL errors in this case, we are potentially (likely) hiding \"real\" errors which occur.\n      //\n      // Only rethrow error if the session has not been canceled.\n\n\n      if (this.isCanceled) {\n        this.logger.warn(\"An error occurred while attempting to formulate and send a response to an incoming INVITE.\" + \" However a CANCEL was received and processed while doing so which can (and often does) result\" + \" in errors occurring as the session terminates in the meantime. Said error is being ignored.\");\n        return;\n      }\n\n      throw error;\n    }\n    /**\n     * Callback for when ACK for a 2xx response is never received.\n     * @param session - Session the ACK never arrived for.\n     */\n\n  }, {\n    key: \"onAckTimeout\",\n    value: function onAckTimeout() {\n      this.logger.log(\"Invitation.onAckTimeout\");\n\n      if (!this.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      this.logger.log(\"No ACK received for an extended period of time, terminating session\");\n      this.dialog.bye();\n      this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * A version of `accept` which resolves a session when the 200 Ok response is sent.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"sendAccept\",\n    value: function sendAccept() {\n      var _this5 = this;\n\n      var responseOptions = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n      }; // The UAS MAY send a final response to the initial request before\n      // having received PRACKs for all unacknowledged reliable provisional\n      // responses, unless the final response is 2xx and any of the\n      // unacknowledged reliable provisional responses contained a session\n      // description.  In that case, it MUST NOT send a final response until\n      // those provisional responses are acknowledged.  If the UAS does send a\n      // final response when reliable responses are still unacknowledged, it\n      // SHOULD NOT continue to retransmit the unacknowledged reliable\n      // provisional responses, but it MUST be prepared to process PRACK\n      // requests for those outstanding responses.  A UAS MUST NOT send new\n      // reliable provisional responses (as opposed to retransmissions of\n      // unacknowledged ones) after sending a final response to a request.\n      // https://tools.ietf.org/html/rfc3262#section-3\n\n      if (this.waitingForPrack) {\n        return this.waitForArrivalOfPrack().then(function () {\n          return clearTimeout(_this5.userNoAnswerTimer);\n        }) // Ported\n        .then(function () {\n          return _this5.generateResponseOfferAnswer(_this5.incomingInviteRequest, responseOptions);\n        }).then(function (body) {\n          return _this5.incomingInviteRequest.accept({\n            statusCode: 200,\n            body: body\n          });\n        });\n      }\n\n      clearTimeout(this.userNoAnswerTimer); // Ported\n\n      return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(function (body) {\n        return _this5.incomingInviteRequest.accept({\n          statusCode: 200,\n          body: body\n        });\n      });\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response is sent.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"sendProgress\",\n    value: function sendProgress() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var statusCode = options.statusCode || 180;\n      var reasonPhrase = options.reasonPhrase;\n      var extraHeaders = (options.extraHeaders || []).slice();\n      var body = options.body ? fromBodyLegacy(options.body) : undefined; // The 183 (Session Progress) response is used to convey information\n      // about the progress of the call that is not otherwise classified.  The\n      // Reason-Phrase, header fields, or message body MAY be used to convey\n      // more details about the call progress.\n      // https://tools.ietf.org/html/rfc3261#section-21.1.5\n      // It is the de facto industry standard to utilize 183 with SDP to provide \"early media\".\n      // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.\n\n      if (statusCode === 183 && !body) {\n        return this.sendProgressWithSDP(options);\n      }\n\n      try {\n        var progressResponse = this.incomingInviteRequest.progress({\n          statusCode: statusCode,\n          reasonPhrase: reasonPhrase,\n          extraHeaders: extraHeaders,\n          body: body\n        });\n        this._dialog = progressResponse.session;\n        return Promise.resolve(progressResponse);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response with sdp is sent.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"sendProgressWithSDP\",\n    value: function sendProgressWithSDP() {\n      var _this6 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var responseOptions = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n      };\n      var statusCode = options.statusCode || 183;\n      var reasonPhrase = options.reasonPhrase;\n      var extraHeaders = (options.extraHeaders || []).slice(); // Get an offer/answer and send a reply.\n\n      return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(function (body) {\n        return _this6.incomingInviteRequest.progress({\n          statusCode: statusCode,\n          reasonPhrase: reasonPhrase,\n          extraHeaders: extraHeaders,\n          body: body\n        });\n      }).then(function (progressResponse) {\n        _this6._dialog = progressResponse.session;\n        return progressResponse;\n      });\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is sent.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"sendProgressReliable\",\n    value: function sendProgressReliable() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      options.extraHeaders = (options.extraHeaders || []).slice();\n      options.extraHeaders.push(\"Require: 100rel\");\n      options.extraHeaders.push(\"RSeq: \" + Math.floor(Math.random() * 10000));\n      return this.sendProgressWithSDP(options);\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is acknowledged.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"sendProgressReliableWaitForPrack\",\n    value: function sendProgressReliableWaitForPrack() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var responseOptions = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n      };\n      var statusCode = options.statusCode || 183;\n      var reasonPhrase = options.reasonPhrase;\n      var extraHeaders = (options.extraHeaders || []).slice();\n      extraHeaders.push(\"Require: 100rel\");\n      extraHeaders.push(\"RSeq: \" + this.rseq++);\n      var body;\n      return new Promise(function (resolve, reject) {\n        _this7.waitingForPrack = true;\n\n        _this7.generateResponseOfferAnswer(_this7.incomingInviteRequest, responseOptions).then(function (offerAnswer) {\n          body = offerAnswer;\n          return _this7.incomingInviteRequest.progress({\n            statusCode: statusCode,\n            reasonPhrase: reasonPhrase,\n            extraHeaders: extraHeaders,\n            body: body\n          });\n        }).then(function (progressResponse) {\n          _this7._dialog = progressResponse.session;\n          var prackRequest;\n          var prackResponse;\n          progressResponse.session.delegate = {\n            onPrack: function onPrack(request) {\n              prackRequest = request; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n              clearTimeout(prackWaitTimeoutTimer); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n              clearTimeout(rel1xxRetransmissionTimer);\n\n              if (!_this7.waitingForPrack) {\n                return;\n              }\n\n              _this7.waitingForPrack = false;\n\n              _this7.handlePrackOfferAnswer(prackRequest).then(function (prackResponseBody) {\n                try {\n                  prackResponse = prackRequest.accept({\n                    statusCode: 200,\n                    body: prackResponseBody\n                  });\n\n                  _this7.prackArrived();\n\n                  resolve({\n                    prackRequest: prackRequest,\n                    prackResponse: prackResponse,\n                    progressResponse: progressResponse\n                  });\n                } catch (error) {\n                  reject(error);\n                }\n              }).catch(function (error) {\n                return reject(error);\n              });\n            }\n          }; // https://tools.ietf.org/html/rfc3262#section-3\n\n          var prackWaitTimeout = function prackWaitTimeout() {\n            if (!_this7.waitingForPrack) {\n              return;\n            }\n\n            _this7.waitingForPrack = false;\n\n            _this7.logger.warn(\"No PRACK received, rejecting INVITE.\"); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n            clearTimeout(rel1xxRetransmissionTimer);\n\n            _this7.reject({\n              statusCode: 504\n            }).then(function () {\n              return reject(new SessionTerminatedError());\n            }).catch(function (error) {\n              return reject(error);\n            });\n          };\n\n          var prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64); // https://tools.ietf.org/html/rfc3262#section-3\n\n          var rel1xxRetransmission = function rel1xxRetransmission() {\n            try {\n              _this7.incomingInviteRequest.progress({\n                statusCode: statusCode,\n                reasonPhrase: reasonPhrase,\n                extraHeaders: extraHeaders,\n                body: body\n              });\n            } catch (error) {\n              _this7.waitingForPrack = false;\n              reject(error);\n              return;\n            } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n            rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);\n          };\n\n          var timeout = Timers.T1;\n          var rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);\n        }).catch(function (error) {\n          _this7.waitingForPrack = false;\n          reject(error);\n        });\n      });\n    }\n    /**\n     * A version of `progress` which resolves when a 100 Trying provisional response is sent.\n     */\n\n  }, {\n    key: \"sendProgressTrying\",\n    value: function sendProgressTrying() {\n      try {\n        var progressResponse = this.incomingInviteRequest.trying();\n        return Promise.resolve(progressResponse);\n      } catch (error) {\n        return Promise.reject(error);\n      }\n    }\n    /**\n     * When attempting to accept the INVITE, an invitation waits\n     * for any outstanding PRACK to arrive before sending the 200 Ok.\n     * It will be waiting on this Promise to resolve which lets it know\n     * the PRACK has arrived and it may proceed to send the 200 Ok.\n     */\n\n  }, {\n    key: \"waitForArrivalOfPrack\",\n    value: function waitForArrivalOfPrack() {\n      var _this8 = this;\n\n      if (this.waitingForPrackPromise) {\n        throw new Error(\"Already waiting for PRACK\");\n      }\n\n      this.waitingForPrackPromise = new Promise(function (resolve, reject) {\n        _this8.waitingForPrackResolve = resolve;\n        _this8.waitingForPrackReject = reject;\n      });\n      return this.waitingForPrackPromise;\n    }\n    /**\n     * Here we are resolving the promise which in turn will cause\n     * the accept to proceed (it may still fail for other reasons, but...).\n     */\n\n  }, {\n    key: \"prackArrived\",\n    value: function prackArrived() {\n      if (this.waitingForPrackResolve) {\n        this.waitingForPrackResolve();\n      }\n\n      this.waitingForPrackPromise = undefined;\n      this.waitingForPrackResolve = undefined;\n      this.waitingForPrackReject = undefined;\n    }\n    /**\n     * Here we are rejecting the promise which in turn will cause\n     * the accept to fail and the session to transition to \"terminated\".\n     */\n\n  }, {\n    key: \"prackNeverArrived\",\n    value: function prackNeverArrived() {\n      if (this.waitingForPrackReject) {\n        this.waitingForPrackReject(new SessionTerminatedError());\n      }\n\n      this.waitingForPrackPromise = undefined;\n      this.waitingForPrackResolve = undefined;\n      this.waitingForPrackReject = undefined;\n    }\n  }, {\n    key: \"autoSendAnInitialProvisionalResponse\",\n    get: function get() {\n      return this.rel100 === \"required\" ? false : true;\n    }\n    /**\n     * Initial incoming INVITE request message body.\n     */\n\n  }, {\n    key: \"body\",\n    get: function get() {\n      return this.incomingInviteRequest.message.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n\n  }, {\n    key: \"localIdentity\",\n    get: function get() {\n      return this.request.to;\n    }\n    /**\n     * The identity of the remote user.\n     */\n\n  }, {\n    key: \"remoteIdentity\",\n    get: function get() {\n      return this.request.from;\n    }\n    /**\n     * Initial incoming INVITE request message.\n     */\n\n  }, {\n    key: \"request\",\n    get: function get() {\n      return this.incomingInviteRequest.message;\n    }\n  }]);\n\n  return Invitation;\n}(Session);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/invitation.js"],"names":["fromBodyLegacy","getBody","Grammar","SignalingState","Timers","TransactionStateError","getReasonPhrase","ContentTypeUnsupportedError","SessionDescriptionHandlerError","SessionTerminatedError","Session","SessionState","SIPExtension","Invitation","userAgent","incomingInviteRequest","disposed","expiresTimer","undefined","isCanceled","rel100","rseq","Math","floor","random","userNoAnswerTimer","waitingForPrack","logger","getLogger","incomingRequestMessage","message","requireHeader","getHeader","toLowerCase","includes","supportedHeader","toTag","TypeError","setTimeout","reject","statusCode","stateTransition","Terminated","configuration","noAnswerTimeout","hasHeader","expires","Number","state","Initial","assertedIdentity","request","_assertedIdentity","nameAddrHeaderParse","_contact","contact","toString","contentDisposition","parseHeader","type","_renderbody","body","_rendertype","_id","callId","fromTag","_sessions","Promise","resolve","clearTimeout","prackNeverArrived","then","Establishing","Established","Terminating","Error","options","log","error","sessionDescriptionHandlerModifiers","sessionDescriptionHandlerOptions","sendAccept","session","delegate","onAck","ackRequest","onAckRequest","onAckTimeout","onBye","byeRequest","onByeRequest","onInfo","infoRequest","onInfoRequest","onInvite","inviteRequest","onInviteRequest","onMessage","messageRequest","onMessageRequest","onNotify","notifyRequest","onNotifyRequest","onPrack","prackRequest","onPrackRequest","onRefer","referRequest","onReferRequest","_dialog","_replacee","_bye","catch","handleResponseError","warn","sendProgressTrying","sipExtension100rel","Required","sendProgress","sendProgressReliableWaitForPrack","reasonPhrase","extraHeaders","redirect","dialog","signalingState","Stable","setAnswer","HaveLocalOffer","HaveRemoteOffer","setOfferAndGetAnswer","Closed","e","bye","responseOptions","waitForArrivalOfPrack","generateResponseOfferAnswer","accept","slice","sendProgressWithSDP","progressResponse","progress","push","offerAnswer","prackResponse","prackWaitTimeoutTimer","rel1xxRetransmissionTimer","handlePrackOfferAnswer","prackResponseBody","prackArrived","prackWaitTimeout","T1","rel1xxRetransmission","timeout","trying","waitingForPrackPromise","waitingForPrackResolve","waitingForPrackReject","to","from"],"mappings":"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","sourcesContent":["import { fromBodyLegacy, getBody, Grammar, SignalingState, Timers, TransactionStateError } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { ContentTypeUnsupportedError, SessionDescriptionHandlerError, SessionTerminatedError } from \"./exceptions\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An invitation is an offer to establish a {@link Session} (incoming INVITE).\n * @public\n */\nexport class Invitation extends Session {\n    /** @internal */\n    constructor(userAgent, incomingInviteRequest) {\n        super(userAgent);\n        this.incomingInviteRequest = incomingInviteRequest;\n        /** True if dispose() has been called. */\n        this.disposed = false;\n        /** INVITE will be rejected if not accepted within a certain period time. */\n        this.expiresTimer = undefined;\n        /** True if this Session has been Terminated due to a CANCEL request. */\n        this.isCanceled = false;\n        /** Are reliable provisional responses required or supported. */\n        this.rel100 = \"none\";\n        /** The current RSeq header value. */\n        this.rseq = Math.floor(Math.random() * 10000);\n        /** INVITE will be rejected if final response not sent in a certain period time. */\n        this.userNoAnswerTimer = undefined;\n        /** True if waiting for a PRACK before sending a 200 Ok. */\n        this.waitingForPrack = false;\n        this.logger = userAgent.getLogger(\"sip.Invitation\");\n        const incomingRequestMessage = this.incomingInviteRequest.message;\n        // Set 100rel if necessary\n        const requireHeader = incomingRequestMessage.getHeader(\"require\");\n        if (requireHeader && requireHeader.toLowerCase().includes(\"100rel\")) {\n            this.rel100 = \"required\";\n        }\n        const supportedHeader = incomingRequestMessage.getHeader(\"supported\");\n        if (supportedHeader && supportedHeader.toLowerCase().includes(\"100rel\")) {\n            this.rel100 = \"supported\";\n        }\n        // FIXME: HACK: This is a hack to port an existing behavior.\n        // Set the toTag on the incoming request message to the toTag which\n        // will be used in the response to the incoming request!!!\n        // The behavior being ported appears to be a hack itself,\n        // so this is a hack to port a hack. At least one test spec\n        // relies on it (which is yet another hack).\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        incomingRequestMessage.toTag = incomingInviteRequest.toTag;\n        if (typeof incomingRequestMessage.toTag !== \"string\") {\n            throw new TypeError(\"toTag should have been a string.\");\n        }\n        // The following mapping values are RECOMMENDED:\n        // ...\n        // 19 no answer from the user              480 Temporarily unavailable\n        // https://tools.ietf.org/html/rfc3398#section-7.2.4.1\n        this.userNoAnswerTimer = setTimeout(() => {\n            incomingInviteRequest.reject({ statusCode: 480 });\n            this.stateTransition(SessionState.Terminated);\n        }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1000 : 60000);\n        // 1. If the request is an INVITE that contains an Expires header\n        // field, the UAS core sets a timer for the number of seconds\n        // indicated in the header field value.  When the timer fires, the\n        // invitation is considered to be expired.  If the invitation\n        // expires before the UAS has generated a final response, a 487\n        // (Request Terminated) response SHOULD be generated.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1\n        if (incomingRequestMessage.hasHeader(\"expires\")) {\n            const expires = Number(incomingRequestMessage.getHeader(\"expires\") || 0) * 1000;\n            this.expiresTimer = setTimeout(() => {\n                if (this.state === SessionState.Initial) {\n                    incomingInviteRequest.reject({ statusCode: 487 });\n                    this.stateTransition(SessionState.Terminated);\n                }\n            }, expires);\n        }\n        // Session parent properties\n        const assertedIdentity = this.request.getHeader(\"P-Asserted-Identity\");\n        if (assertedIdentity) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);\n        }\n        this._contact = this.userAgent.contact.toString();\n        const contentDisposition = incomingRequestMessage.parseHeader(\"Content-Disposition\");\n        if (contentDisposition && contentDisposition.type === \"render\") {\n            this._renderbody = incomingRequestMessage.body;\n            this._rendertype = incomingRequestMessage.getHeader(\"Content-Type\");\n        }\n        // Identifier\n        this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag;\n        // Add to the user agent's session collection.\n        this.userAgent._sessions[this._id] = this;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        // Only run through this once. It can and does get called multiple times\n        // depending on the what the sessions state is when first called.\n        // For example, if called when \"establishing\" it will be called again\n        // at least once when the session transitions to \"terminated\".\n        // Regardless, running through this more than once is pointless.\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        // Clear timers\n        if (this.expiresTimer) {\n            clearTimeout(this.expiresTimer);\n            this.expiresTimer = undefined;\n        }\n        if (this.userNoAnswerTimer) {\n            clearTimeout(this.userNoAnswerTimer);\n            this.userNoAnswerTimer = undefined;\n        }\n        // If accept() is still waiting for a PRACK, make sure it rejects\n        this.prackNeverArrived();\n        // If the final response for the initial INVITE not yet been sent, reject it\n        switch (this.state) {\n            case SessionState.Initial:\n                return this.reject().then(() => super.dispose());\n            case SessionState.Establishing:\n                return this.reject().then(() => super.dispose());\n            case SessionState.Established:\n                return super.dispose();\n            case SessionState.Terminating:\n                return super.dispose();\n            case SessionState.Terminated:\n                return super.dispose();\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n    }\n    /**\n     * If true, a first provisional response after the 100 Trying\n     * will be sent automatically. This is false it the UAC required\n     * reliable provisional responses (100rel in Require header),\n     * otherwise it is true. The provisional is sent by calling\n     * `progress()` without any options.\n     *\n     * FIXME: TODO: It seems reasonable that the ISC user should\n     * be able to optionally disable this behavior. As the provisional\n     * is sent prior to the \"invite\" event being emitted, it's a known\n     * issue that the ISC user cannot register listeners or do any other\n     * setup prior to the call to `progress()`. As an example why this is\n     * an issue, setting `ua.configuration.rel100` to REQUIRED will result\n     * in an attempt by `progress()` to send a 183 with SDP produced by\n     * calling `getDescription()` on a session description handler, but\n     * the ISC user cannot perform any potentially required session description\n     * handler initialization (thus preventing the utilization of setting\n     * `ua.configuration.rel100` to REQUIRED). That begs the question of\n     * why this behavior is disabled when the UAC requires 100rel but not\n     * when the UAS requires 100rel? But ignoring that, it's just one example\n     * of a class of cases where the ISC user needs to do something prior\n     * to the first call to `progress()` and is unable to do so.\n     * @internal\n     */\n    get autoSendAnInitialProvisionalResponse() {\n        return this.rel100 === \"required\" ? false : true;\n    }\n    /**\n     * Initial incoming INVITE request message body.\n     */\n    get body() {\n        return this.incomingInviteRequest.message.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n    get localIdentity() {\n        return this.request.to;\n    }\n    /**\n     * The identity of the remote user.\n     */\n    get remoteIdentity() {\n        return this.request.from;\n    }\n    /**\n     * Initial incoming INVITE request message.\n     */\n    get request() {\n        return this.incomingInviteRequest.message;\n    }\n    /**\n     * Accept the invitation.\n     *\n     * @remarks\n     * Accept the incoming INVITE request to start a Session.\n     * Replies to the INVITE request with a 200 Ok response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * This method may reject for a variety of reasons including\n     * the receipt of a CANCEL request before `accept` is able\n     * to construct a response.\n     * @param options - Options bucket.\n     */\n    accept(options = {}) {\n        this.logger.log(\"Invitation.accept\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // transition state\n        this.stateTransition(SessionState.Establishing);\n        return (this.sendAccept()\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            .then(({ message, session }) => {\n            session.delegate = {\n                onAck: (ackRequest) => this.onAckRequest(ackRequest),\n                onAckTimeout: () => this.onAckTimeout(),\n                onBye: (byeRequest) => this.onByeRequest(byeRequest),\n                onInfo: (infoRequest) => this.onInfoRequest(infoRequest),\n                onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),\n                onMessage: (messageRequest) => this.onMessageRequest(messageRequest),\n                onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),\n                onPrack: (prackRequest) => this.onPrackRequest(prackRequest),\n                onRefer: (referRequest) => this.onReferRequest(referRequest)\n            };\n            this._dialog = session;\n            this.stateTransition(SessionState.Established);\n            // TODO: Reconsider this \"automagic\" send of a BYE to replacee behavior.\n            // This behavior has been ported forward from legacy versions.\n            if (this._replacee) {\n                this._replacee._bye();\n            }\n        })\n            .catch((error) => this.handleResponseError(error)));\n    }\n    /**\n     * Indicate progress processing the invitation.\n     *\n     * @remarks\n     * Report progress to the the caller.\n     * Replies to the INVITE request with a 1xx provisional response.\n     * Resolves once the response sent, otherwise rejects.\n     * @param options - Options bucket.\n     */\n    progress(options = {}) {\n        this.logger.log(\"Invitation.progress\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // Ported\n        const statusCode = options.statusCode || 180;\n        if (statusCode < 100 || statusCode > 199) {\n            throw new TypeError(\"Invalid statusCode: \" + statusCode);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // After the first reliable provisional response for a request has been\n        // acknowledged, the UAS MAY send additional reliable provisional\n        // responses.  The UAS MUST NOT send a second reliable provisional\n        // response until the first is acknowledged.  After the first, it is\n        // RECOMMENDED that the UAS not send an additional reliable provisional\n        // response until the previous is acknowledged.  The first reliable\n        // provisional response receives special treatment because it conveys\n        // the initial sequence number.  If additional reliable provisional\n        // responses were sent before the first was acknowledged, the UAS could\n        // not be certain these were received in order.\n        // https://tools.ietf.org/html/rfc3262#section-3\n        if (this.waitingForPrack) {\n            this.logger.warn(\"Unexpected call for progress while waiting for prack, ignoring\");\n            return Promise.resolve();\n        }\n        // Trying provisional response\n        if (options.statusCode === 100) {\n            return this.sendProgressTrying()\n                .then(() => {\n                return;\n            })\n                .catch((error) => this.handleResponseError(error));\n        }\n        // Standard provisional response\n        if (!(this.rel100 === \"required\") &&\n            !(this.rel100 === \"supported\" && options.rel100) &&\n            !(this.rel100 === \"supported\" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {\n            return this.sendProgress(options)\n                .then(() => {\n                return;\n            })\n                .catch((error) => this.handleResponseError(error));\n        }\n        // Reliable provisional response\n        return this.sendProgressReliableWaitForPrack(options)\n            .then(() => {\n            return;\n        })\n            .catch((error) => this.handleResponseError(error));\n    }\n    /**\n     * Reject the invitation.\n     *\n     * @remarks\n     * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * The expectation is that this method is used to reject an INVITE request.\n     * That is indeed the case - a call to `progress` followed by `reject` is\n     * a typical way to \"decline\" an incoming INVITE request. However it may\n     * also be called after calling `accept` (but only before it completes)\n     * which will reject the call and cause `accept` to reject.\n     * @param options - Options bucket.\n     */\n    reject(options = {}) {\n        this.logger.log(\"Invitation.reject\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        const statusCode = options.statusCode || 480;\n        const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);\n        const extraHeaders = options.extraHeaders || [];\n        if (statusCode < 300 || statusCode > 699) {\n            throw new TypeError(\"Invalid statusCode: \" + statusCode);\n        }\n        const body = options.body ? fromBodyLegacy(options.body) : undefined;\n        // FIXME: Need to redirect to someplace\n        statusCode < 400\n            ? this.incomingInviteRequest.redirect([], { statusCode, reasonPhrase, extraHeaders, body })\n            : this.incomingInviteRequest.reject({ statusCode, reasonPhrase, extraHeaders, body });\n        this.stateTransition(SessionState.Terminated);\n        return Promise.resolve();\n    }\n    /**\n     * Handle CANCEL request.\n     *\n     * @param message - CANCEL message.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _onCancel(message) {\n        this.logger.log(\"Invitation._onCancel\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // flag canceled\n        this.isCanceled = true;\n        // reject INVITE with 487 status code\n        this.incomingInviteRequest.reject({ statusCode: 487 });\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Helper function to handle offer/answer in a PRACK.\n     */\n    handlePrackOfferAnswer(request) {\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        // If the PRACK doesn't have an offer/answer, nothing to be done.\n        const body = getBody(request.message);\n        if (!body || body.contentDisposition !== \"session\") {\n            return Promise.resolve(undefined);\n        }\n        const options = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        // If the UAC receives a reliable provisional response with an offer\n        // (this would occur if the UAC sent an INVITE without an offer, in\n        // which case the first reliable provisional response will contain the\n        // offer), it MUST generate an answer in the PRACK.  If the UAC receives\n        // a reliable provisional response with an answer, it MAY generate an\n        // additional offer in the PRACK.  If the UAS receives a PRACK with an\n        // offer, it MUST place the answer in the 2xx to the PRACK.\n        // https://tools.ietf.org/html/rfc3262#section-5\n        switch (this.dialog.signalingState) {\n            case SignalingState.Initial:\n                // State should never be reached as first reliable provisional response must have answer/offer.\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            case SignalingState.Stable:\n                // Receved answer.\n                return this.setAnswer(body, options).then(() => undefined);\n            case SignalingState.HaveLocalOffer:\n                // State should never be reached as local offer would be answered by this PRACK\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            case SignalingState.HaveRemoteOffer:\n                // Received offer, generate answer.\n                return this.setOfferAndGetAnswer(body, options);\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n        }\n    }\n    /**\n     * A handler for errors which occur while attempting to send 1xx and 2xx responses.\n     * In all cases, an attempt is made to reject the request if it is still outstanding.\n     * And while there are a variety of things which can go wrong and we log something here\n     * for all errors, there are a handful of common exceptions we pay some extra attention to.\n     * @param error - The error which occurred.\n     */\n    handleResponseError(error) {\n        let statusCode = 480; // \"Temporarily Unavailable\"\n        // Log Error message\n        if (error instanceof Error) {\n            this.logger.error(error.message);\n        }\n        else {\n            // We don't actually know what a session description handler implementation might throw our way,\n            // and more generally as a last resort catch all, just assume we are getting an \"unknown\" and log it.\n            this.logger.error(error);\n        }\n        // Log Exception message\n        if (error instanceof ContentTypeUnsupportedError) {\n            this.logger.error(\"A session description handler occurred while sending response (content type unsupported\");\n            statusCode = 415; // \"Unsupported Media Type\"\n        }\n        else if (error instanceof SessionDescriptionHandlerError) {\n            this.logger.error(\"A session description handler occurred while sending response\");\n        }\n        else if (error instanceof SessionTerminatedError) {\n            this.logger.error(\"Session ended before response could be formulated and sent (while waiting for PRACK)\");\n        }\n        else if (error instanceof TransactionStateError) {\n            this.logger.error(\"Session changed state before response could be formulated and sent\");\n        }\n        // Reject if still in \"initial\" or \"establishing\" state.\n        if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {\n            try {\n                this.incomingInviteRequest.reject({ statusCode });\n                this.stateTransition(SessionState.Terminated);\n            }\n            catch (e) {\n                this.logger.error(\"An error occurred attempting to reject the request while handling another error\");\n                throw e; // This is not a good place to be...\n            }\n        }\n        // FIXME: TODO:\n        // Here we are squelching the throwing of errors due to an race condition.\n        // We have an internal race between calling `accept()` and handling an incoming\n        // CANCEL request. As there is no good way currently to delegate the handling of\n        // these race errors to the caller of `accept()`, we are squelching the throwing\n        // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know\n        // is a \"normal\" exceptional condition. While this is a completely reasonable approach,\n        // the decision should be left up to the library user. Furthermore, as we are eating\n        // ALL errors in this case, we are potentially (likely) hiding \"real\" errors which occur.\n        //\n        // Only rethrow error if the session has not been canceled.\n        if (this.isCanceled) {\n            this.logger.warn(\"An error occurred while attempting to formulate and send a response to an incoming INVITE.\" +\n                \" However a CANCEL was received and processed while doing so which can (and often does) result\" +\n                \" in errors occurring as the session terminates in the meantime. Said error is being ignored.\");\n            return;\n        }\n        throw error;\n    }\n    /**\n     * Callback for when ACK for a 2xx response is never received.\n     * @param session - Session the ACK never arrived for.\n     */\n    onAckTimeout() {\n        this.logger.log(\"Invitation.onAckTimeout\");\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        this.logger.log(\"No ACK received for an extended period of time, terminating session\");\n        this.dialog.bye();\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * A version of `accept` which resolves a session when the 200 Ok response is sent.\n     * @param options - Options bucket.\n     */\n    sendAccept() {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        // The UAS MAY send a final response to the initial request before\n        // having received PRACKs for all unacknowledged reliable provisional\n        // responses, unless the final response is 2xx and any of the\n        // unacknowledged reliable provisional responses contained a session\n        // description.  In that case, it MUST NOT send a final response until\n        // those provisional responses are acknowledged.  If the UAS does send a\n        // final response when reliable responses are still unacknowledged, it\n        // SHOULD NOT continue to retransmit the unacknowledged reliable\n        // provisional responses, but it MUST be prepared to process PRACK\n        // requests for those outstanding responses.  A UAS MUST NOT send new\n        // reliable provisional responses (as opposed to retransmissions of\n        // unacknowledged ones) after sending a final response to a request.\n        // https://tools.ietf.org/html/rfc3262#section-3\n        if (this.waitingForPrack) {\n            return this.waitForArrivalOfPrack()\n                .then(() => clearTimeout(this.userNoAnswerTimer)) // Ported\n                .then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions))\n                .then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body }));\n        }\n        clearTimeout(this.userNoAnswerTimer); // Ported\n        return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then((body) => this.incomingInviteRequest.accept({ statusCode: 200, body }));\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response is sent.\n     * @param options - Options bucket.\n     */\n    sendProgress(options = {}) {\n        const statusCode = options.statusCode || 180;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        const body = options.body ? fromBodyLegacy(options.body) : undefined;\n        // The 183 (Session Progress) response is used to convey information\n        // about the progress of the call that is not otherwise classified.  The\n        // Reason-Phrase, header fields, or message body MAY be used to convey\n        // more details about the call progress.\n        // https://tools.ietf.org/html/rfc3261#section-21.1.5\n        // It is the de facto industry standard to utilize 183 with SDP to provide \"early media\".\n        // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.\n        if (statusCode === 183 && !body) {\n            return this.sendProgressWithSDP(options);\n        }\n        try {\n            const progressResponse = this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n            this._dialog = progressResponse.session;\n            return Promise.resolve(progressResponse);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * A version of `progress` which resolves when the provisional response with sdp is sent.\n     * @param options - Options bucket.\n     */\n    sendProgressWithSDP(options = {}) {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        const statusCode = options.statusCode || 183;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        // Get an offer/answer and send a reply.\n        return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)\n            .then((body) => this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body }))\n            .then((progressResponse) => {\n            this._dialog = progressResponse.session;\n            return progressResponse;\n        });\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is sent.\n     * @param options - Options bucket.\n     */\n    sendProgressReliable(options = {}) {\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(\"Require: 100rel\");\n        options.extraHeaders.push(\"RSeq: \" + Math.floor(Math.random() * 10000));\n        return this.sendProgressWithSDP(options);\n    }\n    /**\n     * A version of `progress` which resolves when the reliable provisional response is acknowledged.\n     * @param options - Options bucket.\n     */\n    sendProgressReliableWaitForPrack(options = {}) {\n        const responseOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n        };\n        const statusCode = options.statusCode || 183;\n        const reasonPhrase = options.reasonPhrase;\n        const extraHeaders = (options.extraHeaders || []).slice();\n        extraHeaders.push(\"Require: 100rel\");\n        extraHeaders.push(\"RSeq: \" + this.rseq++);\n        let body;\n        return new Promise((resolve, reject) => {\n            this.waitingForPrack = true;\n            this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)\n                .then((offerAnswer) => {\n                body = offerAnswer;\n                return this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n            })\n                .then((progressResponse) => {\n                this._dialog = progressResponse.session;\n                let prackRequest;\n                let prackResponse;\n                progressResponse.session.delegate = {\n                    onPrack: (request) => {\n                        prackRequest = request;\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                        clearTimeout(prackWaitTimeoutTimer);\n                        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                        clearTimeout(rel1xxRetransmissionTimer);\n                        if (!this.waitingForPrack) {\n                            return;\n                        }\n                        this.waitingForPrack = false;\n                        this.handlePrackOfferAnswer(prackRequest)\n                            .then((prackResponseBody) => {\n                            try {\n                                prackResponse = prackRequest.accept({ statusCode: 200, body: prackResponseBody });\n                                this.prackArrived();\n                                resolve({ prackRequest, prackResponse, progressResponse });\n                            }\n                            catch (error) {\n                                reject(error);\n                            }\n                        })\n                            .catch((error) => reject(error));\n                    }\n                };\n                // https://tools.ietf.org/html/rfc3262#section-3\n                const prackWaitTimeout = () => {\n                    if (!this.waitingForPrack) {\n                        return;\n                    }\n                    this.waitingForPrack = false;\n                    this.logger.warn(\"No PRACK received, rejecting INVITE.\");\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    clearTimeout(rel1xxRetransmissionTimer);\n                    this.reject({ statusCode: 504 })\n                        .then(() => reject(new SessionTerminatedError()))\n                        .catch((error) => reject(error));\n                };\n                const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64);\n                // https://tools.ietf.org/html/rfc3262#section-3\n                const rel1xxRetransmission = () => {\n                    try {\n                        this.incomingInviteRequest.progress({ statusCode, reasonPhrase, extraHeaders, body });\n                    }\n                    catch (error) {\n                        this.waitingForPrack = false;\n                        reject(error);\n                        return;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, (timeout *= 2));\n                };\n                let timeout = Timers.T1;\n                let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);\n            })\n                .catch((error) => {\n                this.waitingForPrack = false;\n                reject(error);\n            });\n        });\n    }\n    /**\n     * A version of `progress` which resolves when a 100 Trying provisional response is sent.\n     */\n    sendProgressTrying() {\n        try {\n            const progressResponse = this.incomingInviteRequest.trying();\n            return Promise.resolve(progressResponse);\n        }\n        catch (error) {\n            return Promise.reject(error);\n        }\n    }\n    /**\n     * When attempting to accept the INVITE, an invitation waits\n     * for any outstanding PRACK to arrive before sending the 200 Ok.\n     * It will be waiting on this Promise to resolve which lets it know\n     * the PRACK has arrived and it may proceed to send the 200 Ok.\n     */\n    waitForArrivalOfPrack() {\n        if (this.waitingForPrackPromise) {\n            throw new Error(\"Already waiting for PRACK\");\n        }\n        this.waitingForPrackPromise = new Promise((resolve, reject) => {\n            this.waitingForPrackResolve = resolve;\n            this.waitingForPrackReject = reject;\n        });\n        return this.waitingForPrackPromise;\n    }\n    /**\n     * Here we are resolving the promise which in turn will cause\n     * the accept to proceed (it may still fail for other reasons, but...).\n     */\n    prackArrived() {\n        if (this.waitingForPrackResolve) {\n            this.waitingForPrackResolve();\n        }\n        this.waitingForPrackPromise = undefined;\n        this.waitingForPrackResolve = undefined;\n        this.waitingForPrackReject = undefined;\n    }\n    /**\n     * Here we are rejecting the promise which in turn will cause\n     * the accept to fail and the session to transition to \"terminated\".\n     */\n    prackNeverArrived() {\n        if (this.waitingForPrackReject) {\n            this.waitingForPrackReject(new SessionTerminatedError());\n        }\n        this.waitingForPrackPromise = undefined;\n        this.waitingForPrackResolve = undefined;\n        this.waitingForPrackReject = undefined;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}