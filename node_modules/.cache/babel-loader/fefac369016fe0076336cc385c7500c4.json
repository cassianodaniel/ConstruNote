{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { C, Grammar, SignalingState } from \"../core\";\nimport { getReasonPhrase, newTag } from \"../core/messages/utils\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An inviter offers to establish a {@link Session} (outgoing INVITE).\n * @public\n */\n\nexport var Inviter = /*#__PURE__*/function (_Session) {\n  _inherits(Inviter, _Session);\n\n  var _super = _createSuper(Inviter);\n\n  /**\n   * Constructs a new instance of the `Inviter` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - Request URI identifying the target of the message.\n   * @param options - Options bucket. See {@link InviterOptions} for details.\n   */\n  function Inviter(userAgent, targetURI) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Inviter);\n\n    _this = _super.call(this, userAgent, options);\n    /** True if dispose() has been called. */\n\n    _this.disposed = false;\n    /** True if early media use is enabled. */\n\n    _this.earlyMedia = false;\n    /** The early media session description handlers. */\n\n    _this.earlyMediaSessionDescriptionHandlers = new Map();\n    /** True if cancel() was called. */\n\n    _this.isCanceled = false;\n    /** True if initial INVITE without SDP. */\n\n    _this.inviteWithoutSdp = false;\n    _this.logger = userAgent.getLogger(\"sip.Inviter\"); // Early media\n\n    _this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : _this.earlyMedia; // From tag\n\n    _this.fromTag = newTag(); // Invite without SDP\n\n    _this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : _this.inviteWithoutSdp; // Inviter options (could do better copying these options)\n\n    var inviterOptions = Object.assign({}, options);\n    inviterOptions.params = Object.assign({}, options.params); // Anonymous call\n\n    var anonymous = options.anonymous || false; // Contact\n\n    var contact = userAgent.contact.toString({\n      anonymous: anonymous,\n      // Do not add ;ob in initial forming dialog requests if the\n      // registration over the current connection got a GRUU URI.\n      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu\n    }); // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception\n    // which is not something we want our constructor to do. URIs should be passed in as params.\n    // URIs\n\n    if (anonymous && userAgent.configuration.uri) {\n      inviterOptions.params.fromDisplayName = \"Anonymous\";\n      inviterOptions.params.fromUri = \"sip:anonymous@anonymous.invalid\";\n    }\n\n    var fromURI = userAgent.userAgentCore.configuration.aor;\n\n    if (inviterOptions.params.fromUri) {\n      fromURI = typeof inviterOptions.params.fromUri === \"string\" ? Grammar.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;\n    }\n\n    if (!fromURI) {\n      throw new TypeError(\"Invalid from URI: \" + inviterOptions.params.fromUri);\n    }\n\n    var toURI = targetURI;\n\n    if (inviterOptions.params.toUri) {\n      toURI = typeof inviterOptions.params.toUri === \"string\" ? Grammar.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;\n    }\n\n    if (!toURI) {\n      throw new TypeError(\"Invalid to URI: \" + inviterOptions.params.toUri);\n    } // Params\n\n\n    var messageOptions = Object.assign({}, inviterOptions.params);\n    messageOptions.fromTag = _this.fromTag; // Extra headers\n\n    var extraHeaders = (inviterOptions.extraHeaders || []).slice();\n\n    if (anonymous && userAgent.configuration.uri) {\n      extraHeaders.push(\"P-Preferred-Identity: \" + userAgent.configuration.uri.toString());\n      extraHeaders.push(\"Privacy: id\");\n    }\n\n    extraHeaders.push(\"Contact: \" + contact);\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n\n    if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {\n      extraHeaders.push(\"Require: 100rel\");\n    }\n\n    if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {\n      extraHeaders.push(\"Require: replaces\");\n    }\n\n    inviterOptions.extraHeaders = extraHeaders; // Body\n\n    var body = undefined; // Make initial outgoing request message\n\n    _this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body); // Session parent properties\n\n    _this._contact = contact;\n    _this._referralInviterOptions = inviterOptions;\n    _this._renderbody = options.renderbody;\n    _this._rendertype = options.rendertype; // Modifiers and options for initial INVITE transaction\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      _this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      _this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // Modifiers and options for re-INVITE transactions\n\n\n    if (options.sessionDescriptionHandlerModifiersReInvite) {\n      _this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;\n    }\n\n    if (options.sessionDescriptionHandlerOptionsReInvite) {\n      _this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;\n    } // Identifier\n\n\n    _this._id = _this.outgoingRequestMessage.callId + _this.fromTag; // Add to the user agent's session collection.\n\n    _this.userAgent._sessions[_this._id] = _assertThisInitialized(_this);\n    return _this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(Inviter, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _this2 = this;\n\n      // Only run through this once. It can and does get called multiple times\n      // depending on the what the sessions state is when first called.\n      // For example, if called when \"establishing\" it will be called again\n      // at least once when the session transitions to \"terminated\".\n      // Regardless, running through this more than once is pointless.\n      if (this.disposed) {\n        return Promise.resolve();\n      }\n\n      this.disposed = true; // Dispose of early dialog media\n\n      this.disposeEarlyMedia(); // If the final response for the initial INVITE not yet been received, cancel it\n\n      switch (this.state) {\n        case SessionState.Initial:\n          return this.cancel().then(function () {\n            return _get(_getPrototypeOf(Inviter.prototype), \"dispose\", _this2).call(_this2);\n          });\n\n        case SessionState.Establishing:\n          return this.cancel().then(function () {\n            return _get(_getPrototypeOf(Inviter.prototype), \"dispose\", _this2).call(_this2);\n          });\n\n        case SessionState.Established:\n          return _get(_getPrototypeOf(Inviter.prototype), \"dispose\", this).call(this);\n\n        case SessionState.Terminating:\n          return _get(_getPrototypeOf(Inviter.prototype), \"dispose\", this).call(this);\n\n        case SessionState.Terminated:\n          return _get(_getPrototypeOf(Inviter.prototype), \"dispose\", this).call(this);\n\n        default:\n          throw new Error(\"Unknown state.\");\n      }\n    }\n    /**\n     * Initial outgoing INVITE request message body.\n     */\n\n  }, {\n    key: \"cancel\",\n\n    /**\n     * Cancels the INVITE request.\n     *\n     * @remarks\n     * Sends a CANCEL request.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * After sending a CANCEL request the expectation is that a 487 final response\n     * will be received for the INVITE. However a 200 final response to the INVITE\n     * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before\n     * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect\n     * is that this method will terminate the session regardless of the race.\n     * @param options - Options bucket.\n     */\n    value: function cancel() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Inviter.cancel\"); // validate state\n\n      if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n        var error = new Error(\"Invalid session state \".concat(this.state));\n        this.logger.error(error.message);\n        return Promise.reject(error);\n      } // flag canceled\n\n\n      this.isCanceled = true; // transition state\n\n      this.stateTransition(SessionState.Terminating); // helper function\n\n      function getCancelReason(code, reason) {\n        if (code && code < 200 || code > 699) {\n          throw new TypeError(\"Invalid statusCode: \" + code);\n        } else if (code) {\n          var cause = code;\n          var text = getReasonPhrase(code) || reason;\n          return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n        }\n      }\n\n      if (this.outgoingInviteRequest) {\n        // the CANCEL may not be respected by peer(s), so don't transition to terminated\n        var cancelReason;\n\n        if (options.statusCode && options.reasonPhrase) {\n          cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);\n        }\n\n        this.outgoingInviteRequest.cancel(cancelReason, options);\n      } else {\n        this.logger.warn(\"Canceled session before INVITE was sent\");\n        this.stateTransition(SessionState.Terminated);\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * Sends the INVITE request.\n     *\n     * @remarks\n     * TLDR...\n     *  1) Only one offer/answer exchange permitted during initial INVITE.\n     *  2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *  3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * 1) Only one offer/answer exchange permitted during initial INVITE.\n     *\n     * Our implementation replaces the following bullet point...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MAY generate subsequent offers in requests based on rules\n     *    specified for that method, but only if it has received answers\n     *    to any previous offers, and has not sent any offers to which it\n     *    hasn't gotten an answer.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...with...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MUST NOT generate subsequent offers in requests based on rules\n     *    specified for that method.\n     *\n     * ...which in combination with this bullet point...\n     *\n     * o  Once the UAS has sent or received an answer to the initial\n     *    offer, it MUST NOT generate subsequent offers in any responses\n     *    to the initial INVITE.  This means that a UAS based on this\n     *    specification alone can never generate subsequent offers until\n     *    completion of the initial transaction.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...ensures that EXACTLY ONE offer/answer exchange will occur\n     * during an initial out of dialog INVITE request made by our UAC.\n     *\n     *\n     * 2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *\n     * While our implementation adheres to the following bullet point...\n     *\n     * o  If the initial offer is in an INVITE, the answer MUST be in a\n     *    reliable non-failure message from UAS back to UAC which is\n     *    correlated to that INVITE.  For this specification, that is\n     *    only the final 2xx response to that INVITE.  That same exact\n     *    answer MAY also be placed in any provisional responses sent\n     *    prior to the answer.  The UAC MUST treat the first session\n     *    description it receives as the answer, and MUST ignore any\n     *    session descriptions in subsequent responses to the initial\n     *    INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * We have made the following implementation decision with regard to early media...\n     *\n     * o  If the initial offer is in the INVITE, the answer from the\n     *    UAS back to the UAC will establish a media session only\n     *    only after the final 2xx response to that INVITE is received.\n     *\n     * The reason for this decision is rooted in a restriction currently\n     * inherent in WebRTC. Specifically, while a SIP INVITE request with an\n     * initial offer may fork resulting in more than one provisional answer,\n     * there is currently no easy/good way to to \"fork\" an offer generated\n     * by a peer connection. In particular, a WebRTC offer currently may only\n     * be matched with one answer and we have no good way to know which\n     * \"provisional answer\" is going to be the \"final answer\". So we have\n     * decided to punt and not create any \"early media\" sessions in this case.\n     *\n     * The upshot is that if you want \"early media\", you must not put the\n     * initial offer in the INVITE. Instead, force the UAS to provide the\n     * initial offer by sending an INVITE without an offer. In the WebRTC\n     * case this allows us to create a unique peer connection with a unique\n     * answer for every provisional offer with \"early media\" on all of them.\n     *\n     *\n     * 3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * The default behavior may be altered and \"early media\" utilized if the\n     * initial offer is in the an INVITE by setting the `earlyMedia` options.\n     * However in that case the INVITE request MUST NOT fork. This allows for\n     * \"early media\" in environments where the forking behavior of the SIP\n     * servers being utilized is configured to disallow forking.\n     */\n\n  }, {\n    key: \"invite\",\n    value: function invite() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Inviter.invite\"); // validate state\n\n      if (this.state !== SessionState.Initial) {\n        // re-invite\n        return _get(_getPrototypeOf(Inviter.prototype), \"invite\", this).call(this, options);\n      } // Modifiers and options for initial INVITE transaction\n\n\n      if (options.sessionDescriptionHandlerModifiers) {\n        this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n      }\n\n      if (options.sessionDescriptionHandlerOptions) {\n        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n      } // just send an INVITE with no sdp...\n\n\n      if (options.withoutSdp || this.inviteWithoutSdp) {\n        if (this._renderbody && this._rendertype) {\n          this.outgoingRequestMessage.body = {\n            contentType: this._rendertype,\n            body: this._renderbody\n          };\n        } // transition state\n\n\n        this.stateTransition(SessionState.Establishing);\n        return Promise.resolve(this.sendInvite(options));\n      } // get an offer and send it in an INVITE\n\n\n      var offerOptions = {\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n      };\n      return this.getOffer(offerOptions).then(function (body) {\n        _this3.outgoingRequestMessage.body = {\n          body: body.content,\n          contentType: body.contentType\n        }; // transition state\n\n        _this3.stateTransition(SessionState.Establishing);\n\n        return _this3.sendInvite(options);\n      }).catch(function (error) {\n        _this3.logger.log(error.message);\n\n        _this3.stateTransition(SessionState.Terminated);\n\n        throw error;\n      });\n    }\n    /**\n     * 13.2.1 Creating the Initial INVITE\n     *\n     * Since the initial INVITE represents a request outside of a dialog,\n     * its construction follows the procedures of Section 8.1.1.  Additional\n     * processing is required for the specific case of INVITE.\n     *\n     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.\n     * It indicates what methods can be invoked within a dialog, on the UA\n     * sending the INVITE, for the duration of the dialog.  For example, a\n     * UA capable of receiving INFO requests within a dialog [34] SHOULD\n     * include an Allow header field listing the INFO method.\n     *\n     * A Supported header field (Section 20.37) SHOULD be present in the\n     * INVITE.  It enumerates all the extensions understood by the UAC.\n     *\n     * An Accept (Section 20.1) header field MAY be present in the INVITE.\n     * It indicates which Content-Types are acceptable to the UA, in both\n     * the response received by it, and in any subsequent requests sent to\n     * it within dialogs established by the INVITE.  The Accept header field\n     * is especially useful for indicating support of various session\n     * description formats.\n     *\n     * The UAC MAY add an Expires header field (Section 20.19) to limit the\n     * validity of the invitation.  If the time indicated in the Expires\n     * header field is reached and no final answer for the INVITE has been\n     * received, the UAC core SHOULD generate a CANCEL request for the\n     * INVITE, as per Section 9.\n     *\n     * A UAC MAY also find it useful to add, among others, Subject (Section\n     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)\n     * header fields.  They all contain information related to the INVITE.\n     *\n     * The UAC MAY choose to add a message body to the INVITE.  Section\n     * 8.1.1.10 deals with how to construct the header fields -- Content-\n     * Type among others -- needed to describe the message body.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     */\n\n  }, {\n    key: \"sendInvite\",\n    value: function sendInvite() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      //    There are special rules for message bodies that contain a session\n      //    description - their corresponding Content-Disposition is \"session\".\n      //    SIP uses an offer/answer model where one UA sends a session\n      //    description, called the offer, which contains a proposed description\n      //    of the session.  The offer indicates the desired communications means\n      //    (audio, video, games), parameters of those means (such as codec\n      //    types) and addresses for receiving media from the answerer.  The\n      //    other UA responds with another session description, called the\n      //    answer, which indicates which communications means are accepted, the\n      //    parameters that apply to those means, and addresses for receiving\n      //    media from the offerer. An offer/answer exchange is within the\n      //    context of a dialog, so that if a SIP INVITE results in multiple\n      //    dialogs, each is a separate offer/answer exchange.  The offer/answer\n      //    model defines restrictions on when offers and answers can be made\n      //    (for example, you cannot make a new offer while one is in progress).\n      //    This results in restrictions on where the offers and answers can\n      //    appear in SIP messages.  In this specification, offers and answers\n      //    can only appear in INVITE requests and responses, and ACK.  The usage\n      //    of offers and answers is further restricted.  For the initial INVITE\n      //    transaction, the rules are:\n      //\n      //       o  The initial offer MUST be in either an INVITE or, if not there,\n      //          in the first reliable non-failure message from the UAS back to\n      //          the UAC.  In this specification, that is the final 2xx\n      //          response.\n      //\n      //       o  If the initial offer is in an INVITE, the answer MUST be in a\n      //          reliable non-failure message from UAS back to UAC which is\n      //          correlated to that INVITE.  For this specification, that is\n      //          only the final 2xx response to that INVITE.  That same exact\n      //          answer MAY also be placed in any provisional responses sent\n      //          prior to the answer.  The UAC MUST treat the first session\n      //          description it receives as the answer, and MUST ignore any\n      //          session descriptions in subsequent responses to the initial\n      //          INVITE.\n      //\n      //       o  If the initial offer is in the first reliable non-failure\n      //          message from the UAS back to UAC, the answer MUST be in the\n      //          acknowledgement for that message (in this specification, ACK\n      //          for a 2xx response).\n      //\n      //       o  After having sent or received an answer to the first offer, the\n      //          UAC MAY generate subsequent offers in requests based on rules\n      //          specified for that method, but only if it has received answers\n      //          to any previous offers, and has not sent any offers to which it\n      //          hasn't gotten an answer.\n      //\n      //       o  Once the UAS has sent or received an answer to the initial\n      //          offer, it MUST NOT generate subsequent offers in any responses\n      //          to the initial INVITE.  This means that a UAS based on this\n      //          specification alone can never generate subsequent offers until\n      //          completion of the initial transaction.\n      //\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      // 5 The Offer/Answer Model and PRACK\n      //\n      //    RFC 3261 describes guidelines for the sets of messages in which\n      //    offers and answers [3] can appear.  Based on those guidelines, this\n      //    extension provides additional opportunities for offer/answer\n      //    exchanges.\n      //    If the INVITE contained an offer, the UAS MAY generate an answer in a\n      //    reliable provisional response (assuming these are supported by the\n      //    UAC).  That results in the establishment of the session before\n      //    completion of the call.  Similarly, if a reliable provisional\n      //    response is the first reliable message sent back to the UAC, and the\n      //    INVITE did not contain an offer, one MUST appear in that reliable\n      //    provisional response.\n      //    If the UAC receives a reliable provisional response with an offer\n      //    (this would occur if the UAC sent an INVITE without an offer, in\n      //    which case the first reliable provisional response will contain the\n      //    offer), it MUST generate an answer in the PRACK.  If the UAC receives\n      //    a reliable provisional response with an answer, it MAY generate an\n      //    additional offer in the PRACK.  If the UAS receives a PRACK with an\n      //    offer, it MUST place the answer in the 2xx to the PRACK.\n      //    Once an answer has been sent or received, the UA SHOULD establish the\n      //    session based on the parameters of the offer and answer, even if the\n      //    original INVITE itself has not been responded to.\n      //    If the UAS had placed a session description in any reliable\n      //    provisional response that is unacknowledged when the INVITE is\n      //    accepted, the UAS MUST delay sending the 2xx until the provisional\n      //    response is acknowledged.  Otherwise, the reliability of the 1xx\n      //    cannot be guaranteed, and reliability is needed for proper operation\n      //    of the offer/answer exchange.\n      //    All user agents that support this extension MUST support all\n      //    offer/answer exchanges that are possible based on the rules in\n      //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK\n      //    as requests, and 2xx and reliable 1xx as non-failure reliable\n      //    responses.\n      //\n      // https://tools.ietf.org/html/rfc3262#section-5\n      ////\n      // The Offer/Answer Model Implementation\n      //\n      // The offer/answer model is straight forward, but one MUST READ the specifications...\n      //\n      // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      //\n      // 5 The Offer/Answer Model and PRACK\n      // https://tools.ietf.org/html/rfc3262#section-5\n      //\n      // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model\n      // https://tools.ietf.org/html/rfc6337\n      ////\n      ////\n      // TODO: The Offer/Answer Model Implementation\n      //\n      // Currently if `earlyMedia` is enabled and the INVITE request forks,\n      // the session is terminated if the early dialog does not match the\n      // confirmed dialog. This restriction make sense in a WebRTC environment,\n      // but there are other environments where this restriction does not hold.\n      //\n      // So while we currently cannot make the offer in INVITE+forking+webrtc\n      // case work, we propose doing the following...\n      //\n      // OPTION 1\n      // - add a `earlyMediaForking` option and\n      // - require SDH.setDescription() to be callable multiple times.\n      //\n      // OPTION 2\n      // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...\n      // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...\n      // 3) ask SDH Factory if it supports \"earlyRemoteAnswer\"\n      //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)\n      //   b) if false, defer getting a SDH until 2xx response is received\n      //\n      // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)\n      // early media if initial offer is in the INVITE). We will, however, provide an \"inviteWillNotFork\"\n      // option which if set to \"true\" will have our supplied WebRTC SDH behave in the 3a manner.\n      // That will result in\n      //  - early media working with initial offer in the INVITE, and...\n      //  - if the INVITE forks, the session terminating with an ERROR that reads like\n      //    \"You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too.\"\n      //  - furthermore, we accept that users will report that error to us as \"bug\" regardless\n      //\n      // So, SDH Factory is going to end up with a new interface along the lines of...\n      //\n      // interface SessionDescriptionHandlerFactory {\n      //   makeLocalOffer(): Promise<ContentTypeAndBody>;\n      //   makeSessionDescriptionHandler(\n      //     initialOffer: ContentTypeAndBody, offerType: \"local\" | \"remote\"\n      //   ): Promise<SessionDescriptionHandler>;\n      //   supportsEarlyRemoteAnswer: boolean;\n      //   supportsContentType(contentType: string): boolean;\n      //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>\n      //   setDescription(description: ContentTypeAndBody): Promise<void>\n      // }\n      ////\n      // Send the INVITE request.\n      this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {\n        onAccept: function onAccept(inviteResponse) {\n          // Our transaction layer is \"non-standard\" in that it will only\n          // pass us a 2xx response once per branch, so there is no need to\n          // worry about dealing with 2xx retransmissions. However, we can\n          // and do still get 2xx responses for multiple branches (when an\n          // INVITE is forked) which may create multiple confirmed dialogs.\n          // Herein we are acking and sending a bye to any confirmed dialogs\n          // which arrive beyond the first one. This is the desired behavior\n          // for most applications (but certainly not all).\n          // If we already received a confirmed dialog, ack & bye this additional confirmed session.\n          if (_this4.dialog) {\n            _this4.logger.log(\"Additional confirmed dialog, sending ACK and BYE\");\n\n            _this4.ackAndBye(inviteResponse); // We do NOT transition state in this case (this is an \"extra\" dialog)\n\n\n            return;\n          } // If the user requested cancellation, ack & bye this session.\n\n\n          if (_this4.isCanceled) {\n            _this4.logger.log(\"Canceled session accepted, sending ACK and BYE\");\n\n            _this4.ackAndBye(inviteResponse);\n\n            _this4.stateTransition(SessionState.Terminated);\n\n            return;\n          }\n\n          _this4.notifyReferer(inviteResponse);\n\n          _this4.onAccept(inviteResponse).then(function () {\n            _this4.disposeEarlyMedia();\n          }).catch(function () {\n            _this4.disposeEarlyMedia();\n          }).then(function () {\n            if (options.requestDelegate && options.requestDelegate.onAccept) {\n              options.requestDelegate.onAccept(inviteResponse);\n            }\n          });\n        },\n        onProgress: function onProgress(inviteResponse) {\n          // If the user requested cancellation, ignore response.\n          if (_this4.isCanceled) {\n            return;\n          }\n\n          _this4.notifyReferer(inviteResponse);\n\n          _this4.onProgress(inviteResponse).catch(function () {\n            _this4.disposeEarlyMedia();\n          }).then(function () {\n            if (options.requestDelegate && options.requestDelegate.onProgress) {\n              options.requestDelegate.onProgress(inviteResponse);\n            }\n          });\n        },\n        onRedirect: function onRedirect(inviteResponse) {\n          _this4.notifyReferer(inviteResponse);\n\n          _this4.onRedirect(inviteResponse);\n\n          if (options.requestDelegate && options.requestDelegate.onRedirect) {\n            options.requestDelegate.onRedirect(inviteResponse);\n          }\n        },\n        onReject: function onReject(inviteResponse) {\n          _this4.notifyReferer(inviteResponse);\n\n          _this4.onReject(inviteResponse);\n\n          if (options.requestDelegate && options.requestDelegate.onReject) {\n            options.requestDelegate.onReject(inviteResponse);\n          }\n        },\n        onTrying: function onTrying(inviteResponse) {\n          _this4.notifyReferer(inviteResponse);\n\n          _this4.onTrying(inviteResponse);\n\n          if (options.requestDelegate && options.requestDelegate.onTrying) {\n            options.requestDelegate.onTrying(inviteResponse);\n          }\n        }\n      });\n      return this.outgoingInviteRequest;\n    }\n  }, {\n    key: \"disposeEarlyMedia\",\n    value: function disposeEarlyMedia() {\n      this.earlyMediaSessionDescriptionHandlers.forEach(function (sessionDescriptionHandler) {\n        sessionDescriptionHandler.close();\n      });\n      this.earlyMediaSessionDescriptionHandlers.clear();\n    }\n  }, {\n    key: \"notifyReferer\",\n    value: function notifyReferer(response) {\n      var _this5 = this;\n\n      if (!this._referred) {\n        return;\n      }\n\n      if (!(this._referred instanceof Session)) {\n        throw new Error(\"Referred session not instance of session\");\n      }\n\n      if (!this._referred.dialog) {\n        return;\n      }\n\n      if (!response.message.statusCode) {\n        throw new Error(\"Status code undefined.\");\n      }\n\n      if (!response.message.reasonPhrase) {\n        throw new Error(\"Reason phrase undefined.\");\n      }\n\n      var statusCode = response.message.statusCode;\n      var reasonPhrase = response.message.reasonPhrase;\n      var body = \"SIP/2.0 \".concat(statusCode, \" \").concat(reasonPhrase).trim();\n\n      var outgoingNotifyRequest = this._referred.dialog.notify(undefined, {\n        extraHeaders: [\"Event: refer\", \"Subscription-State: terminated\"],\n        body: {\n          contentDisposition: \"render\",\n          contentType: \"message/sipfrag\",\n          content: body\n        }\n      }); // The implicit subscription created by a REFER is the same as a\n      // subscription created with a SUBSCRIBE request.  The agent issuing the\n      // REFER can terminate this subscription prematurely by unsubscribing\n      // using the mechanisms described in [2].  Terminating a subscription,\n      // either by explicitly unsubscribing or rejecting NOTIFY, is not an\n      // indication that the referenced request should be withdrawn or\n      // abandoned.\n      // https://tools.ietf.org/html/rfc3515#section-2.4.4\n      // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.\n      // If the notify is rejected, stop sending NOTIFY requests.\n\n\n      outgoingNotifyRequest.delegate = {\n        onReject: function onReject() {\n          _this5._referred = undefined;\n        }\n      };\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 2xx response.\n     */\n\n  }, {\n    key: \"onAccept\",\n    value: function onAccept(inviteResponse) {\n      var _this6 = this;\n\n      this.logger.log(\"Inviter.onAccept\"); // validate state\n\n      if (this.state !== SessionState.Establishing) {\n        this.logger.error(\"Accept received while in state \".concat(this.state, \", dropping response\"));\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      var response = inviteResponse.message;\n      var session = inviteResponse.session; // Ported behavior.\n\n      if (response.hasHeader(\"P-Asserted-Identity\")) {\n        this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n      } // We have a confirmed dialog.\n\n\n      session.delegate = {\n        onAck: function onAck(ackRequest) {\n          return _this6.onAckRequest(ackRequest);\n        },\n        onBye: function onBye(byeRequest) {\n          return _this6.onByeRequest(byeRequest);\n        },\n        onInfo: function onInfo(infoRequest) {\n          return _this6.onInfoRequest(infoRequest);\n        },\n        onInvite: function onInvite(inviteRequest) {\n          return _this6.onInviteRequest(inviteRequest);\n        },\n        onMessage: function onMessage(messageRequest) {\n          return _this6.onMessageRequest(messageRequest);\n        },\n        onNotify: function onNotify(notifyRequest) {\n          return _this6.onNotifyRequest(notifyRequest);\n        },\n        onPrack: function onPrack(prackRequest) {\n          return _this6.onPrackRequest(prackRequest);\n        },\n        onRefer: function onRefer(referRequest) {\n          return _this6.onReferRequest(referRequest);\n        }\n      };\n      this._dialog = session;\n\n      switch (session.signalingState) {\n        case SignalingState.Initial:\n          // INVITE without offer, so MUST have offer at this point, so invalid state.\n          this.logger.error(\"Received 2xx response to INVITE without a session description\");\n          this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n          this.stateTransition(SessionState.Terminated);\n          return Promise.reject(new Error(\"Bad Media Description\"));\n\n        case SignalingState.HaveLocalOffer:\n          // INVITE with offer, so MUST have answer at this point, so invalid state.\n          this.logger.error(\"Received 2xx response to INVITE without a session description\");\n          this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n          this.stateTransition(SessionState.Terminated);\n          return Promise.reject(new Error(\"Bad Media Description\"));\n\n        case SignalingState.HaveRemoteOffer:\n          {\n            // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.\n            if (!this._dialog.offer) {\n              throw new Error(\"Session offer undefined in signaling state \".concat(this._dialog.signalingState, \".\"));\n            }\n\n            var options = {\n              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n            };\n            return this.setOfferAndGetAnswer(this._dialog.offer, options).then(function (body) {\n              inviteResponse.ack({\n                body: body\n              });\n\n              _this6.stateTransition(SessionState.Established);\n            }).catch(function (error) {\n              _this6.ackAndBye(inviteResponse, 488, \"Invalid session description\");\n\n              _this6.stateTransition(SessionState.Terminated);\n\n              throw error;\n            });\n          }\n\n        case SignalingState.Stable:\n          {\n            // If INVITE without offer and we have already completed the initial exchange.\n            if (this.earlyMediaSessionDescriptionHandlers.size > 0) {\n              var sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);\n\n              if (!sdh) {\n                throw new Error(\"Session description handler undefined.\");\n              }\n\n              this.setSessionDescriptionHandler(sdh);\n              this.earlyMediaSessionDescriptionHandlers.delete(session.id);\n              inviteResponse.ack();\n              this.stateTransition(SessionState.Established);\n              return Promise.resolve();\n            } // If INVITE with offer and we used an \"early\" answer in a provisional response for media\n\n\n            if (this.earlyMediaDialog) {\n              // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.\n              // This limitation stems from how WebRTC currently implements its offer/answer model.\n              // There are details elsewhere, but in short a WebRTC offer cannot be forked.\n              if (this.earlyMediaDialog !== session) {\n                if (this.earlyMedia) {\n                  var message = \"You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests \" + \"do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly \" + \"the end point which accepted the INVITE (confirmed dialog) does not match the end point with \" + \"which early media has been setup (early dialog) and thus this session is unable to proceed. \" + \"In accordance with the SIP specifications, the SIP servers your end point is connected to \" + \"determine if an INVITE forks and the forking behavior of those servers cannot be controlled \" + \"by this library. If you wish to use early media with this library you must configure those \" + \"servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow \" + \"this library to function with any INVITE requests which do fork.\";\n                  this.logger.error(message);\n                }\n\n                var error = new Error(\"Early media dialog does not equal confirmed dialog, terminating session\");\n                this.logger.error(error.message);\n                this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n                this.stateTransition(SessionState.Terminated);\n                return Promise.reject(error);\n              } // Otherwise we are good to go.\n\n\n              inviteResponse.ack();\n              this.stateTransition(SessionState.Established);\n              return Promise.resolve();\n            } // If INVITE with offer and we have been waiting till now to apply the answer.\n\n\n            var answer = session.answer;\n\n            if (!answer) {\n              throw new Error(\"Answer is undefined.\");\n            }\n\n            var _options = {\n              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n            };\n            return this.setAnswer(answer, _options).then(function () {\n              // This session has completed an initial offer/answer exchange...\n              var ackOptions;\n\n              if (_this6._renderbody && _this6._rendertype) {\n                ackOptions = {\n                  body: {\n                    contentDisposition: \"render\",\n                    contentType: _this6._rendertype,\n                    content: _this6._renderbody\n                  }\n                };\n              }\n\n              inviteResponse.ack(ackOptions);\n\n              _this6.stateTransition(SessionState.Established);\n            }).catch(function (error) {\n              _this6.logger.error(error.message);\n\n              _this6.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n\n              _this6.stateTransition(SessionState.Terminated);\n\n              throw error;\n            });\n          }\n\n        case SignalingState.Closed:\n          // Dialog has terminated.\n          return Promise.reject(new Error(\"Terminated.\"));\n\n        default:\n          throw new Error(\"Unknown session signaling state.\");\n      }\n    }\n    /**\n     * Handle provisional response to initial INVITE.\n     * @param inviteResponse - 1xx response.\n     */\n\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(inviteResponse) {\n      var _this7 = this;\n\n      var _a;\n\n      this.logger.log(\"Inviter.onProgress\"); // validate state\n\n      if (this.state !== SessionState.Establishing) {\n        this.logger.error(\"Progress received while in state \".concat(this.state, \", dropping response\"));\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      if (!this.outgoingInviteRequest) {\n        throw new Error(\"Outgoing INVITE request undefined.\");\n      }\n\n      var response = inviteResponse.message;\n      var session = inviteResponse.session; // Ported - Set assertedIdentity.\n\n      if (response.hasHeader(\"P-Asserted-Identity\")) {\n        this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n      } // If a provisional response is received for an initial request, and\n      // that response contains a Require header field containing the option\n      // tag 100rel, the response is to be sent reliably.  If the response is\n      // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n      // ignored, and the procedures below MUST NOT be used.\n      // https://tools.ietf.org/html/rfc3262#section-4\n\n\n      var requireHeader = response.getHeader(\"require\");\n      var rseqHeader = response.getHeader(\"rseq\");\n      var rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n      var responseReliable = !!rseq;\n      var extraHeaders = [];\n\n      if (responseReliable) {\n        extraHeaders.push(\"RAck: \" + response.getHeader(\"rseq\") + \" \" + response.getHeader(\"cseq\"));\n      }\n\n      switch (session.signalingState) {\n        case SignalingState.Initial:\n          // INVITE without offer and session still has no offer (and no answer).\n          if (responseReliable) {\n            // Similarly, if a reliable provisional\n            // response is the first reliable message sent back to the UAC, and the\n            // INVITE did not contain an offer, one MUST appear in that reliable\n            // provisional response.\n            // https://tools.ietf.org/html/rfc3262#section-5\n            this.logger.warn(\"First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.\"); // FIXME: Known popular UA's currently end up here...\n\n            inviteResponse.prack({\n              extraHeaders: extraHeaders\n            });\n          }\n\n          return Promise.resolve();\n\n        case SignalingState.HaveLocalOffer:\n          // INVITE with offer and session only has that initial local offer.\n          if (responseReliable) {\n            inviteResponse.prack({\n              extraHeaders: extraHeaders\n            });\n          }\n\n          return Promise.resolve();\n\n        case SignalingState.HaveRemoteOffer:\n          if (!responseReliable) {\n            // The initial offer MUST be in either an INVITE or, if not there,\n            // in the first reliable non-failure message from the UAS back to\n            // the UAC.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            // According to Section 13.2.1 of [RFC3261], 'The first reliable\n            // non-failure message' must have an offer if there is no offer in the\n            // INVITE request.  This means that the User Agent (UA) that receives\n            // the INVITE request without an offer must include an offer in the\n            // first reliable response with 100rel extension.  If no reliable\n            // provisional response has been sent, the User Agent Server (UAS) must\n            // include an offer when sending 2xx response.\n            // https://tools.ietf.org/html/rfc6337#section-2.2\n            this.logger.warn(\"Non-reliable provisional response MUST NOT contain an initial offer, discarding response.\");\n            return Promise.resolve();\n          }\n\n          {\n            // If the initial offer is in the first reliable non-failure\n            // message from the UAS back to UAC, the answer MUST be in the\n            // acknowledgement for that message\n            var sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});\n\n            if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n              this.delegate.onSessionDescriptionHandler(sdh, true);\n            }\n\n            this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);\n            return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(function () {\n              return sdh.getDescription(_this7.sessionDescriptionHandlerOptions, _this7.sessionDescriptionHandlerModifiers);\n            }).then(function (description) {\n              var body = {\n                contentDisposition: \"session\",\n                contentType: description.contentType,\n                content: description.body\n              };\n              inviteResponse.prack({\n                extraHeaders: extraHeaders,\n                body: body\n              });\n            }).catch(function (error) {\n              _this7.stateTransition(SessionState.Terminated);\n\n              throw error;\n            });\n          }\n\n        case SignalingState.Stable:\n          // This session has completed an initial offer/answer exchange, so...\n          // - INVITE with SDP and this provisional response MAY be reliable\n          // - INVITE without SDP and this provisional response MAY be reliable\n          if (responseReliable) {\n            inviteResponse.prack({\n              extraHeaders: extraHeaders\n            });\n          }\n\n          if (this.earlyMedia && !this.earlyMediaDialog) {\n            this.earlyMediaDialog = session;\n            var answer = session.answer;\n\n            if (!answer) {\n              throw new Error(\"Answer is undefined.\");\n            }\n\n            var options = {\n              sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n              sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n            };\n            return this.setAnswer(answer, options).catch(function (error) {\n              _this7.stateTransition(SessionState.Terminated);\n\n              throw error;\n            });\n          }\n\n          return Promise.resolve();\n\n        case SignalingState.Closed:\n          // Dialog has terminated.\n          return Promise.reject(new Error(\"Terminated.\"));\n\n        default:\n          throw new Error(\"Unknown session signaling state.\");\n      }\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 3xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onRedirect\",\n    value: function onRedirect(inviteResponse) {\n      this.logger.log(\"Inviter.onRedirect\"); // validate state\n\n      if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n        this.logger.error(\"Redirect received while in state \".concat(this.state, \", dropping response\"));\n        return;\n      } // transition state\n\n\n      this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 4xx, 5xx, or 6xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onReject\",\n    value: function onReject(inviteResponse) {\n      this.logger.log(\"Inviter.onReject\"); // validate state\n\n      if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n        this.logger.error(\"Reject received while in state \".concat(this.state, \", dropping response\"));\n        return;\n      } // transition state\n\n\n      this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 100 response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onTrying\",\n    value: function onTrying(inviteResponse) {\n      this.logger.log(\"Inviter.onTrying\"); // validate state\n\n      if (this.state !== SessionState.Establishing) {\n        this.logger.error(\"Trying received while in state \".concat(this.state, \", dropping response\"));\n        return;\n      }\n    }\n  }, {\n    key: \"body\",\n    get: function get() {\n      return this.outgoingRequestMessage.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n\n  }, {\n    key: \"localIdentity\",\n    get: function get() {\n      return this.outgoingRequestMessage.from;\n    }\n    /**\n     * The identity of the remote user.\n     */\n\n  }, {\n    key: \"remoteIdentity\",\n    get: function get() {\n      return this.outgoingRequestMessage.to;\n    }\n    /**\n     * Initial outgoing INVITE request message.\n     */\n\n  }, {\n    key: \"request\",\n    get: function get() {\n      return this.outgoingRequestMessage;\n    }\n  }]);\n\n  return Inviter;\n}(Session);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/inviter.js"],"names":["C","Grammar","SignalingState","getReasonPhrase","newTag","Session","SessionState","SIPExtension","Inviter","userAgent","targetURI","options","disposed","earlyMedia","earlyMediaSessionDescriptionHandlers","Map","isCanceled","inviteWithoutSdp","logger","getLogger","undefined","fromTag","inviterOptions","Object","assign","params","anonymous","contact","toString","outbound","tempGruu","pubGruu","configuration","uri","fromDisplayName","fromUri","fromURI","userAgentCore","aor","URIParse","TypeError","toURI","toUri","messageOptions","extraHeaders","slice","push","sipExtension100rel","Required","sipExtensionReplaces","body","outgoingRequestMessage","makeOutgoingRequestMessage","INVITE","_contact","_referralInviterOptions","_renderbody","renderbody","_rendertype","rendertype","sessionDescriptionHandlerModifiers","sessionDescriptionHandlerOptions","sessionDescriptionHandlerModifiersReInvite","sessionDescriptionHandlerOptionsReInvite","_id","callId","_sessions","Promise","resolve","disposeEarlyMedia","state","Initial","cancel","then","Establishing","Established","Terminating","Terminated","Error","log","error","message","reject","stateTransition","getCancelReason","code","reason","cause","text","outgoingInviteRequest","cancelReason","statusCode","reasonPhrase","warn","withoutSdp","contentType","sendInvite","offerOptions","getOffer","content","catch","invite","onAccept","inviteResponse","dialog","ackAndBye","notifyReferer","requestDelegate","onProgress","onRedirect","onReject","onTrying","forEach","sessionDescriptionHandler","close","clear","response","_referred","trim","outgoingNotifyRequest","notify","contentDisposition","delegate","session","hasHeader","_assertedIdentity","nameAddrHeaderParse","getHeader","onAck","ackRequest","onAckRequest","onBye","byeRequest","onByeRequest","onInfo","infoRequest","onInfoRequest","onInvite","inviteRequest","onInviteRequest","onMessage","messageRequest","onMessageRequest","onNotify","notifyRequest","onNotifyRequest","onPrack","prackRequest","onPrackRequest","onRefer","referRequest","onReferRequest","_dialog","signalingState","HaveLocalOffer","HaveRemoteOffer","offer","setOfferAndGetAnswer","ack","Stable","size","sdh","get","id","setSessionDescriptionHandler","delete","earlyMediaDialog","answer","setAnswer","ackOptions","Closed","_a","requireHeader","rseqHeader","rseq","includes","Number","responseReliable","prack","sessionDescriptionHandlerFactory","sessionDescriptionHandlerFactoryOptions","onSessionDescriptionHandler","set","setDescription","getDescription","description","from","to"],"mappings":"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,UAAlC;AACH;;AACD,aAAOV,OAAO,CAACC,OAAR,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5SA;AAAA;AAAA,6BA6SyB;AAAA;;AAAA,UAAdzD,OAAc,uEAAJ,EAAI;AACjB,WAAKO,MAAL,CAAY6D,GAAZ,CAAgB,gBAAhB,EADiB,CAEjB;;AACA,UAAI,KAAKT,KAAL,KAAehE,YAAY,CAACiE,OAAhC,EAAyC;AACrC;AACA,mFAAoB5D,OAApB;AACH,OANgB,CAOjB;;;AACA,UAAIA,OAAO,CAACiD,kCAAZ,EAAgD;AAC5C,aAAKA,kCAAL,GAA0CjD,OAAO,CAACiD,kCAAlD;AACH;;AACD,UAAIjD,OAAO,CAACkD,gCAAZ,EAA8C;AAC1C,aAAKA,gCAAL,GAAwClD,OAAO,CAACkD,gCAAhD;AACH,OAbgB,CAcjB;;;AACA,UAAIlD,OAAO,CAACmF,UAAR,IAAsB,KAAK7E,gBAA/B,EAAiD;AAC7C,YAAI,KAAKuC,WAAL,IAAoB,KAAKE,WAA7B,EAA0C;AACtC,eAAKP,sBAAL,CAA4BD,IAA5B,GAAmC;AAAE6C,YAAAA,WAAW,EAAE,KAAKrC,WAApB;AAAiCR,YAAAA,IAAI,EAAE,KAAKM;AAA5C,WAAnC;AACH,SAH4C,CAI7C;;;AACA,aAAK2B,eAAL,CAAqB7E,YAAY,CAACoE,YAAlC;AACA,eAAOP,OAAO,CAACC,OAAR,CAAgB,KAAK4B,UAAL,CAAgBrF,OAAhB,CAAhB,CAAP;AACH,OAtBgB,CAuBjB;;;AACA,UAAMsF,YAAY,GAAG;AACjBrC,QAAAA,kCAAkC,EAAE,KAAKA,kCADxB;AAEjBC,QAAAA,gCAAgC,EAAE,KAAKA;AAFtB,OAArB;AAIA,aAAO,KAAKqC,QAAL,CAAcD,YAAd,EACFxB,IADE,CACG,UAACvB,IAAD,EAAU;AAChB,QAAA,MAAI,CAACC,sBAAL,CAA4BD,IAA5B,GAAmC;AAAEA,UAAAA,IAAI,EAAEA,IAAI,CAACiD,OAAb;AAAsBJ,UAAAA,WAAW,EAAE7C,IAAI,CAAC6C;AAAxC,SAAnC,CADgB,CAEhB;;AACA,QAAA,MAAI,CAACZ,eAAL,CAAqB7E,YAAY,CAACoE,YAAlC;;AACA,eAAO,MAAI,CAACsB,UAAL,CAAgBrF,OAAhB,CAAP;AACH,OANM,EAOFyF,KAPE,CAOI,UAACpB,KAAD,EAAW;AAClB,QAAA,MAAI,CAAC9D,MAAL,CAAY6D,GAAZ,CAAgBC,KAAK,CAACC,OAAtB;;AACA,QAAA,MAAI,CAACE,eAAL,CAAqB7E,YAAY,CAACuE,UAAlC;;AACA,cAAMG,KAAN;AACH,OAXM,CAAP;AAYH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5XA;AAAA;AAAA,iCA6X6B;AAAA;;AAAA,UAAdrE,OAAc,uEAAJ,EAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAK8E,qBAAL,GAA6B,KAAKhF,SAAL,CAAe4B,aAAf,CAA6BgE,MAA7B,CAAoC,KAAKlD,sBAAzC,EAAiE;AAC1FmD,QAAAA,QAAQ,EAAE,kBAACC,cAAD,EAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAI,MAAI,CAACC,MAAT,EAAiB;AACb,YAAA,MAAI,CAACtF,MAAL,CAAY6D,GAAZ,CAAgB,kDAAhB;;AACA,YAAA,MAAI,CAAC0B,SAAL,CAAeF,cAAf,EAFa,CAGb;;;AACA;AACH,WAfyB,CAgB1B;;;AACA,cAAI,MAAI,CAACvF,UAAT,EAAqB;AACjB,YAAA,MAAI,CAACE,MAAL,CAAY6D,GAAZ,CAAgB,gDAAhB;;AACA,YAAA,MAAI,CAAC0B,SAAL,CAAeF,cAAf;;AACA,YAAA,MAAI,CAACpB,eAAL,CAAqB7E,YAAY,CAACuE,UAAlC;;AACA;AACH;;AACD,UAAA,MAAI,CAAC6B,aAAL,CAAmBH,cAAnB;;AACA,UAAA,MAAI,CAACD,QAAL,CAAcC,cAAd,EACK9B,IADL,CACU,YAAM;AACZ,YAAA,MAAI,CAACJ,iBAAL;AACH,WAHD,EAIK+B,KAJL,CAIW,YAAM;AACb,YAAA,MAAI,CAAC/B,iBAAL;AACH,WAND,EAOKI,IAPL,CAOU,YAAM;AAC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","sourcesContent":["import { C, Grammar, SignalingState } from \"../core\";\nimport { getReasonPhrase, newTag } from \"../core/messages/utils\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An inviter offers to establish a {@link Session} (outgoing INVITE).\n * @public\n */\nexport class Inviter extends Session {\n    /**\n     * Constructs a new instance of the `Inviter` class.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param targetURI - Request URI identifying the target of the message.\n     * @param options - Options bucket. See {@link InviterOptions} for details.\n     */\n    constructor(userAgent, targetURI, options = {}) {\n        super(userAgent, options);\n        /** True if dispose() has been called. */\n        this.disposed = false;\n        /** True if early media use is enabled. */\n        this.earlyMedia = false;\n        /** The early media session description handlers. */\n        this.earlyMediaSessionDescriptionHandlers = new Map();\n        /** True if cancel() was called. */\n        this.isCanceled = false;\n        /** True if initial INVITE without SDP. */\n        this.inviteWithoutSdp = false;\n        this.logger = userAgent.getLogger(\"sip.Inviter\");\n        // Early media\n        this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : this.earlyMedia;\n        // From tag\n        this.fromTag = newTag();\n        // Invite without SDP\n        this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : this.inviteWithoutSdp;\n        // Inviter options (could do better copying these options)\n        const inviterOptions = Object.assign({}, options);\n        inviterOptions.params = Object.assign({}, options.params);\n        // Anonymous call\n        const anonymous = options.anonymous || false;\n        // Contact\n        const contact = userAgent.contact.toString({\n            anonymous,\n            // Do not add ;ob in initial forming dialog requests if the\n            // registration over the current connection got a GRUU URI.\n            outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu\n        });\n        // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception\n        // which is not something we want our constructor to do. URIs should be passed in as params.\n        // URIs\n        if (anonymous && userAgent.configuration.uri) {\n            inviterOptions.params.fromDisplayName = \"Anonymous\";\n            inviterOptions.params.fromUri = \"sip:anonymous@anonymous.invalid\";\n        }\n        let fromURI = userAgent.userAgentCore.configuration.aor;\n        if (inviterOptions.params.fromUri) {\n            fromURI =\n                typeof inviterOptions.params.fromUri === \"string\"\n                    ? Grammar.URIParse(inviterOptions.params.fromUri)\n                    : inviterOptions.params.fromUri;\n        }\n        if (!fromURI) {\n            throw new TypeError(\"Invalid from URI: \" + inviterOptions.params.fromUri);\n        }\n        let toURI = targetURI;\n        if (inviterOptions.params.toUri) {\n            toURI =\n                typeof inviterOptions.params.toUri === \"string\"\n                    ? Grammar.URIParse(inviterOptions.params.toUri)\n                    : inviterOptions.params.toUri;\n        }\n        if (!toURI) {\n            throw new TypeError(\"Invalid to URI: \" + inviterOptions.params.toUri);\n        }\n        // Params\n        const messageOptions = Object.assign({}, inviterOptions.params);\n        messageOptions.fromTag = this.fromTag;\n        // Extra headers\n        const extraHeaders = (inviterOptions.extraHeaders || []).slice();\n        if (anonymous && userAgent.configuration.uri) {\n            extraHeaders.push(\"P-Preferred-Identity: \" + userAgent.configuration.uri.toString());\n            extraHeaders.push(\"Privacy: id\");\n        }\n        extraHeaders.push(\"Contact: \" + contact);\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {\n            extraHeaders.push(\"Require: 100rel\");\n        }\n        if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {\n            extraHeaders.push(\"Require: replaces\");\n        }\n        inviterOptions.extraHeaders = extraHeaders;\n        // Body\n        const body = undefined;\n        // Make initial outgoing request message\n        this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body);\n        // Session parent properties\n        this._contact = contact;\n        this._referralInviterOptions = inviterOptions;\n        this._renderbody = options.renderbody;\n        this._rendertype = options.rendertype;\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // Modifiers and options for re-INVITE transactions\n        if (options.sessionDescriptionHandlerModifiersReInvite) {\n            this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;\n        }\n        if (options.sessionDescriptionHandlerOptionsReInvite) {\n            this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;\n        }\n        // Identifier\n        this._id = this.outgoingRequestMessage.callId + this.fromTag;\n        // Add to the user agent's session collection.\n        this.userAgent._sessions[this._id] = this;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        // Only run through this once. It can and does get called multiple times\n        // depending on the what the sessions state is when first called.\n        // For example, if called when \"establishing\" it will be called again\n        // at least once when the session transitions to \"terminated\".\n        // Regardless, running through this more than once is pointless.\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        // Dispose of early dialog media\n        this.disposeEarlyMedia();\n        // If the final response for the initial INVITE not yet been received, cancel it\n        switch (this.state) {\n            case SessionState.Initial:\n                return this.cancel().then(() => super.dispose());\n            case SessionState.Establishing:\n                return this.cancel().then(() => super.dispose());\n            case SessionState.Established:\n                return super.dispose();\n            case SessionState.Terminating:\n                return super.dispose();\n            case SessionState.Terminated:\n                return super.dispose();\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n    }\n    /**\n     * Initial outgoing INVITE request message body.\n     */\n    get body() {\n        return this.outgoingRequestMessage.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n    get localIdentity() {\n        return this.outgoingRequestMessage.from;\n    }\n    /**\n     * The identity of the remote user.\n     */\n    get remoteIdentity() {\n        return this.outgoingRequestMessage.to;\n    }\n    /**\n     * Initial outgoing INVITE request message.\n     */\n    get request() {\n        return this.outgoingRequestMessage;\n    }\n    /**\n     * Cancels the INVITE request.\n     *\n     * @remarks\n     * Sends a CANCEL request.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * After sending a CANCEL request the expectation is that a 487 final response\n     * will be received for the INVITE. However a 200 final response to the INVITE\n     * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before\n     * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect\n     * is that this method will terminate the session regardless of the race.\n     * @param options - Options bucket.\n     */\n    cancel(options = {}) {\n        this.logger.log(\"Inviter.cancel\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // flag canceled\n        this.isCanceled = true;\n        // transition state\n        this.stateTransition(SessionState.Terminating);\n        // helper function\n        function getCancelReason(code, reason) {\n            if ((code && code < 200) || code > 699) {\n                throw new TypeError(\"Invalid statusCode: \" + code);\n            }\n            else if (code) {\n                const cause = code;\n                const text = getReasonPhrase(code) || reason;\n                return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n            }\n        }\n        if (this.outgoingInviteRequest) {\n            // the CANCEL may not be respected by peer(s), so don't transition to terminated\n            let cancelReason;\n            if (options.statusCode && options.reasonPhrase) {\n                cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);\n            }\n            this.outgoingInviteRequest.cancel(cancelReason, options);\n        }\n        else {\n            this.logger.warn(\"Canceled session before INVITE was sent\");\n            this.stateTransition(SessionState.Terminated);\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Sends the INVITE request.\n     *\n     * @remarks\n     * TLDR...\n     *  1) Only one offer/answer exchange permitted during initial INVITE.\n     *  2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *  3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * 1) Only one offer/answer exchange permitted during initial INVITE.\n     *\n     * Our implementation replaces the following bullet point...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MAY generate subsequent offers in requests based on rules\n     *    specified for that method, but only if it has received answers\n     *    to any previous offers, and has not sent any offers to which it\n     *    hasn't gotten an answer.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...with...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MUST NOT generate subsequent offers in requests based on rules\n     *    specified for that method.\n     *\n     * ...which in combination with this bullet point...\n     *\n     * o  Once the UAS has sent or received an answer to the initial\n     *    offer, it MUST NOT generate subsequent offers in any responses\n     *    to the initial INVITE.  This means that a UAS based on this\n     *    specification alone can never generate subsequent offers until\n     *    completion of the initial transaction.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...ensures that EXACTLY ONE offer/answer exchange will occur\n     * during an initial out of dialog INVITE request made by our UAC.\n     *\n     *\n     * 2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *\n     * While our implementation adheres to the following bullet point...\n     *\n     * o  If the initial offer is in an INVITE, the answer MUST be in a\n     *    reliable non-failure message from UAS back to UAC which is\n     *    correlated to that INVITE.  For this specification, that is\n     *    only the final 2xx response to that INVITE.  That same exact\n     *    answer MAY also be placed in any provisional responses sent\n     *    prior to the answer.  The UAC MUST treat the first session\n     *    description it receives as the answer, and MUST ignore any\n     *    session descriptions in subsequent responses to the initial\n     *    INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * We have made the following implementation decision with regard to early media...\n     *\n     * o  If the initial offer is in the INVITE, the answer from the\n     *    UAS back to the UAC will establish a media session only\n     *    only after the final 2xx response to that INVITE is received.\n     *\n     * The reason for this decision is rooted in a restriction currently\n     * inherent in WebRTC. Specifically, while a SIP INVITE request with an\n     * initial offer may fork resulting in more than one provisional answer,\n     * there is currently no easy/good way to to \"fork\" an offer generated\n     * by a peer connection. In particular, a WebRTC offer currently may only\n     * be matched with one answer and we have no good way to know which\n     * \"provisional answer\" is going to be the \"final answer\". So we have\n     * decided to punt and not create any \"early media\" sessions in this case.\n     *\n     * The upshot is that if you want \"early media\", you must not put the\n     * initial offer in the INVITE. Instead, force the UAS to provide the\n     * initial offer by sending an INVITE without an offer. In the WebRTC\n     * case this allows us to create a unique peer connection with a unique\n     * answer for every provisional offer with \"early media\" on all of them.\n     *\n     *\n     * 3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * The default behavior may be altered and \"early media\" utilized if the\n     * initial offer is in the an INVITE by setting the `earlyMedia` options.\n     * However in that case the INVITE request MUST NOT fork. This allows for\n     * \"early media\" in environments where the forking behavior of the SIP\n     * servers being utilized is configured to disallow forking.\n     */\n    invite(options = {}) {\n        this.logger.log(\"Inviter.invite\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            // re-invite\n            return super.invite(options);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // just send an INVITE with no sdp...\n        if (options.withoutSdp || this.inviteWithoutSdp) {\n            if (this._renderbody && this._rendertype) {\n                this.outgoingRequestMessage.body = { contentType: this._rendertype, body: this._renderbody };\n            }\n            // transition state\n            this.stateTransition(SessionState.Establishing);\n            return Promise.resolve(this.sendInvite(options));\n        }\n        // get an offer and send it in an INVITE\n        const offerOptions = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n        };\n        return this.getOffer(offerOptions)\n            .then((body) => {\n            this.outgoingRequestMessage.body = { body: body.content, contentType: body.contentType };\n            // transition state\n            this.stateTransition(SessionState.Establishing);\n            return this.sendInvite(options);\n        })\n            .catch((error) => {\n            this.logger.log(error.message);\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n        });\n    }\n    /**\n     * 13.2.1 Creating the Initial INVITE\n     *\n     * Since the initial INVITE represents a request outside of a dialog,\n     * its construction follows the procedures of Section 8.1.1.  Additional\n     * processing is required for the specific case of INVITE.\n     *\n     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.\n     * It indicates what methods can be invoked within a dialog, on the UA\n     * sending the INVITE, for the duration of the dialog.  For example, a\n     * UA capable of receiving INFO requests within a dialog [34] SHOULD\n     * include an Allow header field listing the INFO method.\n     *\n     * A Supported header field (Section 20.37) SHOULD be present in the\n     * INVITE.  It enumerates all the extensions understood by the UAC.\n     *\n     * An Accept (Section 20.1) header field MAY be present in the INVITE.\n     * It indicates which Content-Types are acceptable to the UA, in both\n     * the response received by it, and in any subsequent requests sent to\n     * it within dialogs established by the INVITE.  The Accept header field\n     * is especially useful for indicating support of various session\n     * description formats.\n     *\n     * The UAC MAY add an Expires header field (Section 20.19) to limit the\n     * validity of the invitation.  If the time indicated in the Expires\n     * header field is reached and no final answer for the INVITE has been\n     * received, the UAC core SHOULD generate a CANCEL request for the\n     * INVITE, as per Section 9.\n     *\n     * A UAC MAY also find it useful to add, among others, Subject (Section\n     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)\n     * header fields.  They all contain information related to the INVITE.\n     *\n     * The UAC MAY choose to add a message body to the INVITE.  Section\n     * 8.1.1.10 deals with how to construct the header fields -- Content-\n     * Type among others -- needed to describe the message body.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     */\n    sendInvite(options = {}) {\n        //    There are special rules for message bodies that contain a session\n        //    description - their corresponding Content-Disposition is \"session\".\n        //    SIP uses an offer/answer model where one UA sends a session\n        //    description, called the offer, which contains a proposed description\n        //    of the session.  The offer indicates the desired communications means\n        //    (audio, video, games), parameters of those means (such as codec\n        //    types) and addresses for receiving media from the answerer.  The\n        //    other UA responds with another session description, called the\n        //    answer, which indicates which communications means are accepted, the\n        //    parameters that apply to those means, and addresses for receiving\n        //    media from the offerer. An offer/answer exchange is within the\n        //    context of a dialog, so that if a SIP INVITE results in multiple\n        //    dialogs, each is a separate offer/answer exchange.  The offer/answer\n        //    model defines restrictions on when offers and answers can be made\n        //    (for example, you cannot make a new offer while one is in progress).\n        //    This results in restrictions on where the offers and answers can\n        //    appear in SIP messages.  In this specification, offers and answers\n        //    can only appear in INVITE requests and responses, and ACK.  The usage\n        //    of offers and answers is further restricted.  For the initial INVITE\n        //    transaction, the rules are:\n        //\n        //       o  The initial offer MUST be in either an INVITE or, if not there,\n        //          in the first reliable non-failure message from the UAS back to\n        //          the UAC.  In this specification, that is the final 2xx\n        //          response.\n        //\n        //       o  If the initial offer is in an INVITE, the answer MUST be in a\n        //          reliable non-failure message from UAS back to UAC which is\n        //          correlated to that INVITE.  For this specification, that is\n        //          only the final 2xx response to that INVITE.  That same exact\n        //          answer MAY also be placed in any provisional responses sent\n        //          prior to the answer.  The UAC MUST treat the first session\n        //          description it receives as the answer, and MUST ignore any\n        //          session descriptions in subsequent responses to the initial\n        //          INVITE.\n        //\n        //       o  If the initial offer is in the first reliable non-failure\n        //          message from the UAS back to UAC, the answer MUST be in the\n        //          acknowledgement for that message (in this specification, ACK\n        //          for a 2xx response).\n        //\n        //       o  After having sent or received an answer to the first offer, the\n        //          UAC MAY generate subsequent offers in requests based on rules\n        //          specified for that method, but only if it has received answers\n        //          to any previous offers, and has not sent any offers to which it\n        //          hasn't gotten an answer.\n        //\n        //       o  Once the UAS has sent or received an answer to the initial\n        //          offer, it MUST NOT generate subsequent offers in any responses\n        //          to the initial INVITE.  This means that a UAS based on this\n        //          specification alone can never generate subsequent offers until\n        //          completion of the initial transaction.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        // 5 The Offer/Answer Model and PRACK\n        //\n        //    RFC 3261 describes guidelines for the sets of messages in which\n        //    offers and answers [3] can appear.  Based on those guidelines, this\n        //    extension provides additional opportunities for offer/answer\n        //    exchanges.\n        //    If the INVITE contained an offer, the UAS MAY generate an answer in a\n        //    reliable provisional response (assuming these are supported by the\n        //    UAC).  That results in the establishment of the session before\n        //    completion of the call.  Similarly, if a reliable provisional\n        //    response is the first reliable message sent back to the UAC, and the\n        //    INVITE did not contain an offer, one MUST appear in that reliable\n        //    provisional response.\n        //    If the UAC receives a reliable provisional response with an offer\n        //    (this would occur if the UAC sent an INVITE without an offer, in\n        //    which case the first reliable provisional response will contain the\n        //    offer), it MUST generate an answer in the PRACK.  If the UAC receives\n        //    a reliable provisional response with an answer, it MAY generate an\n        //    additional offer in the PRACK.  If the UAS receives a PRACK with an\n        //    offer, it MUST place the answer in the 2xx to the PRACK.\n        //    Once an answer has been sent or received, the UA SHOULD establish the\n        //    session based on the parameters of the offer and answer, even if the\n        //    original INVITE itself has not been responded to.\n        //    If the UAS had placed a session description in any reliable\n        //    provisional response that is unacknowledged when the INVITE is\n        //    accepted, the UAS MUST delay sending the 2xx until the provisional\n        //    response is acknowledged.  Otherwise, the reliability of the 1xx\n        //    cannot be guaranteed, and reliability is needed for proper operation\n        //    of the offer/answer exchange.\n        //    All user agents that support this extension MUST support all\n        //    offer/answer exchanges that are possible based on the rules in\n        //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK\n        //    as requests, and 2xx and reliable 1xx as non-failure reliable\n        //    responses.\n        //\n        // https://tools.ietf.org/html/rfc3262#section-5\n        ////\n        // The Offer/Answer Model Implementation\n        //\n        // The offer/answer model is straight forward, but one MUST READ the specifications...\n        //\n        // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        //\n        // 5 The Offer/Answer Model and PRACK\n        // https://tools.ietf.org/html/rfc3262#section-5\n        //\n        // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model\n        // https://tools.ietf.org/html/rfc6337\n        ////\n        ////\n        // TODO: The Offer/Answer Model Implementation\n        //\n        // Currently if `earlyMedia` is enabled and the INVITE request forks,\n        // the session is terminated if the early dialog does not match the\n        // confirmed dialog. This restriction make sense in a WebRTC environment,\n        // but there are other environments where this restriction does not hold.\n        //\n        // So while we currently cannot make the offer in INVITE+forking+webrtc\n        // case work, we propose doing the following...\n        //\n        // OPTION 1\n        // - add a `earlyMediaForking` option and\n        // - require SDH.setDescription() to be callable multiple times.\n        //\n        // OPTION 2\n        // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...\n        // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...\n        // 3) ask SDH Factory if it supports \"earlyRemoteAnswer\"\n        //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)\n        //   b) if false, defer getting a SDH until 2xx response is received\n        //\n        // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)\n        // early media if initial offer is in the INVITE). We will, however, provide an \"inviteWillNotFork\"\n        // option which if set to \"true\" will have our supplied WebRTC SDH behave in the 3a manner.\n        // That will result in\n        //  - early media working with initial offer in the INVITE, and...\n        //  - if the INVITE forks, the session terminating with an ERROR that reads like\n        //    \"You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too.\"\n        //  - furthermore, we accept that users will report that error to us as \"bug\" regardless\n        //\n        // So, SDH Factory is going to end up with a new interface along the lines of...\n        //\n        // interface SessionDescriptionHandlerFactory {\n        //   makeLocalOffer(): Promise<ContentTypeAndBody>;\n        //   makeSessionDescriptionHandler(\n        //     initialOffer: ContentTypeAndBody, offerType: \"local\" | \"remote\"\n        //   ): Promise<SessionDescriptionHandler>;\n        //   supportsEarlyRemoteAnswer: boolean;\n        //   supportsContentType(contentType: string): boolean;\n        //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>\n        //   setDescription(description: ContentTypeAndBody): Promise<void>\n        // }\n        ////\n        // Send the INVITE request.\n        this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {\n            onAccept: (inviteResponse) => {\n                // Our transaction layer is \"non-standard\" in that it will only\n                // pass us a 2xx response once per branch, so there is no need to\n                // worry about dealing with 2xx retransmissions. However, we can\n                // and do still get 2xx responses for multiple branches (when an\n                // INVITE is forked) which may create multiple confirmed dialogs.\n                // Herein we are acking and sending a bye to any confirmed dialogs\n                // which arrive beyond the first one. This is the desired behavior\n                // for most applications (but certainly not all).\n                // If we already received a confirmed dialog, ack & bye this additional confirmed session.\n                if (this.dialog) {\n                    this.logger.log(\"Additional confirmed dialog, sending ACK and BYE\");\n                    this.ackAndBye(inviteResponse);\n                    // We do NOT transition state in this case (this is an \"extra\" dialog)\n                    return;\n                }\n                // If the user requested cancellation, ack & bye this session.\n                if (this.isCanceled) {\n                    this.logger.log(\"Canceled session accepted, sending ACK and BYE\");\n                    this.ackAndBye(inviteResponse);\n                    this.stateTransition(SessionState.Terminated);\n                    return;\n                }\n                this.notifyReferer(inviteResponse);\n                this.onAccept(inviteResponse)\n                    .then(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .catch(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .then(() => {\n                    if (options.requestDelegate && options.requestDelegate.onAccept) {\n                        options.requestDelegate.onAccept(inviteResponse);\n                    }\n                });\n            },\n            onProgress: (inviteResponse) => {\n                // If the user requested cancellation, ignore response.\n                if (this.isCanceled) {\n                    return;\n                }\n                this.notifyReferer(inviteResponse);\n                this.onProgress(inviteResponse)\n                    .catch(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .then(() => {\n                    if (options.requestDelegate && options.requestDelegate.onProgress) {\n                        options.requestDelegate.onProgress(inviteResponse);\n                    }\n                });\n            },\n            onRedirect: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onRedirect(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(inviteResponse);\n                }\n            },\n            onReject: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onReject(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(inviteResponse);\n                }\n            },\n            onTrying: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onTrying(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(inviteResponse);\n                }\n            }\n        });\n        return this.outgoingInviteRequest;\n    }\n    disposeEarlyMedia() {\n        this.earlyMediaSessionDescriptionHandlers.forEach((sessionDescriptionHandler) => {\n            sessionDescriptionHandler.close();\n        });\n        this.earlyMediaSessionDescriptionHandlers.clear();\n    }\n    notifyReferer(response) {\n        if (!this._referred) {\n            return;\n        }\n        if (!(this._referred instanceof Session)) {\n            throw new Error(\"Referred session not instance of session\");\n        }\n        if (!this._referred.dialog) {\n            return;\n        }\n        if (!response.message.statusCode) {\n            throw new Error(\"Status code undefined.\");\n        }\n        if (!response.message.reasonPhrase) {\n            throw new Error(\"Reason phrase undefined.\");\n        }\n        const statusCode = response.message.statusCode;\n        const reasonPhrase = response.message.reasonPhrase;\n        const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();\n        const outgoingNotifyRequest = this._referred.dialog.notify(undefined, {\n            extraHeaders: [\"Event: refer\", \"Subscription-State: terminated\"],\n            body: {\n                contentDisposition: \"render\",\n                contentType: \"message/sipfrag\",\n                content: body\n            }\n        });\n        // The implicit subscription created by a REFER is the same as a\n        // subscription created with a SUBSCRIBE request.  The agent issuing the\n        // REFER can terminate this subscription prematurely by unsubscribing\n        // using the mechanisms described in [2].  Terminating a subscription,\n        // either by explicitly unsubscribing or rejecting NOTIFY, is not an\n        // indication that the referenced request should be withdrawn or\n        // abandoned.\n        // https://tools.ietf.org/html/rfc3515#section-2.4.4\n        // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.\n        // If the notify is rejected, stop sending NOTIFY requests.\n        outgoingNotifyRequest.delegate = {\n            onReject: () => {\n                this._referred = undefined;\n            }\n        };\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 2xx response.\n     */\n    onAccept(inviteResponse) {\n        this.logger.log(\"Inviter.onAccept\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Accept received while in state ${this.state}, dropping response`);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const response = inviteResponse.message;\n        const session = inviteResponse.session;\n        // Ported behavior.\n        if (response.hasHeader(\"P-Asserted-Identity\")) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n        }\n        // We have a confirmed dialog.\n        session.delegate = {\n            onAck: (ackRequest) => this.onAckRequest(ackRequest),\n            onBye: (byeRequest) => this.onByeRequest(byeRequest),\n            onInfo: (infoRequest) => this.onInfoRequest(infoRequest),\n            onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),\n            onMessage: (messageRequest) => this.onMessageRequest(messageRequest),\n            onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),\n            onPrack: (prackRequest) => this.onPrackRequest(prackRequest),\n            onRefer: (referRequest) => this.onReferRequest(referRequest)\n        };\n        this._dialog = session;\n        switch (session.signalingState) {\n            case SignalingState.Initial:\n                // INVITE without offer, so MUST have offer at this point, so invalid state.\n                this.logger.error(\"Received 2xx response to INVITE without a session description\");\n                this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n                this.stateTransition(SessionState.Terminated);\n                return Promise.reject(new Error(\"Bad Media Description\"));\n            case SignalingState.HaveLocalOffer:\n                // INVITE with offer, so MUST have answer at this point, so invalid state.\n                this.logger.error(\"Received 2xx response to INVITE without a session description\");\n                this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n                this.stateTransition(SessionState.Terminated);\n                return Promise.reject(new Error(\"Bad Media Description\"));\n            case SignalingState.HaveRemoteOffer: {\n                // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.\n                if (!this._dialog.offer) {\n                    throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);\n                }\n                const options = {\n                    sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                    sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                };\n                return this.setOfferAndGetAnswer(this._dialog.offer, options)\n                    .then((body) => {\n                    inviteResponse.ack({ body });\n                    this.stateTransition(SessionState.Established);\n                })\n                    .catch((error) => {\n                    this.ackAndBye(inviteResponse, 488, \"Invalid session description\");\n                    this.stateTransition(SessionState.Terminated);\n                    throw error;\n                });\n            }\n            case SignalingState.Stable: {\n                // If INVITE without offer and we have already completed the initial exchange.\n                if (this.earlyMediaSessionDescriptionHandlers.size > 0) {\n                    const sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);\n                    if (!sdh) {\n                        throw new Error(\"Session description handler undefined.\");\n                    }\n                    this.setSessionDescriptionHandler(sdh);\n                    this.earlyMediaSessionDescriptionHandlers.delete(session.id);\n                    inviteResponse.ack();\n                    this.stateTransition(SessionState.Established);\n                    return Promise.resolve();\n                }\n                // If INVITE with offer and we used an \"early\" answer in a provisional response for media\n                if (this.earlyMediaDialog) {\n                    // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.\n                    // This limitation stems from how WebRTC currently implements its offer/answer model.\n                    // There are details elsewhere, but in short a WebRTC offer cannot be forked.\n                    if (this.earlyMediaDialog !== session) {\n                        if (this.earlyMedia) {\n                            const message = \"You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests \" +\n                                \"do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly \" +\n                                \"the end point which accepted the INVITE (confirmed dialog) does not match the end point with \" +\n                                \"which early media has been setup (early dialog) and thus this session is unable to proceed. \" +\n                                \"In accordance with the SIP specifications, the SIP servers your end point is connected to \" +\n                                \"determine if an INVITE forks and the forking behavior of those servers cannot be controlled \" +\n                                \"by this library. If you wish to use early media with this library you must configure those \" +\n                                \"servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow \" +\n                                \"this library to function with any INVITE requests which do fork.\";\n                            this.logger.error(message);\n                        }\n                        const error = new Error(\"Early media dialog does not equal confirmed dialog, terminating session\");\n                        this.logger.error(error.message);\n                        this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n                        this.stateTransition(SessionState.Terminated);\n                        return Promise.reject(error);\n                    }\n                    // Otherwise we are good to go.\n                    inviteResponse.ack();\n                    this.stateTransition(SessionState.Established);\n                    return Promise.resolve();\n                }\n                // If INVITE with offer and we have been waiting till now to apply the answer.\n                const answer = session.answer;\n                if (!answer) {\n                    throw new Error(\"Answer is undefined.\");\n                }\n                const options = {\n                    sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                    sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                };\n                return this.setAnswer(answer, options)\n                    .then(() => {\n                    // This session has completed an initial offer/answer exchange...\n                    let ackOptions;\n                    if (this._renderbody && this._rendertype) {\n                        ackOptions = {\n                            body: { contentDisposition: \"render\", contentType: this._rendertype, content: this._renderbody }\n                        };\n                    }\n                    inviteResponse.ack(ackOptions);\n                    this.stateTransition(SessionState.Established);\n                })\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                    this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n                    this.stateTransition(SessionState.Terminated);\n                    throw error;\n                });\n            }\n            case SignalingState.Closed:\n                // Dialog has terminated.\n                return Promise.reject(new Error(\"Terminated.\"));\n            default:\n                throw new Error(\"Unknown session signaling state.\");\n        }\n    }\n    /**\n     * Handle provisional response to initial INVITE.\n     * @param inviteResponse - 1xx response.\n     */\n    onProgress(inviteResponse) {\n        var _a;\n        this.logger.log(\"Inviter.onProgress\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Progress received while in state ${this.state}, dropping response`);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        if (!this.outgoingInviteRequest) {\n            throw new Error(\"Outgoing INVITE request undefined.\");\n        }\n        const response = inviteResponse.message;\n        const session = inviteResponse.session;\n        // Ported - Set assertedIdentity.\n        if (response.hasHeader(\"P-Asserted-Identity\")) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n        }\n        // If a provisional response is received for an initial request, and\n        // that response contains a Require header field containing the option\n        // tag 100rel, the response is to be sent reliably.  If the response is\n        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n        // ignored, and the procedures below MUST NOT be used.\n        // https://tools.ietf.org/html/rfc3262#section-4\n        const requireHeader = response.getHeader(\"require\");\n        const rseqHeader = response.getHeader(\"rseq\");\n        const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n        const responseReliable = !!rseq;\n        const extraHeaders = [];\n        if (responseReliable) {\n            extraHeaders.push(\"RAck: \" + response.getHeader(\"rseq\") + \" \" + response.getHeader(\"cseq\"));\n        }\n        switch (session.signalingState) {\n            case SignalingState.Initial:\n                // INVITE without offer and session still has no offer (and no answer).\n                if (responseReliable) {\n                    // Similarly, if a reliable provisional\n                    // response is the first reliable message sent back to the UAC, and the\n                    // INVITE did not contain an offer, one MUST appear in that reliable\n                    // provisional response.\n                    // https://tools.ietf.org/html/rfc3262#section-5\n                    this.logger.warn(\"First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.\");\n                    // FIXME: Known popular UA's currently end up here...\n                    inviteResponse.prack({ extraHeaders });\n                }\n                return Promise.resolve();\n            case SignalingState.HaveLocalOffer:\n                // INVITE with offer and session only has that initial local offer.\n                if (responseReliable) {\n                    inviteResponse.prack({ extraHeaders });\n                }\n                return Promise.resolve();\n            case SignalingState.HaveRemoteOffer:\n                if (!responseReliable) {\n                    // The initial offer MUST be in either an INVITE or, if not there,\n                    // in the first reliable non-failure message from the UAS back to\n                    // the UAC.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // According to Section 13.2.1 of [RFC3261], 'The first reliable\n                    // non-failure message' must have an offer if there is no offer in the\n                    // INVITE request.  This means that the User Agent (UA) that receives\n                    // the INVITE request without an offer must include an offer in the\n                    // first reliable response with 100rel extension.  If no reliable\n                    // provisional response has been sent, the User Agent Server (UAS) must\n                    // include an offer when sending 2xx response.\n                    // https://tools.ietf.org/html/rfc6337#section-2.2\n                    this.logger.warn(\"Non-reliable provisional response MUST NOT contain an initial offer, discarding response.\");\n                    return Promise.resolve();\n                }\n                {\n                    // If the initial offer is in the first reliable non-failure\n                    // message from the UAS back to UAC, the answer MUST be in the\n                    // acknowledgement for that message\n                    const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});\n                    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n                        this.delegate.onSessionDescriptionHandler(sdh, true);\n                    }\n                    this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);\n                    return sdh\n                        .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)\n                        .then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers))\n                        .then((description) => {\n                        const body = {\n                            contentDisposition: \"session\",\n                            contentType: description.contentType,\n                            content: description.body\n                        };\n                        inviteResponse.prack({ extraHeaders, body });\n                    })\n                        .catch((error) => {\n                        this.stateTransition(SessionState.Terminated);\n                        throw error;\n                    });\n                }\n            case SignalingState.Stable:\n                // This session has completed an initial offer/answer exchange, so...\n                // - INVITE with SDP and this provisional response MAY be reliable\n                // - INVITE without SDP and this provisional response MAY be reliable\n                if (responseReliable) {\n                    inviteResponse.prack({ extraHeaders });\n                }\n                if (this.earlyMedia && !this.earlyMediaDialog) {\n                    this.earlyMediaDialog = session;\n                    const answer = session.answer;\n                    if (!answer) {\n                        throw new Error(\"Answer is undefined.\");\n                    }\n                    const options = {\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                    };\n                    return this.setAnswer(answer, options).catch((error) => {\n                        this.stateTransition(SessionState.Terminated);\n                        throw error;\n                    });\n                }\n                return Promise.resolve();\n            case SignalingState.Closed:\n                // Dialog has terminated.\n                return Promise.reject(new Error(\"Terminated.\"));\n            default:\n                throw new Error(\"Unknown session signaling state.\");\n        }\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 3xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onRedirect(inviteResponse) {\n        this.logger.log(\"Inviter.onRedirect\");\n        // validate state\n        if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n            this.logger.error(`Redirect received while in state ${this.state}, dropping response`);\n            return;\n        }\n        // transition state\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 4xx, 5xx, or 6xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onReject(inviteResponse) {\n        this.logger.log(\"Inviter.onReject\");\n        // validate state\n        if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n            this.logger.error(`Reject received while in state ${this.state}, dropping response`);\n            return;\n        }\n        // transition state\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 100 response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrying(inviteResponse) {\n        this.logger.log(\"Inviter.onTrying\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Trying received while in state ${this.state}, dropping response`);\n            return;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}