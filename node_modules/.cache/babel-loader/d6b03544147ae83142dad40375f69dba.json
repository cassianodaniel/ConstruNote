{"ast":null,"code":"import { C, constructOutgoingResponse, OutgoingRequestMessage } from \"../messages\";\nimport { InviteServerTransaction, NonInviteClientTransaction, TransactionState } from \"../transactions\";\nimport { InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentServer, PublishUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient } from \"../user-agents\";\nimport { AllowedMethods } from \"./allowed-methods\";\n/**\n * This is ported from UA.C.ACCEPTED_BODY_TYPES.\n * FIXME: TODO: Should be configurable/variable.\n */\n\nconst acceptedBodyTypes = [\"application/sdp\", \"application/dtmf-relay\"];\n/**\n * User Agent Core.\n * @remarks\n * Core designates the functions specific to a particular type\n * of SIP entity, i.e., specific to either a stateful or stateless\n * proxy, a user agent or registrar.  All cores, except those for\n * the stateless proxy, are transaction users.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAC Core: The set of processing functions required of a UAC that\n * reside above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAS Core: The set of processing functions required at a UAS that\n * resides above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport class UserAgentCore {\n  /**\n   * Constructor.\n   * @param configuration - Configuration.\n   * @param delegate - Delegate.\n   */\n  constructor(configuration, delegate = {}) {\n    /** UACs. */\n    this.userAgentClients = new Map();\n    /** UASs. */\n\n    this.userAgentServers = new Map();\n    this.configuration = configuration;\n    this.delegate = delegate;\n    this.dialogs = new Map();\n    this.subscribers = new Map();\n    this.logger = configuration.loggerFactory.getLogger(\"sip.user-agent-core\");\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    this.reset();\n  }\n  /** Reset. */\n\n\n  reset() {\n    this.dialogs.forEach(dialog => dialog.dispose());\n    this.dialogs.clear();\n    this.subscribers.forEach(subscriber => subscriber.dispose());\n    this.subscribers.clear();\n    this.userAgentClients.forEach(uac => uac.dispose());\n    this.userAgentClients.clear();\n    this.userAgentServers.forEach(uac => uac.dispose());\n    this.userAgentServers.clear();\n  }\n  /** Logger factory. */\n\n\n  get loggerFactory() {\n    return this.configuration.loggerFactory;\n  }\n  /** Transport. */\n\n\n  get transport() {\n    const transport = this.configuration.transportAccessor();\n\n    if (!transport) {\n      throw new Error(\"Transport undefined.\");\n    }\n\n    return transport;\n  }\n  /**\n   * Send INVITE.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  invite(request, delegate) {\n    return new InviteUserAgentClient(this, request, delegate);\n  }\n  /**\n   * Send MESSAGE.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  message(request, delegate) {\n    return new MessageUserAgentClient(this, request, delegate);\n  }\n  /**\n   * Send PUBLISH.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  publish(request, delegate) {\n    return new PublishUserAgentClient(this, request, delegate);\n  }\n  /**\n   * Send REGISTER.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  register(request, delegate) {\n    return new RegisterUserAgentClient(this, request, delegate);\n  }\n  /**\n   * Send SUBSCRIBE.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  subscribe(request, delegate) {\n    return new SubscribeUserAgentClient(this, request, delegate);\n  }\n  /**\n   * Send a request.\n   * @param request - Outgoing request.\n   * @param delegate - Request delegate.\n   */\n\n\n  request(request, delegate) {\n    return new UserAgentClient(NonInviteClientTransaction, this, request, delegate);\n  }\n  /**\n   * Outgoing request message factory function.\n   * @param method - Method.\n   * @param requestURI - Request-URI.\n   * @param fromURI - From URI.\n   * @param toURI - To URI.\n   * @param options - Request options.\n   * @param extraHeaders - Extra headers to add.\n   * @param body - Message body.\n   */\n\n\n  makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {\n    // default values from user agent configuration\n    const callIdPrefix = this.configuration.sipjsId;\n    const fromDisplayName = this.configuration.displayName;\n    const forceRport = this.configuration.viaForceRport;\n    const hackViaTcp = this.configuration.hackViaTcp;\n    const optionTags = this.configuration.supportedOptionTags.slice();\n\n    if (method === C.REGISTER) {\n      optionTags.push(\"path\", \"gruu\");\n    }\n\n    if (method === C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {\n      optionTags.push(\"gruu\");\n    }\n\n    const routeSet = this.configuration.routeSet;\n    const userAgentString = this.configuration.userAgentHeaderFieldValue;\n    const viaHost = this.configuration.viaHost;\n    const defaultOptions = {\n      callIdPrefix,\n      forceRport,\n      fromDisplayName,\n      hackViaTcp,\n      optionTags,\n      routeSet,\n      userAgentString,\n      viaHost\n    }; // merge provided options with default options\n\n    const requestOptions = Object.assign(Object.assign({}, defaultOptions), options);\n    return new OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);\n  }\n  /**\n   * Handle an incoming request message from the transport.\n   * @param message - Incoming request message from transport layer.\n   */\n\n\n  receiveIncomingRequestFromTransport(message) {\n    this.receiveRequestFromTransport(message);\n  }\n  /**\n   * Handle an incoming response message from the transport.\n   * @param message - Incoming response message from transport layer.\n   */\n\n\n  receiveIncomingResponseFromTransport(message) {\n    this.receiveResponseFromTransport(message);\n  }\n  /**\n   * A stateless UAS is a UAS that does not maintain transaction state.\n   * It replies to requests normally, but discards any state that would\n   * ordinarily be retained by a UAS after a response has been sent.  If a\n   * stateless UAS receives a retransmission of a request, it regenerates\n   * the response and re-sends it, just as if it were replying to the first\n   * instance of the request. A UAS cannot be stateless unless the request\n   * processing for that method would always result in the same response\n   * if the requests are identical. This rules out stateless registrars,\n   * for example.  Stateless UASs do not use a transaction layer; they\n   * receive requests directly from the transport layer and send responses\n   * directly to the transport layer.\n   * https://tools.ietf.org/html/rfc3261#section-8.2.7\n   * @param message - Incoming request message to reply to.\n   * @param statusCode - Status code to reply with.\n   */\n\n\n  replyStateless(message, options) {\n    const userAgent = this.configuration.userAgentHeaderFieldValue;\n    const supported = this.configuration.supportedOptionTagsResponse;\n    options = Object.assign(Object.assign({}, options), {\n      userAgent,\n      supported\n    });\n    const response = constructOutgoingResponse(message, options);\n    this.transport.send(response.message).catch(error => {\n      // If the transport rejects, it SHOULD reject with a TransportError.\n      // But the transport may be external code, so we are careful...\n      if (error instanceof Error) {\n        this.logger.error(error.message);\n      }\n\n      this.logger.error(`Transport error occurred sending stateless reply to ${message.method} request.`); // TODO: Currently there is no hook to provide notification that a transport error occurred\n      // and throwing would result in an uncaught error (in promise), so we silently eat the error.\n      // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.\n    });\n    return response;\n  }\n  /**\n   * In Section 18.2.1, replace the last paragraph with:\n   *\n   * Next, the server transport attempts to match the request to a\n   * server transaction.  It does so using the matching rules described\n   * in Section 17.2.3.  If a matching server transaction is found, the\n   * request is passed to that transaction for processing.  If no match\n   * is found, the request is passed to the core, which may decide to\n   * construct a new server transaction for that request.\n   * https://tools.ietf.org/html/rfc6026#section-8.10\n   * @param message - Incoming request message from transport layer.\n   */\n\n\n  receiveRequestFromTransport(message) {\n    // When a request is received from the network by the server, it has to\n    // be matched to an existing transaction.  This is accomplished in the\n    // following manner.\n    //\n    // The branch parameter in the topmost Via header field of the request\n    // is examined.  If it is present and begins with the magic cookie\n    // \"z9hG4bK\", the request was generated by a client transaction\n    // compliant to this specification.  Therefore, the branch parameter\n    // will be unique across all transactions sent by that client.  The\n    // request matches a transaction if:\n    //\n    //    1. the branch parameter in the request is equal to the one in the\n    //       top Via header field of the request that created the\n    //       transaction, and\n    //\n    //    2. the sent-by value in the top Via of the request is equal to the\n    //       one in the request that created the transaction, and\n    //\n    //    3. the method of the request matches the one that created the\n    //       transaction, except for ACK, where the method of the request\n    //       that created the transaction is INVITE.\n    //\n    // This matching rule applies to both INVITE and non-INVITE transactions\n    // alike.\n    //\n    //    The sent-by value is used as part of the matching process because\n    //    there could be accidental or malicious duplication of branch\n    //    parameters from different clients.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.3\n    const transactionId = message.viaBranch; // FIXME: Currently only using rule 1...\n\n    const uas = this.userAgentServers.get(transactionId); // When receiving an ACK that matches an existing INVITE server\n    // transaction and that does not contain a branch parameter containing\n    // the magic cookie defined in RFC 3261, the matching transaction MUST\n    // be checked to see if it is in the \"Accepted\" state.  If it is, then\n    // the ACK must be passed directly to the transaction user instead of\n    // being absorbed by the transaction state machine.  This is necessary\n    // as requests from RFC 2543 clients will not include a unique branch\n    // parameter, and the mechanisms for calculating the transaction ID from\n    // such a request will be the same for both INVITE and ACKs.\n    // https://tools.ietf.org/html/rfc6026#section-6\n    // Any ACKs received from the network while in the \"Accepted\" state MUST be\n    // passed directly to the TU and not absorbed.\n    // https://tools.ietf.org/html/rfc6026#section-7.1\n\n    if (message.method === C.ACK) {\n      if (uas && uas.transaction.state === TransactionState.Accepted) {\n        if (uas instanceof InviteUserAgentServer) {\n          // These are ACKs matching an INVITE server transaction.\n          // These should never happen with RFC 3261 compliant user agents\n          // (would be a broken ACK to negative final response or something)\n          // but is apparently how RFC 2543 user agents do things.\n          // We are not currently supporting this case.\n          // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n          this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${transactionId}.`);\n          return;\n        }\n      }\n    } // The CANCEL method requests that the TU at the server side cancel a\n    // pending transaction.  The TU determines the transaction to be\n    // cancelled by taking the CANCEL request, and then assuming that the\n    // request method is anything but CANCEL or ACK and applying the\n    // transaction matching procedures of Section 17.2.3.  The matching\n    // transaction is the one to be cancelled.\n    // https://tools.ietf.org/html/rfc3261#section-9.2\n\n\n    if (message.method === C.CANCEL) {\n      if (uas) {\n        // Regardless of the method of the original request, as long as the\n        // CANCEL matched an existing transaction, the UAS answers the CANCEL\n        // request itself with a 200 (OK) response.\n        // https://tools.ietf.org/html/rfc3261#section-9.2\n        this.replyStateless(message, {\n          statusCode: 200\n        }); // If the transaction for the original request still exists, the behavior\n        // of the UAS on receiving a CANCEL request depends on whether it has already\n        // sent a final response for the original request. If it has, the CANCEL\n        // request has no effect on the processing of the original request, no\n        // effect on any session state, and no effect on the responses generated\n        // for the original request. If the UAS has not issued a final response\n        // for the original request, its behavior depends on the method of the\n        // original request. If the original request was an INVITE, the UAS\n        // SHOULD immediately respond to the INVITE with a 487 (Request\n        // Terminated).\n        // https://tools.ietf.org/html/rfc3261#section-9.2\n\n        if (uas.transaction instanceof InviteServerTransaction && uas.transaction.state === TransactionState.Proceeding) {\n          if (uas instanceof InviteUserAgentServer) {\n            uas.receiveCancel(message);\n          } // A CANCEL request has no impact on the processing of\n          // transactions with any other method defined in this specification.\n          // https://tools.ietf.org/html/rfc3261#section-9.2\n\n        }\n      } else {\n        // If the UAS did not find a matching transaction for the CANCEL\n        // according to the procedure above, it SHOULD respond to the CANCEL\n        // with a 481 (Call Leg/Transaction Does Not Exist).\n        // https://tools.ietf.org/html/rfc3261#section-9.2\n        this.replyStateless(message, {\n          statusCode: 481\n        });\n      }\n\n      return;\n    } // If a matching server transaction is found, the request is passed to that\n    // transaction for processing.\n    // https://tools.ietf.org/html/rfc6026#section-8.10\n\n\n    if (uas) {\n      uas.transaction.receiveRequest(message);\n      return;\n    } // If no match is found, the request is passed to the core, which may decide to\n    // construct a new server transaction for that request.\n    // https://tools.ietf.org/html/rfc6026#section-8.10\n\n\n    this.receiveRequest(message);\n    return;\n  }\n  /**\n   * UAC and UAS procedures depend strongly on two factors.  First, based\n   * on whether the request or response is inside or outside of a dialog,\n   * and second, based on the method of a request.  Dialogs are discussed\n   * thoroughly in Section 12; they represent a peer-to-peer relationship\n   * between user agents and are established by specific SIP methods, such\n   * as INVITE.\n   * @param message - Incoming request message.\n   */\n\n\n  receiveRequest(message) {\n    // 8.2 UAS Behavior\n    // UASs SHOULD process the requests in the order of the steps that\n    // follow in this section (that is, starting with authentication, then\n    // inspecting the method, the header fields, and so on throughout the\n    // remainder of this section).\n    // https://tools.ietf.org/html/rfc3261#section-8.2\n    // 8.2.1 Method Inspection\n    // Once a request is authenticated (or authentication is skipped), the\n    // UAS MUST inspect the method of the request.  If the UAS recognizes\n    // but does not support the method of a request, it MUST generate a 405\n    // (Method Not Allowed) response.  Procedures for generating responses\n    // are described in Section 8.2.6.  The UAS MUST also add an Allow\n    // header field to the 405 (Method Not Allowed) response.  The Allow\n    // header field MUST list the set of methods supported by the UAS\n    // generating the message.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.1\n    if (!AllowedMethods.includes(message.method)) {\n      const allowHeader = \"Allow: \" + AllowedMethods.toString();\n      this.replyStateless(message, {\n        statusCode: 405,\n        extraHeaders: [allowHeader]\n      });\n      return;\n    } // 8.2.2 Header Inspection\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2\n\n\n    if (!message.ruri) {\n      // FIXME: A request message should always have an ruri\n      throw new Error(\"Request-URI undefined.\");\n    } // 8.2.2.1 To and Request-URI\n    // If the Request-URI uses a scheme not supported by the UAS, it SHOULD\n    // reject the request with a 416 (Unsupported URI Scheme) response.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n    if (message.ruri.scheme !== \"sip\") {\n      this.replyStateless(message, {\n        statusCode: 416\n      });\n      return;\n    } // 8.2.2.1 To and Request-URI\n    // If the Request-URI does not identify an address that the\n    // UAS is willing to accept requests for, it SHOULD reject\n    // the request with a 404 (Not Found) response.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n    const ruri = message.ruri;\n\n    const ruriMatches = uri => {\n      return !!uri && uri.user === ruri.user;\n    };\n\n    if (!ruriMatches(this.configuration.aor) && !(ruriMatches(this.configuration.contact.uri) || ruriMatches(this.configuration.contact.pubGruu) || ruriMatches(this.configuration.contact.tempGruu))) {\n      this.logger.warn(\"Request-URI does not point to us.\");\n\n      if (message.method !== C.ACK) {\n        this.replyStateless(message, {\n          statusCode: 404\n        });\n      }\n\n      return;\n    } // 8.2.2.1 To and Request-URI\n    // Other potential sources of received Request-URIs include\n    // the Contact header fields of requests and responses sent by the UA\n    // that establish or refresh dialogs.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n    if (message.method === C.INVITE) {\n      if (!message.hasHeader(\"Contact\")) {\n        this.replyStateless(message, {\n          statusCode: 400,\n          reasonPhrase: \"Missing Contact Header\"\n        });\n        return;\n      }\n    } // 8.2.2.2 Merged Requests\n    // If the request has no tag in the To header field, the UAS core MUST\n    // check the request against ongoing transactions.  If the From tag,\n    // Call-ID, and CSeq exactly match those associated with an ongoing\n    // transaction, but the request does not match that transaction (based\n    // on the matching rules in Section 17.2.3), the UAS core SHOULD\n    // generate a 482 (Loop Detected) response and pass it to the server\n    // transaction.\n    //\n    //    The same request has arrived at the UAS more than once, following\n    //    different paths, most likely due to forking.  The UAS processes\n    //    the first such request received and responds with a 482 (Loop\n    //    Detected) to the rest of them.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2.2\n\n\n    if (!message.toTag) {\n      const transactionId = message.viaBranch;\n\n      if (!this.userAgentServers.has(transactionId)) {\n        const mergedRequest = Array.from(this.userAgentServers.values()).some(uas => uas.transaction.request.fromTag === message.fromTag && uas.transaction.request.callId === message.callId && uas.transaction.request.cseq === message.cseq);\n\n        if (mergedRequest) {\n          this.replyStateless(message, {\n            statusCode: 482\n          });\n          return;\n        }\n      }\n    } // 8.2.2.3 Require\n    // https://tools.ietf.org/html/rfc3261#section-8.2.2.3\n    // TODO\n    // 8.2.3 Content Processing\n    // https://tools.ietf.org/html/rfc3261#section-8.2.3\n    // TODO\n    // 8.2.4 Applying Extensions\n    // https://tools.ietf.org/html/rfc3261#section-8.2.4\n    // TODO\n    // 8.2.5 Processing the Request\n    // Assuming all of the checks in the previous subsections are passed,\n    // the UAS processing becomes method-specific.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.5\n    // The UAS will receive the request from the transaction layer.  If the\n    // request has a tag in the To header field, the UAS core computes the\n    // dialog identifier corresponding to the request and compares it with\n    // existing dialogs.  If there is a match, this is a mid-dialog request.\n    // In that case, the UAS first applies the same processing rules for\n    // requests outside of a dialog, discussed in Section 8.2.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    if (message.toTag) {\n      this.receiveInsideDialogRequest(message);\n    } else {\n      this.receiveOutsideDialogRequest(message);\n    }\n\n    return;\n  }\n  /**\n   * Once a dialog has been established between two UAs, either of them\n   * MAY initiate new transactions as needed within the dialog.  The UA\n   * sending the request will take the UAC role for the transaction.  The\n   * UA receiving the request will take the UAS role.  Note that these may\n   * be different roles than the UAs held during the transaction that\n   * established the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.2\n   * @param message - Incoming request message.\n   */\n\n\n  receiveInsideDialogRequest(message) {\n    // NOTIFY requests are matched to such SUBSCRIBE requests if they\n    // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n    // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n    // request, and the same \"Event\" header field.  Rules for comparisons of\n    // the \"Event\" header fields are described in Section 8.2.1.\n    // https://tools.ietf.org/html/rfc6665#section-4.4.1\n    if (message.method === C.NOTIFY) {\n      const event = message.parseHeader(\"Event\");\n\n      if (!event || !event.event) {\n        this.replyStateless(message, {\n          statusCode: 489\n        });\n        return;\n      } // FIXME: Subscriber id should also matching on event id.\n\n\n      const subscriberId = message.callId + message.toTag + event.event;\n      const subscriber = this.subscribers.get(subscriberId);\n\n      if (subscriber) {\n        const uas = new NotifyUserAgentServer(this, message);\n        subscriber.onNotify(uas);\n        return;\n      }\n    } // Requests sent within a dialog, as any other requests, are atomic.  If\n    // a particular request is accepted by the UAS, all the state changes\n    // associated with it are performed.  If the request is rejected, none\n    // of the state changes are performed.\n    //\n    //    Note that some requests, such as INVITEs, affect several pieces of\n    //    state.\n    //\n    // The UAS will receive the request from the transaction layer.  If the\n    // request has a tag in the To header field, the UAS core computes the\n    // dialog identifier corresponding to the request and compares it with\n    // existing dialogs.  If there is a match, this is a mid-dialog request.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    const dialogId = message.callId + message.toTag + message.fromTag;\n    const dialog = this.dialogs.get(dialogId);\n\n    if (dialog) {\n      // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS\n      // You got the question right.\n      //\n      // And you got the right answer too. :-)\n      //\n      //   Thanks,\n      //   Paul\n      //\n      // Robert Sparks wrote:\n      // > So I've lost track of the question during the musing.\n      // >\n      // > I _think_ the fundamental question being asked is this:\n      // >\n      // > Is an endpoint required to reject (with a 481) an OPTIONS request that\n      // > arrives with at to-tag but does not match any existing dialog state.\n      // > (Assuming some earlier requirement hasn't forced another error code). Or\n      // > is it OK if it just sends\n      // > a 200 OK anyhow.\n      // >\n      // > My take on the collection of specs is that its _not_ ok for it to send\n      // > the 200 OK anyhow and that it is required to send\n      // > the 481. I base this primarily on these sentences from 11.2 in 3261:\n      // >\n      // >    The response to an OPTIONS is constructed using the standard rules\n      // >    for a SIP response as discussed in Section 8.2.6.  The response code\n      // >    chosen MUST be the same that would have been chosen had the request\n      // >    been an INVITE.\n      // >\n      // > Did I miss the point of the question?\n      // >\n      // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:\n      // >\n      // >> [Including Robert in hopes of getting his insight on this.]\n      // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html\n      //\n      // Requests that do not change in any way the state of a dialog may be\n      // received within a dialog (for example, an OPTIONS request).  They are\n      // processed as if they had been received outside the dialog.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n      if (message.method === C.OPTIONS) {\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n        this.replyStateless(message, {\n          statusCode: 200,\n          extraHeaders: [allowHeader, acceptHeader]\n        });\n        return;\n      } // Pass the incoming request to the dialog for further handling.\n\n\n      dialog.receiveRequest(message);\n      return;\n    } // The most important behaviors of a stateless UAS are the following:\n    // ...\n    // o  A stateless UAS MUST ignore ACK requests.\n    // ...\n    // https://tools.ietf.org/html/rfc3261#section-8.2.7\n\n\n    if (message.method === C.ACK) {\n      // If a final response to an INVITE was sent statelessly,\n      // the corresponding ACK:\n      // - will not match an existing transaction\n      // - may have tag in the To header field\n      // - not not match any existing dialogs\n      // Absorb unmatched ACKs.\n      return;\n    } // If the request has a tag in the To header field, but the dialog\n    // identifier does not match any existing dialogs, the UAS may have\n    // crashed and restarted, or it may have received a request for a\n    // different (possibly failed) UAS (the UASs can construct the To tags\n    // so that a UAS can identify that the tag was for a UAS for which it is\n    // providing recovery).  Another possibility is that the incoming\n    // request has been simply mis-routed.  Based on the To tag, the UAS MAY\n    // either accept or reject the request.  Accepting the request for\n    // acceptable To tags provides robustness, so that dialogs can persist\n    // even through crashes.  UAs wishing to support this capability must\n    // take into consideration some issues such as choosing monotonically\n    // increasing CSeq sequence numbers even across reboots, reconstructing\n    // the route set, and accepting out-of-range RTP timestamps and sequence\n    // numbers.\n    //\n    // If the UAS wishes to reject the request because it does not wish to\n    // recreate the dialog, it MUST respond to the request with a 481\n    // (Call/Transaction Does Not Exist) status code and pass that to the\n    // server transaction.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    this.replyStateless(message, {\n      statusCode: 481\n    });\n    return;\n  }\n  /**\n   * Assuming all of the checks in the previous subsections are passed,\n   * the UAS processing becomes method-specific.\n   *  https://tools.ietf.org/html/rfc3261#section-8.2.5\n   * @param message - Incoming request message.\n   */\n\n\n  receiveOutsideDialogRequest(message) {\n    switch (message.method) {\n      case C.ACK:\n        // Absorb stray out of dialog ACKs\n        break;\n\n      case C.BYE:\n        // If the BYE does not match an existing dialog, the UAS core SHOULD\n        // generate a 481 (Call/Transaction Does Not Exist) response and pass\n        // that to the server transaction. This rule means that a BYE sent\n        // without tags by a UAC will be rejected.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.2\n        this.replyStateless(message, {\n          statusCode: 481\n        });\n        break;\n\n      case C.CANCEL:\n        throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n        break;\n\n      case C.INFO:\n        // Use of the INFO method does not constitute a separate dialog usage.\n        // INFO messages are always part of, and share the fate of, an invite\n        // dialog usage [RFC5057].  INFO messages cannot be sent as part of\n        // other dialog usages, or outside an existing dialog.\n        // https://tools.ietf.org/html/rfc6086#section-1\n        this.replyStateless(message, {\n          statusCode: 405\n        }); // Should never happen\n\n        break;\n\n      case C.INVITE:\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1\n        {\n          const uas = new InviteUserAgentServer(this, message);\n          this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();\n        }\n        break;\n\n      case C.MESSAGE:\n        // MESSAGE requests are discouraged inside a dialog.  Implementations\n        // are restricted from creating a usage for the purpose of carrying a\n        // sequence of MESSAGE requests (though some implementations use it that\n        // way, against the standard recommendation).\n        // https://tools.ietf.org/html/rfc5057#section-5.3\n        {\n          const uas = new MessageUserAgentServer(this, message);\n          this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n        }\n        break;\n\n      case C.NOTIFY:\n        // Obsoleted by: RFC 6665\n        // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,\n        // it is the responsibility of the parties defining those mechanisms to\n        // ensure that correlation of a NOTIFY message to the corresponding\n        // subscription is possible.  Designers of such mechanisms are also\n        // warned to make a distinction between sending a NOTIFY message to a\n        // subscriber who is aware of the subscription, and sending a NOTIFY\n        // message to an unsuspecting node.  The latter behavior is invalid, and\n        // MUST receive a \"481 Subscription does not exist\" response (unless\n        // some other 400- or 500-class error code is more applicable), as\n        // described in section 3.2.4.  In other words, knowledge of a\n        // subscription must exist in both the subscriber and the notifier to be\n        // valid, even if installed via a non-SUBSCRIBE mechanism.\n        // https://tools.ietf.org/html/rfc3265#section-3.2\n        //\n        // NOTIFY requests are sent to inform subscribers of changes in state to\n        // which the subscriber has a subscription.  Subscriptions are created\n        // using the SUBSCRIBE method.  In legacy implementations, it is\n        // possible that other means of subscription creation have been used.\n        // However, this specification does not allow the creation of\n        // subscriptions except through SUBSCRIBE requests and (for backwards-\n        // compatibility) REFER requests [RFC3515].\n        // https://tools.ietf.org/html/rfc6665#section-3.2\n        {\n          const uas = new NotifyUserAgentServer(this, message);\n          this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.reject({\n            statusCode: 405\n          });\n        }\n        break;\n\n      case C.OPTIONS:\n        // https://tools.ietf.org/html/rfc3261#section-11.2\n        {\n          const allowHeader = \"Allow: \" + AllowedMethods.toString();\n          const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n          this.replyStateless(message, {\n            statusCode: 200,\n            extraHeaders: [allowHeader, acceptHeader]\n          });\n        }\n        break;\n\n      case C.REFER:\n        // https://tools.ietf.org/html/rfc3515#section-2.4.2\n        {\n          const uas = new ReferUserAgentServer(this, message);\n          this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject({\n            statusCode: 405\n          });\n        }\n        break;\n\n      case C.REGISTER:\n        // https://tools.ietf.org/html/rfc3261#section-10.3\n        {\n          const uas = new RegisterUserAgentServer(this, message);\n          this.delegate.onRegister ? this.delegate.onRegister(uas) : uas.reject({\n            statusCode: 405\n          });\n        }\n        break;\n\n      case C.SUBSCRIBE:\n        // https://tools.ietf.org/html/rfc6665#section-4.2\n        {\n          const uas = new SubscribeUserAgentServer(this, message);\n          this.delegate.onSubscribe ? this.delegate.onSubscribe(uas) : uas.reject({\n            statusCode: 480\n          });\n        }\n        break;\n\n      default:\n        throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n    }\n\n    return;\n  }\n  /**\n   * Responses are first processed by the transport layer and then passed\n   * up to the transaction layer.  The transaction layer performs its\n   * processing and then passes the response up to the TU.  The majority\n   * of response processing in the TU is method specific.  However, there\n   * are some general behaviors independent of the method.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3\n   * @param message - Incoming response message from transport layer.\n   */\n\n\n  receiveResponseFromTransport(message) {\n    // 8.1.3.1 Transaction Layer Errors\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n    // Handled by transaction layer callbacks.\n    // 8.1.3.2 Unrecognized Responses\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n    // TODO\n    // 8.1.3.3 Vias\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.3\n    if (message.getHeaders(\"via\").length > 1) {\n      this.logger.warn(\"More than one Via header field present in the response, dropping\");\n      return;\n    } // 8.1.3.4 Processing 3xx Responses\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.4\n    // TODO\n    // 8.1.3.5 Processing 4xx Responses\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n    // TODO\n    // When the transport layer in the client receives a response, it has to\n    // determine which client transaction will handle the response, so that\n    // the processing of Sections 17.1.1 and 17.1.2 can take place.  The\n    // branch parameter in the top Via header field is used for this\n    // purpose.  A response matches a client transaction under two\n    // conditions:\n    //\n    //    1.  If the response has the same value of the branch parameter in\n    //        the top Via header field as the branch parameter in the top\n    //        Via header field of the request that created the transaction.\n    //\n    //    2.  If the method parameter in the CSeq header field matches the\n    //        method of the request that created the transaction.  The\n    //        method is needed since a CANCEL request constitutes a\n    //        different transaction, but shares the same value of the branch\n    //        parameter.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.3\n\n\n    const userAgentClientId = message.viaBranch + message.method;\n    const userAgentClient = this.userAgentClients.get(userAgentClientId); // The client transport uses the matching procedures of Section\n    // 17.1.3 to attempt to match the response to an existing\n    // transaction.  If there is a match, the response MUST be passed to\n    // that transaction.  Otherwise, any element other than a stateless\n    // proxy MUST silently discard the response.\n    // https://tools.ietf.org/html/rfc6026#section-8.9\n\n    if (userAgentClient) {\n      userAgentClient.transaction.receiveResponse(message);\n    } else {\n      this.logger.warn(`Discarding unmatched ${message.statusCode} response to ${message.method} ${userAgentClientId}.`);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js"],"names":["C","constructOutgoingResponse","OutgoingRequestMessage","InviteServerTransaction","NonInviteClientTransaction","TransactionState","InviteUserAgentClient","InviteUserAgentServer","MessageUserAgentClient","MessageUserAgentServer","NotifyUserAgentServer","PublishUserAgentClient","ReferUserAgentServer","RegisterUserAgentClient","RegisterUserAgentServer","SubscribeUserAgentClient","SubscribeUserAgentServer","UserAgentClient","AllowedMethods","acceptedBodyTypes","UserAgentCore","constructor","configuration","delegate","userAgentClients","Map","userAgentServers","dialogs","subscribers","logger","loggerFactory","getLogger","dispose","reset","forEach","dialog","clear","subscriber","uac","transport","transportAccessor","Error","invite","request","message","publish","register","subscribe","makeOutgoingRequestMessage","method","requestURI","fromURI","toURI","options","extraHeaders","body","callIdPrefix","sipjsId","fromDisplayName","displayName","forceRport","viaForceRport","hackViaTcp","optionTags","supportedOptionTags","slice","REGISTER","push","INVITE","contact","pubGruu","tempGruu","routeSet","userAgentString","userAgentHeaderFieldValue","viaHost","defaultOptions","requestOptions","Object","assign","receiveIncomingRequestFromTransport","receiveRequestFromTransport","receiveIncomingResponseFromTransport","receiveResponseFromTransport","replyStateless","userAgent","supported","supportedOptionTagsResponse","response","send","catch","error","transactionId","viaBranch","uas","get","ACK","transaction","state","Accepted","warn","CANCEL","statusCode","Proceeding","receiveCancel","receiveRequest","includes","allowHeader","toString","ruri","scheme","ruriMatches","uri","user","aor","hasHeader","reasonPhrase","toTag","has","mergedRequest","Array","from","values","some","fromTag","callId","cseq","receiveInsideDialogRequest","receiveOutsideDialogRequest","NOTIFY","event","parseHeader","subscriberId","onNotify","dialogId","OPTIONS","acceptHeader","BYE","INFO","onInvite","reject","MESSAGE","onMessage","accept","REFER","onRefer","onRegister","SUBSCRIBE","onSubscribe","getHeaders","length","userAgentClientId","userAgentClient","receiveResponse"],"mappings":"AAAA,SAASA,CAAT,EAAYC,yBAAZ,EAAuCC,sBAAvC,QAAqE,aAArE;AACA,SAASC,uBAAT,EAAkCC,0BAAlC,EAA8DC,gBAA9D,QAAsF,iBAAtF;AACA,SAASC,qBAAT,EAAgCC,qBAAhC,EAAuDC,sBAAvD,EAA+EC,sBAA/E,EAAuGC,qBAAvG,EAA8HC,sBAA9H,EAAsJC,oBAAtJ,EAA4KC,uBAA5K,EAAqMC,uBAArM,EAA8NC,wBAA9N,EAAwPC,wBAAxP,EAAkRC,eAAlR,QAAyS,gBAAzS;AACA,SAASC,cAAT,QAA+B,mBAA/B;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAG,CAAC,iBAAD,EAAoB,wBAApB,CAA1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,aAAN,CAAoB;AACvB;AACJ;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,aAAD,EAAgBC,QAAQ,GAAG,EAA3B,EAA+B;AACtC;AACA,SAAKC,gBAAL,GAAwB,IAAIC,GAAJ,EAAxB;AACA;;AACA,SAAKC,gBAAL,GAAwB,IAAID,GAAJ,EAAxB;AACA,SAAKH,aAAL,GAAqBA,aAArB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKI,OAAL,GAAe,IAAIF,GAAJ,EAAf;AACA,SAAKG,WAAL,GAAmB,IAAIH,GAAJ,EAAnB;AACA,SAAKI,MAAL,GAAcP,aAAa,CAACQ,aAAd,CAA4BC,SAA5B,CAAsC,qBAAtC,CAAd;AACH;AACD;;;AACAC,EAAAA,OAAO,GAAG;AACN,SAAKC,KAAL;AACH;AACD;;;AACAA,EAAAA,KAAK,GAAG;AACJ,SAAKN,OAAL,CAAaO,OAAb,CAAsBC,MAAD,IAAYA,MAAM,CAACH,OAAP,EAAjC;AACA,SAAKL,OAAL,CAAaS,KAAb;AACA,SAAKR,WAAL,CAAiBM,OAAjB,CAA0BG,UAAD,IAAgBA,UAAU,CAACL,OAAX,EAAzC;AACA,SAAKJ,WAAL,CAAiBQ,KAAjB;AACA,SAAKZ,gBAAL,CAAsBU,OAAtB,CAA+BI,GAAD,IAASA,GAAG,CAACN,OAAJ,EAAvC;AACA,SAAKR,gBAAL,CAAsBY,KAAtB;AACA,SAAKV,gBAAL,CAAsBQ,OAAtB,CAA+BI,GAAD,IAASA,GAAG,CAACN,OAAJ,EAAvC;AACA,SAAKN,gBAAL,CAAsBU,KAAtB;AACH;AACD;;;AACA,MAAIN,aAAJ,GAAoB;AAChB,WAAO,KAAKR,aAAL,CAAmBQ,aAA1B;AACH;AACD;;;AACA,MAAIS,SAAJ,GAAgB;AACZ,UAAMA,SAAS,GAAG,KAAKjB,aAAL,CAAmBkB,iBAAnB,EAAlB;;AACA,QAAI,CAACD,SAAL,EAAgB;AACZ,YAAM,IAAIE,KAAJ,CAAU,sBAAV,CAAN;AACH;;AACD,WAAOF,SAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIG,EAAAA,MAAM,CAACC,OAAD,EAAUpB,QAAV,EAAoB;AACtB,WAAO,IAAIjB,qBAAJ,CAA0B,IAA1B,EAAgCqC,OAAhC,EAAyCpB,QAAzC,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIqB,EAAAA,OAAO,CAACD,OAAD,EAAUpB,QAAV,EAAoB;AACvB,WAAO,IAAIf,sBAAJ,CAA2B,IAA3B,EAAiCmC,OAAjC,EAA0CpB,QAA1C,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIsB,EAAAA,OAAO,CAACF,OAAD,EAAUpB,QAAV,EAAoB;AACvB,WAAO,IAAIZ,sBAAJ,CAA2B,IAA3B,EAAiCgC,OAAjC,EAA0CpB,QAA1C,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIuB,EAAAA,QAAQ,CAACH,OAAD,EAAUpB,QAAV,EAAoB;AACxB,WAAO,IAAIV,uBAAJ,CAA4B,IAA5B,EAAkC8B,OAAlC,EAA2CpB,QAA3C,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIwB,EAAAA,SAAS,CAACJ,OAAD,EAAUpB,QAAV,EAAoB;AACzB,WAAO,IAAIR,wBAAJ,CAA6B,IAA7B,EAAmC4B,OAAnC,EAA4CpB,QAA5C,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIoB,EAAAA,OAAO,CAACA,OAAD,EAAUpB,QAAV,EAAoB;AACvB,WAAO,IAAIN,eAAJ,CAAoBb,0BAApB,EAAgD,IAAhD,EAAsDuC,OAAtD,EAA+DpB,QAA/D,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIyB,EAAAA,0BAA0B,CAACC,MAAD,EAASC,UAAT,EAAqBC,OAArB,EAA8BC,KAA9B,EAAqCC,OAArC,EAA8CC,YAA9C,EAA4DC,IAA5D,EAAkE;AACxF;AACA,UAAMC,YAAY,GAAG,KAAKlC,aAAL,CAAmBmC,OAAxC;AACA,UAAMC,eAAe,GAAG,KAAKpC,aAAL,CAAmBqC,WAA3C;AACA,UAAMC,UAAU,GAAG,KAAKtC,aAAL,CAAmBuC,aAAtC;AACA,UAAMC,UAAU,GAAG,KAAKxC,aAAL,CAAmBwC,UAAtC;AACA,UAAMC,UAAU,GAAG,KAAKzC,aAAL,CAAmB0C,mBAAnB,CAAuCC,KAAvC,EAAnB;;AACA,QAAIhB,MAAM,KAAKjD,CAAC,CAACkE,QAAjB,EAA2B;AACvBH,MAAAA,UAAU,CAACI,IAAX,CAAgB,MAAhB,EAAwB,MAAxB;AACH;;AACD,QAAIlB,MAAM,KAAKjD,CAAC,CAACoE,MAAb,KAAwB,KAAK9C,aAAL,CAAmB+C,OAAnB,CAA2BC,OAA3B,IAAsC,KAAKhD,aAAL,CAAmB+C,OAAnB,CAA2BE,QAAzF,CAAJ,EAAwG;AACpGR,MAAAA,UAAU,CAACI,IAAX,CAAgB,MAAhB;AACH;;AACD,UAAMK,QAAQ,GAAG,KAAKlD,aAAL,CAAmBkD,QAApC;AACA,UAAMC,eAAe,GAAG,KAAKnD,aAAL,CAAmBoD,yBAA3C;AACA,UAAMC,OAAO,GAAG,KAAKrD,aAAL,CAAmBqD,OAAnC;AACA,UAAMC,cAAc,GAAG;AACnBpB,MAAAA,YADmB;AAEnBI,MAAAA,UAFmB;AAGnBF,MAAAA,eAHmB;AAInBI,MAAAA,UAJmB;AAKnBC,MAAAA,UALmB;AAMnBS,MAAAA,QANmB;AAOnBC,MAAAA,eAPmB;AAQnBE,MAAAA;AARmB,KAAvB,CAhBwF,CA0BxF;;AACA,UAAME,cAAc,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBH,cAAlB,CAAd,EAAiDvB,OAAjD,CAAvB;AACA,WAAO,IAAInD,sBAAJ,CAA2B+C,MAA3B,EAAmCC,UAAnC,EAA+CC,OAA/C,EAAwDC,KAAxD,EAA+DyB,cAA/D,EAA+EvB,YAA/E,EAA6FC,IAA7F,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIyB,EAAAA,mCAAmC,CAACpC,OAAD,EAAU;AACzC,SAAKqC,2BAAL,CAAiCrC,OAAjC;AACH;AACD;AACJ;AACA;AACA;;;AACIsC,EAAAA,oCAAoC,CAACtC,OAAD,EAAU;AAC1C,SAAKuC,4BAAL,CAAkCvC,OAAlC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIwC,EAAAA,cAAc,CAACxC,OAAD,EAAUS,OAAV,EAAmB;AAC7B,UAAMgC,SAAS,GAAG,KAAK/D,aAAL,CAAmBoD,yBAArC;AACA,UAAMY,SAAS,GAAG,KAAKhE,aAAL,CAAmBiE,2BAArC;AACAlC,IAAAA,OAAO,GAAGyB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB1B,OAAlB,CAAd,EAA0C;AAAEgC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAA1C,CAAV;AACA,UAAME,QAAQ,GAAGvF,yBAAyB,CAAC2C,OAAD,EAAUS,OAAV,CAA1C;AACA,SAAKd,SAAL,CAAekD,IAAf,CAAoBD,QAAQ,CAAC5C,OAA7B,EAAsC8C,KAAtC,CAA6CC,KAAD,IAAW;AACnD;AACA;AACA,UAAIA,KAAK,YAAYlD,KAArB,EAA4B;AACxB,aAAKZ,MAAL,CAAY8D,KAAZ,CAAkBA,KAAK,CAAC/C,OAAxB;AACH;;AACD,WAAKf,MAAL,CAAY8D,KAAZ,CAAmB,uDAAsD/C,OAAO,CAACK,MAAO,WAAxF,EANmD,CAOnD;AACA;AACA;AACH,KAVD;AAWA,WAAOuC,QAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIP,EAAAA,2BAA2B,CAACrC,OAAD,EAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMgD,aAAa,GAAGhD,OAAO,CAACiD,SAA9B,CA9BiC,CA8BQ;;AACzC,UAAMC,GAAG,GAAG,KAAKpE,gBAAL,CAAsBqE,GAAtB,CAA0BH,aAA1B,CAAZ,CA/BiC,CAgCjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIhD,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACgG,GAAzB,EAA8B;AAC1B,UAAIF,GAAG,IAAIA,GAAG,CAACG,WAAJ,CAAgBC,KAAhB,KAA0B7F,gBAAgB,CAAC8F,QAAtD,EAAgE;AAC5D,YAAIL,GAAG,YAAYvF,qBAAnB,EAA0C;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAKsB,MAAL,CAAYuE,IAAZ,CAAkB,uEAAsER,aAAc,GAAtG;AACA;AACH;AACJ;AACJ,KA1DgC,CA2DjC;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIhD,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACqG,MAAzB,EAAiC;AAC7B,UAAIP,GAAJ,EAAS;AACL;AACA;AACA;AACA;AACA,aAAKV,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,UAAAA,UAAU,EAAE;AAAd,SAA7B,EALK,CAML;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAIR,GAAG,CAACG,WAAJ,YAA2B9F,uBAA3B,IACA2F,GAAG,CAACG,WAAJ,CAAgBC,KAAhB,KAA0B7F,gBAAgB,CAACkG,UAD/C,EAC2D;AACvD,cAAIT,GAAG,YAAYvF,qBAAnB,EAA0C;AACtCuF,YAAAA,GAAG,CAACU,aAAJ,CAAkB5D,OAAlB;AACH,WAHsD,CAIvD;AACA;AACA;;AACH;AACJ,OA1BD,MA2BK;AACD;AACA;AACA;AACA;AACA,aAAKwC,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,UAAAA,UAAU,EAAE;AAAd,SAA7B;AACH;;AACD;AACH,KAtGgC,CAuGjC;AACA;AACA;;;AACA,QAAIR,GAAJ,EAAS;AACLA,MAAAA,GAAG,CAACG,WAAJ,CAAgBQ,cAAhB,CAA+B7D,OAA/B;AACA;AACH,KA7GgC,CA8GjC;AACA;AACA;;;AACA,SAAK6D,cAAL,CAAoB7D,OAApB;AACA;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI6D,EAAAA,cAAc,CAAC7D,OAAD,EAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAI,CAAC1B,cAAc,CAACwF,QAAf,CAAwB9D,OAAO,CAACK,MAAhC,CAAL,EAA8C;AAC1C,YAAM0D,WAAW,GAAG,YAAYzF,cAAc,CAAC0F,QAAf,EAAhC;AACA,WAAKxB,cAAL,CAAoBxC,OAApB,EAA6B;AACzB0D,QAAAA,UAAU,EAAE,GADa;AAEzBhD,QAAAA,YAAY,EAAE,CAACqD,WAAD;AAFW,OAA7B;AAIA;AACH,KAxBmB,CAyBpB;AACA;;;AACA,QAAI,CAAC/D,OAAO,CAACiE,IAAb,EAAmB;AACf;AACA,YAAM,IAAIpE,KAAJ,CAAU,wBAAV,CAAN;AACH,KA9BmB,CA+BpB;AACA;AACA;AACA;;;AACA,QAAIG,OAAO,CAACiE,IAAR,CAAaC,MAAb,KAAwB,KAA5B,EAAmC;AAC/B,WAAK1B,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,QAAAA,UAAU,EAAE;AAAd,OAA7B;AACA;AACH,KAtCmB,CAuCpB;AACA;AACA;AACA;AACA;;;AACA,UAAMO,IAAI,GAAGjE,OAAO,CAACiE,IAArB;;AACA,UAAME,WAAW,GAAIC,GAAD,IAAS;AACzB,aAAO,CAAC,CAACA,GAAF,IAASA,GAAG,CAACC,IAAJ,KAAaJ,IAAI,CAACI,IAAlC;AACH,KAFD;;AAGA,QAAI,CAACF,WAAW,CAAC,KAAKzF,aAAL,CAAmB4F,GAApB,CAAZ,IACA,EAAEH,WAAW,CAAC,KAAKzF,aAAL,CAAmB+C,OAAnB,CAA2B2C,GAA5B,CAAX,IACED,WAAW,CAAC,KAAKzF,aAAL,CAAmB+C,OAAnB,CAA2BC,OAA5B,CADb,IAEEyC,WAAW,CAAC,KAAKzF,aAAL,CAAmB+C,OAAnB,CAA2BE,QAA5B,CAFf,CADJ,EAG2D;AACvD,WAAK1C,MAAL,CAAYuE,IAAZ,CAAiB,mCAAjB;;AACA,UAAIxD,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACgG,GAAzB,EAA8B;AAC1B,aAAKZ,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,UAAAA,UAAU,EAAE;AAAd,SAA7B;AACH;;AACD;AACH,KAzDmB,CA0DpB;AACA;AACA;AACA;AACA;;;AACA,QAAI1D,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACoE,MAAzB,EAAiC;AAC7B,UAAI,CAACxB,OAAO,CAACuE,SAAR,CAAkB,SAAlB,CAAL,EAAmC;AAC/B,aAAK/B,cAAL,CAAoBxC,OAApB,EAA6B;AACzB0D,UAAAA,UAAU,EAAE,GADa;AAEzBc,UAAAA,YAAY,EAAE;AAFW,SAA7B;AAIA;AACH;AACJ,KAvEmB,CAwEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAI,CAACxE,OAAO,CAACyE,KAAb,EAAoB;AAChB,YAAMzB,aAAa,GAAGhD,OAAO,CAACiD,SAA9B;;AACA,UAAI,CAAC,KAAKnE,gBAAL,CAAsB4F,GAAtB,CAA0B1B,aAA1B,CAAL,EAA+C;AAC3C,cAAM2B,aAAa,GAAGC,KAAK,CAACC,IAAN,CAAW,KAAK/F,gBAAL,CAAsBgG,MAAtB,EAAX,EAA2CC,IAA3C,CAAiD7B,GAAD,IAASA,GAAG,CAACG,WAAJ,CAAgBtD,OAAhB,CAAwBiF,OAAxB,KAAoChF,OAAO,CAACgF,OAA5C,IAC3E9B,GAAG,CAACG,WAAJ,CAAgBtD,OAAhB,CAAwBkF,MAAxB,KAAmCjF,OAAO,CAACiF,MADgC,IAE3E/B,GAAG,CAACG,WAAJ,CAAgBtD,OAAhB,CAAwBmF,IAAxB,KAAiClF,OAAO,CAACkF,IAFvB,CAAtB;;AAGA,YAAIP,aAAJ,EAAmB;AACf,eAAKnC,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,YAAAA,UAAU,EAAE;AAAd,WAA7B;AACA;AACH;AACJ;AACJ,KAjGmB,CAkGpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAI1D,OAAO,CAACyE,KAAZ,EAAmB;AACf,WAAKU,0BAAL,CAAgCnF,OAAhC;AACH,KAFD,MAGK;AACD,WAAKoF,2BAAL,CAAiCpF,OAAjC;AACH;;AACD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACImF,EAAAA,0BAA0B,CAACnF,OAAD,EAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,QAAIA,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACiI,MAAzB,EAAiC;AAC7B,YAAMC,KAAK,GAAGtF,OAAO,CAACuF,WAAR,CAAoB,OAApB,CAAd;;AACA,UAAI,CAACD,KAAD,IAAU,CAACA,KAAK,CAACA,KAArB,EAA4B;AACxB,aAAK9C,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,UAAAA,UAAU,EAAE;AAAd,SAA7B;AACA;AACH,OAL4B,CAM7B;;;AACA,YAAM8B,YAAY,GAAGxF,OAAO,CAACiF,MAAR,GAAiBjF,OAAO,CAACyE,KAAzB,GAAiCa,KAAK,CAACA,KAA5D;AACA,YAAM7F,UAAU,GAAG,KAAKT,WAAL,CAAiBmE,GAAjB,CAAqBqC,YAArB,CAAnB;;AACA,UAAI/F,UAAJ,EAAgB;AACZ,cAAMyD,GAAG,GAAG,IAAIpF,qBAAJ,CAA0B,IAA1B,EAAgCkC,OAAhC,CAAZ;AACAP,QAAAA,UAAU,CAACgG,QAAX,CAAoBvC,GAApB;AACA;AACH;AACJ,KArB+B,CAsBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMwC,QAAQ,GAAG1F,OAAO,CAACiF,MAAR,GAAiBjF,OAAO,CAACyE,KAAzB,GAAiCzE,OAAO,CAACgF,OAA1D;AACA,UAAMzF,MAAM,GAAG,KAAKR,OAAL,CAAaoE,GAAb,CAAiBuC,QAAjB,CAAf;;AACA,QAAInG,MAAJ,EAAY;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIS,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACuI,OAAzB,EAAkC;AAC9B,cAAM5B,WAAW,GAAG,YAAYzF,cAAc,CAAC0F,QAAf,EAAhC;AACA,cAAM4B,YAAY,GAAG,aAAarH,iBAAiB,CAACyF,QAAlB,EAAlC;AACA,aAAKxB,cAAL,CAAoBxC,OAApB,EAA6B;AACzB0D,UAAAA,UAAU,EAAE,GADa;AAEzBhD,UAAAA,YAAY,EAAE,CAACqD,WAAD,EAAc6B,YAAd;AAFW,SAA7B;AAIA;AACH,OAhDO,CAiDR;;;AACArG,MAAAA,MAAM,CAACsE,cAAP,CAAsB7D,OAAtB;AACA;AACH,KAzF+B,CA0FhC;AACA;AACA;AACA;AACA;;;AACA,QAAIA,OAAO,CAACK,MAAR,KAAmBjD,CAAC,CAACgG,GAAzB,EAA8B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACH,KAvG+B,CAwGhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAKZ,cAAL,CAAoBxC,OAApB,EAA6B;AAAE0D,MAAAA,UAAU,EAAE;AAAd,KAA7B;AACA;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACI0B,EAAAA,2BAA2B,CAACpF,OAAD,EAAU;AACjC,YAAQA,OAAO,CAACK,MAAhB;AACI,WAAKjD,CAAC,CAACgG,GAAP;AACI;AACA;;AACJ,WAAKhG,CA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","sourcesContent":["import { C, constructOutgoingResponse, OutgoingRequestMessage } from \"../messages\";\nimport { InviteServerTransaction, NonInviteClientTransaction, TransactionState } from \"../transactions\";\nimport { InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentServer, PublishUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient } from \"../user-agents\";\nimport { AllowedMethods } from \"./allowed-methods\";\n/**\n * This is ported from UA.C.ACCEPTED_BODY_TYPES.\n * FIXME: TODO: Should be configurable/variable.\n */\nconst acceptedBodyTypes = [\"application/sdp\", \"application/dtmf-relay\"];\n/**\n * User Agent Core.\n * @remarks\n * Core designates the functions specific to a particular type\n * of SIP entity, i.e., specific to either a stateful or stateless\n * proxy, a user agent or registrar.  All cores, except those for\n * the stateless proxy, are transaction users.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAC Core: The set of processing functions required of a UAC that\n * reside above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAS Core: The set of processing functions required at a UAS that\n * resides above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\nexport class UserAgentCore {\n    /**\n     * Constructor.\n     * @param configuration - Configuration.\n     * @param delegate - Delegate.\n     */\n    constructor(configuration, delegate = {}) {\n        /** UACs. */\n        this.userAgentClients = new Map();\n        /** UASs. */\n        this.userAgentServers = new Map();\n        this.configuration = configuration;\n        this.delegate = delegate;\n        this.dialogs = new Map();\n        this.subscribers = new Map();\n        this.logger = configuration.loggerFactory.getLogger(\"sip.user-agent-core\");\n    }\n    /** Destructor. */\n    dispose() {\n        this.reset();\n    }\n    /** Reset. */\n    reset() {\n        this.dialogs.forEach((dialog) => dialog.dispose());\n        this.dialogs.clear();\n        this.subscribers.forEach((subscriber) => subscriber.dispose());\n        this.subscribers.clear();\n        this.userAgentClients.forEach((uac) => uac.dispose());\n        this.userAgentClients.clear();\n        this.userAgentServers.forEach((uac) => uac.dispose());\n        this.userAgentServers.clear();\n    }\n    /** Logger factory. */\n    get loggerFactory() {\n        return this.configuration.loggerFactory;\n    }\n    /** Transport. */\n    get transport() {\n        const transport = this.configuration.transportAccessor();\n        if (!transport) {\n            throw new Error(\"Transport undefined.\");\n        }\n        return transport;\n    }\n    /**\n     * Send INVITE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    invite(request, delegate) {\n        return new InviteUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send MESSAGE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    message(request, delegate) {\n        return new MessageUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send PUBLISH.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    publish(request, delegate) {\n        return new PublishUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send REGISTER.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    register(request, delegate) {\n        return new RegisterUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send SUBSCRIBE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    subscribe(request, delegate) {\n        return new SubscribeUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send a request.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    request(request, delegate) {\n        return new UserAgentClient(NonInviteClientTransaction, this, request, delegate);\n    }\n    /**\n     * Outgoing request message factory function.\n     * @param method - Method.\n     * @param requestURI - Request-URI.\n     * @param fromURI - From URI.\n     * @param toURI - To URI.\n     * @param options - Request options.\n     * @param extraHeaders - Extra headers to add.\n     * @param body - Message body.\n     */\n    makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {\n        // default values from user agent configuration\n        const callIdPrefix = this.configuration.sipjsId;\n        const fromDisplayName = this.configuration.displayName;\n        const forceRport = this.configuration.viaForceRport;\n        const hackViaTcp = this.configuration.hackViaTcp;\n        const optionTags = this.configuration.supportedOptionTags.slice();\n        if (method === C.REGISTER) {\n            optionTags.push(\"path\", \"gruu\");\n        }\n        if (method === C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {\n            optionTags.push(\"gruu\");\n        }\n        const routeSet = this.configuration.routeSet;\n        const userAgentString = this.configuration.userAgentHeaderFieldValue;\n        const viaHost = this.configuration.viaHost;\n        const defaultOptions = {\n            callIdPrefix,\n            forceRport,\n            fromDisplayName,\n            hackViaTcp,\n            optionTags,\n            routeSet,\n            userAgentString,\n            viaHost\n        };\n        // merge provided options with default options\n        const requestOptions = Object.assign(Object.assign({}, defaultOptions), options);\n        return new OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);\n    }\n    /**\n     * Handle an incoming request message from the transport.\n     * @param message - Incoming request message from transport layer.\n     */\n    receiveIncomingRequestFromTransport(message) {\n        this.receiveRequestFromTransport(message);\n    }\n    /**\n     * Handle an incoming response message from the transport.\n     * @param message - Incoming response message from transport layer.\n     */\n    receiveIncomingResponseFromTransport(message) {\n        this.receiveResponseFromTransport(message);\n    }\n    /**\n     * A stateless UAS is a UAS that does not maintain transaction state.\n     * It replies to requests normally, but discards any state that would\n     * ordinarily be retained by a UAS after a response has been sent.  If a\n     * stateless UAS receives a retransmission of a request, it regenerates\n     * the response and re-sends it, just as if it were replying to the first\n     * instance of the request. A UAS cannot be stateless unless the request\n     * processing for that method would always result in the same response\n     * if the requests are identical. This rules out stateless registrars,\n     * for example.  Stateless UASs do not use a transaction layer; they\n     * receive requests directly from the transport layer and send responses\n     * directly to the transport layer.\n     * https://tools.ietf.org/html/rfc3261#section-8.2.7\n     * @param message - Incoming request message to reply to.\n     * @param statusCode - Status code to reply with.\n     */\n    replyStateless(message, options) {\n        const userAgent = this.configuration.userAgentHeaderFieldValue;\n        const supported = this.configuration.supportedOptionTagsResponse;\n        options = Object.assign(Object.assign({}, options), { userAgent, supported });\n        const response = constructOutgoingResponse(message, options);\n        this.transport.send(response.message).catch((error) => {\n            // If the transport rejects, it SHOULD reject with a TransportError.\n            // But the transport may be external code, so we are careful...\n            if (error instanceof Error) {\n                this.logger.error(error.message);\n            }\n            this.logger.error(`Transport error occurred sending stateless reply to ${message.method} request.`);\n            // TODO: Currently there is no hook to provide notification that a transport error occurred\n            // and throwing would result in an uncaught error (in promise), so we silently eat the error.\n            // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.\n        });\n        return response;\n    }\n    /**\n     * In Section 18.2.1, replace the last paragraph with:\n     *\n     * Next, the server transport attempts to match the request to a\n     * server transaction.  It does so using the matching rules described\n     * in Section 17.2.3.  If a matching server transaction is found, the\n     * request is passed to that transaction for processing.  If no match\n     * is found, the request is passed to the core, which may decide to\n     * construct a new server transaction for that request.\n     * https://tools.ietf.org/html/rfc6026#section-8.10\n     * @param message - Incoming request message from transport layer.\n     */\n    receiveRequestFromTransport(message) {\n        // When a request is received from the network by the server, it has to\n        // be matched to an existing transaction.  This is accomplished in the\n        // following manner.\n        //\n        // The branch parameter in the topmost Via header field of the request\n        // is examined.  If it is present and begins with the magic cookie\n        // \"z9hG4bK\", the request was generated by a client transaction\n        // compliant to this specification.  Therefore, the branch parameter\n        // will be unique across all transactions sent by that client.  The\n        // request matches a transaction if:\n        //\n        //    1. the branch parameter in the request is equal to the one in the\n        //       top Via header field of the request that created the\n        //       transaction, and\n        //\n        //    2. the sent-by value in the top Via of the request is equal to the\n        //       one in the request that created the transaction, and\n        //\n        //    3. the method of the request matches the one that created the\n        //       transaction, except for ACK, where the method of the request\n        //       that created the transaction is INVITE.\n        //\n        // This matching rule applies to both INVITE and non-INVITE transactions\n        // alike.\n        //\n        //    The sent-by value is used as part of the matching process because\n        //    there could be accidental or malicious duplication of branch\n        //    parameters from different clients.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.3\n        const transactionId = message.viaBranch; // FIXME: Currently only using rule 1...\n        const uas = this.userAgentServers.get(transactionId);\n        // When receiving an ACK that matches an existing INVITE server\n        // transaction and that does not contain a branch parameter containing\n        // the magic cookie defined in RFC 3261, the matching transaction MUST\n        // be checked to see if it is in the \"Accepted\" state.  If it is, then\n        // the ACK must be passed directly to the transaction user instead of\n        // being absorbed by the transaction state machine.  This is necessary\n        // as requests from RFC 2543 clients will not include a unique branch\n        // parameter, and the mechanisms for calculating the transaction ID from\n        // such a request will be the same for both INVITE and ACKs.\n        // https://tools.ietf.org/html/rfc6026#section-6\n        // Any ACKs received from the network while in the \"Accepted\" state MUST be\n        // passed directly to the TU and not absorbed.\n        // https://tools.ietf.org/html/rfc6026#section-7.1\n        if (message.method === C.ACK) {\n            if (uas && uas.transaction.state === TransactionState.Accepted) {\n                if (uas instanceof InviteUserAgentServer) {\n                    // These are ACKs matching an INVITE server transaction.\n                    // These should never happen with RFC 3261 compliant user agents\n                    // (would be a broken ACK to negative final response or something)\n                    // but is apparently how RFC 2543 user agents do things.\n                    // We are not currently supporting this case.\n                    // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n                    this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${transactionId}.`);\n                    return;\n                }\n            }\n        }\n        // The CANCEL method requests that the TU at the server side cancel a\n        // pending transaction.  The TU determines the transaction to be\n        // cancelled by taking the CANCEL request, and then assuming that the\n        // request method is anything but CANCEL or ACK and applying the\n        // transaction matching procedures of Section 17.2.3.  The matching\n        // transaction is the one to be cancelled.\n        // https://tools.ietf.org/html/rfc3261#section-9.2\n        if (message.method === C.CANCEL) {\n            if (uas) {\n                // Regardless of the method of the original request, as long as the\n                // CANCEL matched an existing transaction, the UAS answers the CANCEL\n                // request itself with a 200 (OK) response.\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                this.replyStateless(message, { statusCode: 200 });\n                // If the transaction for the original request still exists, the behavior\n                // of the UAS on receiving a CANCEL request depends on whether it has already\n                // sent a final response for the original request. If it has, the CANCEL\n                // request has no effect on the processing of the original request, no\n                // effect on any session state, and no effect on the responses generated\n                // for the original request. If the UAS has not issued a final response\n                // for the original request, its behavior depends on the method of the\n                // original request. If the original request was an INVITE, the UAS\n                // SHOULD immediately respond to the INVITE with a 487 (Request\n                // Terminated).\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                if (uas.transaction instanceof InviteServerTransaction &&\n                    uas.transaction.state === TransactionState.Proceeding) {\n                    if (uas instanceof InviteUserAgentServer) {\n                        uas.receiveCancel(message);\n                    }\n                    // A CANCEL request has no impact on the processing of\n                    // transactions with any other method defined in this specification.\n                    // https://tools.ietf.org/html/rfc3261#section-9.2\n                }\n            }\n            else {\n                // If the UAS did not find a matching transaction for the CANCEL\n                // according to the procedure above, it SHOULD respond to the CANCEL\n                // with a 481 (Call Leg/Transaction Does Not Exist).\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                this.replyStateless(message, { statusCode: 481 });\n            }\n            return;\n        }\n        // If a matching server transaction is found, the request is passed to that\n        // transaction for processing.\n        // https://tools.ietf.org/html/rfc6026#section-8.10\n        if (uas) {\n            uas.transaction.receiveRequest(message);\n            return;\n        }\n        // If no match is found, the request is passed to the core, which may decide to\n        // construct a new server transaction for that request.\n        // https://tools.ietf.org/html/rfc6026#section-8.10\n        this.receiveRequest(message);\n        return;\n    }\n    /**\n     * UAC and UAS procedures depend strongly on two factors.  First, based\n     * on whether the request or response is inside or outside of a dialog,\n     * and second, based on the method of a request.  Dialogs are discussed\n     * thoroughly in Section 12; they represent a peer-to-peer relationship\n     * between user agents and are established by specific SIP methods, such\n     * as INVITE.\n     * @param message - Incoming request message.\n     */\n    receiveRequest(message) {\n        // 8.2 UAS Behavior\n        // UASs SHOULD process the requests in the order of the steps that\n        // follow in this section (that is, starting with authentication, then\n        // inspecting the method, the header fields, and so on throughout the\n        // remainder of this section).\n        // https://tools.ietf.org/html/rfc3261#section-8.2\n        // 8.2.1 Method Inspection\n        // Once a request is authenticated (or authentication is skipped), the\n        // UAS MUST inspect the method of the request.  If the UAS recognizes\n        // but does not support the method of a request, it MUST generate a 405\n        // (Method Not Allowed) response.  Procedures for generating responses\n        // are described in Section 8.2.6.  The UAS MUST also add an Allow\n        // header field to the 405 (Method Not Allowed) response.  The Allow\n        // header field MUST list the set of methods supported by the UAS\n        // generating the message.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.1\n        if (!AllowedMethods.includes(message.method)) {\n            const allowHeader = \"Allow: \" + AllowedMethods.toString();\n            this.replyStateless(message, {\n                statusCode: 405,\n                extraHeaders: [allowHeader]\n            });\n            return;\n        }\n        // 8.2.2 Header Inspection\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2\n        if (!message.ruri) {\n            // FIXME: A request message should always have an ruri\n            throw new Error(\"Request-URI undefined.\");\n        }\n        // 8.2.2.1 To and Request-URI\n        // If the Request-URI uses a scheme not supported by the UAS, it SHOULD\n        // reject the request with a 416 (Unsupported URI Scheme) response.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        if (message.ruri.scheme !== \"sip\") {\n            this.replyStateless(message, { statusCode: 416 });\n            return;\n        }\n        // 8.2.2.1 To and Request-URI\n        // If the Request-URI does not identify an address that the\n        // UAS is willing to accept requests for, it SHOULD reject\n        // the request with a 404 (Not Found) response.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        const ruri = message.ruri;\n        const ruriMatches = (uri) => {\n            return !!uri && uri.user === ruri.user;\n        };\n        if (!ruriMatches(this.configuration.aor) &&\n            !(ruriMatches(this.configuration.contact.uri) ||\n                ruriMatches(this.configuration.contact.pubGruu) ||\n                ruriMatches(this.configuration.contact.tempGruu))) {\n            this.logger.warn(\"Request-URI does not point to us.\");\n            if (message.method !== C.ACK) {\n                this.replyStateless(message, { statusCode: 404 });\n            }\n            return;\n        }\n        // 8.2.2.1 To and Request-URI\n        // Other potential sources of received Request-URIs include\n        // the Contact header fields of requests and responses sent by the UA\n        // that establish or refresh dialogs.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        if (message.method === C.INVITE) {\n            if (!message.hasHeader(\"Contact\")) {\n                this.replyStateless(message, {\n                    statusCode: 400,\n                    reasonPhrase: \"Missing Contact Header\"\n                });\n                return;\n            }\n        }\n        // 8.2.2.2 Merged Requests\n        // If the request has no tag in the To header field, the UAS core MUST\n        // check the request against ongoing transactions.  If the From tag,\n        // Call-ID, and CSeq exactly match those associated with an ongoing\n        // transaction, but the request does not match that transaction (based\n        // on the matching rules in Section 17.2.3), the UAS core SHOULD\n        // generate a 482 (Loop Detected) response and pass it to the server\n        // transaction.\n        //\n        //    The same request has arrived at the UAS more than once, following\n        //    different paths, most likely due to forking.  The UAS processes\n        //    the first such request received and responds with a 482 (Loop\n        //    Detected) to the rest of them.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.2\n        if (!message.toTag) {\n            const transactionId = message.viaBranch;\n            if (!this.userAgentServers.has(transactionId)) {\n                const mergedRequest = Array.from(this.userAgentServers.values()).some((uas) => uas.transaction.request.fromTag === message.fromTag &&\n                    uas.transaction.request.callId === message.callId &&\n                    uas.transaction.request.cseq === message.cseq);\n                if (mergedRequest) {\n                    this.replyStateless(message, { statusCode: 482 });\n                    return;\n                }\n            }\n        }\n        // 8.2.2.3 Require\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.3\n        // TODO\n        // 8.2.3 Content Processing\n        // https://tools.ietf.org/html/rfc3261#section-8.2.3\n        // TODO\n        // 8.2.4 Applying Extensions\n        // https://tools.ietf.org/html/rfc3261#section-8.2.4\n        // TODO\n        // 8.2.5 Processing the Request\n        // Assuming all of the checks in the previous subsections are passed,\n        // the UAS processing becomes method-specific.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.5\n        // The UAS will receive the request from the transaction layer.  If the\n        // request has a tag in the To header field, the UAS core computes the\n        // dialog identifier corresponding to the request and compares it with\n        // existing dialogs.  If there is a match, this is a mid-dialog request.\n        // In that case, the UAS first applies the same processing rules for\n        // requests outside of a dialog, discussed in Section 8.2.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (message.toTag) {\n            this.receiveInsideDialogRequest(message);\n        }\n        else {\n            this.receiveOutsideDialogRequest(message);\n        }\n        return;\n    }\n    /**\n     * Once a dialog has been established between two UAs, either of them\n     * MAY initiate new transactions as needed within the dialog.  The UA\n     * sending the request will take the UAC role for the transaction.  The\n     * UA receiving the request will take the UAS role.  Note that these may\n     * be different roles than the UAs held during the transaction that\n     * established the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2\n     * @param message - Incoming request message.\n     */\n    receiveInsideDialogRequest(message) {\n        // NOTIFY requests are matched to such SUBSCRIBE requests if they\n        // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n        // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n        // request, and the same \"Event\" header field.  Rules for comparisons of\n        // the \"Event\" header fields are described in Section 8.2.1.\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        if (message.method === C.NOTIFY) {\n            const event = message.parseHeader(\"Event\");\n            if (!event || !event.event) {\n                this.replyStateless(message, { statusCode: 489 });\n                return;\n            }\n            // FIXME: Subscriber id should also matching on event id.\n            const subscriberId = message.callId + message.toTag + event.event;\n            const subscriber = this.subscribers.get(subscriberId);\n            if (subscriber) {\n                const uas = new NotifyUserAgentServer(this, message);\n                subscriber.onNotify(uas);\n                return;\n            }\n        }\n        // Requests sent within a dialog, as any other requests, are atomic.  If\n        // a particular request is accepted by the UAS, all the state changes\n        // associated with it are performed.  If the request is rejected, none\n        // of the state changes are performed.\n        //\n        //    Note that some requests, such as INVITEs, affect several pieces of\n        //    state.\n        //\n        // The UAS will receive the request from the transaction layer.  If the\n        // request has a tag in the To header field, the UAS core computes the\n        // dialog identifier corresponding to the request and compares it with\n        // existing dialogs.  If there is a match, this is a mid-dialog request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        const dialogId = message.callId + message.toTag + message.fromTag;\n        const dialog = this.dialogs.get(dialogId);\n        if (dialog) {\n            // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS\n            // You got the question right.\n            //\n            // And you got the right answer too. :-)\n            //\n            //   Thanks,\n            //   Paul\n            //\n            // Robert Sparks wrote:\n            // > So I've lost track of the question during the musing.\n            // >\n            // > I _think_ the fundamental question being asked is this:\n            // >\n            // > Is an endpoint required to reject (with a 481) an OPTIONS request that\n            // > arrives with at to-tag but does not match any existing dialog state.\n            // > (Assuming some earlier requirement hasn't forced another error code). Or\n            // > is it OK if it just sends\n            // > a 200 OK anyhow.\n            // >\n            // > My take on the collection of specs is that its _not_ ok for it to send\n            // > the 200 OK anyhow and that it is required to send\n            // > the 481. I base this primarily on these sentences from 11.2 in 3261:\n            // >\n            // >    The response to an OPTIONS is constructed using the standard rules\n            // >    for a SIP response as discussed in Section 8.2.6.  The response code\n            // >    chosen MUST be the same that would have been chosen had the request\n            // >    been an INVITE.\n            // >\n            // > Did I miss the point of the question?\n            // >\n            // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:\n            // >\n            // >> [Including Robert in hopes of getting his insight on this.]\n            // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html\n            //\n            // Requests that do not change in any way the state of a dialog may be\n            // received within a dialog (for example, an OPTIONS request).  They are\n            // processed as if they had been received outside the dialog.\n            // https://tools.ietf.org/html/rfc3261#section-12.2.2\n            if (message.method === C.OPTIONS) {\n                const allowHeader = \"Allow: \" + AllowedMethods.toString();\n                const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n                this.replyStateless(message, {\n                    statusCode: 200,\n                    extraHeaders: [allowHeader, acceptHeader]\n                });\n                return;\n            }\n            // Pass the incoming request to the dialog for further handling.\n            dialog.receiveRequest(message);\n            return;\n        }\n        // The most important behaviors of a stateless UAS are the following:\n        // ...\n        // o  A stateless UAS MUST ignore ACK requests.\n        // ...\n        // https://tools.ietf.org/html/rfc3261#section-8.2.7\n        if (message.method === C.ACK) {\n            // If a final response to an INVITE was sent statelessly,\n            // the corresponding ACK:\n            // - will not match an existing transaction\n            // - may have tag in the To header field\n            // - not not match any existing dialogs\n            // Absorb unmatched ACKs.\n            return;\n        }\n        // If the request has a tag in the To header field, but the dialog\n        // identifier does not match any existing dialogs, the UAS may have\n        // crashed and restarted, or it may have received a request for a\n        // different (possibly failed) UAS (the UASs can construct the To tags\n        // so that a UAS can identify that the tag was for a UAS for which it is\n        // providing recovery).  Another possibility is that the incoming\n        // request has been simply mis-routed.  Based on the To tag, the UAS MAY\n        // either accept or reject the request.  Accepting the request for\n        // acceptable To tags provides robustness, so that dialogs can persist\n        // even through crashes.  UAs wishing to support this capability must\n        // take into consideration some issues such as choosing monotonically\n        // increasing CSeq sequence numbers even across reboots, reconstructing\n        // the route set, and accepting out-of-range RTP timestamps and sequence\n        // numbers.\n        //\n        // If the UAS wishes to reject the request because it does not wish to\n        // recreate the dialog, it MUST respond to the request with a 481\n        // (Call/Transaction Does Not Exist) status code and pass that to the\n        // server transaction.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        this.replyStateless(message, { statusCode: 481 });\n        return;\n    }\n    /**\n     * Assuming all of the checks in the previous subsections are passed,\n     * the UAS processing becomes method-specific.\n     *  https://tools.ietf.org/html/rfc3261#section-8.2.5\n     * @param message - Incoming request message.\n     */\n    receiveOutsideDialogRequest(message) {\n        switch (message.method) {\n            case C.ACK:\n                // Absorb stray out of dialog ACKs\n                break;\n            case C.BYE:\n                // If the BYE does not match an existing dialog, the UAS core SHOULD\n                // generate a 481 (Call/Transaction Does Not Exist) response and pass\n                // that to the server transaction. This rule means that a BYE sent\n                // without tags by a UAC will be rejected.\n                // https://tools.ietf.org/html/rfc3261#section-15.1.2\n                this.replyStateless(message, { statusCode: 481 });\n                break;\n            case C.CANCEL:\n                throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n                break;\n            case C.INFO:\n                // Use of the INFO method does not constitute a separate dialog usage.\n                // INFO messages are always part of, and share the fate of, an invite\n                // dialog usage [RFC5057].  INFO messages cannot be sent as part of\n                // other dialog usages, or outside an existing dialog.\n                // https://tools.ietf.org/html/rfc6086#section-1\n                this.replyStateless(message, { statusCode: 405 }); // Should never happen\n                break;\n            case C.INVITE:\n                // https://tools.ietf.org/html/rfc3261#section-13.3.1\n                {\n                    const uas = new InviteUserAgentServer(this, message);\n                    this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();\n                }\n                break;\n            case C.MESSAGE:\n                // MESSAGE requests are discouraged inside a dialog.  Implementations\n                // are restricted from creating a usage for the purpose of carrying a\n                // sequence of MESSAGE requests (though some implementations use it that\n                // way, against the standard recommendation).\n                // https://tools.ietf.org/html/rfc5057#section-5.3\n                {\n                    const uas = new MessageUserAgentServer(this, message);\n                    this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n                }\n                break;\n            case C.NOTIFY:\n                // Obsoleted by: RFC 6665\n                // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,\n                // it is the responsibility of the parties defining those mechanisms to\n                // ensure that correlation of a NOTIFY message to the corresponding\n                // subscription is possible.  Designers of such mechanisms are also\n                // warned to make a distinction between sending a NOTIFY message to a\n                // subscriber who is aware of the subscription, and sending a NOTIFY\n                // message to an unsuspecting node.  The latter behavior is invalid, and\n                // MUST receive a \"481 Subscription does not exist\" response (unless\n                // some other 400- or 500-class error code is more applicable), as\n                // described in section 3.2.4.  In other words, knowledge of a\n                // subscription must exist in both the subscriber and the notifier to be\n                // valid, even if installed via a non-SUBSCRIBE mechanism.\n                // https://tools.ietf.org/html/rfc3265#section-3.2\n                //\n                // NOTIFY requests are sent to inform subscribers of changes in state to\n                // which the subscriber has a subscription.  Subscriptions are created\n                // using the SUBSCRIBE method.  In legacy implementations, it is\n                // possible that other means of subscription creation have been used.\n                // However, this specification does not allow the creation of\n                // subscriptions except through SUBSCRIBE requests and (for backwards-\n                // compatibility) REFER requests [RFC3515].\n                // https://tools.ietf.org/html/rfc6665#section-3.2\n                {\n                    const uas = new NotifyUserAgentServer(this, message);\n                    this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.OPTIONS:\n                // https://tools.ietf.org/html/rfc3261#section-11.2\n                {\n                    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n                    const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n                    this.replyStateless(message, {\n                        statusCode: 200,\n                        extraHeaders: [allowHeader, acceptHeader]\n                    });\n                }\n                break;\n            case C.REFER:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.2\n                {\n                    const uas = new ReferUserAgentServer(this, message);\n                    this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.REGISTER:\n                // https://tools.ietf.org/html/rfc3261#section-10.3\n                {\n                    const uas = new RegisterUserAgentServer(this, message);\n                    this.delegate.onRegister ? this.delegate.onRegister(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.SUBSCRIBE:\n                // https://tools.ietf.org/html/rfc6665#section-4.2\n                {\n                    const uas = new SubscribeUserAgentServer(this, message);\n                    this.delegate.onSubscribe ? this.delegate.onSubscribe(uas) : uas.reject({ statusCode: 480 });\n                }\n                break;\n            default:\n                throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n        }\n        return;\n    }\n    /**\n     * Responses are first processed by the transport layer and then passed\n     * up to the transaction layer.  The transaction layer performs its\n     * processing and then passes the response up to the TU.  The majority\n     * of response processing in the TU is method specific.  However, there\n     * are some general behaviors independent of the method.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3\n     * @param message - Incoming response message from transport layer.\n     */\n    receiveResponseFromTransport(message) {\n        // 8.1.3.1 Transaction Layer Errors\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n        // Handled by transaction layer callbacks.\n        // 8.1.3.2 Unrecognized Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n        // TODO\n        // 8.1.3.3 Vias\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.3\n        if (message.getHeaders(\"via\").length > 1) {\n            this.logger.warn(\"More than one Via header field present in the response, dropping\");\n            return;\n        }\n        // 8.1.3.4 Processing 3xx Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.4\n        // TODO\n        // 8.1.3.5 Processing 4xx Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n        // TODO\n        // When the transport layer in the client receives a response, it has to\n        // determine which client transaction will handle the response, so that\n        // the processing of Sections 17.1.1 and 17.1.2 can take place.  The\n        // branch parameter in the top Via header field is used for this\n        // purpose.  A response matches a client transaction under two\n        // conditions:\n        //\n        //    1.  If the response has the same value of the branch parameter in\n        //        the top Via header field as the branch parameter in the top\n        //        Via header field of the request that created the transaction.\n        //\n        //    2.  If the method parameter in the CSeq header field matches the\n        //        method of the request that created the transaction.  The\n        //        method is needed since a CANCEL request constitutes a\n        //        different transaction, but shares the same value of the branch\n        //        parameter.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.3\n        const userAgentClientId = message.viaBranch + message.method;\n        const userAgentClient = this.userAgentClients.get(userAgentClientId);\n        // The client transport uses the matching procedures of Section\n        // 17.1.3 to attempt to match the response to an existing\n        // transaction.  If there is a match, the response MUST be passed to\n        // that transaction.  Otherwise, any element other than a stateless\n        // proxy MUST silently discard the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.9\n        if (userAgentClient) {\n            userAgentClient.transaction.receiveResponse(message);\n        }\n        else {\n            this.logger.warn(`Discarding unmatched ${message.statusCode} response to ${message.method} ${userAgentClientId}.`);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}