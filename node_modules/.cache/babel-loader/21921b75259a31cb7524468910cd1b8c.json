{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport var SessionDescriptionHandler = /*#__PURE__*/function () {\n  /**\n   * Constructor\n   * @param logger - A logger\n   * @param mediaStreamFactory - A factory to provide a MediaStream\n   * @param options - Options passed from the SessionDescriptionHandleFactory\n   */\n  function SessionDescriptionHandler(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n    _classCallCheck(this, SessionDescriptionHandler);\n\n    logger.debug(\"SessionDescriptionHandler.constructor\");\n    this.logger = logger;\n    this.mediaStreamFactory = mediaStreamFactory;\n    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n    this._localMediaStream = new MediaStream();\n    this._remoteMediaStream = new MediaStream();\n    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);\n    this.initPeerConnectionEventHandlers();\n  }\n  /**\n   * The local media stream currently being sent.\n   *\n   * @remarks\n   * The local media stream initially has no tracks, so the presence of tracks\n   * should not be assumed. Furthermore, tracks may be added or removed if the\n   * local media changes - for example, on upgrade from audio only to a video session.\n   * At any given time there will be at most one audio track and one video track\n   * (it's possible that this restriction may not apply to sub-classes).\n   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n   * to detect when a new track becomes available:\n   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n   */\n\n\n  _createClass(SessionDescriptionHandler, [{\n    key: \"close\",\n\n    /**\n     * Stop tracks and close peer connection.\n     */\n    value: function close() {\n      this.logger.debug(\"SessionDescriptionHandler.close\");\n\n      if (this._peerConnection === undefined) {\n        return;\n      }\n\n      this._peerConnection.getReceivers().forEach(function (receiver) {\n        receiver.track && receiver.track.stop();\n      });\n\n      this._peerConnection.getSenders().forEach(function (sender) {\n        sender.track && sender.track.stop();\n      });\n\n      if (this._dataChannel) {\n        this._dataChannel.close();\n      }\n\n      this._peerConnection.close();\n\n      this._peerConnection = undefined;\n    }\n    /**\n     * Creates an offer or answer.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n\n  }, {\n    key: \"getDescription\",\n    value: function getDescription(options, modifiers) {\n      var _this = this;\n\n      var _a, _b;\n\n      this.logger.debug(\"SessionDescriptionHandler.getDescription\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      } // Callback on data channel creation\n\n\n      this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // ICE will restart upon applying an offer created with the iceRestart option\n\n      var iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart; // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n\n      var iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;\n      return this.getLocalMediaStream(options).then(function () {\n        return _this.createDataChannel(options);\n      }).then(function () {\n        return _this.createLocalOfferOrAnswer(options);\n      }).then(function (sessionDescription) {\n        return _this.applyModifiers(sessionDescription, modifiers);\n      }).then(function (sessionDescription) {\n        return _this.setLocalSessionDescription(sessionDescription);\n      }).then(function () {\n        return _this.waitForIceGatheringComplete(iceRestart, iceTimeout);\n      }).then(function () {\n        return _this.getLocalSessionDescription();\n      }).then(function (sessionDescription) {\n        return {\n          body: sessionDescription.sdp,\n          contentType: \"application/sdp\"\n        };\n      }).catch(function (error) {\n        _this.logger.error(\"SessionDescriptionHandler.getDescription failed - \" + error);\n\n        throw error;\n      });\n    }\n    /**\n     * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n     * @param contentType - The content type that is in the SIP Message.\n     */\n\n  }, {\n    key: \"hasDescription\",\n    value: function hasDescription(contentType) {\n      this.logger.debug(\"SessionDescriptionHandler.hasDescription\");\n      return contentType === \"application/sdp\";\n    }\n    /**\n     * Send DTMF via RTP (RFC 4733).\n     * Returns true if DTMF send is successful, false otherwise.\n     * @param tones - A string containing DTMF digits.\n     * @param options - Options object to be used by sendDtmf.\n     */\n\n  }, {\n    key: \"sendDtmf\",\n    value: function sendDtmf(tones, options) {\n      this.logger.debug(\"SessionDescriptionHandler.sendDtmf\");\n\n      if (this._peerConnection === undefined) {\n        this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - peer connection closed\");\n        return false;\n      }\n\n      var senders = this._peerConnection.getSenders();\n\n      if (senders.length === 0) {\n        this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no senders\");\n        return false;\n      }\n\n      var dtmfSender = senders[0].dtmf;\n\n      if (!dtmfSender) {\n        this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no DTMF sender\");\n        return false;\n      }\n\n      var duration = options === null || options === void 0 ? void 0 : options.duration;\n      var interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;\n\n      try {\n        dtmfSender.insertDTMF(tones, duration, interToneGap);\n      } catch (e) {\n        this.logger.error(e);\n        return false;\n      }\n\n      this.logger.log(\"SessionDescriptionHandler.sendDtmf sent via RTP: \" + tones.toString());\n      return true;\n    }\n    /**\n     * Sets an offer or answer.\n     * @param sdp - The session description.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n\n  }, {\n    key: \"setDescription\",\n    value: function setDescription(sdp, options, modifiers) {\n      var _this2 = this;\n\n      this.logger.debug(\"SessionDescriptionHandler.setDescription\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      } // Callback on data channel creation\n\n\n      this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // SDP type\n\n      var type = this._peerConnection.signalingState === \"have-local-offer\" ? \"answer\" : \"offer\";\n      return this.getLocalMediaStream(options).then(function () {\n        return _this2.applyModifiers({\n          sdp: sdp,\n          type: type\n        }, modifiers);\n      }).then(function (sessionDescription) {\n        return _this2.setRemoteSessionDescription(sessionDescription);\n      }).catch(function (error) {\n        _this2.logger.error(\"SessionDescriptionHandler.setDescription failed - \" + error);\n\n        throw error;\n      });\n    }\n    /**\n     * Applies modifiers to SDP prior to setting the local or remote description.\n     * @param sdp - SDP to modify.\n     * @param modifiers - Modifiers to apply.\n     */\n\n  }, {\n    key: \"applyModifiers\",\n    value: function applyModifiers(sdp, modifiers) {\n      var _this3 = this;\n\n      this.logger.debug(\"SessionDescriptionHandler.applyModifiers\");\n\n      if (!modifiers || modifiers.length === 0) {\n        return Promise.resolve(sdp);\n      }\n\n      return modifiers.reduce(function (cur, next) {\n        return cur.then(next);\n      }, Promise.resolve(sdp)).then(function (modified) {\n        _this3.logger.debug(\"SessionDescriptionHandler.applyModifiers - modified sdp\");\n\n        if (!modified.sdp || !modified.type) {\n          throw new Error(\"Invalid SDP.\");\n        }\n\n        return {\n          sdp: modified.sdp,\n          type: modified.type\n        };\n      });\n    }\n    /**\n     * Create a data channel.\n     * @remarks\n     * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n     * Only creates a data channel if creating a local offer.\n     * Only if one does not already exist.\n     * @param options - Session description handler options.\n     */\n\n  }, {\n    key: \"createDataChannel\",\n    value: function createDataChannel(options) {\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      } // only create a data channel if requested\n\n\n      if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {\n        return Promise.resolve();\n      } // do not create a data channel if we already have one\n\n\n      if (this._dataChannel) {\n        return Promise.resolve();\n      }\n\n      switch (this._peerConnection.signalingState) {\n        case \"stable\":\n          // if we are stable, assume we are creating a local offer so create a data channel\n          this.logger.debug(\"SessionDescriptionHandler.createDataChannel - creating data channel\");\n\n          try {\n            this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || \"\", options === null || options === void 0 ? void 0 : options.dataChannelOptions);\n\n            if (this.onDataChannel) {\n              this.onDataChannel(this._dataChannel);\n            }\n\n            return Promise.resolve();\n          } catch (error) {\n            return Promise.reject(error);\n          }\n\n        case \"have-remote-offer\":\n          return Promise.resolve();\n\n        case \"have-local-offer\":\n        case \"have-local-pranswer\":\n        case \"have-remote-pranswer\":\n        case \"closed\":\n        default:\n          return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n      }\n    }\n    /**\n     * Depending on current signaling state, create a local offer or answer.\n     * @param options - Session description handler options.\n     */\n\n  }, {\n    key: \"createLocalOfferOrAnswer\",\n    value: function createLocalOfferOrAnswer(options) {\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      }\n\n      switch (this._peerConnection.signalingState) {\n        case \"stable\":\n          // if we are stable, assume we are creating a local offer\n          this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer\");\n          return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);\n\n        case \"have-remote-offer\":\n          // if we have a remote offer, assume we are creating a local answer\n          this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer\");\n          return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);\n\n        case \"have-local-offer\":\n        case \"have-local-pranswer\":\n        case \"have-remote-pranswer\":\n        case \"closed\":\n        default:\n          return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n      }\n    }\n    /**\n     * Get a media stream from the media stream factory and set the local media stream.\n     * @param options - Session description handler options.\n     */\n\n  }, {\n    key: \"getLocalMediaStream\",\n    value: function getLocalMediaStream(options) {\n      var _this4 = this;\n\n      this.logger.debug(\"SessionDescriptionHandler.getLocalMediaStream\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      }\n\n      var constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints); // if we already have a local media stream...\n\n      if (this.localMediaStreamConstraints) {\n        // ignore constraint \"downgrades\"\n        constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n        constraints.video = constraints.video || this.localMediaStreamConstraints.video; // if constraints have not changed, do not get a new media stream\n\n        if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n          return Promise.resolve();\n        }\n      } else {\n        // if no constraints have been specified, default to audio for initial media stream\n        if (constraints.audio === undefined && constraints.video === undefined) {\n          constraints = {\n            audio: true\n          };\n        }\n      }\n\n      this.localMediaStreamConstraints = constraints;\n      return this.mediaStreamFactory(constraints, this).then(function (mediaStream) {\n        return _this4.setLocalMediaStream(mediaStream);\n      });\n    }\n    /**\n     * Sets the peer connection's sender tracks and local media stream tracks.\n     *\n     * @remarks\n     * Only the first audio and video tracks of the provided MediaStream are utilized.\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param stream - Media stream containing tracks to be utilized.\n     */\n\n  }, {\n    key: \"setLocalMediaStream\",\n    value: function setLocalMediaStream(stream) {\n      var _this5 = this;\n\n      this.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream\");\n\n      if (!this._peerConnection) {\n        throw new Error(\"Peer connection undefined.\");\n      }\n\n      var pc = this._peerConnection;\n      var localStream = this._localMediaStream;\n      var trackUpdates = [];\n\n      var updateTrack = function updateTrack(newTrack) {\n        var kind = newTrack.kind;\n\n        if (kind !== \"audio\" && kind !== \"video\") {\n          throw new Error(\"Unknown new track kind \".concat(kind, \".\"));\n        }\n\n        var sender = pc.getSenders().find(function (sender) {\n          return sender.track && sender.track.kind === kind;\n        });\n\n        if (sender) {\n          trackUpdates.push(new Promise(function (resolve) {\n            _this5.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream - replacing sender \".concat(kind, \" track\"));\n\n            resolve();\n          }).then(function () {\n            return sender.replaceTrack(newTrack).then(function () {\n              var oldTrack = localStream.getTracks().find(function (localTrack) {\n                return localTrack.kind === kind;\n              });\n\n              if (oldTrack) {\n                oldTrack.stop();\n                localStream.removeTrack(oldTrack);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n              }\n\n              localStream.addTrack(newTrack);\n              SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n            }).catch(function (error) {\n              _this5.logger.error(\"SessionDescriptionHandler.setLocalMediaStream - failed to replace sender \".concat(kind, \" track\"));\n\n              throw error;\n            });\n          }));\n        } else {\n          trackUpdates.push(new Promise(function (resolve) {\n            _this5.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream - adding sender \".concat(kind, \" track\"));\n\n            resolve();\n          }).then(function () {\n            // Review: could make streamless tracks a configurable option?\n            // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n            try {\n              pc.addTrack(newTrack, localStream);\n            } catch (error) {\n              _this5.logger.error(\"SessionDescriptionHandler.setLocalMediaStream - failed to add sender \".concat(kind, \" track\"));\n\n              throw error;\n            }\n\n            localStream.addTrack(newTrack);\n            SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n          }));\n        }\n      }; // update peer connection audio tracks\n\n\n      var audioTracks = stream.getAudioTracks();\n\n      if (audioTracks.length) {\n        updateTrack(audioTracks[0]);\n      } // update peer connection video tracks\n\n\n      var videoTracks = stream.getVideoTracks();\n\n      if (videoTracks.length) {\n        updateTrack(videoTracks[0]);\n      }\n\n      return trackUpdates.reduce(function (p, x) {\n        return p.then(function () {\n          return x;\n        });\n      }, Promise.resolve());\n    }\n    /**\n     * Gets the peer connection's local session description.\n     */\n\n  }, {\n    key: \"getLocalSessionDescription\",\n    value: function getLocalSessionDescription() {\n      this.logger.debug(\"SessionDescriptionHandler.getLocalSessionDescription\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      }\n\n      var sdp = this._peerConnection.localDescription;\n\n      if (!sdp) {\n        return Promise.reject(new Error(\"Failed to get local session description\"));\n      }\n\n      return Promise.resolve(sdp);\n    }\n    /**\n     * Sets the peer connection's local session description.\n     * @param sessionDescription - sessionDescription The session description.\n     */\n\n  }, {\n    key: \"setLocalSessionDescription\",\n    value: function setLocalSessionDescription(sessionDescription) {\n      this.logger.debug(\"SessionDescriptionHandler.setLocalSessionDescription\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      }\n\n      return this._peerConnection.setLocalDescription(sessionDescription);\n    }\n    /**\n     * Sets the peer connection's remote session description.\n     * @param sessionDescription - The session description.\n     */\n\n  }, {\n    key: \"setRemoteSessionDescription\",\n    value: function setRemoteSessionDescription(sessionDescription) {\n      this.logger.debug(\"SessionDescriptionHandler.setRemoteSessionDescription\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(new Error(\"Peer connection closed.\"));\n      }\n\n      var sdp = sessionDescription.sdp;\n      var type;\n\n      switch (this._peerConnection.signalingState) {\n        case \"stable\":\n          // if we are stable assume this is a remote offer\n          type = \"offer\";\n          break;\n\n        case \"have-local-offer\":\n          // if we made an offer, assume this is a remote answer\n          type = \"answer\";\n          break;\n\n        case \"have-local-pranswer\":\n        case \"have-remote-offer\":\n        case \"have-remote-pranswer\":\n        case \"closed\":\n        default:\n          return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n      }\n\n      if (!sdp) {\n        this.logger.error(\"SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp\");\n        return Promise.reject(new Error(\"SDP is undefined\"));\n      }\n\n      return this._peerConnection.setRemoteDescription({\n        sdp: sdp,\n        type: type\n      });\n    }\n    /**\n     * Sets a remote media stream track.\n     *\n     * @remarks\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param track - Media stream track to be utilized.\n     */\n\n  }, {\n    key: \"setRemoteTrack\",\n    value: function setRemoteTrack(track) {\n      this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack\");\n      var remoteStream = this._remoteMediaStream;\n\n      if (remoteStream.getTrackById(track.id)) {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack - have remote \".concat(track.kind, \" track\"));\n      } else if (track.kind === \"audio\") {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack - adding remote \".concat(track.kind, \" track\"));\n        remoteStream.getAudioTracks().forEach(function (track) {\n          track.stop();\n          remoteStream.removeTrack(track);\n          SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n        });\n        remoteStream.addTrack(track);\n        SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n      } else if (track.kind === \"video\") {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack - adding remote \".concat(track.kind, \" track\"));\n        remoteStream.getVideoTracks().forEach(function (track) {\n          track.stop();\n          remoteStream.removeTrack(track);\n          SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n        });\n        remoteStream.addTrack(track);\n        SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n      }\n    }\n    /**\n     * Called when ICE gathering completes and resolves any waiting promise.\n     */\n\n  }, {\n    key: \"iceGatheringComplete\",\n    value: function iceGatheringComplete() {\n      this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete\"); // clear timer if need be\n\n      if (this.iceGatheringCompleteTimeoutId !== undefined) {\n        this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - clearing timeout\");\n        clearTimeout(this.iceGatheringCompleteTimeoutId);\n        this.iceGatheringCompleteTimeoutId = undefined;\n      } // resolve and cleanup promise if need be\n\n\n      if (this.iceGatheringCompletePromise !== undefined) {\n        this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - resolving promise\");\n        this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();\n        this.iceGatheringCompletePromise = undefined;\n        this.iceGatheringCompleteResolve = undefined;\n        this.iceGatheringCompleteReject = undefined;\n      }\n    }\n    /**\n     * Wait for ICE gathering to complete.\n     * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n     * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n     */\n\n  }, {\n    key: \"waitForIceGatheringComplete\",\n    value: function waitForIceGatheringComplete() {\n      var _this6 = this;\n\n      var restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete\");\n\n      if (this._peerConnection === undefined) {\n        return Promise.reject(\"Peer connection closed.\");\n      } // guard already complete\n\n\n      if (!restart && this._peerConnection.iceGatheringState === \"complete\") {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - already complete\");\n        return Promise.resolve();\n      } // only one may be waiting, reject any prior\n\n\n      if (this.iceGatheringCompletePromise !== undefined) {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise\");\n        this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error(\"Promise superseded.\"));\n        this.iceGatheringCompletePromise = undefined;\n        this.iceGatheringCompleteResolve = undefined;\n        this.iceGatheringCompleteReject = undefined;\n      }\n\n      this.iceGatheringCompletePromise = new Promise(function (resolve, reject) {\n        _this6.iceGatheringCompleteResolve = resolve;\n        _this6.iceGatheringCompleteReject = reject;\n\n        if (timeout > 0) {\n          _this6.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in \" + timeout);\n\n          _this6.iceGatheringCompleteTimeoutId = setTimeout(function () {\n            _this6.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout\");\n\n            _this6.iceGatheringComplete();\n          }, timeout);\n        }\n      });\n      return this.iceGatheringCompletePromise;\n    }\n    /**\n     * Initializes the peer connection event handlers\n     */\n\n  }, {\n    key: \"initPeerConnectionEventHandlers\",\n    value: function initPeerConnectionEventHandlers() {\n      var _this7 = this;\n\n      this.logger.debug(\"SessionDescriptionHandler.initPeerConnectionEventHandlers\");\n      if (!this._peerConnection) throw new Error(\"Peer connection undefined.\");\n      var peerConnection = this._peerConnection;\n\n      peerConnection.onconnectionstatechange = function (event) {\n        var _a;\n\n        var newState = peerConnection.connectionState;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onconnectionstatechange \".concat(newState));\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {\n          _this7._peerConnectionDelegate.onconnectionstatechange(event);\n        }\n      };\n\n      peerConnection.ondatachannel = function (event) {\n        var _a;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.ondatachannel\");\n\n        _this7._dataChannel = event.channel;\n\n        if (_this7.onDataChannel) {\n          _this7.onDataChannel(_this7._dataChannel);\n        }\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {\n          _this7._peerConnectionDelegate.ondatachannel(event);\n        }\n      };\n\n      peerConnection.onicecandidate = function (event) {\n        var _a;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onicecandidate\");\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {\n          _this7._peerConnectionDelegate.onicecandidate(event);\n        }\n      };\n\n      peerConnection.onicecandidateerror = function (event) {\n        var _a;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onicecandidateerror\");\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {\n          _this7._peerConnectionDelegate.onicecandidateerror(event);\n        }\n      };\n\n      peerConnection.oniceconnectionstatechange = function (event) {\n        var _a;\n\n        var newState = peerConnection.iceConnectionState;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.oniceconnectionstatechange \".concat(newState));\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {\n          _this7._peerConnectionDelegate.oniceconnectionstatechange(event);\n        }\n      };\n\n      peerConnection.onicegatheringstatechange = function (event) {\n        var _a;\n\n        var newState = peerConnection.iceGatheringState;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onicegatheringstatechange \".concat(newState));\n\n        if (newState === \"complete\") {\n          _this7.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n\n        }\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {\n          _this7._peerConnectionDelegate.onicegatheringstatechange(event);\n        }\n      };\n\n      peerConnection.onnegotiationneeded = function (event) {\n        var _a;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onnegotiationneeded\");\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {\n          _this7._peerConnectionDelegate.onnegotiationneeded(event);\n        }\n      };\n\n      peerConnection.onsignalingstatechange = function (event) {\n        var _a;\n\n        var newState = peerConnection.signalingState;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onsignalingstatechange \".concat(newState));\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {\n          _this7._peerConnectionDelegate.onsignalingstatechange(event);\n        }\n      };\n\n      peerConnection.onstatsended = function (event) {\n        var _a;\n\n        _this7.logger.debug(\"SessionDescriptionHandler.onstatsended\");\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {\n          _this7._peerConnectionDelegate.onstatsended(event);\n        }\n      };\n\n      peerConnection.ontrack = function (event) {\n        var _a;\n\n        var kind = event.track.kind;\n        var enabled = event.track.enabled ? \"enabled\" : \"disabled\";\n\n        _this7.logger.debug(\"SessionDescriptionHandler.ontrack \".concat(kind, \" \").concat(enabled));\n\n        _this7.setRemoteTrack(event.track);\n\n        if ((_a = _this7._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {\n          _this7._peerConnectionDelegate.ontrack(event);\n        }\n      };\n    }\n  }, {\n    key: \"localMediaStream\",\n    get: function get() {\n      return this._localMediaStream;\n    }\n    /**\n     * The remote media stream currently being received.\n     *\n     * @remarks\n     * The remote media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * remote media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n\n  }, {\n    key: \"remoteMediaStream\",\n    get: function get() {\n      return this._remoteMediaStream;\n    }\n    /**\n     * The data channel. Undefined before it is created.\n     */\n\n  }, {\n    key: \"dataChannel\",\n    get: function get() {\n      return this._dataChannel;\n    }\n    /**\n     * The peer connection. Undefined if peer connection has closed.\n     *\n     * @remarks\n     * While access to the underlying `RTCPeerConnection` is provided, note that\n     * using methods with modify it may break the operation of this class.\n     * In particular, this class depends on exclusive access to the\n     * event handler properties. If you need access to the peer connection\n     * events, either register for events using `addEventListener()` on\n     * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n     * this `SessionDescriptionHandler`.\n     */\n\n  }, {\n    key: \"peerConnection\",\n    get: function get() {\n      return this._peerConnection;\n    }\n    /**\n     * A delegate which provides access to the peer connection event handlers.\n     *\n     * @remarks\n     * Setting the peer connection event handlers directly is not supported\n     * and may break this class. As this class depends on exclusive access\n     * to them, a delegate may be set which provides alternative access to\n     * the event handlers in a fashion which is supported.\n     */\n\n  }, {\n    key: \"peerConnectionDelegate\",\n    get: function get() {\n      return this._peerConnectionDelegate;\n    },\n    set: function set(delegate) {\n      this._peerConnectionDelegate = delegate;\n    } // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n\n  }], [{\n    key: \"dispatchAddTrackEvent\",\n    value: function dispatchAddTrackEvent(stream, track) {\n      stream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", {\n        track: track\n      }));\n    } // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n\n  }, {\n    key: \"dispatchRemoveTrackEvent\",\n    value: function dispatchRemoveTrackEvent(stream, track) {\n      stream.dispatchEvent(new MediaStreamTrackEvent(\"removetrack\", {\n        track: track\n      }));\n    }\n  }]);\n\n  return SessionDescriptionHandler;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js"],"names":["SessionDescriptionHandler","logger","mediaStreamFactory","sessionDescriptionHandlerConfiguration","debug","_localMediaStream","MediaStream","_remoteMediaStream","_peerConnection","RTCPeerConnection","peerConnectionConfiguration","initPeerConnectionEventHandlers","undefined","getReceivers","forEach","receiver","track","stop","getSenders","sender","_dataChannel","close","options","modifiers","_a","_b","Promise","reject","Error","onDataChannel","iceRestart","offerOptions","iceTimeout","iceGatheringTimeout","getLocalMediaStream","then","createDataChannel","createLocalOfferOrAnswer","sessionDescription","applyModifiers","setLocalSessionDescription","waitForIceGatheringComplete","getLocalSessionDescription","body","sdp","contentType","catch","error","tones","senders","length","dtmfSender","dtmf","duration","interToneGap","insertDTMF","e","log","toString","type","signalingState","setRemoteSessionDescription","resolve","reduce","cur","next","modified","dataChannel","dataChannelLabel","dataChannelOptions","createOffer","createAnswer","answerOptions","constraints","Object","assign","localMediaStreamConstraints","audio","video","JSON","stringify","mediaStream","setLocalMediaStream","stream","pc","localStream","trackUpdates","updateTrack","newTrack","kind","find","push","replaceTrack","oldTrack","getTracks","localTrack","removeTrack","dispatchRemoveTrackEvent","addTrack","dispatchAddTrackEvent","audioTracks","getAudioTracks","videoTracks","getVideoTracks","p","x","localDescription","setLocalDescription","setRemoteDescription","remoteStream","getTrackById","id","iceGatheringCompleteTimeoutId","clearTimeout","iceGatheringCompletePromise","iceGatheringCompleteResolve","iceGatheringCompleteReject","restart","timeout","iceGatheringState","setTimeout","iceGatheringComplete","peerConnection","onconnectionstatechange","event","newState","connectionState","_peerConnectionDelegate","ondatachannel","channel","onicecandidate","onicecandidateerror","oniceconnectionstatechange","iceConnectionState","onicegatheringstatechange","onnegotiationneeded","onsignalingstatechange","onstatsended","ontrack","enabled","setRemoteTrack","delegate","dispatchEvent","MediaStreamTrackEvent"],"mappings":"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","sourcesContent":["/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport class SessionDescriptionHandler {\n    /**\n     * Constructor\n     * @param logger - A logger\n     * @param mediaStreamFactory - A factory to provide a MediaStream\n     * @param options - Options passed from the SessionDescriptionHandleFactory\n     */\n    constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n        logger.debug(\"SessionDescriptionHandler.constructor\");\n        this.logger = logger;\n        this.mediaStreamFactory = mediaStreamFactory;\n        this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n        this._localMediaStream = new MediaStream();\n        this._remoteMediaStream = new MediaStream();\n        this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);\n        this.initPeerConnectionEventHandlers();\n    }\n    /**\n     * The local media stream currently being sent.\n     *\n     * @remarks\n     * The local media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * local media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get localMediaStream() {\n        return this._localMediaStream;\n    }\n    /**\n     * The remote media stream currently being received.\n     *\n     * @remarks\n     * The remote media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * remote media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get remoteMediaStream() {\n        return this._remoteMediaStream;\n    }\n    /**\n     * The data channel. Undefined before it is created.\n     */\n    get dataChannel() {\n        return this._dataChannel;\n    }\n    /**\n     * The peer connection. Undefined if peer connection has closed.\n     *\n     * @remarks\n     * While access to the underlying `RTCPeerConnection` is provided, note that\n     * using methods with modify it may break the operation of this class.\n     * In particular, this class depends on exclusive access to the\n     * event handler properties. If you need access to the peer connection\n     * events, either register for events using `addEventListener()` on\n     * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n     * this `SessionDescriptionHandler`.\n     */\n    get peerConnection() {\n        return this._peerConnection;\n    }\n    /**\n     * A delegate which provides access to the peer connection event handlers.\n     *\n     * @remarks\n     * Setting the peer connection event handlers directly is not supported\n     * and may break this class. As this class depends on exclusive access\n     * to them, a delegate may be set which provides alternative access to\n     * the event handlers in a fashion which is supported.\n     */\n    get peerConnectionDelegate() {\n        return this._peerConnectionDelegate;\n    }\n    set peerConnectionDelegate(delegate) {\n        this._peerConnectionDelegate = delegate;\n    }\n    // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n    static dispatchAddTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", { track }));\n    }\n    // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n    static dispatchRemoveTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent(\"removetrack\", { track }));\n    }\n    /**\n     * Stop tracks and close peer connection.\n     */\n    close() {\n        this.logger.debug(\"SessionDescriptionHandler.close\");\n        if (this._peerConnection === undefined) {\n            return;\n        }\n        this._peerConnection.getReceivers().forEach((receiver) => {\n            receiver.track && receiver.track.stop();\n        });\n        this._peerConnection.getSenders().forEach((sender) => {\n            sender.track && sender.track.stop();\n        });\n        if (this._dataChannel) {\n            this._dataChannel.close();\n        }\n        this._peerConnection.close();\n        this._peerConnection = undefined;\n    }\n    /**\n     * Creates an offer or answer.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    getDescription(options, modifiers) {\n        var _a, _b;\n        this.logger.debug(\"SessionDescriptionHandler.getDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;\n        // ICE will restart upon applying an offer created with the iceRestart option\n        const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart;\n        // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n        const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined\n            ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;\n        return this.getLocalMediaStream(options)\n            .then(() => this.createDataChannel(options))\n            .then(() => this.createLocalOfferOrAnswer(options))\n            .then((sessionDescription) => this.applyModifiers(sessionDescription, modifiers))\n            .then((sessionDescription) => this.setLocalSessionDescription(sessionDescription))\n            .then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout))\n            .then(() => this.getLocalSessionDescription())\n            .then((sessionDescription) => {\n            return {\n                body: sessionDescription.sdp,\n                contentType: \"application/sdp\"\n            };\n        })\n            .catch((error) => {\n            this.logger.error(\"SessionDescriptionHandler.getDescription failed - \" + error);\n            throw error;\n        });\n    }\n    /**\n     * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n     * @param contentType - The content type that is in the SIP Message.\n     */\n    hasDescription(contentType) {\n        this.logger.debug(\"SessionDescriptionHandler.hasDescription\");\n        return contentType === \"application/sdp\";\n    }\n    /**\n     * Send DTMF via RTP (RFC 4733).\n     * Returns true if DTMF send is successful, false otherwise.\n     * @param tones - A string containing DTMF digits.\n     * @param options - Options object to be used by sendDtmf.\n     */\n    sendDtmf(tones, options) {\n        this.logger.debug(\"SessionDescriptionHandler.sendDtmf\");\n        if (this._peerConnection === undefined) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - peer connection closed\");\n            return false;\n        }\n        const senders = this._peerConnection.getSenders();\n        if (senders.length === 0) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no senders\");\n            return false;\n        }\n        const dtmfSender = senders[0].dtmf;\n        if (!dtmfSender) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no DTMF sender\");\n            return false;\n        }\n        const duration = options === null || options === void 0 ? void 0 : options.duration;\n        const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;\n        try {\n            dtmfSender.insertDTMF(tones, duration, interToneGap);\n        }\n        catch (e) {\n            this.logger.error(e);\n            return false;\n        }\n        this.logger.log(\"SessionDescriptionHandler.sendDtmf sent via RTP: \" + tones.toString());\n        return true;\n    }\n    /**\n     * Sets an offer or answer.\n     * @param sdp - The session description.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    setDescription(sdp, options, modifiers) {\n        this.logger.debug(\"SessionDescriptionHandler.setDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;\n        // SDP type\n        const type = this._peerConnection.signalingState === \"have-local-offer\" ? \"answer\" : \"offer\";\n        return this.getLocalMediaStream(options)\n            .then(() => this.applyModifiers({ sdp, type }, modifiers))\n            .then((sessionDescription) => this.setRemoteSessionDescription(sessionDescription))\n            .catch((error) => {\n            this.logger.error(\"SessionDescriptionHandler.setDescription failed - \" + error);\n            throw error;\n        });\n    }\n    /**\n     * Applies modifiers to SDP prior to setting the local or remote description.\n     * @param sdp - SDP to modify.\n     * @param modifiers - Modifiers to apply.\n     */\n    applyModifiers(sdp, modifiers) {\n        this.logger.debug(\"SessionDescriptionHandler.applyModifiers\");\n        if (!modifiers || modifiers.length === 0) {\n            return Promise.resolve(sdp);\n        }\n        return modifiers\n            .reduce((cur, next) => cur.then(next), Promise.resolve(sdp))\n            .then((modified) => {\n            this.logger.debug(\"SessionDescriptionHandler.applyModifiers - modified sdp\");\n            if (!modified.sdp || !modified.type) {\n                throw new Error(\"Invalid SDP.\");\n            }\n            return { sdp: modified.sdp, type: modified.type };\n        });\n    }\n    /**\n     * Create a data channel.\n     * @remarks\n     * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n     * Only creates a data channel if creating a local offer.\n     * Only if one does not already exist.\n     * @param options - Session description handler options.\n     */\n    createDataChannel(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // only create a data channel if requested\n        if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {\n            return Promise.resolve();\n        }\n        // do not create a data channel if we already have one\n        if (this._dataChannel) {\n            return Promise.resolve();\n        }\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable, assume we are creating a local offer so create a data channel\n                this.logger.debug(\"SessionDescriptionHandler.createDataChannel - creating data channel\");\n                try {\n                    this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || \"\", options === null || options === void 0 ? void 0 : options.dataChannelOptions);\n                    if (this.onDataChannel) {\n                        this.onDataChannel(this._dataChannel);\n                    }\n                    return Promise.resolve();\n                }\n                catch (error) {\n                    return Promise.reject(error);\n                }\n            case \"have-remote-offer\":\n                return Promise.resolve();\n            case \"have-local-offer\":\n            case \"have-local-pranswer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Depending on current signaling state, create a local offer or answer.\n     * @param options - Session description handler options.\n     */\n    createLocalOfferOrAnswer(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable, assume we are creating a local offer\n                this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer\");\n                return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);\n            case \"have-remote-offer\":\n                // if we have a remote offer, assume we are creating a local answer\n                this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer\");\n                return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);\n            case \"have-local-offer\":\n            case \"have-local-pranswer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Get a media stream from the media stream factory and set the local media stream.\n     * @param options - Session description handler options.\n     */\n    getLocalMediaStream(options) {\n        this.logger.debug(\"SessionDescriptionHandler.getLocalMediaStream\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints);\n        // if we already have a local media stream...\n        if (this.localMediaStreamConstraints) {\n            // ignore constraint \"downgrades\"\n            constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n            constraints.video = constraints.video || this.localMediaStreamConstraints.video;\n            // if constraints have not changed, do not get a new media stream\n            if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) &&\n                JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n                return Promise.resolve();\n            }\n        }\n        else {\n            // if no constraints have been specified, default to audio for initial media stream\n            if (constraints.audio === undefined && constraints.video === undefined) {\n                constraints = { audio: true };\n            }\n        }\n        this.localMediaStreamConstraints = constraints;\n        return this.mediaStreamFactory(constraints, this).then((mediaStream) => this.setLocalMediaStream(mediaStream));\n    }\n    /**\n     * Sets the peer connection's sender tracks and local media stream tracks.\n     *\n     * @remarks\n     * Only the first audio and video tracks of the provided MediaStream are utilized.\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param stream - Media stream containing tracks to be utilized.\n     */\n    setLocalMediaStream(stream) {\n        this.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream\");\n        if (!this._peerConnection) {\n            throw new Error(\"Peer connection undefined.\");\n        }\n        const pc = this._peerConnection;\n        const localStream = this._localMediaStream;\n        const trackUpdates = [];\n        const updateTrack = (newTrack) => {\n            const kind = newTrack.kind;\n            if (kind !== \"audio\" && kind !== \"video\") {\n                throw new Error(`Unknown new track kind ${kind}.`);\n            }\n            const sender = pc.getSenders().find((sender) => sender.track && sender.track.kind === kind);\n            if (sender) {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);\n                    resolve();\n                }).then(() => sender\n                    .replaceTrack(newTrack)\n                    .then(() => {\n                    const oldTrack = localStream.getTracks().find((localTrack) => localTrack.kind === kind);\n                    if (oldTrack) {\n                        oldTrack.stop();\n                        localStream.removeTrack(oldTrack);\n                        SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                })\n                    .catch((error) => {\n                    this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);\n                    throw error;\n                })));\n            }\n            else {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);\n                    resolve();\n                }).then(() => {\n                    // Review: could make streamless tracks a configurable option?\n                    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n                    try {\n                        pc.addTrack(newTrack, localStream);\n                    }\n                    catch (error) {\n                        this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);\n                        throw error;\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                }));\n            }\n        };\n        // update peer connection audio tracks\n        const audioTracks = stream.getAudioTracks();\n        if (audioTracks.length) {\n            updateTrack(audioTracks[0]);\n        }\n        // update peer connection video tracks\n        const videoTracks = stream.getVideoTracks();\n        if (videoTracks.length) {\n            updateTrack(videoTracks[0]);\n        }\n        return trackUpdates.reduce((p, x) => p.then(() => x), Promise.resolve());\n    }\n    /**\n     * Gets the peer connection's local session description.\n     */\n    getLocalSessionDescription() {\n        this.logger.debug(\"SessionDescriptionHandler.getLocalSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        const sdp = this._peerConnection.localDescription;\n        if (!sdp) {\n            return Promise.reject(new Error(\"Failed to get local session description\"));\n        }\n        return Promise.resolve(sdp);\n    }\n    /**\n     * Sets the peer connection's local session description.\n     * @param sessionDescription - sessionDescription The session description.\n     */\n    setLocalSessionDescription(sessionDescription) {\n        this.logger.debug(\"SessionDescriptionHandler.setLocalSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        return this._peerConnection.setLocalDescription(sessionDescription);\n    }\n    /**\n     * Sets the peer connection's remote session description.\n     * @param sessionDescription - The session description.\n     */\n    setRemoteSessionDescription(sessionDescription) {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        const sdp = sessionDescription.sdp;\n        let type;\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable assume this is a remote offer\n                type = \"offer\";\n                break;\n            case \"have-local-offer\":\n                // if we made an offer, assume this is a remote answer\n                type = \"answer\";\n                break;\n            case \"have-local-pranswer\":\n            case \"have-remote-offer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n        if (!sdp) {\n            this.logger.error(\"SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp\");\n            return Promise.reject(new Error(\"SDP is undefined\"));\n        }\n        return this._peerConnection.setRemoteDescription({ sdp, type });\n    }\n    /**\n     * Sets a remote media stream track.\n     *\n     * @remarks\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param track - Media stream track to be utilized.\n     */\n    setRemoteTrack(track) {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack\");\n        const remoteStream = this._remoteMediaStream;\n        if (remoteStream.getTrackById(track.id)) {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);\n        }\n        else if (track.kind === \"audio\") {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getAudioTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n        else if (track.kind === \"video\") {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getVideoTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n    }\n    /**\n     * Called when ICE gathering completes and resolves any waiting promise.\n     */\n    iceGatheringComplete() {\n        this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete\");\n        // clear timer if need be\n        if (this.iceGatheringCompleteTimeoutId !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - clearing timeout\");\n            clearTimeout(this.iceGatheringCompleteTimeoutId);\n            this.iceGatheringCompleteTimeoutId = undefined;\n        }\n        // resolve and cleanup promise if need be\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - resolving promise\");\n            this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n    }\n    /**\n     * Wait for ICE gathering to complete.\n     * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n     * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n     */\n    waitForIceGatheringComplete(restart = false, timeout = 0) {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(\"Peer connection closed.\");\n        }\n        // guard already complete\n        if (!restart && this._peerConnection.iceGatheringState === \"complete\") {\n            this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - already complete\");\n            return Promise.resolve();\n        }\n        // only one may be waiting, reject any prior\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise\");\n            this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error(\"Promise superseded.\"));\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n        this.iceGatheringCompletePromise = new Promise((resolve, reject) => {\n            this.iceGatheringCompleteResolve = resolve;\n            this.iceGatheringCompleteReject = reject;\n            if (timeout > 0) {\n                this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in \" + timeout);\n                this.iceGatheringCompleteTimeoutId = setTimeout(() => {\n                    this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout\");\n                    this.iceGatheringComplete();\n                }, timeout);\n            }\n        });\n        return this.iceGatheringCompletePromise;\n    }\n    /**\n     * Initializes the peer connection event handlers\n     */\n    initPeerConnectionEventHandlers() {\n        this.logger.debug(\"SessionDescriptionHandler.initPeerConnectionEventHandlers\");\n        if (!this._peerConnection)\n            throw new Error(\"Peer connection undefined.\");\n        const peerConnection = this._peerConnection;\n        peerConnection.onconnectionstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.connectionState;\n            this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {\n                this._peerConnectionDelegate.onconnectionstatechange(event);\n            }\n        };\n        peerConnection.ondatachannel = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.ondatachannel`);\n            this._dataChannel = event.channel;\n            if (this.onDataChannel) {\n                this.onDataChannel(this._dataChannel);\n            }\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {\n                this._peerConnectionDelegate.ondatachannel(event);\n            }\n        };\n        peerConnection.onicecandidate = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onicecandidate`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {\n                this._peerConnectionDelegate.onicecandidate(event);\n            }\n        };\n        peerConnection.onicecandidateerror = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {\n                this._peerConnectionDelegate.onicecandidateerror(event);\n            }\n        };\n        peerConnection.oniceconnectionstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.iceConnectionState;\n            this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {\n                this._peerConnectionDelegate.oniceconnectionstatechange(event);\n            }\n        };\n        peerConnection.onicegatheringstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.iceGatheringState;\n            this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);\n            if (newState === \"complete\") {\n                this.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n            }\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {\n                this._peerConnectionDelegate.onicegatheringstatechange(event);\n            }\n        };\n        peerConnection.onnegotiationneeded = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {\n                this._peerConnectionDelegate.onnegotiationneeded(event);\n            }\n        };\n        peerConnection.onsignalingstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.signalingState;\n            this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {\n                this._peerConnectionDelegate.onsignalingstatechange(event);\n            }\n        };\n        peerConnection.onstatsended = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onstatsended`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {\n                this._peerConnectionDelegate.onstatsended(event);\n            }\n        };\n        peerConnection.ontrack = (event) => {\n            var _a;\n            const kind = event.track.kind;\n            const enabled = event.track.enabled ? \"enabled\" : \"disabled\";\n            this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);\n            this.setRemoteTrack(event.track);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {\n                this._peerConnectionDelegate.ontrack(event);\n            }\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}