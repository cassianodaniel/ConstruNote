{"ast":null,"code":"import { SameValue, TimeClip } from '../../262';\nimport { ToLocalTime } from './ToLocalTime';\nimport { FormatDateTimePattern } from './FormatDateTimePattern';\nimport { PartitionPattern } from '../PartitionPattern';\nvar TABLE_2_FIELDS = ['era', 'year', 'month', 'day', 'ampm', 'hour', 'minute', 'second'];\nexport function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {\n  x = TimeClip(x);\n\n  if (isNaN(x)) {\n    throw new RangeError('Invalid start time');\n  }\n\n  y = TimeClip(y);\n\n  if (isNaN(y)) {\n    throw new RangeError('Invalid end time');\n  }\n  /** IMPL START */\n\n\n  var getInternalSlots = implDetails.getInternalSlots,\n      tzData = implDetails.tzData;\n  var internalSlots = getInternalSlots(dtf);\n  /** IMPL END */\n\n  var tm1 = ToLocalTime(x, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var tm2 = ToLocalTime(y, // @ts-ignore\n  internalSlots.calendar, internalSlots.timeZone, {\n    tzData: tzData\n  });\n  var pattern = internalSlots.pattern,\n      rangePatterns = internalSlots.rangePatterns;\n  var rangePattern;\n  var dateFieldsPracticallyEqual = true;\n  var patternContainsLargerDateField = false;\n\n  for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {\n    var fieldName = TABLE_2_FIELDS_1[_i];\n\n    if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {\n      if (fieldName === 'ampm') {\n        var v1 = tm1.hour;\n        var v2 = tm2.hour;\n        var rp = rangePatterns.ampm;\n\n        if (v1 > 11 && v2 < 11 || v1 < 11 && v2 > 11) {\n          dateFieldsPracticallyEqual = false;\n        }\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        }\n\n        rangePattern = rp;\n      } else {\n        var v1 = tm1[fieldName];\n        var v2 = tm2[fieldName];\n        var rp = rangePatterns[fieldName];\n\n        if (!SameValue(v1, v2)) {\n          dateFieldsPracticallyEqual = false;\n        }\n\n        if (rangePattern !== undefined && rp === undefined) {\n          patternContainsLargerDateField = true;\n        }\n\n        rangePattern = rp;\n      }\n    }\n  }\n\n  if (dateFieldsPracticallyEqual) {\n    var result_2 = FormatDateTimePattern(dtf, PartitionPattern(pattern), x, implDetails);\n\n    for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {\n      var r = result_1[_a];\n      r.source = \"shared\"\n      /* shared */\n      ;\n    }\n\n    return result_2;\n  }\n\n  var result = [];\n\n  if (rangePattern === undefined) {\n    rangePattern = rangePatterns.default;\n  }\n\n  for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {\n    var rangePatternPart = _c[_b];\n    var source = rangePatternPart.source,\n        pattern_1 = rangePatternPart.pattern;\n    var z = void 0;\n\n    if (source === \"startRange\"\n    /* startRange */\n    || source === \"shared\"\n    /* shared */\n    ) {\n        z = x;\n      } else {\n      z = y;\n    }\n\n    var patternParts = PartitionPattern(pattern_1);\n    var partResult = FormatDateTimePattern(dtf, patternParts, z, implDetails);\n\n    for (var _d = 0, partResult_1 = partResult; _d < partResult_1.length; _d++) {\n      var r = partResult_1[_d];\n      r.source = source;\n    }\n\n    result = result.concat(partResult);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@formatjs/ecma402-abstract/lib/src/DateTimeFormat/PartitionDateTimeRangePattern.js"],"names":["SameValue","TimeClip","ToLocalTime","FormatDateTimePattern","PartitionPattern","TABLE_2_FIELDS","PartitionDateTimeRangePattern","dtf","x","y","implDetails","isNaN","RangeError","getInternalSlots","tzData","internalSlots","tm1","calendar","timeZone","tm2","pattern","rangePatterns","rangePattern","dateFieldsPracticallyEqual","patternContainsLargerDateField","_i","TABLE_2_FIELDS_1","length","fieldName","v1","hour","v2","rp","ampm","undefined","result_2","_a","result_1","r","source","result","default","_b","_c","patternParts","rangePatternPart","pattern_1","z","partResult","_d","partResult_1","concat"],"mappings":"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","sourcesContent":["import { SameValue, TimeClip } from '../../262';\nimport { ToLocalTime } from './ToLocalTime';\nimport { FormatDateTimePattern, } from './FormatDateTimePattern';\nimport { PartitionPattern } from '../PartitionPattern';\nvar TABLE_2_FIELDS = [\n    'era',\n    'year',\n    'month',\n    'day',\n    'ampm',\n    'hour',\n    'minute',\n    'second',\n];\nexport function PartitionDateTimeRangePattern(dtf, x, y, implDetails) {\n    x = TimeClip(x);\n    if (isNaN(x)) {\n        throw new RangeError('Invalid start time');\n    }\n    y = TimeClip(y);\n    if (isNaN(y)) {\n        throw new RangeError('Invalid end time');\n    }\n    /** IMPL START */\n    var getInternalSlots = implDetails.getInternalSlots, tzData = implDetails.tzData;\n    var internalSlots = getInternalSlots(dtf);\n    /** IMPL END */\n    var tm1 = ToLocalTime(x, \n    // @ts-ignore\n    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });\n    var tm2 = ToLocalTime(y, \n    // @ts-ignore\n    internalSlots.calendar, internalSlots.timeZone, { tzData: tzData });\n    var pattern = internalSlots.pattern, rangePatterns = internalSlots.rangePatterns;\n    var rangePattern;\n    var dateFieldsPracticallyEqual = true;\n    var patternContainsLargerDateField = false;\n    for (var _i = 0, TABLE_2_FIELDS_1 = TABLE_2_FIELDS; _i < TABLE_2_FIELDS_1.length; _i++) {\n        var fieldName = TABLE_2_FIELDS_1[_i];\n        if (dateFieldsPracticallyEqual && !patternContainsLargerDateField) {\n            if (fieldName === 'ampm') {\n                var v1 = tm1.hour;\n                var v2 = tm2.hour;\n                var rp = rangePatterns.ampm;\n                if ((v1 > 11 && v2 < 11) || (v1 < 11 && v2 > 11)) {\n                    dateFieldsPracticallyEqual = false;\n                }\n                if (rangePattern !== undefined && rp === undefined) {\n                    patternContainsLargerDateField = true;\n                }\n                rangePattern = rp;\n            }\n            else {\n                var v1 = tm1[fieldName];\n                var v2 = tm2[fieldName];\n                var rp = rangePatterns[fieldName];\n                if (!SameValue(v1, v2)) {\n                    dateFieldsPracticallyEqual = false;\n                }\n                if (rangePattern !== undefined && rp === undefined) {\n                    patternContainsLargerDateField = true;\n                }\n                rangePattern = rp;\n            }\n        }\n    }\n    if (dateFieldsPracticallyEqual) {\n        var result_2 = FormatDateTimePattern(dtf, PartitionPattern(pattern), x, implDetails);\n        for (var _a = 0, result_1 = result_2; _a < result_1.length; _a++) {\n            var r = result_1[_a];\n            r.source = \"shared\" /* shared */;\n        }\n        return result_2;\n    }\n    var result = [];\n    if (rangePattern === undefined) {\n        rangePattern = rangePatterns.default;\n    }\n    for (var _b = 0, _c = rangePattern.patternParts; _b < _c.length; _b++) {\n        var rangePatternPart = _c[_b];\n        var source = rangePatternPart.source, pattern_1 = rangePatternPart.pattern;\n        var z = void 0;\n        if (source === \"startRange\" /* startRange */ ||\n            source === \"shared\" /* shared */) {\n            z = x;\n        }\n        else {\n            z = y;\n        }\n        var patternParts = PartitionPattern(pattern_1);\n        var partResult = FormatDateTimePattern(dtf, patternParts, z, implDetails);\n        for (var _d = 0, partResult_1 = partResult; _d < partResult_1.length; _d++) {\n            var r = partResult_1[_d];\n            r.source = source;\n        }\n        result = result.concat(partResult);\n    }\n    return result;\n}\n"]},"metadata":{},"sourceType":"module"}