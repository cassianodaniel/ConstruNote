{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant } from '../utils';\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty } from './utils';\nimport { processDateTimePattern } from './skeleton';\n\nfunction isNumericType(t) {\n  return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\n\n\nexport function bestFitFormatMatcherScore(options, format) {\n  var score = 0;\n\n  if (options.hour12 && !format.hour12) {\n    score -= removalPenalty;\n  } else if (!options.hour12 && format.hour12) {\n    score -= additionPenalty;\n  }\n\n  for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n    var prop = DATE_TIME_PROPS_1[_i];\n    var optionsProp = options[prop];\n    var formatProp = format[prop];\n\n    if (optionsProp === undefined && formatProp !== undefined) {\n      score -= additionPenalty;\n    } else if (optionsProp !== undefined && formatProp === undefined) {\n      score -= removalPenalty;\n    } else if (optionsProp !== formatProp) {\n      // extra penalty for numeric vs non-numeric\n      if (isNumericType(optionsProp) !== isNumericType(formatProp)) {\n        score -= differentNumericTypePenalty;\n      } else {\n        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n        var optionsPropIndex = values.indexOf(optionsProp);\n        var formatPropIndex = values.indexOf(formatProp);\n        var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n\n        if (delta === 2) {\n          score -= longMorePenalty;\n        } else if (delta === 1) {\n          score -= shortMorePenalty;\n        } else if (delta === -1) {\n          score -= shortLessPenalty;\n        } else if (delta === -2) {\n          score -= longLessPenalty;\n        }\n      }\n    }\n  }\n\n  return score;\n}\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\n\nexport function BestFitFormatMatcher(options, formats) {\n  var bestScore = -Infinity;\n  var bestFormat = formats[0];\n  invariant(Array.isArray(formats), 'formats should be a list of things');\n\n  for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n    var format = formats_1[_i];\n    var score = bestFitFormatMatcherScore(options, format);\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestFormat = format;\n    }\n  }\n\n  var skeletonFormat = __assign({}, bestFormat);\n\n  var patternFormat = {\n    rawPattern: bestFormat.rawPattern\n  };\n  processDateTimePattern(bestFormat.rawPattern, patternFormat); // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n  // Method adjustFieldTypes\n\n  for (var prop in skeletonFormat) {\n    var skeletonValue = skeletonFormat[prop];\n    var patternValue = patternFormat[prop];\n    var requestedValue = options[prop]; // Don't mess with minute/second or we can get in the situation of\n    // 7:0:0 which is weird\n\n    if (prop === 'minute' || prop === 'second') {\n      continue;\n    } // Nothing to do here\n\n\n    if (!requestedValue) {\n      continue;\n    } // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n    // Looks like we should not convert numeric to alphabetic but the other way\n    // around is ok\n\n\n    if (isNumericType(patternValue) && !isNumericType(requestedValue)) {\n      continue;\n    }\n\n    if (skeletonValue === requestedValue) {\n      continue;\n    }\n\n    patternFormat[prop] = requestedValue;\n  } // Copy those over\n\n\n  patternFormat.pattern = skeletonFormat.pattern;\n  patternFormat.pattern12 = skeletonFormat.pattern12;\n  patternFormat.skeleton = skeletonFormat.skeleton;\n  patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n  patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n  return patternFormat;\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@formatjs/ecma402-abstract/lib/src/DateTimeFormat/BestFitFormatMatcher.js"],"names":["__assign","invariant","DATE_TIME_PROPS","removalPenalty","additionPenalty","differentNumericTypePenalty","longMorePenalty","shortMorePenalty","shortLessPenalty","longLessPenalty","processDateTimePattern","isNumericType","t","bestFitFormatMatcherScore","options","format","score","hour12","_i","DATE_TIME_PROPS_1","length","prop","optionsProp","formatProp","undefined","values","optionsPropIndex","indexOf","formatPropIndex","delta","Math","max","min","BestFitFormatMatcher","formats","bestScore","Infinity","bestFormat","Array","isArray","formats_1","skeletonFormat","patternFormat","rawPattern","skeletonValue","patternValue","requestedValue","pattern","pattern12","skeleton","rangePatterns","rangePatterns12"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { invariant } from '../utils';\nimport { DATE_TIME_PROPS, removalPenalty, additionPenalty, differentNumericTypePenalty, longMorePenalty, shortMorePenalty, shortLessPenalty, longLessPenalty, } from './utils';\nimport { processDateTimePattern } from './skeleton';\nfunction isNumericType(t) {\n    return t === 'numeric' || t === '2-digit';\n}\n/**\n * Credit: https://github.com/andyearnshaw/Intl.js/blob/0958dc1ad8153f1056653ea22b8208f0df289a4e/src/12.datetimeformat.js#L611\n * with some modifications\n * @param options\n * @param format\n */\nexport function bestFitFormatMatcherScore(options, format) {\n    var score = 0;\n    if (options.hour12 && !format.hour12) {\n        score -= removalPenalty;\n    }\n    else if (!options.hour12 && format.hour12) {\n        score -= additionPenalty;\n    }\n    for (var _i = 0, DATE_TIME_PROPS_1 = DATE_TIME_PROPS; _i < DATE_TIME_PROPS_1.length; _i++) {\n        var prop = DATE_TIME_PROPS_1[_i];\n        var optionsProp = options[prop];\n        var formatProp = format[prop];\n        if (optionsProp === undefined && formatProp !== undefined) {\n            score -= additionPenalty;\n        }\n        else if (optionsProp !== undefined && formatProp === undefined) {\n            score -= removalPenalty;\n        }\n        else if (optionsProp !== formatProp) {\n            // extra penalty for numeric vs non-numeric\n            if (isNumericType(optionsProp) !==\n                isNumericType(formatProp)) {\n                score -= differentNumericTypePenalty;\n            }\n            else {\n                var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n                var optionsPropIndex = values.indexOf(optionsProp);\n                var formatPropIndex = values.indexOf(formatProp);\n                var delta = Math.max(-2, Math.min(formatPropIndex - optionsPropIndex, 2));\n                if (delta === 2) {\n                    score -= longMorePenalty;\n                }\n                else if (delta === 1) {\n                    score -= shortMorePenalty;\n                }\n                else if (delta === -1) {\n                    score -= shortLessPenalty;\n                }\n                else if (delta === -2) {\n                    score -= longLessPenalty;\n                }\n            }\n        }\n    }\n    return score;\n}\n/**\n * https://tc39.es/ecma402/#sec-bestfitformatmatcher\n * Just alias to basic for now\n * @param options\n * @param formats\n * @param implDetails Implementation details\n */\nexport function BestFitFormatMatcher(options, formats) {\n    var bestScore = -Infinity;\n    var bestFormat = formats[0];\n    invariant(Array.isArray(formats), 'formats should be a list of things');\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format = formats_1[_i];\n        var score = bestFitFormatMatcherScore(options, format);\n        if (score > bestScore) {\n            bestScore = score;\n            bestFormat = format;\n        }\n    }\n    var skeletonFormat = __assign({}, bestFormat);\n    var patternFormat = { rawPattern: bestFormat.rawPattern };\n    processDateTimePattern(bestFormat.rawPattern, patternFormat);\n    // Kinda following https://github.com/unicode-org/icu/blob/dd50e38f459d84e9bf1b0c618be8483d318458ad/icu4j/main/classes/core/src/com/ibm/icu/text/DateTimePatternGenerator.java\n    // Method adjustFieldTypes\n    for (var prop in skeletonFormat) {\n        var skeletonValue = skeletonFormat[prop];\n        var patternValue = patternFormat[prop];\n        var requestedValue = options[prop];\n        // Don't mess with minute/second or we can get in the situation of\n        // 7:0:0 which is weird\n        if (prop === 'minute' || prop === 'second') {\n            continue;\n        }\n        // Nothing to do here\n        if (!requestedValue) {\n            continue;\n        }\n        // https://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n        // Looks like we should not convert numeric to alphabetic but the other way\n        // around is ok\n        if (isNumericType(patternValue) &&\n            !isNumericType(requestedValue)) {\n            continue;\n        }\n        if (skeletonValue === requestedValue) {\n            continue;\n        }\n        patternFormat[prop] = requestedValue;\n    }\n    // Copy those over\n    patternFormat.pattern = skeletonFormat.pattern;\n    patternFormat.pattern12 = skeletonFormat.pattern12;\n    patternFormat.skeleton = skeletonFormat.skeleton;\n    patternFormat.rangePatterns = skeletonFormat.rangePatterns;\n    patternFormat.rangePatterns12 = skeletonFormat.rangePatterns12;\n    return patternFormat;\n}\n"]},"metadata":{},"sourceType":"module"}