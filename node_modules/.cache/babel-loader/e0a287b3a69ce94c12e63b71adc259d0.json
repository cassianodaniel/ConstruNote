{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar resolve = require('./resolve');\n\nvar _require = require('@xmpp/events'),\n    promise = _require.promise;\n\nfunction fetchURIs(_x) {\n  return _fetchURIs.apply(this, arguments);\n}\n\nfunction _fetchURIs() {\n  _fetchURIs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(domain) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = _toConsumableArray;\n            _context2.t1 = Set;\n            _context2.next = 4;\n            return resolve(domain, {\n              srv: [{\n                service: 'xmpps-client',\n                protocol: 'tcp'\n              }, {\n                service: 'xmpp-client',\n                protocol: 'tcp'\n              }]\n            });\n\n          case 4:\n            _context2.t2 = _context2.sent.map(function (record) {\n              return record.uri;\n            });\n            _context2.t3 = new _context2.t1(_context2.t2);\n            return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t3));\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _fetchURIs.apply(this, arguments);\n}\n\nfunction filterSupportedURIs(entity, uris) {\n  return uris.filter(function (uri) {\n    return entity._findTransport(uri);\n  });\n}\n\nfunction fallbackConnect(_x2, _x3) {\n  return _fallbackConnect.apply(this, arguments);\n}\n\nfunction _fallbackConnect() {\n  _fallbackConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(entity, uris) {\n    var uri, Transport, params, socket;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(uris.length === 0)) {\n              _context3.next = 2;\n              break;\n            }\n\n            throw new Error(\"Couldn't connect\");\n\n          case 2:\n            uri = uris.shift();\n            Transport = entity._findTransport(uri);\n\n            if (Transport) {\n              _context3.next = 6;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", fallbackConnect(entity, uris));\n\n          case 6:\n            entity._status('connecting', uri);\n\n            params = Transport.prototype.socketParameters(uri);\n            socket = new Transport.prototype.Socket();\n            _context3.prev = 9;\n            socket.connect(params);\n            _context3.next = 13;\n            return promise(socket, 'connect');\n\n          case 13:\n            _context3.next = 18;\n            break;\n\n          case 15:\n            _context3.prev = 15;\n            _context3.t0 = _context3[\"catch\"](9);\n            return _context3.abrupt(\"return\", fallbackConnect(entity, uris));\n\n          case 18:\n            entity._attachSocket(socket);\n\n            socket.emit('connect');\n            entity.Transport = Transport;\n            entity.Socket = Transport.prototype.Socket;\n            entity.Parser = Transport.prototype.Parser;\n\n          case 23:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[9, 15]]);\n  }));\n  return _fallbackConnect.apply(this, arguments);\n}\n\nmodule.exports = function (_ref) {\n  var entity = _ref.entity;\n  var _connect = entity.connect;\n\n  entity.connect = /*#__PURE__*/function () {\n    var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(service) {\n      var uris;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!service || service.match(/:\\/\\//))) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\", _connect.call(this, service));\n\n            case 2:\n              _context.t0 = filterSupportedURIs;\n              _context.t1 = entity;\n              _context.next = 6;\n              return fetchURIs(service);\n\n            case 6:\n              _context.t2 = _context.sent;\n              uris = (0, _context.t0)(_context.t1, _context.t2);\n\n              if (!(uris.length === 0)) {\n                _context.next = 10;\n                break;\n              }\n\n              throw new Error('No compatible transport found.');\n\n            case 10:\n              _context.prev = 10;\n              _context.next = 13;\n              return fallbackConnect(entity, uris);\n\n            case 13:\n              _context.next = 20;\n              break;\n\n            case 15:\n              _context.prev = 15;\n              _context.t3 = _context[\"catch\"](10);\n\n              entity._reset();\n\n              entity._status('disconnect');\n\n              throw _context.t3;\n\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[10, 15]]);\n    }));\n\n    function connect(_x4) {\n      return _connect2.apply(this, arguments);\n    }\n\n    return connect;\n  }();\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/resolve/index.js"],"names":["resolve","require","promise","fetchURIs","domain","Set","srv","service","protocol","map","record","uri","filterSupportedURIs","entity","uris","filter","_findTransport","fallbackConnect","length","Error","shift","Transport","_status","params","prototype","socketParameters","socket","Socket","connect","_attachSocket","emit","Parser","module","exports","_connect","match","call","_reset"],"mappings":"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","sourcesContent":["'use strict'\n\nconst resolve = require('./resolve')\nconst {promise} = require('@xmpp/events')\n\nasync function fetchURIs(domain) {\n  return [\n    // Remove duplicates\n    ...new Set(\n      (\n        await resolve(domain, {\n          srv: [\n            {\n              service: 'xmpps-client',\n              protocol: 'tcp',\n            },\n            {\n              service: 'xmpp-client',\n              protocol: 'tcp',\n            },\n          ],\n        })\n      ).map(record => record.uri)\n    ),\n  ]\n}\n\nfunction filterSupportedURIs(entity, uris) {\n  return uris.filter(uri => entity._findTransport(uri))\n}\n\nasync function fallbackConnect(entity, uris) {\n  if (uris.length === 0) {\n    throw new Error(\"Couldn't connect\")\n  }\n\n  const uri = uris.shift()\n  const Transport = entity._findTransport(uri)\n\n  if (!Transport) {\n    return fallbackConnect(entity, uris)\n  }\n\n  entity._status('connecting', uri)\n  const params = Transport.prototype.socketParameters(uri)\n  const socket = new Transport.prototype.Socket()\n\n  try {\n    socket.connect(params)\n    await promise(socket, 'connect')\n    // eslint-disable-next-line no-unused-vars\n  } catch (err) {\n    return fallbackConnect(entity, uris)\n  }\n\n  entity._attachSocket(socket)\n  socket.emit('connect')\n  entity.Transport = Transport\n  entity.Socket = Transport.prototype.Socket\n  entity.Parser = Transport.prototype.Parser\n}\n\nmodule.exports = function({entity}) {\n  const _connect = entity.connect\n  entity.connect = async function connect(service) {\n    if (!service || service.match(/:\\/\\//)) {\n      return _connect.call(this, service)\n    }\n\n    const uris = filterSupportedURIs(entity, await fetchURIs(service))\n\n    if (uris.length === 0) {\n      throw new Error('No compatible transport found.')\n    }\n\n    try {\n      await fallbackConnect(entity, uris)\n    } catch (err) {\n      entity._reset()\n      entity._status('disconnect')\n      throw err\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}