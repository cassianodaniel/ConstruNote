{"ast":null,"code":"import { Md5 } from \"./md5\";\nimport { createRandomToken } from \"./utils\";\n\nfunction MD5(s) {\n  return Md5.hashStr(s);\n}\n/**\n * Digest Authentication.\n * @internal\n */\n\n\nexport class DigestAuthentication {\n  /**\n   * Constructor.\n   * @param loggerFactory - LoggerFactory.\n   * @param username - Username.\n   * @param password - Password.\n   */\n  constructor(loggerFactory, ha1, username, password) {\n    this.logger = loggerFactory.getLogger(\"sipjs.digestauthentication\");\n    this.username = username;\n    this.password = password;\n    this.ha1 = ha1;\n    this.nc = 0;\n    this.ncHex = \"00000000\";\n  }\n  /**\n   * Performs Digest authentication given a SIP request and the challenge\n   * received in a response to that request.\n   * @param request -\n   * @param challenge -\n   * @returns true if credentials were successfully generated, false otherwise.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  authenticate(request, challenge, body) {\n    // Inspect and validate the challenge.\n    this.algorithm = challenge.algorithm;\n    this.realm = challenge.realm;\n    this.nonce = challenge.nonce;\n    this.opaque = challenge.opaque;\n    this.stale = challenge.stale;\n\n    if (this.algorithm) {\n      if (this.algorithm !== \"MD5\") {\n        this.logger.warn(\"challenge with Digest algorithm different than 'MD5', authentication aborted\");\n        return false;\n      }\n    } else {\n      this.algorithm = \"MD5\";\n    }\n\n    if (!this.realm) {\n      this.logger.warn(\"challenge without Digest realm, authentication aborted\");\n      return false;\n    }\n\n    if (!this.nonce) {\n      this.logger.warn(\"challenge without Digest nonce, authentication aborted\");\n      return false;\n    } // 'qop' can contain a list of values (Array). Let's choose just one.\n\n\n    if (challenge.qop) {\n      if (challenge.qop.indexOf(\"auth\") > -1) {\n        this.qop = \"auth\";\n      } else if (challenge.qop.indexOf(\"auth-int\") > -1) {\n        this.qop = \"auth-int\";\n      } else {\n        // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n        this.logger.warn(\"challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted\");\n        return false;\n      }\n    } else {\n      this.qop = undefined;\n    } // Fill other attributes.\n\n\n    this.method = request.method;\n    this.uri = request.ruri;\n    this.cnonce = createRandomToken(12);\n    this.nc += 1;\n    this.updateNcHex(); // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n\n    if (this.nc === 4294967296) {\n      this.nc = 1;\n      this.ncHex = \"00000001\";\n    } // Calculate the Digest \"response\" value.\n\n\n    this.calculateResponse(body);\n    return true;\n  }\n  /**\n   * Return the Proxy-Authorization or WWW-Authorization header value.\n   */\n\n\n  toString() {\n    const authParams = [];\n\n    if (!this.response) {\n      throw new Error(\"response field does not exist, cannot generate Authorization header\");\n    }\n\n    authParams.push(\"algorithm=\" + this.algorithm);\n    authParams.push('username=\"' + this.username + '\"');\n    authParams.push('realm=\"' + this.realm + '\"');\n    authParams.push('nonce=\"' + this.nonce + '\"');\n    authParams.push('uri=\"' + this.uri + '\"');\n    authParams.push('response=\"' + this.response + '\"');\n\n    if (this.opaque) {\n      authParams.push('opaque=\"' + this.opaque + '\"');\n    }\n\n    if (this.qop) {\n      authParams.push(\"qop=\" + this.qop);\n      authParams.push('cnonce=\"' + this.cnonce + '\"');\n      authParams.push(\"nc=\" + this.ncHex);\n    }\n\n    return \"Digest \" + authParams.join(\", \");\n  }\n  /**\n   * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n   */\n\n\n  updateNcHex() {\n    const hex = Number(this.nc).toString(16);\n    this.ncHex = \"00000000\".substr(0, 8 - hex.length) + hex;\n  }\n  /**\n   * Generate Digest 'response' value.\n   */\n\n\n  calculateResponse(body) {\n    let ha1, ha2; // HA1 = MD5(A1) = MD5(username:realm:password)\n\n    ha1 = this.ha1;\n\n    if (ha1 === \"\" || ha1 === undefined) {\n      ha1 = MD5(this.username + \":\" + this.realm + \":\" + this.password);\n    }\n\n    if (this.qop === \"auth\") {\n      // HA2 = MD5(A2) = MD5(method:digestURI)\n      ha2 = MD5(this.method + \":\" + this.uri); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)`\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n    } else if (this.qop === \"auth-int\") {\n      // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n      ha2 = MD5(this.method + \":\" + this.uri + \":\" + MD5(body ? body : \"\")); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n    } else if (this.qop === undefined) {\n      // HA2 = MD5(A2) = MD5(method:digestURI)\n      ha2 = MD5(this.method + \":\" + this.uri); // response = MD5(HA1:nonce:HA2)\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/digest-authentication.js"],"names":["Md5","createRandomToken","MD5","s","hashStr","DigestAuthentication","constructor","loggerFactory","ha1","username","password","logger","getLogger","nc","ncHex","authenticate","request","challenge","body","algorithm","realm","nonce","opaque","stale","warn","qop","indexOf","undefined","method","uri","ruri","cnonce","updateNcHex","calculateResponse","toString","authParams","response","Error","push","join","hex","Number","substr","length","ha2"],"mappings":"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","sourcesContent":["import { Md5 } from \"./md5\";\nimport { createRandomToken } from \"./utils\";\nfunction MD5(s) {\n    return Md5.hashStr(s);\n}\n/**\n * Digest Authentication.\n * @internal\n */\nexport class DigestAuthentication {\n    /**\n     * Constructor.\n     * @param loggerFactory - LoggerFactory.\n     * @param username - Username.\n     * @param password - Password.\n     */\n    constructor(loggerFactory, ha1, username, password) {\n        this.logger = loggerFactory.getLogger(\"sipjs.digestauthentication\");\n        this.username = username;\n        this.password = password;\n        this.ha1 = ha1;\n        this.nc = 0;\n        this.ncHex = \"00000000\";\n    }\n    /**\n     * Performs Digest authentication given a SIP request and the challenge\n     * received in a response to that request.\n     * @param request -\n     * @param challenge -\n     * @returns true if credentials were successfully generated, false otherwise.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    authenticate(request, challenge, body) {\n        // Inspect and validate the challenge.\n        this.algorithm = challenge.algorithm;\n        this.realm = challenge.realm;\n        this.nonce = challenge.nonce;\n        this.opaque = challenge.opaque;\n        this.stale = challenge.stale;\n        if (this.algorithm) {\n            if (this.algorithm !== \"MD5\") {\n                this.logger.warn(\"challenge with Digest algorithm different than 'MD5', authentication aborted\");\n                return false;\n            }\n        }\n        else {\n            this.algorithm = \"MD5\";\n        }\n        if (!this.realm) {\n            this.logger.warn(\"challenge without Digest realm, authentication aborted\");\n            return false;\n        }\n        if (!this.nonce) {\n            this.logger.warn(\"challenge without Digest nonce, authentication aborted\");\n            return false;\n        }\n        // 'qop' can contain a list of values (Array). Let's choose just one.\n        if (challenge.qop) {\n            if (challenge.qop.indexOf(\"auth\") > -1) {\n                this.qop = \"auth\";\n            }\n            else if (challenge.qop.indexOf(\"auth-int\") > -1) {\n                this.qop = \"auth-int\";\n            }\n            else {\n                // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n                this.logger.warn(\"challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted\");\n                return false;\n            }\n        }\n        else {\n            this.qop = undefined;\n        }\n        // Fill other attributes.\n        this.method = request.method;\n        this.uri = request.ruri;\n        this.cnonce = createRandomToken(12);\n        this.nc += 1;\n        this.updateNcHex();\n        // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n        if (this.nc === 4294967296) {\n            this.nc = 1;\n            this.ncHex = \"00000001\";\n        }\n        // Calculate the Digest \"response\" value.\n        this.calculateResponse(body);\n        return true;\n    }\n    /**\n     * Return the Proxy-Authorization or WWW-Authorization header value.\n     */\n    toString() {\n        const authParams = [];\n        if (!this.response) {\n            throw new Error(\"response field does not exist, cannot generate Authorization header\");\n        }\n        authParams.push(\"algorithm=\" + this.algorithm);\n        authParams.push('username=\"' + this.username + '\"');\n        authParams.push('realm=\"' + this.realm + '\"');\n        authParams.push('nonce=\"' + this.nonce + '\"');\n        authParams.push('uri=\"' + this.uri + '\"');\n        authParams.push('response=\"' + this.response + '\"');\n        if (this.opaque) {\n            authParams.push('opaque=\"' + this.opaque + '\"');\n        }\n        if (this.qop) {\n            authParams.push(\"qop=\" + this.qop);\n            authParams.push('cnonce=\"' + this.cnonce + '\"');\n            authParams.push(\"nc=\" + this.ncHex);\n        }\n        return \"Digest \" + authParams.join(\", \");\n    }\n    /**\n     * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n     */\n    updateNcHex() {\n        const hex = Number(this.nc).toString(16);\n        this.ncHex = \"00000000\".substr(0, 8 - hex.length) + hex;\n    }\n    /**\n     * Generate Digest 'response' value.\n     */\n    calculateResponse(body) {\n        let ha1, ha2;\n        // HA1 = MD5(A1) = MD5(username:realm:password)\n        ha1 = this.ha1;\n        if (ha1 === \"\" || ha1 === undefined) {\n            ha1 = MD5(this.username + \":\" + this.realm + \":\" + this.password);\n        }\n        if (this.qop === \"auth\") {\n            // HA2 = MD5(A2) = MD5(method:digestURI)\n            ha2 = MD5(this.method + \":\" + this.uri);\n            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)`\n            this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n        }\n        else if (this.qop === \"auth-int\") {\n            // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n            ha2 = MD5(this.method + \":\" + this.uri + \":\" + MD5(body ? body : \"\"));\n            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n            this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n        }\n        else if (this.qop === undefined) {\n            // HA2 = MD5(A2) = MD5(method:digestURI)\n            ha2 = MD5(this.method + \":\" + this.uri);\n            // response = MD5(HA1:nonce:HA2)\n            this.response = MD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}