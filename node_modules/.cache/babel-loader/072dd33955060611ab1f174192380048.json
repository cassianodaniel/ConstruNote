{"ast":null,"code":"import { invariant } from '../utils';\nimport { SingularRelativeTimeUnit } from './SingularRelativeTimeUnit';\nimport { MakePartsList } from './MakePartsList';\nimport { ToString, Type, SameValue } from '../../262';\nexport function PartitionRelativeTimePattern(rtf, value, unit, _a) {\n  var getInternalSlots = _a.getInternalSlots;\n  invariant(Type(value) === 'Number', \"value must be number, instead got \" + typeof value, TypeError);\n  invariant(Type(unit) === 'String', \"unit must be number, instead got \" + typeof value, TypeError);\n\n  if (isNaN(value) || !isFinite(value)) {\n    throw new RangeError(\"Invalid value \" + value);\n  }\n\n  var resolvedUnit = SingularRelativeTimeUnit(unit);\n\n  var _b = getInternalSlots(rtf),\n      fields = _b.fields,\n      style = _b.style,\n      numeric = _b.numeric,\n      pluralRules = _b.pluralRules,\n      numberFormat = _b.numberFormat;\n\n  var entry = resolvedUnit;\n\n  if (style === 'short') {\n    entry = resolvedUnit + \"-short\";\n  } else if (style === 'narrow') {\n    entry = resolvedUnit + \"-narrow\";\n  }\n\n  if (!(entry in fields)) {\n    entry = resolvedUnit;\n  }\n\n  var patterns = fields[entry];\n\n  if (numeric === 'auto') {\n    if (ToString(value) in patterns) {\n      return [{\n        type: 'literal',\n        value: patterns[ToString(value)]\n      }];\n    }\n  }\n\n  var tl = 'future';\n\n  if (SameValue(value, -0) || value < 0) {\n    tl = 'past';\n  }\n\n  var po = patterns[tl];\n  var fv = typeof numberFormat.formatToParts === 'function' ? numberFormat.formatToParts(Math.abs(value)) : // TODO: If formatToParts is not supported, we assume the whole formatted\n  // number is a part\n  [{\n    type: 'literal',\n    value: numberFormat.format(Math.abs(value)),\n    unit: unit\n  }];\n  var pr = pluralRules.select(value);\n  var pattern = po[pr];\n  return MakePartsList(pattern, resolvedUnit, fv);\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@formatjs/ecma402-abstract/lib/src/RelativeTimeFormat/PartitionRelativeTimePattern.js"],"names":["invariant","SingularRelativeTimeUnit","MakePartsList","ToString","Type","SameValue","PartitionRelativeTimePattern","rtf","value","unit","_a","getInternalSlots","TypeError","isNaN","isFinite","RangeError","resolvedUnit","_b","fields","style","numeric","pluralRules","numberFormat","entry","patterns","type","tl","po","fv","formatToParts","Math","abs","format","pr","select","pattern"],"mappings":"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","sourcesContent":["import { invariant } from '../utils';\nimport { SingularRelativeTimeUnit } from './SingularRelativeTimeUnit';\nimport { MakePartsList } from './MakePartsList';\nimport { ToString, Type, SameValue } from '../../262';\nexport function PartitionRelativeTimePattern(rtf, value, unit, _a) {\n    var getInternalSlots = _a.getInternalSlots;\n    invariant(Type(value) === 'Number', \"value must be number, instead got \" + typeof value, TypeError);\n    invariant(Type(unit) === 'String', \"unit must be number, instead got \" + typeof value, TypeError);\n    if (isNaN(value) || !isFinite(value)) {\n        throw new RangeError(\"Invalid value \" + value);\n    }\n    var resolvedUnit = SingularRelativeTimeUnit(unit);\n    var _b = getInternalSlots(rtf), fields = _b.fields, style = _b.style, numeric = _b.numeric, pluralRules = _b.pluralRules, numberFormat = _b.numberFormat;\n    var entry = resolvedUnit;\n    if (style === 'short') {\n        entry = resolvedUnit + \"-short\";\n    }\n    else if (style === 'narrow') {\n        entry = resolvedUnit + \"-narrow\";\n    }\n    if (!(entry in fields)) {\n        entry = resolvedUnit;\n    }\n    var patterns = fields[entry];\n    if (numeric === 'auto') {\n        if (ToString(value) in patterns) {\n            return [\n                {\n                    type: 'literal',\n                    value: patterns[ToString(value)],\n                },\n            ];\n        }\n    }\n    var tl = 'future';\n    if (SameValue(value, -0) || value < 0) {\n        tl = 'past';\n    }\n    var po = patterns[tl];\n    var fv = typeof numberFormat.formatToParts === 'function'\n        ? numberFormat.formatToParts(Math.abs(value))\n        : // TODO: If formatToParts is not supported, we assume the whole formatted\n            // number is a part\n            [\n                {\n                    type: 'literal',\n                    value: numberFormat.format(Math.abs(value)),\n                    unit: unit,\n                },\n            ];\n    var pr = pluralRules.select(value);\n    var pattern = po[pr];\n    return MakePartsList(pattern, resolvedUnit, fv);\n}\n"]},"metadata":{},"sourceType":"module"}