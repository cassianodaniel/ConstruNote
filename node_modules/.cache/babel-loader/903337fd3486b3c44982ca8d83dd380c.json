{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Transaction } from \"./transaction\";\n/**\n * Client Transaction.\n * @remarks\n * The client transaction provides its functionality through the\n * maintenance of a state machine.\n *\n * The TU communicates with the client transaction through a simple\n * interface.  When the TU wishes to initiate a new transaction, it\n * creates a client transaction and passes it the SIP request to send\n * and an IP address, port, and transport to which to send it.  The\n * client transaction begins execution of its state machine.  Valid\n * responses are passed up to the TU from the client transaction.\n * https://tools.ietf.org/html/rfc3261#section-17.1\n * @public\n */\n\nexport var ClientTransaction = /*#__PURE__*/function (_Transaction) {\n  _inherits(ClientTransaction, _Transaction);\n\n  var _super = _createSuper(ClientTransaction);\n\n  function ClientTransaction(_request, transport, user, state, loggerCategory) {\n    var _this;\n\n    _classCallCheck(this, ClientTransaction);\n\n    _this = _super.call(this, transport, user, ClientTransaction.makeId(_request), state, loggerCategory);\n    _this._request = _request;\n    _this.user = user; // The Via header field indicates the transport used for the transaction\n    // and identifies the location where the response is to be sent.  A Via\n    // header field value is added only after the transport that will be\n    // used to reach the next hop has been selected (which may involve the\n    // usage of the procedures in [4]).\n    // https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n\n    _request.setViaHeader(_this.id, transport.protocol);\n\n    return _this;\n  }\n\n  _createClass(ClientTransaction, [{\n    key: \"onRequestTimeout\",\n\n    /**\n     * A 408 to non-INVITE will always arrive too late to be useful ([3]),\n     * The client already has full knowledge of the timeout. The only\n     * information this message would convey is whether or not the server\n     * believed the transaction timed out. However, with the current design\n     * of the NIT, a client cannot do anything with this knowledge. Thus,\n     * the 408 is simply wasting network resources and contributes to the\n     * response bombardment illustrated in [3].\n     * https://tools.ietf.org/html/rfc4320#section-4.1\n     */\n    value: function onRequestTimeout() {\n      if (this.user.onRequestTimeout) {\n        this.user.onRequestTimeout();\n      }\n    }\n  }, {\n    key: \"request\",\n\n    /** The outgoing request the transaction handling. */\n    get: function get() {\n      return this._request;\n    }\n  }], [{\n    key: \"makeId\",\n    value: function makeId(request) {\n      if (request.method === \"CANCEL\") {\n        if (!request.branch) {\n          throw new Error(\"Outgoing CANCEL request without a branch.\");\n        }\n\n        return request.branch;\n      } else {\n        return \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n      }\n    }\n  }]);\n\n  return ClientTransaction;\n}(Transaction);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/client-transaction.js"],"names":["Transaction","ClientTransaction","_request","transport","user","state","loggerCategory","makeId","setViaHeader","id","protocol","onRequestTimeout","request","method","branch","Error","Math","floor","random"],"mappings":";;;;AAAA,SAASA,WAAT,QAA4B,eAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,iBAAb;AAAA;;AAAA;;AACI,6BAAYC,QAAZ,EAAsBC,SAAtB,EAAiCC,IAAjC,EAAuCC,KAAvC,EAA8CC,cAA9C,EAA8D;AAAA;;AAAA;;AAC1D,8BAAMH,SAAN,EAAiBC,IAAjB,EAAuBH,iBAAiB,CAACM,MAAlB,CAAyBL,QAAzB,CAAvB,EAA2DG,KAA3D,EAAkEC,cAAlE;AACA,UAAKJ,QAAL,GAAgBA,QAAhB;AACA,UAAKE,IAAL,GAAYA,IAAZ,CAH0D,CAI1D;AACA;AACA;AACA;AACA;AACA;;AACAF,IAAAA,QAAQ,CAACM,YAAT,CAAsB,MAAKC,EAA3B,EAA+BN,SAAS,CAACO,QAAzC;;AAV0D;AAW7D;;AAZL;AAAA;;AA4BI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA,uCAsCuB;AACf,UAAI,KAAKN,IAAL,CAAUO,gBAAd,EAAgC;AAC5B,aAAKP,IAAL,CAAUO,gBAAV;AACH;AACJ;AA1CL;AAAA;;AAwBI;AAxBJ,wBAyBkB;AACV,aAAO,KAAKT,QAAZ;AACH;AA3BL;AAAA;AAAA,2BAakBU,OAblB,EAa2B;AACnB,UAAIA,OAAO,CAACC,MAAR,KAAmB,QAAvB,EAAiC;AAC7B,YAAI,CAACD,OAAO,CAACE,MAAb,EAAqB;AACjB,gBAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACH;;AACD,eAAOH,OAAO,CAACE,MAAf;AACH,OALD,MAMK;AACD,eAAO,YAAYE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,QAA3B,CAAnB;AACH;AACJ;AAvBL;;AAAA;AAAA,EAAuClB,WAAvC","sourcesContent":["import { Transaction } from \"./transaction\";\n/**\n * Client Transaction.\n * @remarks\n * The client transaction provides its functionality through the\n * maintenance of a state machine.\n *\n * The TU communicates with the client transaction through a simple\n * interface.  When the TU wishes to initiate a new transaction, it\n * creates a client transaction and passes it the SIP request to send\n * and an IP address, port, and transport to which to send it.  The\n * client transaction begins execution of its state machine.  Valid\n * responses are passed up to the TU from the client transaction.\n * https://tools.ietf.org/html/rfc3261#section-17.1\n * @public\n */\nexport class ClientTransaction extends Transaction {\n    constructor(_request, transport, user, state, loggerCategory) {\n        super(transport, user, ClientTransaction.makeId(_request), state, loggerCategory);\n        this._request = _request;\n        this.user = user;\n        // The Via header field indicates the transport used for the transaction\n        // and identifies the location where the response is to be sent.  A Via\n        // header field value is added only after the transport that will be\n        // used to reach the next hop has been selected (which may involve the\n        // usage of the procedures in [4]).\n        // https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n        _request.setViaHeader(this.id, transport.protocol);\n    }\n    static makeId(request) {\n        if (request.method === \"CANCEL\") {\n            if (!request.branch) {\n                throw new Error(\"Outgoing CANCEL request without a branch.\");\n            }\n            return request.branch;\n        }\n        else {\n            return \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n        }\n    }\n    /** The outgoing request the transaction handling. */\n    get request() {\n        return this._request;\n    }\n    /**\n     * A 408 to non-INVITE will always arrive too late to be useful ([3]),\n     * The client already has full knowledge of the timeout. The only\n     * information this message would convey is whether or not the server\n     * believed the transaction timed out. However, with the current design\n     * of the NIT, a client cannot do anything with this knowledge. Thus,\n     * the 408 is simply wasting network resources and contributes to the\n     * response bombardment illustrated in [3].\n     * https://tools.ietf.org/html/rfc4320#section-4.1\n     */\n    onRequestTimeout() {\n        if (this.user.onRequestTimeout) {\n            this.user.onRequestTimeout();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}