{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { C, Grammar, URI } from \"../core\";\nimport { EmitterImpl } from \"./emitter\";\nimport { RequestPendingError } from \"./exceptions\";\nimport { RegistererState } from \"./registerer-state\";\n/**\n * A registerer registers a contact for an address of record (outgoing REGISTER).\n * @public\n */\n\nexport var Registerer = /*#__PURE__*/function () {\n  /**\n   * Constructs a new instance of the `Registerer` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param options - Options bucket. See {@link RegistererOptions} for details.\n   */\n  function Registerer(userAgent) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Registerer);\n\n    this.disposed = false;\n    /** The contacts returned from the most recent accepted REGISTER request. */\n\n    this._contacts = [];\n    /** The number of seconds to wait before retrying to register. */\n\n    this._retryAfter = undefined;\n    /** The registration state. */\n\n    this._state = RegistererState.Initial;\n    /** True is waiting for final response to outstanding REGISTER request. */\n\n    this._waiting = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // waiting emitter\n\n    this._waitingEventEmitter = new EmitterImpl(); // Set user agent\n\n    this.userAgent = userAgent; // Default registrar is domain portion of user agent uri\n\n    var defaultUserAgentRegistrar = userAgent.configuration.uri.clone();\n    defaultUserAgentRegistrar.user = undefined; // Initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), {\n      registrar: defaultUserAgentRegistrar\n    }), Registerer.stripUndefinedProperties(options)); // Make sure we are not using references to array options\n\n    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();\n    this.options.extraHeaders = (this.options.extraHeaders || []).slice(); // Make sure we are not using references to registrar uri\n\n    if (!this.options.registrar) {\n      throw new Error(\"Registrar undefined.\");\n    }\n\n    this.options.registrar = this.options.registrar.clone(); // Set instanceId and regId conditional defaults and validate\n\n    if (this.options.regId && !this.options.instanceId) {\n      this.options.instanceId = Registerer.newUUID();\n    } else if (!this.options.regId && this.options.instanceId) {\n      this.options.regId = 1;\n    }\n\n    if (this.options.instanceId && Grammar.parse(this.options.instanceId, \"uuid\") === -1) {\n      throw new Error(\"Invalid instanceId.\");\n    }\n\n    if (this.options.regId && this.options.regId < 0) {\n      throw new Error(\"Invalid regId.\");\n    }\n\n    var registrar = this.options.registrar;\n    var fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;\n    var toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;\n    var params = this.options.params || {};\n    var extraHeaders = (options.extraHeaders || []).slice(); // Build the request\n\n    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined); // Registration expires\n\n    this.expires = this.options.expires || Registerer.defaultExpires;\n\n    if (this.expires < 0) {\n      throw new Error(\"Invalid expires.\");\n    } // initialize logger\n\n\n    this.logger = userAgent.getLogger(\"sip.Registerer\");\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(function (key) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var value = _this.options[key];\n\n        switch (key) {\n          case \"registrar\":\n            _this.logger.log(\"· \" + key + \": \" + value);\n\n            break;\n\n          default:\n            _this.logger.log(\"· \" + key + \": \" + JSON.stringify(value));\n\n        }\n      });\n    } // Identifier\n\n\n    this.id = this.request.callId + this.request.from.parameters.tag; // Add to the user agent's session collection.\n\n    this.userAgent._registerers[this.id] = this;\n  }\n  /** Default registerer options. */\n\n\n  _createClass(Registerer, [{\n    key: \"dispose\",\n\n    /** Destructor. */\n    value: function dispose() {\n      var _this2 = this;\n\n      if (this.disposed) {\n        return Promise.resolve();\n      }\n\n      this.disposed = true;\n      this.logger.log(\"Registerer \".concat(this.id, \" in state \").concat(this.state, \" is being disposed\")); // Remove from the user agent's registerer collection\n\n      delete this.userAgent._registerers[this.id]; // If registered, unregisters and resolves after final response received.\n\n      return new Promise(function (resolve) {\n        var doClose = function doClose() {\n          // If we are registered, unregister and resolve after our state changes\n          if (!_this2.waiting && _this2._state === RegistererState.Registered) {\n            _this2.stateChange.addListener(function () {\n              _this2.terminated();\n\n              resolve();\n            }, {\n              once: true\n            });\n\n            _this2.unregister();\n\n            return;\n          } // Otherwise just resolve\n\n\n          _this2.terminated();\n\n          resolve();\n        }; // If we are waiting for an outstanding request, wait for it to finish and then try closing.\n        // Otherwise just try closing.\n\n\n        if (_this2.waiting) {\n          _this2.waitingChange.addListener(function () {\n            doClose();\n          }, {\n            once: true\n          });\n        } else {\n          doClose();\n        }\n      });\n    }\n    /**\n     * Sends the REGISTER request.\n     * @remarks\n     * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.state === RegistererState.Terminated) {\n        this.stateError();\n        throw new Error(\"Registerer terminated. Unable to register.\");\n      }\n\n      if (this.disposed) {\n        this.stateError();\n        throw new Error(\"Registerer disposed. Unable to register.\");\n      } // UAs MUST NOT send a new registration (that is, containing new Contact\n      // header field values, as opposed to a retransmission) until they have\n      // received a final response from the registrar for the previous one or\n      // the previous REGISTER request has timed out.\n      // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n      if (this.waiting) {\n        this.waitingWarning();\n        var error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n        return Promise.reject(error);\n      } // Options\n\n\n      if (options.requestOptions) {\n        this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);\n      } // Extra headers\n\n\n      var extraHeaders = (this.options.extraHeaders || []).slice();\n      extraHeaders.push(\"Contact: \" + this.generateContactHeader(this.expires)); // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency\n\n      extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString()); // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n      // header field value for registrations sent to a particular\n      // registrar.\n      //\n      // CSeq: The CSeq value guarantees proper ordering of REGISTER\n      // requests.  A UA MUST increment the CSeq value by one for each\n      // REGISTER request with the same Call-ID.\n      // https://tools.ietf.org/html/rfc3261#section-10.2\n\n      this.request.cseq++;\n      this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n      this.request.extraHeaders = extraHeaders;\n      this.waitingToggle(true);\n      var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n        onAccept: function onAccept(response) {\n          var expires; // FIXME: This does NOT appear to be to spec and should be removed.\n          // I haven't found anywhere that an Expires header may be used in a response.\n\n          if (response.message.hasHeader(\"expires\")) {\n            expires = Number(response.message.getHeader(\"expires\"));\n          } // 8. The registrar returns a 200 (OK) response.  The response MUST\n          // contain Contact header field values enumerating all current\n          // bindings.  Each Contact value MUST feature an \"expires\"\n          // parameter indicating its expiration interval chosen by the\n          // registrar.  The response SHOULD include a Date header field.\n          // https://tools.ietf.org/html/rfc3261#section-10.3\n\n\n          _this3._contacts = response.message.getHeaders(\"contact\");\n          var contacts = _this3._contacts.length;\n\n          if (!contacts) {\n            _this3.logger.error(\"No Contact header in response to REGISTER, dropping response.\");\n\n            _this3.unregistered();\n\n            return;\n          } // The 200 (OK) response from the registrar contains a list of Contact\n          // fields enumerating all current bindings.  The UA compares each\n          // contact address to see if it created the contact address, using\n          // comparison rules in Section 19.1.4.  If so, it updates the expiration\n          // time interval according to the expires parameter or, if absent, the\n          // Expires field value.  The UA then issues a REGISTER request for each\n          // of its bindings before the expiration interval has elapsed.\n          // https://tools.ietf.org/html/rfc3261#section-10.2.4\n\n\n          var contact;\n\n          while (contacts--) {\n            contact = response.message.parseHeader(\"contact\", contacts);\n\n            if (!contact) {\n              throw new Error(\"Contact undefined\");\n            }\n\n            if (contact.uri.user === _this3.userAgent.contact.uri.user) {\n              expires = Number(contact.getParam(\"expires\"));\n              break;\n            }\n\n            contact = undefined;\n          } // There must be a matching contact.\n\n\n          if (contact === undefined) {\n            _this3.logger.error(\"No Contact header pointing to us, dropping response\");\n\n            _this3.unregistered();\n\n            _this3.waitingToggle(false);\n\n            return;\n          } // The contact must have an expires.\n\n\n          if (expires === undefined) {\n            _this3.logger.error(\"Contact pointing to us is missing expires parameter, dropping response\");\n\n            _this3.unregistered();\n\n            _this3.waitingToggle(false);\n\n            return;\n          } // Save gruu values\n\n\n          if (contact.hasParam(\"temp-gruu\")) {\n            var gruu = contact.getParam(\"temp-gruu\");\n\n            if (gruu) {\n              _this3.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n            }\n          }\n\n          if (contact.hasParam(\"pub-gruu\")) {\n            var _gruu = contact.getParam(\"pub-gruu\");\n\n            if (_gruu) {\n              _this3.userAgent.contact.pubGruu = Grammar.URIParse(_gruu.replace(/\"/g, \"\"));\n            }\n          }\n\n          _this3.registered(expires);\n\n          if (options.requestDelegate && options.requestDelegate.onAccept) {\n            options.requestDelegate.onAccept(response);\n          }\n\n          _this3.waitingToggle(false);\n        },\n        onProgress: function onProgress(response) {\n          if (options.requestDelegate && options.requestDelegate.onProgress) {\n            options.requestDelegate.onProgress(response);\n          }\n        },\n        onRedirect: function onRedirect(response) {\n          _this3.logger.error(\"Redirect received. Not supported.\");\n\n          _this3.unregistered();\n\n          if (options.requestDelegate && options.requestDelegate.onRedirect) {\n            options.requestDelegate.onRedirect(response);\n          }\n\n          _this3.waitingToggle(false);\n        },\n        onReject: function onReject(response) {\n          if (response.message.statusCode === 423) {\n            // If a UA receives a 423 (Interval Too Brief) response, it MAY retry\n            // the registration after making the expiration interval of all contact\n            // addresses in the REGISTER request equal to or greater than the\n            // expiration interval within the Min-Expires header field of the 423\n            // (Interval Too Brief) response.\n            // https://tools.ietf.org/html/rfc3261#section-10.2.8\n            //\n            // The registrar MAY choose an expiration less than the requested\n            // expiration interval.  If and only if the requested expiration\n            // interval is greater than zero AND smaller than one hour AND\n            // less than a registrar-configured minimum, the registrar MAY\n            // reject the registration with a response of 423 (Interval Too\n            // Brief).  This response MUST contain a Min-Expires header field\n            // that states the minimum expiration interval the registrar is\n            // willing to honor.  It then skips the remaining steps.\n            // https://tools.ietf.org/html/rfc3261#section-10.3\n            if (!response.message.hasHeader(\"min-expires\")) {\n              // This response MUST contain a Min-Expires header field\n              _this3.logger.error(\"423 response received for REGISTER without Min-Expires, dropping response\");\n\n              _this3.unregistered();\n\n              _this3.waitingToggle(false);\n\n              return;\n            } // Increase our registration interval to the suggested minimum\n\n\n            _this3.expires = Number(response.message.getHeader(\"min-expires\")); // Attempt the registration again immediately\n\n            _this3.waitingToggle(false);\n\n            _this3.register();\n\n            return;\n          }\n\n          _this3.logger.warn(\"Failed to register, status code \".concat(response.message.statusCode)); // The Retry-After header field can be used with a 500 (Server Internal\n          // Error) or 503 (Service Unavailable) response to indicate how long the\n          // service is expected to be unavailable to the requesting client...\n          // https://tools.ietf.org/html/rfc3261#section-20.33\n\n\n          var retryAfterDuration = NaN;\n\n          if (response.message.statusCode === 500 || response.message.statusCode === 503) {\n            var header = response.message.getHeader(\"retry-after\");\n\n            if (header) {\n              retryAfterDuration = Number.parseInt(header, undefined);\n            }\n          } // Set for the state change (if any) and the delegate callback (if any)\n\n\n          _this3._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;\n\n          _this3.unregistered();\n\n          if (options.requestDelegate && options.requestDelegate.onReject) {\n            options.requestDelegate.onReject(response);\n          }\n\n          _this3._retryAfter = undefined;\n\n          _this3.waitingToggle(false);\n        },\n        onTrying: function onTrying(response) {\n          if (options.requestDelegate && options.requestDelegate.onTrying) {\n            options.requestDelegate.onTrying(response);\n          }\n        }\n      });\n      return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Sends the REGISTER request with expires equal to zero.\n     * @remarks\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.state === RegistererState.Terminated) {\n        this.stateError();\n        throw new Error(\"Registerer terminated. Unable to register.\");\n      }\n\n      if (this.disposed) {\n        if (this.state !== RegistererState.Registered) {\n          // allows unregister while disposing and registered\n          this.stateError();\n          throw new Error(\"Registerer disposed. Unable to register.\");\n        }\n      } // UAs MUST NOT send a new registration (that is, containing new Contact\n      // header field values, as opposed to a retransmission) until they have\n      // received a final response from the registrar for the previous one or\n      // the previous REGISTER request has timed out.\n      // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n      if (this.waiting) {\n        this.waitingWarning();\n        var error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n        return Promise.reject(error);\n      }\n\n      if (this._state !== RegistererState.Registered && !options.all) {\n        this.logger.warn(\"Not currently registered, but sending an unregister anyway.\");\n      } // Extra headers\n\n\n      var extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();\n      this.request.extraHeaders = extraHeaders; // Registrations are soft state and expire unless refreshed, but can\n      // also be explicitly removed.  A client can attempt to influence the\n      // expiration interval selected by the registrar as described in Section\n      // 10.2.1.  A UA requests the immediate removal of a binding by\n      // specifying an expiration interval of \"0\" for that contact address in\n      // a REGISTER request.  UAs SHOULD support this mechanism so that\n      // bindings can be removed before their expiration interval has passed.\n      //\n      // The REGISTER-specific Contact header field value of \"*\" applies to\n      // all registrations, but it MUST NOT be used unless the Expires header\n      // field is present with a value of \"0\".\n      // https://tools.ietf.org/html/rfc3261#section-10.2.2\n\n      if (options.all) {\n        extraHeaders.push(\"Contact: *\");\n        extraHeaders.push(\"Expires: 0\");\n      } else {\n        extraHeaders.push(\"Contact: \" + this.generateContactHeader(0));\n      } // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n      // header field value for registrations sent to a particular\n      // registrar.\n      //\n      // CSeq: The CSeq value guarantees proper ordering of REGISTER\n      // requests.  A UA MUST increment the CSeq value by one for each\n      // REGISTER request with the same Call-ID.\n      // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n      this.request.cseq++;\n      this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\"); // Pre-emptive clear the registration timer to avoid a race condition where\n      // this timer fires while waiting for a final response to the unsubscribe.\n\n      if (this.registrationTimer !== undefined) {\n        clearTimeout(this.registrationTimer);\n        this.registrationTimer = undefined;\n      }\n\n      this.waitingToggle(true);\n      var outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n        onAccept: function onAccept(response) {\n          _this4._contacts = response.message.getHeaders(\"contact\"); // Update contacts\n\n          _this4.unregistered();\n\n          if (options.requestDelegate && options.requestDelegate.onAccept) {\n            options.requestDelegate.onAccept(response);\n          }\n\n          _this4.waitingToggle(false);\n        },\n        onProgress: function onProgress(response) {\n          if (options.requestDelegate && options.requestDelegate.onProgress) {\n            options.requestDelegate.onProgress(response);\n          }\n        },\n        onRedirect: function onRedirect(response) {\n          _this4.logger.error(\"Unregister redirected. Not currently supported.\");\n\n          _this4.unregistered();\n\n          if (options.requestDelegate && options.requestDelegate.onRedirect) {\n            options.requestDelegate.onRedirect(response);\n          }\n\n          _this4.waitingToggle(false);\n        },\n        onReject: function onReject(response) {\n          _this4.logger.error(\"Unregister rejected with status code \".concat(response.message.statusCode));\n\n          _this4.unregistered();\n\n          if (options.requestDelegate && options.requestDelegate.onReject) {\n            options.requestDelegate.onReject(response);\n          }\n\n          _this4.waitingToggle(false);\n        },\n        onTrying: function onTrying(response) {\n          if (options.requestDelegate && options.requestDelegate.onTrying) {\n            options.requestDelegate.onTrying(response);\n          }\n        }\n      });\n      return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Clear registration timers.\n     */\n\n  }, {\n    key: \"clearTimers\",\n    value: function clearTimers() {\n      if (this.registrationTimer !== undefined) {\n        clearTimeout(this.registrationTimer);\n        this.registrationTimer = undefined;\n      }\n\n      if (this.registrationExpiredTimer !== undefined) {\n        clearTimeout(this.registrationExpiredTimer);\n        this.registrationExpiredTimer = undefined;\n      }\n    }\n    /**\n     * Generate Contact Header\n     */\n\n  }, {\n    key: \"generateContactHeader\",\n    value: function generateContactHeader(expires) {\n      var contact = this.userAgent.contact.toString();\n\n      if (this.options.regId && this.options.instanceId) {\n        contact += \";reg-id=\" + this.options.regId;\n        contact += ';+sip.instance=\"<urn:uuid:' + this.options.instanceId + '>\"';\n      }\n\n      if (this.options.extraContactHeaderParams) {\n        this.options.extraContactHeaderParams.forEach(function (header) {\n          contact += \";\" + header;\n        });\n      }\n\n      contact += \";expires=\" + expires;\n      return contact;\n    }\n    /**\n     * Helper function, called when registered.\n     */\n\n  }, {\n    key: \"registered\",\n    value: function registered(expires) {\n      var _this5 = this;\n\n      this.clearTimers(); // Re-Register before the expiration interval has elapsed.\n      // For that, decrease the expires value. ie: 3 seconds\n\n      this.registrationTimer = setTimeout(function () {\n        _this5.registrationTimer = undefined;\n\n        _this5.register();\n      }, expires * 1000 - 3000); // We are unregistered if the registration expires.\n\n      this.registrationExpiredTimer = setTimeout(function () {\n        _this5.logger.warn(\"Registration expired\");\n\n        _this5.unregistered();\n      }, expires * 1000);\n\n      if (this._state !== RegistererState.Registered) {\n        this.stateTransition(RegistererState.Registered);\n      }\n    }\n    /**\n     * Helper function, called when unregistered.\n     */\n\n  }, {\n    key: \"unregistered\",\n    value: function unregistered() {\n      this.clearTimers();\n\n      if (this._state !== RegistererState.Unregistered) {\n        this.stateTransition(RegistererState.Unregistered);\n      }\n    }\n    /**\n     * Helper function, called when terminated.\n     */\n\n  }, {\n    key: \"terminated\",\n    value: function terminated() {\n      this.clearTimers();\n\n      if (this._state !== RegistererState.Terminated) {\n        this.stateTransition(RegistererState.Terminated);\n      }\n    }\n    /**\n     * Transition registration state.\n     */\n\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState) {\n      var _this6 = this;\n\n      var invalidTransition = function invalidTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this6._state, \" to \").concat(newState));\n      }; // Validate transition\n\n\n      switch (this._state) {\n        case RegistererState.Initial:\n          if (newState !== RegistererState.Registered && newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case RegistererState.Registered:\n          if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case RegistererState.Unregistered:\n          if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case RegistererState.Terminated:\n          invalidTransition();\n          break;\n\n        default:\n          throw new Error(\"Unrecognized state.\");\n      } // Transition\n\n\n      this._state = newState;\n      this.logger.log(\"Registration transitioned to state \".concat(this._state));\n\n      this._stateEventEmitter.emit(this._state); // Dispose\n\n\n      if (newState === RegistererState.Terminated) {\n        this.dispose();\n      }\n    }\n    /** True if the registerer is currently waiting for final response to a REGISTER request. */\n\n  }, {\n    key: \"waitingToggle\",\n\n    /**\n     * Toggle waiting.\n     */\n    value: function waitingToggle(waiting) {\n      if (this._waiting === waiting) {\n        throw new Error(\"Invalid waiting transition from \".concat(this._waiting, \" to \").concat(waiting));\n      }\n\n      this._waiting = waiting;\n      this.logger.log(\"Waiting toggled to \".concat(this._waiting));\n\n      this._waitingEventEmitter.emit(this._waiting);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n  }, {\n    key: \"waitingWarning\",\n    value: function waitingWarning() {\n      var message = \"An attempt was made to send a REGISTER request while a prior one was still in progress.\";\n      message += \" RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response\";\n      message += \" from the registrar for the previous one or the previous REGISTER request has timed out.\";\n      message += \" Note that if the transport disconnects, you still must wait for the prior request to time out before\";\n      message += \" sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.\";\n      this.logger.warn(message);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n  }, {\n    key: \"stateError\",\n    value: function stateError() {\n      var reason = this.state === RegistererState.Terminated ? \"is in 'Terminated' state\" : \"has been disposed\";\n      var message = \"An attempt was made to send a REGISTER request when the Registerer \".concat(reason, \".\");\n      message += \" The Registerer transitions to 'Terminated' when Registerer.dispose() is called.\";\n      message += \" Perhaps you called UserAgent.stop() which dipsoses of all Registerers?\";\n      this.logger.error(message);\n    }\n  }, {\n    key: \"contacts\",\n\n    /** The registered contacts. */\n    get: function get() {\n      return this._contacts.slice();\n    }\n    /**\n     * The number of seconds to wait before retrying to register.\n     * @defaultValue `undefined`\n     * @remarks\n     * When the server rejects a registration request, if it provides a suggested\n     * duration to wait before retrying, that value is available here when and if\n     * the state transitions to `Unsubscribed`. It is also available during the\n     * callback to `onReject` after a call to `register`. (Note that if the state\n     * if already `Unsubscribed`, a rejected request created by `register` will\n     * not cause the state to transition to `Unsubscribed`. One way to avoid this\n     * case is to dispose of `Registerer` when unregistered and create a new\n     * `Registerer` for any attempts to retry registering.)\n     * @example\n     * ```ts\n     * // Checking for retry after on state change\n     * registerer.stateChange.addListener((newState) => {\n     *   switch (newState) {\n     *     case RegistererState.Unregistered:\n     *       const retryAfter = registerer.retryAfter;\n     *       break;\n     *   }\n     * });\n     *\n     * // Checking for retry after on request rejection\n     * registerer.register({\n     *   requestDelegate: {\n     *     onReject: () => {\n     *       const retryAfter = registerer.retryAfter;\n     *     }\n     *   }\n     * });\n     * ```\n     */\n\n  }, {\n    key: \"retryAfter\",\n    get: function get() {\n      return this._retryAfter;\n    }\n    /** The registration state. */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n    /** Emits when the registerer state changes. */\n\n  }, {\n    key: \"stateChange\",\n    get: function get() {\n      return this._stateEventEmitter;\n    }\n  }, {\n    key: \"waiting\",\n    get: function get() {\n      return this._waiting;\n    }\n    /** Emits when the registerer waiting state changes. */\n\n  }, {\n    key: \"waitingChange\",\n    get: function get() {\n      return this._waitingEventEmitter;\n    }\n  }], [{\n    key: \"defaultOptions\",\n    value: function defaultOptions() {\n      return {\n        expires: Registerer.defaultExpires,\n        extraContactHeaderParams: [],\n        extraHeaders: [],\n        logConfiguration: true,\n        instanceId: \"\",\n        params: {},\n        regId: 0,\n        registrar: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\")\n      };\n    } // http://stackoverflow.com/users/109538/broofa\n\n  }, {\n    key: \"newUUID\",\n    value: function newUUID() {\n      var UUID = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n        var r = Math.floor(Math.random() * 16);\n        var v = c === \"x\" ? r : r % 4 + 8;\n        return v.toString(16);\n      });\n      return UUID;\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n\n  }, {\n    key: \"stripUndefinedProperties\",\n    value: function stripUndefinedProperties(options) {\n      return Object.keys(options).reduce(function (object, key) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (options[key] !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          object[key] = options[key];\n        }\n\n        return object;\n      }, {});\n    }\n  }]);\n\n  return Registerer;\n}();\nRegisterer.defaultExpires = 600;","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/registerer.js"],"names":["C","Grammar","URI","EmitterImpl","RequestPendingError","RegistererState","Registerer","userAgent","options","disposed","_contacts","_retryAfter","undefined","_state","Initial","_waiting","_stateEventEmitter","_waitingEventEmitter","defaultUserAgentRegistrar","configuration","uri","clone","user","Object","assign","defaultOptions","registrar","stripUndefinedProperties","extraContactHeaderParams","slice","extraHeaders","Error","regId","instanceId","newUUID","parse","fromURI","params","fromUri","userAgentCore","aor","toURI","toUri","request","makeOutgoingRequestMessage","REGISTER","expires","defaultExpires","logger","getLogger","logConfiguration","log","keys","forEach","key","value","JSON","stringify","id","callId","from","parameters","tag","_registerers","Promise","resolve","state","doClose","waiting","Registered","stateChange","addListener","terminated","once","unregister","waitingChange","Terminated","stateError","waitingWarning","error","reject","requestOptions","push","generateContactHeader","toString","cseq","setHeader","waitingToggle","outgoingRegisterRequest","register","onAccept","response","message","hasHeader","Number","getHeader","getHeaders","contacts","length","unregistered","contact","parseHeader","getParam","hasParam","gruu","tempGruu","URIParse","replace","pubGruu","registered","requestDelegate","onProgress","onRedirect","onReject","statusCode","warn","retryAfterDuration","NaN","header","parseInt","isNaN","onTrying","all","registrationTimer","clearTimeout","registrationExpiredTimer","clearTimers","setTimeout","stateTransition","Unregistered","newState","invalidTransition","emit","dispose","reason","UUID","c","r","Math","floor","random","v","reduce","object"],"mappings":"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","sourcesContent":["import { C, Grammar, URI } from \"../core\";\nimport { EmitterImpl } from \"./emitter\";\nimport { RequestPendingError } from \"./exceptions\";\nimport { RegistererState } from \"./registerer-state\";\n/**\n * A registerer registers a contact for an address of record (outgoing REGISTER).\n * @public\n */\nexport class Registerer {\n    /**\n     * Constructs a new instance of the `Registerer` class.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param options - Options bucket. See {@link RegistererOptions} for details.\n     */\n    constructor(userAgent, options = {}) {\n        this.disposed = false;\n        /** The contacts returned from the most recent accepted REGISTER request. */\n        this._contacts = [];\n        /** The number of seconds to wait before retrying to register. */\n        this._retryAfter = undefined;\n        /** The registration state. */\n        this._state = RegistererState.Initial;\n        /** True is waiting for final response to outstanding REGISTER request. */\n        this._waiting = false;\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // waiting emitter\n        this._waitingEventEmitter = new EmitterImpl();\n        // Set user agent\n        this.userAgent = userAgent;\n        // Default registrar is domain portion of user agent uri\n        const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();\n        defaultUserAgentRegistrar.user = undefined;\n        // Initialize configuration\n        this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), { registrar: defaultUserAgentRegistrar }), Registerer.stripUndefinedProperties(options));\n        // Make sure we are not using references to array options\n        this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();\n        this.options.extraHeaders = (this.options.extraHeaders || []).slice();\n        // Make sure we are not using references to registrar uri\n        if (!this.options.registrar) {\n            throw new Error(\"Registrar undefined.\");\n        }\n        this.options.registrar = this.options.registrar.clone();\n        // Set instanceId and regId conditional defaults and validate\n        if (this.options.regId && !this.options.instanceId) {\n            this.options.instanceId = Registerer.newUUID();\n        }\n        else if (!this.options.regId && this.options.instanceId) {\n            this.options.regId = 1;\n        }\n        if (this.options.instanceId && Grammar.parse(this.options.instanceId, \"uuid\") === -1) {\n            throw new Error(\"Invalid instanceId.\");\n        }\n        if (this.options.regId && this.options.regId < 0) {\n            throw new Error(\"Invalid regId.\");\n        }\n        const registrar = this.options.registrar;\n        const fromURI = (this.options.params && this.options.params.fromUri) || userAgent.userAgentCore.configuration.aor;\n        const toURI = (this.options.params && this.options.params.toUri) || userAgent.configuration.uri;\n        const params = this.options.params || {};\n        const extraHeaders = (options.extraHeaders || []).slice();\n        // Build the request\n        this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined);\n        // Registration expires\n        this.expires = this.options.expires || Registerer.defaultExpires;\n        if (this.expires < 0) {\n            throw new Error(\"Invalid expires.\");\n        }\n        // initialize logger\n        this.logger = userAgent.getLogger(\"sip.Registerer\");\n        if (this.options.logConfiguration) {\n            this.logger.log(\"Configuration:\");\n            Object.keys(this.options).forEach((key) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const value = this.options[key];\n                switch (key) {\n                    case \"registrar\":\n                        this.logger.log(\"· \" + key + \": \" + value);\n                        break;\n                    default:\n                        this.logger.log(\"· \" + key + \": \" + JSON.stringify(value));\n                }\n            });\n        }\n        // Identifier\n        this.id = this.request.callId + this.request.from.parameters.tag;\n        // Add to the user agent's session collection.\n        this.userAgent._registerers[this.id] = this;\n    }\n    /** Default registerer options. */\n    static defaultOptions() {\n        return {\n            expires: Registerer.defaultExpires,\n            extraContactHeaderParams: [],\n            extraHeaders: [],\n            logConfiguration: true,\n            instanceId: \"\",\n            params: {},\n            regId: 0,\n            registrar: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\")\n        };\n    }\n    // http://stackoverflow.com/users/109538/broofa\n    static newUUID() {\n        const UUID = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n            const r = Math.floor(Math.random() * 16);\n            const v = c === \"x\" ? r : (r % 4) + 8;\n            return v.toString(16);\n        });\n        return UUID;\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n    static stripUndefinedProperties(options) {\n        return Object.keys(options).reduce((object, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (options[key] !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                object[key] = options[key];\n            }\n            return object;\n        }, {});\n    }\n    /** The registered contacts. */\n    get contacts() {\n        return this._contacts.slice();\n    }\n    /**\n     * The number of seconds to wait before retrying to register.\n     * @defaultValue `undefined`\n     * @remarks\n     * When the server rejects a registration request, if it provides a suggested\n     * duration to wait before retrying, that value is available here when and if\n     * the state transitions to `Unsubscribed`. It is also available during the\n     * callback to `onReject` after a call to `register`. (Note that if the state\n     * if already `Unsubscribed`, a rejected request created by `register` will\n     * not cause the state to transition to `Unsubscribed`. One way to avoid this\n     * case is to dispose of `Registerer` when unregistered and create a new\n     * `Registerer` for any attempts to retry registering.)\n     * @example\n     * ```ts\n     * // Checking for retry after on state change\n     * registerer.stateChange.addListener((newState) => {\n     *   switch (newState) {\n     *     case RegistererState.Unregistered:\n     *       const retryAfter = registerer.retryAfter;\n     *       break;\n     *   }\n     * });\n     *\n     * // Checking for retry after on request rejection\n     * registerer.register({\n     *   requestDelegate: {\n     *     onReject: () => {\n     *       const retryAfter = registerer.retryAfter;\n     *     }\n     *   }\n     * });\n     * ```\n     */\n    get retryAfter() {\n        return this._retryAfter;\n    }\n    /** The registration state. */\n    get state() {\n        return this._state;\n    }\n    /** Emits when the registerer state changes. */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /** Destructor. */\n    dispose() {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`);\n        // Remove from the user agent's registerer collection\n        delete this.userAgent._registerers[this.id];\n        // If registered, unregisters and resolves after final response received.\n        return new Promise((resolve) => {\n            const doClose = () => {\n                // If we are registered, unregister and resolve after our state changes\n                if (!this.waiting && this._state === RegistererState.Registered) {\n                    this.stateChange.addListener(() => {\n                        this.terminated();\n                        resolve();\n                    }, { once: true });\n                    this.unregister();\n                    return;\n                }\n                // Otherwise just resolve\n                this.terminated();\n                resolve();\n            };\n            // If we are waiting for an outstanding request, wait for it to finish and then try closing.\n            // Otherwise just try closing.\n            if (this.waiting) {\n                this.waitingChange.addListener(() => {\n                    doClose();\n                }, { once: true });\n            }\n            else {\n                doClose();\n            }\n        });\n    }\n    /**\n     * Sends the REGISTER request.\n     * @remarks\n     * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n    register(options = {}) {\n        if (this.state === RegistererState.Terminated) {\n            this.stateError();\n            throw new Error(\"Registerer terminated. Unable to register.\");\n        }\n        if (this.disposed) {\n            this.stateError();\n            throw new Error(\"Registerer disposed. Unable to register.\");\n        }\n        // UAs MUST NOT send a new registration (that is, containing new Contact\n        // header field values, as opposed to a retransmission) until they have\n        // received a final response from the registrar for the previous one or\n        // the previous REGISTER request has timed out.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        if (this.waiting) {\n            this.waitingWarning();\n            const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n            return Promise.reject(error);\n        }\n        // Options\n        if (options.requestOptions) {\n            this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);\n        }\n        // Extra headers\n        const extraHeaders = (this.options.extraHeaders || []).slice();\n        extraHeaders.push(\"Contact: \" + this.generateContactHeader(this.expires));\n        // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n        // header field value for registrations sent to a particular\n        // registrar.\n        //\n        // CSeq: The CSeq value guarantees proper ordering of REGISTER\n        // requests.  A UA MUST increment the CSeq value by one for each\n        // REGISTER request with the same Call-ID.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        this.request.cseq++;\n        this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n        this.request.extraHeaders = extraHeaders;\n        this.waitingToggle(true);\n        const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n            onAccept: (response) => {\n                let expires;\n                // FIXME: This does NOT appear to be to spec and should be removed.\n                // I haven't found anywhere that an Expires header may be used in a response.\n                if (response.message.hasHeader(\"expires\")) {\n                    expires = Number(response.message.getHeader(\"expires\"));\n                }\n                // 8. The registrar returns a 200 (OK) response.  The response MUST\n                // contain Contact header field values enumerating all current\n                // bindings.  Each Contact value MUST feature an \"expires\"\n                // parameter indicating its expiration interval chosen by the\n                // registrar.  The response SHOULD include a Date header field.\n                // https://tools.ietf.org/html/rfc3261#section-10.3\n                this._contacts = response.message.getHeaders(\"contact\");\n                let contacts = this._contacts.length;\n                if (!contacts) {\n                    this.logger.error(\"No Contact header in response to REGISTER, dropping response.\");\n                    this.unregistered();\n                    return;\n                }\n                // The 200 (OK) response from the registrar contains a list of Contact\n                // fields enumerating all current bindings.  The UA compares each\n                // contact address to see if it created the contact address, using\n                // comparison rules in Section 19.1.4.  If so, it updates the expiration\n                // time interval according to the expires parameter or, if absent, the\n                // Expires field value.  The UA then issues a REGISTER request for each\n                // of its bindings before the expiration interval has elapsed.\n                // https://tools.ietf.org/html/rfc3261#section-10.2.4\n                let contact;\n                while (contacts--) {\n                    contact = response.message.parseHeader(\"contact\", contacts);\n                    if (!contact) {\n                        throw new Error(\"Contact undefined\");\n                    }\n                    if (contact.uri.user === this.userAgent.contact.uri.user) {\n                        expires = Number(contact.getParam(\"expires\"));\n                        break;\n                    }\n                    contact = undefined;\n                }\n                // There must be a matching contact.\n                if (contact === undefined) {\n                    this.logger.error(\"No Contact header pointing to us, dropping response\");\n                    this.unregistered();\n                    this.waitingToggle(false);\n                    return;\n                }\n                // The contact must have an expires.\n                if (expires === undefined) {\n                    this.logger.error(\"Contact pointing to us is missing expires parameter, dropping response\");\n                    this.unregistered();\n                    this.waitingToggle(false);\n                    return;\n                }\n                // Save gruu values\n                if (contact.hasParam(\"temp-gruu\")) {\n                    const gruu = contact.getParam(\"temp-gruu\");\n                    if (gruu) {\n                        this.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n                    }\n                }\n                if (contact.hasParam(\"pub-gruu\")) {\n                    const gruu = contact.getParam(\"pub-gruu\");\n                    if (gruu) {\n                        this.userAgent.contact.pubGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n                    }\n                }\n                this.registered(expires);\n                if (options.requestDelegate && options.requestDelegate.onAccept) {\n                    options.requestDelegate.onAccept(response);\n                }\n                this.waitingToggle(false);\n            },\n            onProgress: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onProgress) {\n                    options.requestDelegate.onProgress(response);\n                }\n            },\n            onRedirect: (response) => {\n                this.logger.error(\"Redirect received. Not supported.\");\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(response);\n                }\n                this.waitingToggle(false);\n            },\n            onReject: (response) => {\n                if (response.message.statusCode === 423) {\n                    // If a UA receives a 423 (Interval Too Brief) response, it MAY retry\n                    // the registration after making the expiration interval of all contact\n                    // addresses in the REGISTER request equal to or greater than the\n                    // expiration interval within the Min-Expires header field of the 423\n                    // (Interval Too Brief) response.\n                    // https://tools.ietf.org/html/rfc3261#section-10.2.8\n                    //\n                    // The registrar MAY choose an expiration less than the requested\n                    // expiration interval.  If and only if the requested expiration\n                    // interval is greater than zero AND smaller than one hour AND\n                    // less than a registrar-configured minimum, the registrar MAY\n                    // reject the registration with a response of 423 (Interval Too\n                    // Brief).  This response MUST contain a Min-Expires header field\n                    // that states the minimum expiration interval the registrar is\n                    // willing to honor.  It then skips the remaining steps.\n                    // https://tools.ietf.org/html/rfc3261#section-10.3\n                    if (!response.message.hasHeader(\"min-expires\")) {\n                        // This response MUST contain a Min-Expires header field\n                        this.logger.error(\"423 response received for REGISTER without Min-Expires, dropping response\");\n                        this.unregistered();\n                        this.waitingToggle(false);\n                        return;\n                    }\n                    // Increase our registration interval to the suggested minimum\n                    this.expires = Number(response.message.getHeader(\"min-expires\"));\n                    // Attempt the registration again immediately\n                    this.waitingToggle(false);\n                    this.register();\n                    return;\n                }\n                this.logger.warn(`Failed to register, status code ${response.message.statusCode}`);\n                // The Retry-After header field can be used with a 500 (Server Internal\n                // Error) or 503 (Service Unavailable) response to indicate how long the\n                // service is expected to be unavailable to the requesting client...\n                // https://tools.ietf.org/html/rfc3261#section-20.33\n                let retryAfterDuration = NaN;\n                if (response.message.statusCode === 500 || response.message.statusCode === 503) {\n                    const header = response.message.getHeader(\"retry-after\");\n                    if (header) {\n                        retryAfterDuration = Number.parseInt(header, undefined);\n                    }\n                }\n                // Set for the state change (if any) and the delegate callback (if any)\n                this._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(response);\n                }\n                this._retryAfter = undefined;\n                this.waitingToggle(false);\n            },\n            onTrying: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(response);\n                }\n            }\n        });\n        return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Sends the REGISTER request with expires equal to zero.\n     * @remarks\n     * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n     */\n    unregister(options = {}) {\n        if (this.state === RegistererState.Terminated) {\n            this.stateError();\n            throw new Error(\"Registerer terminated. Unable to register.\");\n        }\n        if (this.disposed) {\n            if (this.state !== RegistererState.Registered) {\n                // allows unregister while disposing and registered\n                this.stateError();\n                throw new Error(\"Registerer disposed. Unable to register.\");\n            }\n        }\n        // UAs MUST NOT send a new registration (that is, containing new Contact\n        // header field values, as opposed to a retransmission) until they have\n        // received a final response from the registrar for the previous one or\n        // the previous REGISTER request has timed out.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        if (this.waiting) {\n            this.waitingWarning();\n            const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n            return Promise.reject(error);\n        }\n        if (this._state !== RegistererState.Registered && !options.all) {\n            this.logger.warn(\"Not currently registered, but sending an unregister anyway.\");\n        }\n        // Extra headers\n        const extraHeaders = ((options.requestOptions && options.requestOptions.extraHeaders) || []).slice();\n        this.request.extraHeaders = extraHeaders;\n        // Registrations are soft state and expire unless refreshed, but can\n        // also be explicitly removed.  A client can attempt to influence the\n        // expiration interval selected by the registrar as described in Section\n        // 10.2.1.  A UA requests the immediate removal of a binding by\n        // specifying an expiration interval of \"0\" for that contact address in\n        // a REGISTER request.  UAs SHOULD support this mechanism so that\n        // bindings can be removed before their expiration interval has passed.\n        //\n        // The REGISTER-specific Contact header field value of \"*\" applies to\n        // all registrations, but it MUST NOT be used unless the Expires header\n        // field is present with a value of \"0\".\n        // https://tools.ietf.org/html/rfc3261#section-10.2.2\n        if (options.all) {\n            extraHeaders.push(\"Contact: *\");\n            extraHeaders.push(\"Expires: 0\");\n        }\n        else {\n            extraHeaders.push(\"Contact: \" + this.generateContactHeader(0));\n        }\n        // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n        // header field value for registrations sent to a particular\n        // registrar.\n        //\n        // CSeq: The CSeq value guarantees proper ordering of REGISTER\n        // requests.  A UA MUST increment the CSeq value by one for each\n        // REGISTER request with the same Call-ID.\n        // https://tools.ietf.org/html/rfc3261#section-10.2\n        this.request.cseq++;\n        this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n        // Pre-emptive clear the registration timer to avoid a race condition where\n        // this timer fires while waiting for a final response to the unsubscribe.\n        if (this.registrationTimer !== undefined) {\n            clearTimeout(this.registrationTimer);\n            this.registrationTimer = undefined;\n        }\n        this.waitingToggle(true);\n        const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n            onAccept: (response) => {\n                this._contacts = response.message.getHeaders(\"contact\"); // Update contacts\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onAccept) {\n                    options.requestDelegate.onAccept(response);\n                }\n                this.waitingToggle(false);\n            },\n            onProgress: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onProgress) {\n                    options.requestDelegate.onProgress(response);\n                }\n            },\n            onRedirect: (response) => {\n                this.logger.error(\"Unregister redirected. Not currently supported.\");\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(response);\n                }\n                this.waitingToggle(false);\n            },\n            onReject: (response) => {\n                this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);\n                this.unregistered();\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(response);\n                }\n                this.waitingToggle(false);\n            },\n            onTrying: (response) => {\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(response);\n                }\n            }\n        });\n        return Promise.resolve(outgoingRegisterRequest);\n    }\n    /**\n     * Clear registration timers.\n     */\n    clearTimers() {\n        if (this.registrationTimer !== undefined) {\n            clearTimeout(this.registrationTimer);\n            this.registrationTimer = undefined;\n        }\n        if (this.registrationExpiredTimer !== undefined) {\n            clearTimeout(this.registrationExpiredTimer);\n            this.registrationExpiredTimer = undefined;\n        }\n    }\n    /**\n     * Generate Contact Header\n     */\n    generateContactHeader(expires) {\n        let contact = this.userAgent.contact.toString();\n        if (this.options.regId && this.options.instanceId) {\n            contact += \";reg-id=\" + this.options.regId;\n            contact += ';+sip.instance=\"<urn:uuid:' + this.options.instanceId + '>\"';\n        }\n        if (this.options.extraContactHeaderParams) {\n            this.options.extraContactHeaderParams.forEach((header) => {\n                contact += \";\" + header;\n            });\n        }\n        contact += \";expires=\" + expires;\n        return contact;\n    }\n    /**\n     * Helper function, called when registered.\n     */\n    registered(expires) {\n        this.clearTimers();\n        // Re-Register before the expiration interval has elapsed.\n        // For that, decrease the expires value. ie: 3 seconds\n        this.registrationTimer = setTimeout(() => {\n            this.registrationTimer = undefined;\n            this.register();\n        }, expires * 1000 - 3000);\n        // We are unregistered if the registration expires.\n        this.registrationExpiredTimer = setTimeout(() => {\n            this.logger.warn(\"Registration expired\");\n            this.unregistered();\n        }, expires * 1000);\n        if (this._state !== RegistererState.Registered) {\n            this.stateTransition(RegistererState.Registered);\n        }\n    }\n    /**\n     * Helper function, called when unregistered.\n     */\n    unregistered() {\n        this.clearTimers();\n        if (this._state !== RegistererState.Unregistered) {\n            this.stateTransition(RegistererState.Unregistered);\n        }\n    }\n    /**\n     * Helper function, called when terminated.\n     */\n    terminated() {\n        this.clearTimers();\n        if (this._state !== RegistererState.Terminated) {\n            this.stateTransition(RegistererState.Terminated);\n        }\n    }\n    /**\n     * Transition registration state.\n     */\n    stateTransition(newState) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate transition\n        switch (this._state) {\n            case RegistererState.Initial:\n                if (newState !== RegistererState.Registered &&\n                    newState !== RegistererState.Unregistered &&\n                    newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Registered:\n                if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Unregistered:\n                if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case RegistererState.Terminated:\n                invalidTransition();\n                break;\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n        // Transition\n        this._state = newState;\n        this.logger.log(`Registration transitioned to state ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        // Dispose\n        if (newState === RegistererState.Terminated) {\n            this.dispose();\n        }\n    }\n    /** True if the registerer is currently waiting for final response to a REGISTER request. */\n    get waiting() {\n        return this._waiting;\n    }\n    /** Emits when the registerer waiting state changes. */\n    get waitingChange() {\n        return this._waitingEventEmitter;\n    }\n    /**\n     * Toggle waiting.\n     */\n    waitingToggle(waiting) {\n        if (this._waiting === waiting) {\n            throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting}`);\n        }\n        this._waiting = waiting;\n        this.logger.log(`Waiting toggled to ${this._waiting}`);\n        this._waitingEventEmitter.emit(this._waiting);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n    waitingWarning() {\n        let message = \"An attempt was made to send a REGISTER request while a prior one was still in progress.\";\n        message += \" RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response\";\n        message += \" from the registrar for the previous one or the previous REGISTER request has timed out.\";\n        message += \" Note that if the transport disconnects, you still must wait for the prior request to time out before\";\n        message +=\n            \" sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.\";\n        this.logger.warn(message);\n    }\n    /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n    stateError() {\n        const reason = this.state === RegistererState.Terminated ? \"is in 'Terminated' state\" : \"has been disposed\";\n        let message = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;\n        message += \" The Registerer transitions to 'Terminated' when Registerer.dispose() is called.\";\n        message += \" Perhaps you called UserAgent.stop() which dipsoses of all Registerers?\";\n        this.logger.error(message);\n    }\n}\nRegisterer.defaultExpires = 600;\n"]},"metadata":{},"sourceType":"module"}