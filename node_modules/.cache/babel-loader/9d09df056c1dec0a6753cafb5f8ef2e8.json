{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { C, constructOutgoingResponse, OutgoingRequestMessage } from \"../messages\";\nimport { InviteServerTransaction, NonInviteClientTransaction, TransactionState } from \"../transactions\";\nimport { InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentServer, PublishUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient } from \"../user-agents\";\nimport { AllowedMethods } from \"./allowed-methods\";\n/**\n * This is ported from UA.C.ACCEPTED_BODY_TYPES.\n * FIXME: TODO: Should be configurable/variable.\n */\n\nvar acceptedBodyTypes = [\"application/sdp\", \"application/dtmf-relay\"];\n/**\n * User Agent Core.\n * @remarks\n * Core designates the functions specific to a particular type\n * of SIP entity, i.e., specific to either a stateful or stateless\n * proxy, a user agent or registrar.  All cores, except those for\n * the stateless proxy, are transaction users.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAC Core: The set of processing functions required of a UAC that\n * reside above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAS Core: The set of processing functions required at a UAS that\n * resides above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport var UserAgentCore = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   * @param configuration - Configuration.\n   * @param delegate - Delegate.\n   */\n  function UserAgentCore(configuration) {\n    var delegate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, UserAgentCore);\n\n    /** UACs. */\n    this.userAgentClients = new Map();\n    /** UASs. */\n\n    this.userAgentServers = new Map();\n    this.configuration = configuration;\n    this.delegate = delegate;\n    this.dialogs = new Map();\n    this.subscribers = new Map();\n    this.logger = configuration.loggerFactory.getLogger(\"sip.user-agent-core\");\n  }\n  /** Destructor. */\n\n\n  _createClass(UserAgentCore, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.reset();\n    }\n    /** Reset. */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.dialogs.forEach(function (dialog) {\n        return dialog.dispose();\n      });\n      this.dialogs.clear();\n      this.subscribers.forEach(function (subscriber) {\n        return subscriber.dispose();\n      });\n      this.subscribers.clear();\n      this.userAgentClients.forEach(function (uac) {\n        return uac.dispose();\n      });\n      this.userAgentClients.clear();\n      this.userAgentServers.forEach(function (uac) {\n        return uac.dispose();\n      });\n      this.userAgentServers.clear();\n    }\n    /** Logger factory. */\n\n  }, {\n    key: \"invite\",\n\n    /**\n     * Send INVITE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    value: function invite(request, delegate) {\n      return new InviteUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send MESSAGE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n\n  }, {\n    key: \"message\",\n    value: function message(request, delegate) {\n      return new MessageUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send PUBLISH.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(request, delegate) {\n      return new PublishUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send REGISTER.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(request, delegate) {\n      return new RegisterUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send SUBSCRIBE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(request, delegate) {\n      return new SubscribeUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send a request.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n\n  }, {\n    key: \"request\",\n    value: function request(_request, delegate) {\n      return new UserAgentClient(NonInviteClientTransaction, this, _request, delegate);\n    }\n    /**\n     * Outgoing request message factory function.\n     * @param method - Method.\n     * @param requestURI - Request-URI.\n     * @param fromURI - From URI.\n     * @param toURI - To URI.\n     * @param options - Request options.\n     * @param extraHeaders - Extra headers to add.\n     * @param body - Message body.\n     */\n\n  }, {\n    key: \"makeOutgoingRequestMessage\",\n    value: function makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {\n      // default values from user agent configuration\n      var callIdPrefix = this.configuration.sipjsId;\n      var fromDisplayName = this.configuration.displayName;\n      var forceRport = this.configuration.viaForceRport;\n      var hackViaTcp = this.configuration.hackViaTcp;\n      var optionTags = this.configuration.supportedOptionTags.slice();\n\n      if (method === C.REGISTER) {\n        optionTags.push(\"path\", \"gruu\");\n      }\n\n      if (method === C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {\n        optionTags.push(\"gruu\");\n      }\n\n      var routeSet = this.configuration.routeSet;\n      var userAgentString = this.configuration.userAgentHeaderFieldValue;\n      var viaHost = this.configuration.viaHost;\n      var defaultOptions = {\n        callIdPrefix: callIdPrefix,\n        forceRport: forceRport,\n        fromDisplayName: fromDisplayName,\n        hackViaTcp: hackViaTcp,\n        optionTags: optionTags,\n        routeSet: routeSet,\n        userAgentString: userAgentString,\n        viaHost: viaHost\n      }; // merge provided options with default options\n\n      var requestOptions = Object.assign(Object.assign({}, defaultOptions), options);\n      return new OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);\n    }\n    /**\n     * Handle an incoming request message from the transport.\n     * @param message - Incoming request message from transport layer.\n     */\n\n  }, {\n    key: \"receiveIncomingRequestFromTransport\",\n    value: function receiveIncomingRequestFromTransport(message) {\n      this.receiveRequestFromTransport(message);\n    }\n    /**\n     * Handle an incoming response message from the transport.\n     * @param message - Incoming response message from transport layer.\n     */\n\n  }, {\n    key: \"receiveIncomingResponseFromTransport\",\n    value: function receiveIncomingResponseFromTransport(message) {\n      this.receiveResponseFromTransport(message);\n    }\n    /**\n     * A stateless UAS is a UAS that does not maintain transaction state.\n     * It replies to requests normally, but discards any state that would\n     * ordinarily be retained by a UAS after a response has been sent.  If a\n     * stateless UAS receives a retransmission of a request, it regenerates\n     * the response and re-sends it, just as if it were replying to the first\n     * instance of the request. A UAS cannot be stateless unless the request\n     * processing for that method would always result in the same response\n     * if the requests are identical. This rules out stateless registrars,\n     * for example.  Stateless UASs do not use a transaction layer; they\n     * receive requests directly from the transport layer and send responses\n     * directly to the transport layer.\n     * https://tools.ietf.org/html/rfc3261#section-8.2.7\n     * @param message - Incoming request message to reply to.\n     * @param statusCode - Status code to reply with.\n     */\n\n  }, {\n    key: \"replyStateless\",\n    value: function replyStateless(message, options) {\n      var _this = this;\n\n      var userAgent = this.configuration.userAgentHeaderFieldValue;\n      var supported = this.configuration.supportedOptionTagsResponse;\n      options = Object.assign(Object.assign({}, options), {\n        userAgent: userAgent,\n        supported: supported\n      });\n      var response = constructOutgoingResponse(message, options);\n      this.transport.send(response.message).catch(function (error) {\n        // If the transport rejects, it SHOULD reject with a TransportError.\n        // But the transport may be external code, so we are careful...\n        if (error instanceof Error) {\n          _this.logger.error(error.message);\n        }\n\n        _this.logger.error(\"Transport error occurred sending stateless reply to \".concat(message.method, \" request.\")); // TODO: Currently there is no hook to provide notification that a transport error occurred\n        // and throwing would result in an uncaught error (in promise), so we silently eat the error.\n        // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.\n\n      });\n      return response;\n    }\n    /**\n     * In Section 18.2.1, replace the last paragraph with:\n     *\n     * Next, the server transport attempts to match the request to a\n     * server transaction.  It does so using the matching rules described\n     * in Section 17.2.3.  If a matching server transaction is found, the\n     * request is passed to that transaction for processing.  If no match\n     * is found, the request is passed to the core, which may decide to\n     * construct a new server transaction for that request.\n     * https://tools.ietf.org/html/rfc6026#section-8.10\n     * @param message - Incoming request message from transport layer.\n     */\n\n  }, {\n    key: \"receiveRequestFromTransport\",\n    value: function receiveRequestFromTransport(message) {\n      // When a request is received from the network by the server, it has to\n      // be matched to an existing transaction.  This is accomplished in the\n      // following manner.\n      //\n      // The branch parameter in the topmost Via header field of the request\n      // is examined.  If it is present and begins with the magic cookie\n      // \"z9hG4bK\", the request was generated by a client transaction\n      // compliant to this specification.  Therefore, the branch parameter\n      // will be unique across all transactions sent by that client.  The\n      // request matches a transaction if:\n      //\n      //    1. the branch parameter in the request is equal to the one in the\n      //       top Via header field of the request that created the\n      //       transaction, and\n      //\n      //    2. the sent-by value in the top Via of the request is equal to the\n      //       one in the request that created the transaction, and\n      //\n      //    3. the method of the request matches the one that created the\n      //       transaction, except for ACK, where the method of the request\n      //       that created the transaction is INVITE.\n      //\n      // This matching rule applies to both INVITE and non-INVITE transactions\n      // alike.\n      //\n      //    The sent-by value is used as part of the matching process because\n      //    there could be accidental or malicious duplication of branch\n      //    parameters from different clients.\n      // https://tools.ietf.org/html/rfc3261#section-17.2.3\n      var transactionId = message.viaBranch; // FIXME: Currently only using rule 1...\n\n      var uas = this.userAgentServers.get(transactionId); // When receiving an ACK that matches an existing INVITE server\n      // transaction and that does not contain a branch parameter containing\n      // the magic cookie defined in RFC 3261, the matching transaction MUST\n      // be checked to see if it is in the \"Accepted\" state.  If it is, then\n      // the ACK must be passed directly to the transaction user instead of\n      // being absorbed by the transaction state machine.  This is necessary\n      // as requests from RFC 2543 clients will not include a unique branch\n      // parameter, and the mechanisms for calculating the transaction ID from\n      // such a request will be the same for both INVITE and ACKs.\n      // https://tools.ietf.org/html/rfc6026#section-6\n      // Any ACKs received from the network while in the \"Accepted\" state MUST be\n      // passed directly to the TU and not absorbed.\n      // https://tools.ietf.org/html/rfc6026#section-7.1\n\n      if (message.method === C.ACK) {\n        if (uas && uas.transaction.state === TransactionState.Accepted) {\n          if (uas instanceof InviteUserAgentServer) {\n            // These are ACKs matching an INVITE server transaction.\n            // These should never happen with RFC 3261 compliant user agents\n            // (would be a broken ACK to negative final response or something)\n            // but is apparently how RFC 2543 user agents do things.\n            // We are not currently supporting this case.\n            // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n            this.logger.warn(\"Discarding out of dialog ACK after 2xx response sent on transaction \".concat(transactionId, \".\"));\n            return;\n          }\n        }\n      } // The CANCEL method requests that the TU at the server side cancel a\n      // pending transaction.  The TU determines the transaction to be\n      // cancelled by taking the CANCEL request, and then assuming that the\n      // request method is anything but CANCEL or ACK and applying the\n      // transaction matching procedures of Section 17.2.3.  The matching\n      // transaction is the one to be cancelled.\n      // https://tools.ietf.org/html/rfc3261#section-9.2\n\n\n      if (message.method === C.CANCEL) {\n        if (uas) {\n          // Regardless of the method of the original request, as long as the\n          // CANCEL matched an existing transaction, the UAS answers the CANCEL\n          // request itself with a 200 (OK) response.\n          // https://tools.ietf.org/html/rfc3261#section-9.2\n          this.replyStateless(message, {\n            statusCode: 200\n          }); // If the transaction for the original request still exists, the behavior\n          // of the UAS on receiving a CANCEL request depends on whether it has already\n          // sent a final response for the original request. If it has, the CANCEL\n          // request has no effect on the processing of the original request, no\n          // effect on any session state, and no effect on the responses generated\n          // for the original request. If the UAS has not issued a final response\n          // for the original request, its behavior depends on the method of the\n          // original request. If the original request was an INVITE, the UAS\n          // SHOULD immediately respond to the INVITE with a 487 (Request\n          // Terminated).\n          // https://tools.ietf.org/html/rfc3261#section-9.2\n\n          if (uas.transaction instanceof InviteServerTransaction && uas.transaction.state === TransactionState.Proceeding) {\n            if (uas instanceof InviteUserAgentServer) {\n              uas.receiveCancel(message);\n            } // A CANCEL request has no impact on the processing of\n            // transactions with any other method defined in this specification.\n            // https://tools.ietf.org/html/rfc3261#section-9.2\n\n          }\n        } else {\n          // If the UAS did not find a matching transaction for the CANCEL\n          // according to the procedure above, it SHOULD respond to the CANCEL\n          // with a 481 (Call Leg/Transaction Does Not Exist).\n          // https://tools.ietf.org/html/rfc3261#section-9.2\n          this.replyStateless(message, {\n            statusCode: 481\n          });\n        }\n\n        return;\n      } // If a matching server transaction is found, the request is passed to that\n      // transaction for processing.\n      // https://tools.ietf.org/html/rfc6026#section-8.10\n\n\n      if (uas) {\n        uas.transaction.receiveRequest(message);\n        return;\n      } // If no match is found, the request is passed to the core, which may decide to\n      // construct a new server transaction for that request.\n      // https://tools.ietf.org/html/rfc6026#section-8.10\n\n\n      this.receiveRequest(message);\n      return;\n    }\n    /**\n     * UAC and UAS procedures depend strongly on two factors.  First, based\n     * on whether the request or response is inside or outside of a dialog,\n     * and second, based on the method of a request.  Dialogs are discussed\n     * thoroughly in Section 12; they represent a peer-to-peer relationship\n     * between user agents and are established by specific SIP methods, such\n     * as INVITE.\n     * @param message - Incoming request message.\n     */\n\n  }, {\n    key: \"receiveRequest\",\n    value: function receiveRequest(message) {\n      // 8.2 UAS Behavior\n      // UASs SHOULD process the requests in the order of the steps that\n      // follow in this section (that is, starting with authentication, then\n      // inspecting the method, the header fields, and so on throughout the\n      // remainder of this section).\n      // https://tools.ietf.org/html/rfc3261#section-8.2\n      // 8.2.1 Method Inspection\n      // Once a request is authenticated (or authentication is skipped), the\n      // UAS MUST inspect the method of the request.  If the UAS recognizes\n      // but does not support the method of a request, it MUST generate a 405\n      // (Method Not Allowed) response.  Procedures for generating responses\n      // are described in Section 8.2.6.  The UAS MUST also add an Allow\n      // header field to the 405 (Method Not Allowed) response.  The Allow\n      // header field MUST list the set of methods supported by the UAS\n      // generating the message.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.1\n      if (!AllowedMethods.includes(message.method)) {\n        var allowHeader = \"Allow: \" + AllowedMethods.toString();\n        this.replyStateless(message, {\n          statusCode: 405,\n          extraHeaders: [allowHeader]\n        });\n        return;\n      } // 8.2.2 Header Inspection\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2\n\n\n      if (!message.ruri) {\n        // FIXME: A request message should always have an ruri\n        throw new Error(\"Request-URI undefined.\");\n      } // 8.2.2.1 To and Request-URI\n      // If the Request-URI uses a scheme not supported by the UAS, it SHOULD\n      // reject the request with a 416 (Unsupported URI Scheme) response.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n      if (message.ruri.scheme !== \"sip\") {\n        this.replyStateless(message, {\n          statusCode: 416\n        });\n        return;\n      } // 8.2.2.1 To and Request-URI\n      // If the Request-URI does not identify an address that the\n      // UAS is willing to accept requests for, it SHOULD reject\n      // the request with a 404 (Not Found) response.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n      var ruri = message.ruri;\n\n      var ruriMatches = function ruriMatches(uri) {\n        return !!uri && uri.user === ruri.user;\n      };\n\n      if (!ruriMatches(this.configuration.aor) && !(ruriMatches(this.configuration.contact.uri) || ruriMatches(this.configuration.contact.pubGruu) || ruriMatches(this.configuration.contact.tempGruu))) {\n        this.logger.warn(\"Request-URI does not point to us.\");\n\n        if (message.method !== C.ACK) {\n          this.replyStateless(message, {\n            statusCode: 404\n          });\n        }\n\n        return;\n      } // 8.2.2.1 To and Request-URI\n      // Other potential sources of received Request-URIs include\n      // the Contact header fields of requests and responses sent by the UA\n      // that establish or refresh dialogs.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n\n\n      if (message.method === C.INVITE) {\n        if (!message.hasHeader(\"Contact\")) {\n          this.replyStateless(message, {\n            statusCode: 400,\n            reasonPhrase: \"Missing Contact Header\"\n          });\n          return;\n        }\n      } // 8.2.2.2 Merged Requests\n      // If the request has no tag in the To header field, the UAS core MUST\n      // check the request against ongoing transactions.  If the From tag,\n      // Call-ID, and CSeq exactly match those associated with an ongoing\n      // transaction, but the request does not match that transaction (based\n      // on the matching rules in Section 17.2.3), the UAS core SHOULD\n      // generate a 482 (Loop Detected) response and pass it to the server\n      // transaction.\n      //\n      //    The same request has arrived at the UAS more than once, following\n      //    different paths, most likely due to forking.  The UAS processes\n      //    the first such request received and responds with a 482 (Loop\n      //    Detected) to the rest of them.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2.2\n\n\n      if (!message.toTag) {\n        var transactionId = message.viaBranch;\n\n        if (!this.userAgentServers.has(transactionId)) {\n          var mergedRequest = Array.from(this.userAgentServers.values()).some(function (uas) {\n            return uas.transaction.request.fromTag === message.fromTag && uas.transaction.request.callId === message.callId && uas.transaction.request.cseq === message.cseq;\n          });\n\n          if (mergedRequest) {\n            this.replyStateless(message, {\n              statusCode: 482\n            });\n            return;\n          }\n        }\n      } // 8.2.2.3 Require\n      // https://tools.ietf.org/html/rfc3261#section-8.2.2.3\n      // TODO\n      // 8.2.3 Content Processing\n      // https://tools.ietf.org/html/rfc3261#section-8.2.3\n      // TODO\n      // 8.2.4 Applying Extensions\n      // https://tools.ietf.org/html/rfc3261#section-8.2.4\n      // TODO\n      // 8.2.5 Processing the Request\n      // Assuming all of the checks in the previous subsections are passed,\n      // the UAS processing becomes method-specific.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.5\n      // The UAS will receive the request from the transaction layer.  If the\n      // request has a tag in the To header field, the UAS core computes the\n      // dialog identifier corresponding to the request and compares it with\n      // existing dialogs.  If there is a match, this is a mid-dialog request.\n      // In that case, the UAS first applies the same processing rules for\n      // requests outside of a dialog, discussed in Section 8.2.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      if (message.toTag) {\n        this.receiveInsideDialogRequest(message);\n      } else {\n        this.receiveOutsideDialogRequest(message);\n      }\n\n      return;\n    }\n    /**\n     * Once a dialog has been established between two UAs, either of them\n     * MAY initiate new transactions as needed within the dialog.  The UA\n     * sending the request will take the UAC role for the transaction.  The\n     * UA receiving the request will take the UAS role.  Note that these may\n     * be different roles than the UAs held during the transaction that\n     * established the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2\n     * @param message - Incoming request message.\n     */\n\n  }, {\n    key: \"receiveInsideDialogRequest\",\n    value: function receiveInsideDialogRequest(message) {\n      // NOTIFY requests are matched to such SUBSCRIBE requests if they\n      // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n      // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n      // request, and the same \"Event\" header field.  Rules for comparisons of\n      // the \"Event\" header fields are described in Section 8.2.1.\n      // https://tools.ietf.org/html/rfc6665#section-4.4.1\n      if (message.method === C.NOTIFY) {\n        var event = message.parseHeader(\"Event\");\n\n        if (!event || !event.event) {\n          this.replyStateless(message, {\n            statusCode: 489\n          });\n          return;\n        } // FIXME: Subscriber id should also matching on event id.\n\n\n        var subscriberId = message.callId + message.toTag + event.event;\n        var subscriber = this.subscribers.get(subscriberId);\n\n        if (subscriber) {\n          var uas = new NotifyUserAgentServer(this, message);\n          subscriber.onNotify(uas);\n          return;\n        }\n      } // Requests sent within a dialog, as any other requests, are atomic.  If\n      // a particular request is accepted by the UAS, all the state changes\n      // associated with it are performed.  If the request is rejected, none\n      // of the state changes are performed.\n      //\n      //    Note that some requests, such as INVITEs, affect several pieces of\n      //    state.\n      //\n      // The UAS will receive the request from the transaction layer.  If the\n      // request has a tag in the To header field, the UAS core computes the\n      // dialog identifier corresponding to the request and compares it with\n      // existing dialogs.  If there is a match, this is a mid-dialog request.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      var dialogId = message.callId + message.toTag + message.fromTag;\n      var dialog = this.dialogs.get(dialogId);\n\n      if (dialog) {\n        // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS\n        // You got the question right.\n        //\n        // And you got the right answer too. :-)\n        //\n        //   Thanks,\n        //   Paul\n        //\n        // Robert Sparks wrote:\n        // > So I've lost track of the question during the musing.\n        // >\n        // > I _think_ the fundamental question being asked is this:\n        // >\n        // > Is an endpoint required to reject (with a 481) an OPTIONS request that\n        // > arrives with at to-tag but does not match any existing dialog state.\n        // > (Assuming some earlier requirement hasn't forced another error code). Or\n        // > is it OK if it just sends\n        // > a 200 OK anyhow.\n        // >\n        // > My take on the collection of specs is that its _not_ ok for it to send\n        // > the 200 OK anyhow and that it is required to send\n        // > the 481. I base this primarily on these sentences from 11.2 in 3261:\n        // >\n        // >    The response to an OPTIONS is constructed using the standard rules\n        // >    for a SIP response as discussed in Section 8.2.6.  The response code\n        // >    chosen MUST be the same that would have been chosen had the request\n        // >    been an INVITE.\n        // >\n        // > Did I miss the point of the question?\n        // >\n        // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:\n        // >\n        // >> [Including Robert in hopes of getting his insight on this.]\n        // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html\n        //\n        // Requests that do not change in any way the state of a dialog may be\n        // received within a dialog (for example, an OPTIONS request).  They are\n        // processed as if they had been received outside the dialog.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (message.method === C.OPTIONS) {\n          var allowHeader = \"Allow: \" + AllowedMethods.toString();\n          var acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n          this.replyStateless(message, {\n            statusCode: 200,\n            extraHeaders: [allowHeader, acceptHeader]\n          });\n          return;\n        } // Pass the incoming request to the dialog for further handling.\n\n\n        dialog.receiveRequest(message);\n        return;\n      } // The most important behaviors of a stateless UAS are the following:\n      // ...\n      // o  A stateless UAS MUST ignore ACK requests.\n      // ...\n      // https://tools.ietf.org/html/rfc3261#section-8.2.7\n\n\n      if (message.method === C.ACK) {\n        // If a final response to an INVITE was sent statelessly,\n        // the corresponding ACK:\n        // - will not match an existing transaction\n        // - may have tag in the To header field\n        // - not not match any existing dialogs\n        // Absorb unmatched ACKs.\n        return;\n      } // If the request has a tag in the To header field, but the dialog\n      // identifier does not match any existing dialogs, the UAS may have\n      // crashed and restarted, or it may have received a request for a\n      // different (possibly failed) UAS (the UASs can construct the To tags\n      // so that a UAS can identify that the tag was for a UAS for which it is\n      // providing recovery).  Another possibility is that the incoming\n      // request has been simply mis-routed.  Based on the To tag, the UAS MAY\n      // either accept or reject the request.  Accepting the request for\n      // acceptable To tags provides robustness, so that dialogs can persist\n      // even through crashes.  UAs wishing to support this capability must\n      // take into consideration some issues such as choosing monotonically\n      // increasing CSeq sequence numbers even across reboots, reconstructing\n      // the route set, and accepting out-of-range RTP timestamps and sequence\n      // numbers.\n      //\n      // If the UAS wishes to reject the request because it does not wish to\n      // recreate the dialog, it MUST respond to the request with a 481\n      // (Call/Transaction Does Not Exist) status code and pass that to the\n      // server transaction.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      this.replyStateless(message, {\n        statusCode: 481\n      });\n      return;\n    }\n    /**\n     * Assuming all of the checks in the previous subsections are passed,\n     * the UAS processing becomes method-specific.\n     *  https://tools.ietf.org/html/rfc3261#section-8.2.5\n     * @param message - Incoming request message.\n     */\n\n  }, {\n    key: \"receiveOutsideDialogRequest\",\n    value: function receiveOutsideDialogRequest(message) {\n      switch (message.method) {\n        case C.ACK:\n          // Absorb stray out of dialog ACKs\n          break;\n\n        case C.BYE:\n          // If the BYE does not match an existing dialog, the UAS core SHOULD\n          // generate a 481 (Call/Transaction Does Not Exist) response and pass\n          // that to the server transaction. This rule means that a BYE sent\n          // without tags by a UAC will be rejected.\n          // https://tools.ietf.org/html/rfc3261#section-15.1.2\n          this.replyStateless(message, {\n            statusCode: 481\n          });\n          break;\n\n        case C.CANCEL:\n          throw new Error(\"Unexpected out of dialog request method \".concat(message.method, \".\"));\n          break;\n\n        case C.INFO:\n          // Use of the INFO method does not constitute a separate dialog usage.\n          // INFO messages are always part of, and share the fate of, an invite\n          // dialog usage [RFC5057].  INFO messages cannot be sent as part of\n          // other dialog usages, or outside an existing dialog.\n          // https://tools.ietf.org/html/rfc6086#section-1\n          this.replyStateless(message, {\n            statusCode: 405\n          }); // Should never happen\n\n          break;\n\n        case C.INVITE:\n          // https://tools.ietf.org/html/rfc3261#section-13.3.1\n          {\n            var uas = new InviteUserAgentServer(this, message);\n            this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();\n          }\n          break;\n\n        case C.MESSAGE:\n          // MESSAGE requests are discouraged inside a dialog.  Implementations\n          // are restricted from creating a usage for the purpose of carrying a\n          // sequence of MESSAGE requests (though some implementations use it that\n          // way, against the standard recommendation).\n          // https://tools.ietf.org/html/rfc5057#section-5.3\n          {\n            var _uas = new MessageUserAgentServer(this, message);\n\n            this.delegate.onMessage ? this.delegate.onMessage(_uas) : _uas.accept();\n          }\n          break;\n\n        case C.NOTIFY:\n          // Obsoleted by: RFC 6665\n          // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,\n          // it is the responsibility of the parties defining those mechanisms to\n          // ensure that correlation of a NOTIFY message to the corresponding\n          // subscription is possible.  Designers of such mechanisms are also\n          // warned to make a distinction between sending a NOTIFY message to a\n          // subscriber who is aware of the subscription, and sending a NOTIFY\n          // message to an unsuspecting node.  The latter behavior is invalid, and\n          // MUST receive a \"481 Subscription does not exist\" response (unless\n          // some other 400- or 500-class error code is more applicable), as\n          // described in section 3.2.4.  In other words, knowledge of a\n          // subscription must exist in both the subscriber and the notifier to be\n          // valid, even if installed via a non-SUBSCRIBE mechanism.\n          // https://tools.ietf.org/html/rfc3265#section-3.2\n          //\n          // NOTIFY requests are sent to inform subscribers of changes in state to\n          // which the subscriber has a subscription.  Subscriptions are created\n          // using the SUBSCRIBE method.  In legacy implementations, it is\n          // possible that other means of subscription creation have been used.\n          // However, this specification does not allow the creation of\n          // subscriptions except through SUBSCRIBE requests and (for backwards-\n          // compatibility) REFER requests [RFC3515].\n          // https://tools.ietf.org/html/rfc6665#section-3.2\n          {\n            var _uas2 = new NotifyUserAgentServer(this, message);\n\n            this.delegate.onNotify ? this.delegate.onNotify(_uas2) : _uas2.reject({\n              statusCode: 405\n            });\n          }\n          break;\n\n        case C.OPTIONS:\n          // https://tools.ietf.org/html/rfc3261#section-11.2\n          {\n            var allowHeader = \"Allow: \" + AllowedMethods.toString();\n            var acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n            this.replyStateless(message, {\n              statusCode: 200,\n              extraHeaders: [allowHeader, acceptHeader]\n            });\n          }\n          break;\n\n        case C.REFER:\n          // https://tools.ietf.org/html/rfc3515#section-2.4.2\n          {\n            var _uas3 = new ReferUserAgentServer(this, message);\n\n            this.delegate.onRefer ? this.delegate.onRefer(_uas3) : _uas3.reject({\n              statusCode: 405\n            });\n          }\n          break;\n\n        case C.REGISTER:\n          // https://tools.ietf.org/html/rfc3261#section-10.3\n          {\n            var _uas4 = new RegisterUserAgentServer(this, message);\n\n            this.delegate.onRegister ? this.delegate.onRegister(_uas4) : _uas4.reject({\n              statusCode: 405\n            });\n          }\n          break;\n\n        case C.SUBSCRIBE:\n          // https://tools.ietf.org/html/rfc6665#section-4.2\n          {\n            var _uas5 = new SubscribeUserAgentServer(this, message);\n\n            this.delegate.onSubscribe ? this.delegate.onSubscribe(_uas5) : _uas5.reject({\n              statusCode: 480\n            });\n          }\n          break;\n\n        default:\n          throw new Error(\"Unexpected out of dialog request method \".concat(message.method, \".\"));\n      }\n\n      return;\n    }\n    /**\n     * Responses are first processed by the transport layer and then passed\n     * up to the transaction layer.  The transaction layer performs its\n     * processing and then passes the response up to the TU.  The majority\n     * of response processing in the TU is method specific.  However, there\n     * are some general behaviors independent of the method.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3\n     * @param message - Incoming response message from transport layer.\n     */\n\n  }, {\n    key: \"receiveResponseFromTransport\",\n    value: function receiveResponseFromTransport(message) {\n      // 8.1.3.1 Transaction Layer Errors\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n      // Handled by transaction layer callbacks.\n      // 8.1.3.2 Unrecognized Responses\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n      // TODO\n      // 8.1.3.3 Vias\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.3\n      if (message.getHeaders(\"via\").length > 1) {\n        this.logger.warn(\"More than one Via header field present in the response, dropping\");\n        return;\n      } // 8.1.3.4 Processing 3xx Responses\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.4\n      // TODO\n      // 8.1.3.5 Processing 4xx Responses\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n      // TODO\n      // When the transport layer in the client receives a response, it has to\n      // determine which client transaction will handle the response, so that\n      // the processing of Sections 17.1.1 and 17.1.2 can take place.  The\n      // branch parameter in the top Via header field is used for this\n      // purpose.  A response matches a client transaction under two\n      // conditions:\n      //\n      //    1.  If the response has the same value of the branch parameter in\n      //        the top Via header field as the branch parameter in the top\n      //        Via header field of the request that created the transaction.\n      //\n      //    2.  If the method parameter in the CSeq header field matches the\n      //        method of the request that created the transaction.  The\n      //        method is needed since a CANCEL request constitutes a\n      //        different transaction, but shares the same value of the branch\n      //        parameter.\n      // https://tools.ietf.org/html/rfc3261#section-17.1.3\n\n\n      var userAgentClientId = message.viaBranch + message.method;\n      var userAgentClient = this.userAgentClients.get(userAgentClientId); // The client transport uses the matching procedures of Section\n      // 17.1.3 to attempt to match the response to an existing\n      // transaction.  If there is a match, the response MUST be passed to\n      // that transaction.  Otherwise, any element other than a stateless\n      // proxy MUST silently discard the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.9\n\n      if (userAgentClient) {\n        userAgentClient.transaction.receiveResponse(message);\n      } else {\n        this.logger.warn(\"Discarding unmatched \".concat(message.statusCode, \" response to \").concat(message.method, \" \").concat(userAgentClientId, \".\"));\n      }\n    }\n  }, {\n    key: \"loggerFactory\",\n    get: function get() {\n      return this.configuration.loggerFactory;\n    }\n    /** Transport. */\n\n  }, {\n    key: \"transport\",\n    get: function get() {\n      var transport = this.configuration.transportAccessor();\n\n      if (!transport) {\n        throw new Error(\"Transport undefined.\");\n      }\n\n      return transport;\n    }\n  }]);\n\n  return UserAgentCore;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agent-core/user-agent-core.js"],"names":["C","constructOutgoingResponse","OutgoingRequestMessage","InviteServerTransaction","NonInviteClientTransaction","TransactionState","InviteUserAgentClient","InviteUserAgentServer","MessageUserAgentClient","MessageUserAgentServer","NotifyUserAgentServer","PublishUserAgentClient","ReferUserAgentServer","RegisterUserAgentClient","RegisterUserAgentServer","SubscribeUserAgentClient","SubscribeUserAgentServer","UserAgentClient","AllowedMethods","acceptedBodyTypes","UserAgentCore","configuration","delegate","userAgentClients","Map","userAgentServers","dialogs","subscribers","logger","loggerFactory","getLogger","reset","forEach","dialog","dispose","clear","subscriber","uac","request","method","requestURI","fromURI","toURI","options","extraHeaders","body","callIdPrefix","sipjsId","fromDisplayName","displayName","forceRport","viaForceRport","hackViaTcp","optionTags","supportedOptionTags","slice","REGISTER","push","INVITE","contact","pubGruu","tempGruu","routeSet","userAgentString","userAgentHeaderFieldValue","viaHost","defaultOptions","requestOptions","Object","assign","message","receiveRequestFromTransport","receiveResponseFromTransport","userAgent","supported","supportedOptionTagsResponse","response","transport","send","catch","error","Error","transactionId","viaBranch","uas","get","ACK","transaction","state","Accepted","warn","CANCEL","replyStateless","statusCode","Proceeding","receiveCancel","receiveRequest","includes","allowHeader","toString","ruri","scheme","ruriMatches","uri","user","aor","hasHeader","reasonPhrase","toTag","has","mergedRequest","Array","from","values","some","fromTag","callId","cseq","receiveInsideDialogRequest","receiveOutsideDialogRequest","NOTIFY","event","parseHeader","subscriberId","onNotify","dialogId","OPTIONS","acceptHeader","BYE","INFO","onInvite","reject","MESSAGE","onMessage","accept","REFER","onRefer","onRegister","SUBSCRIBE","onSubscribe","getHeaders","length","userAgentClientId","userAgentClient","receiveResponse","transportAccessor"],"mappings":"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","sourcesContent":["import { C, constructOutgoingResponse, OutgoingRequestMessage } from \"../messages\";\nimport { InviteServerTransaction, NonInviteClientTransaction, TransactionState } from \"../transactions\";\nimport { InviteUserAgentClient, InviteUserAgentServer, MessageUserAgentClient, MessageUserAgentServer, NotifyUserAgentServer, PublishUserAgentClient, ReferUserAgentServer, RegisterUserAgentClient, RegisterUserAgentServer, SubscribeUserAgentClient, SubscribeUserAgentServer, UserAgentClient } from \"../user-agents\";\nimport { AllowedMethods } from \"./allowed-methods\";\n/**\n * This is ported from UA.C.ACCEPTED_BODY_TYPES.\n * FIXME: TODO: Should be configurable/variable.\n */\nconst acceptedBodyTypes = [\"application/sdp\", \"application/dtmf-relay\"];\n/**\n * User Agent Core.\n * @remarks\n * Core designates the functions specific to a particular type\n * of SIP entity, i.e., specific to either a stateful or stateless\n * proxy, a user agent or registrar.  All cores, except those for\n * the stateless proxy, are transaction users.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAC Core: The set of processing functions required of a UAC that\n * reside above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n *\n * UAS Core: The set of processing functions required at a UAS that\n * resides above the transaction and transport layers.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\nexport class UserAgentCore {\n    /**\n     * Constructor.\n     * @param configuration - Configuration.\n     * @param delegate - Delegate.\n     */\n    constructor(configuration, delegate = {}) {\n        /** UACs. */\n        this.userAgentClients = new Map();\n        /** UASs. */\n        this.userAgentServers = new Map();\n        this.configuration = configuration;\n        this.delegate = delegate;\n        this.dialogs = new Map();\n        this.subscribers = new Map();\n        this.logger = configuration.loggerFactory.getLogger(\"sip.user-agent-core\");\n    }\n    /** Destructor. */\n    dispose() {\n        this.reset();\n    }\n    /** Reset. */\n    reset() {\n        this.dialogs.forEach((dialog) => dialog.dispose());\n        this.dialogs.clear();\n        this.subscribers.forEach((subscriber) => subscriber.dispose());\n        this.subscribers.clear();\n        this.userAgentClients.forEach((uac) => uac.dispose());\n        this.userAgentClients.clear();\n        this.userAgentServers.forEach((uac) => uac.dispose());\n        this.userAgentServers.clear();\n    }\n    /** Logger factory. */\n    get loggerFactory() {\n        return this.configuration.loggerFactory;\n    }\n    /** Transport. */\n    get transport() {\n        const transport = this.configuration.transportAccessor();\n        if (!transport) {\n            throw new Error(\"Transport undefined.\");\n        }\n        return transport;\n    }\n    /**\n     * Send INVITE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    invite(request, delegate) {\n        return new InviteUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send MESSAGE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    message(request, delegate) {\n        return new MessageUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send PUBLISH.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    publish(request, delegate) {\n        return new PublishUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send REGISTER.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    register(request, delegate) {\n        return new RegisterUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send SUBSCRIBE.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    subscribe(request, delegate) {\n        return new SubscribeUserAgentClient(this, request, delegate);\n    }\n    /**\n     * Send a request.\n     * @param request - Outgoing request.\n     * @param delegate - Request delegate.\n     */\n    request(request, delegate) {\n        return new UserAgentClient(NonInviteClientTransaction, this, request, delegate);\n    }\n    /**\n     * Outgoing request message factory function.\n     * @param method - Method.\n     * @param requestURI - Request-URI.\n     * @param fromURI - From URI.\n     * @param toURI - To URI.\n     * @param options - Request options.\n     * @param extraHeaders - Extra headers to add.\n     * @param body - Message body.\n     */\n    makeOutgoingRequestMessage(method, requestURI, fromURI, toURI, options, extraHeaders, body) {\n        // default values from user agent configuration\n        const callIdPrefix = this.configuration.sipjsId;\n        const fromDisplayName = this.configuration.displayName;\n        const forceRport = this.configuration.viaForceRport;\n        const hackViaTcp = this.configuration.hackViaTcp;\n        const optionTags = this.configuration.supportedOptionTags.slice();\n        if (method === C.REGISTER) {\n            optionTags.push(\"path\", \"gruu\");\n        }\n        if (method === C.INVITE && (this.configuration.contact.pubGruu || this.configuration.contact.tempGruu)) {\n            optionTags.push(\"gruu\");\n        }\n        const routeSet = this.configuration.routeSet;\n        const userAgentString = this.configuration.userAgentHeaderFieldValue;\n        const viaHost = this.configuration.viaHost;\n        const defaultOptions = {\n            callIdPrefix,\n            forceRport,\n            fromDisplayName,\n            hackViaTcp,\n            optionTags,\n            routeSet,\n            userAgentString,\n            viaHost\n        };\n        // merge provided options with default options\n        const requestOptions = Object.assign(Object.assign({}, defaultOptions), options);\n        return new OutgoingRequestMessage(method, requestURI, fromURI, toURI, requestOptions, extraHeaders, body);\n    }\n    /**\n     * Handle an incoming request message from the transport.\n     * @param message - Incoming request message from transport layer.\n     */\n    receiveIncomingRequestFromTransport(message) {\n        this.receiveRequestFromTransport(message);\n    }\n    /**\n     * Handle an incoming response message from the transport.\n     * @param message - Incoming response message from transport layer.\n     */\n    receiveIncomingResponseFromTransport(message) {\n        this.receiveResponseFromTransport(message);\n    }\n    /**\n     * A stateless UAS is a UAS that does not maintain transaction state.\n     * It replies to requests normally, but discards any state that would\n     * ordinarily be retained by a UAS after a response has been sent.  If a\n     * stateless UAS receives a retransmission of a request, it regenerates\n     * the response and re-sends it, just as if it were replying to the first\n     * instance of the request. A UAS cannot be stateless unless the request\n     * processing for that method would always result in the same response\n     * if the requests are identical. This rules out stateless registrars,\n     * for example.  Stateless UASs do not use a transaction layer; they\n     * receive requests directly from the transport layer and send responses\n     * directly to the transport layer.\n     * https://tools.ietf.org/html/rfc3261#section-8.2.7\n     * @param message - Incoming request message to reply to.\n     * @param statusCode - Status code to reply with.\n     */\n    replyStateless(message, options) {\n        const userAgent = this.configuration.userAgentHeaderFieldValue;\n        const supported = this.configuration.supportedOptionTagsResponse;\n        options = Object.assign(Object.assign({}, options), { userAgent, supported });\n        const response = constructOutgoingResponse(message, options);\n        this.transport.send(response.message).catch((error) => {\n            // If the transport rejects, it SHOULD reject with a TransportError.\n            // But the transport may be external code, so we are careful...\n            if (error instanceof Error) {\n                this.logger.error(error.message);\n            }\n            this.logger.error(`Transport error occurred sending stateless reply to ${message.method} request.`);\n            // TODO: Currently there is no hook to provide notification that a transport error occurred\n            // and throwing would result in an uncaught error (in promise), so we silently eat the error.\n            // Furthermore, silently eating stateless reply transport errors is arguably what we want to do here.\n        });\n        return response;\n    }\n    /**\n     * In Section 18.2.1, replace the last paragraph with:\n     *\n     * Next, the server transport attempts to match the request to a\n     * server transaction.  It does so using the matching rules described\n     * in Section 17.2.3.  If a matching server transaction is found, the\n     * request is passed to that transaction for processing.  If no match\n     * is found, the request is passed to the core, which may decide to\n     * construct a new server transaction for that request.\n     * https://tools.ietf.org/html/rfc6026#section-8.10\n     * @param message - Incoming request message from transport layer.\n     */\n    receiveRequestFromTransport(message) {\n        // When a request is received from the network by the server, it has to\n        // be matched to an existing transaction.  This is accomplished in the\n        // following manner.\n        //\n        // The branch parameter in the topmost Via header field of the request\n        // is examined.  If it is present and begins with the magic cookie\n        // \"z9hG4bK\", the request was generated by a client transaction\n        // compliant to this specification.  Therefore, the branch parameter\n        // will be unique across all transactions sent by that client.  The\n        // request matches a transaction if:\n        //\n        //    1. the branch parameter in the request is equal to the one in the\n        //       top Via header field of the request that created the\n        //       transaction, and\n        //\n        //    2. the sent-by value in the top Via of the request is equal to the\n        //       one in the request that created the transaction, and\n        //\n        //    3. the method of the request matches the one that created the\n        //       transaction, except for ACK, where the method of the request\n        //       that created the transaction is INVITE.\n        //\n        // This matching rule applies to both INVITE and non-INVITE transactions\n        // alike.\n        //\n        //    The sent-by value is used as part of the matching process because\n        //    there could be accidental or malicious duplication of branch\n        //    parameters from different clients.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.3\n        const transactionId = message.viaBranch; // FIXME: Currently only using rule 1...\n        const uas = this.userAgentServers.get(transactionId);\n        // When receiving an ACK that matches an existing INVITE server\n        // transaction and that does not contain a branch parameter containing\n        // the magic cookie defined in RFC 3261, the matching transaction MUST\n        // be checked to see if it is in the \"Accepted\" state.  If it is, then\n        // the ACK must be passed directly to the transaction user instead of\n        // being absorbed by the transaction state machine.  This is necessary\n        // as requests from RFC 2543 clients will not include a unique branch\n        // parameter, and the mechanisms for calculating the transaction ID from\n        // such a request will be the same for both INVITE and ACKs.\n        // https://tools.ietf.org/html/rfc6026#section-6\n        // Any ACKs received from the network while in the \"Accepted\" state MUST be\n        // passed directly to the TU and not absorbed.\n        // https://tools.ietf.org/html/rfc6026#section-7.1\n        if (message.method === C.ACK) {\n            if (uas && uas.transaction.state === TransactionState.Accepted) {\n                if (uas instanceof InviteUserAgentServer) {\n                    // These are ACKs matching an INVITE server transaction.\n                    // These should never happen with RFC 3261 compliant user agents\n                    // (would be a broken ACK to negative final response or something)\n                    // but is apparently how RFC 2543 user agents do things.\n                    // We are not currently supporting this case.\n                    // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n                    this.logger.warn(`Discarding out of dialog ACK after 2xx response sent on transaction ${transactionId}.`);\n                    return;\n                }\n            }\n        }\n        // The CANCEL method requests that the TU at the server side cancel a\n        // pending transaction.  The TU determines the transaction to be\n        // cancelled by taking the CANCEL request, and then assuming that the\n        // request method is anything but CANCEL or ACK and applying the\n        // transaction matching procedures of Section 17.2.3.  The matching\n        // transaction is the one to be cancelled.\n        // https://tools.ietf.org/html/rfc3261#section-9.2\n        if (message.method === C.CANCEL) {\n            if (uas) {\n                // Regardless of the method of the original request, as long as the\n                // CANCEL matched an existing transaction, the UAS answers the CANCEL\n                // request itself with a 200 (OK) response.\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                this.replyStateless(message, { statusCode: 200 });\n                // If the transaction for the original request still exists, the behavior\n                // of the UAS on receiving a CANCEL request depends on whether it has already\n                // sent a final response for the original request. If it has, the CANCEL\n                // request has no effect on the processing of the original request, no\n                // effect on any session state, and no effect on the responses generated\n                // for the original request. If the UAS has not issued a final response\n                // for the original request, its behavior depends on the method of the\n                // original request. If the original request was an INVITE, the UAS\n                // SHOULD immediately respond to the INVITE with a 487 (Request\n                // Terminated).\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                if (uas.transaction instanceof InviteServerTransaction &&\n                    uas.transaction.state === TransactionState.Proceeding) {\n                    if (uas instanceof InviteUserAgentServer) {\n                        uas.receiveCancel(message);\n                    }\n                    // A CANCEL request has no impact on the processing of\n                    // transactions with any other method defined in this specification.\n                    // https://tools.ietf.org/html/rfc3261#section-9.2\n                }\n            }\n            else {\n                // If the UAS did not find a matching transaction for the CANCEL\n                // according to the procedure above, it SHOULD respond to the CANCEL\n                // with a 481 (Call Leg/Transaction Does Not Exist).\n                // https://tools.ietf.org/html/rfc3261#section-9.2\n                this.replyStateless(message, { statusCode: 481 });\n            }\n            return;\n        }\n        // If a matching server transaction is found, the request is passed to that\n        // transaction for processing.\n        // https://tools.ietf.org/html/rfc6026#section-8.10\n        if (uas) {\n            uas.transaction.receiveRequest(message);\n            return;\n        }\n        // If no match is found, the request is passed to the core, which may decide to\n        // construct a new server transaction for that request.\n        // https://tools.ietf.org/html/rfc6026#section-8.10\n        this.receiveRequest(message);\n        return;\n    }\n    /**\n     * UAC and UAS procedures depend strongly on two factors.  First, based\n     * on whether the request or response is inside or outside of a dialog,\n     * and second, based on the method of a request.  Dialogs are discussed\n     * thoroughly in Section 12; they represent a peer-to-peer relationship\n     * between user agents and are established by specific SIP methods, such\n     * as INVITE.\n     * @param message - Incoming request message.\n     */\n    receiveRequest(message) {\n        // 8.2 UAS Behavior\n        // UASs SHOULD process the requests in the order of the steps that\n        // follow in this section (that is, starting with authentication, then\n        // inspecting the method, the header fields, and so on throughout the\n        // remainder of this section).\n        // https://tools.ietf.org/html/rfc3261#section-8.2\n        // 8.2.1 Method Inspection\n        // Once a request is authenticated (or authentication is skipped), the\n        // UAS MUST inspect the method of the request.  If the UAS recognizes\n        // but does not support the method of a request, it MUST generate a 405\n        // (Method Not Allowed) response.  Procedures for generating responses\n        // are described in Section 8.2.6.  The UAS MUST also add an Allow\n        // header field to the 405 (Method Not Allowed) response.  The Allow\n        // header field MUST list the set of methods supported by the UAS\n        // generating the message.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.1\n        if (!AllowedMethods.includes(message.method)) {\n            const allowHeader = \"Allow: \" + AllowedMethods.toString();\n            this.replyStateless(message, {\n                statusCode: 405,\n                extraHeaders: [allowHeader]\n            });\n            return;\n        }\n        // 8.2.2 Header Inspection\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2\n        if (!message.ruri) {\n            // FIXME: A request message should always have an ruri\n            throw new Error(\"Request-URI undefined.\");\n        }\n        // 8.2.2.1 To and Request-URI\n        // If the Request-URI uses a scheme not supported by the UAS, it SHOULD\n        // reject the request with a 416 (Unsupported URI Scheme) response.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        if (message.ruri.scheme !== \"sip\") {\n            this.replyStateless(message, { statusCode: 416 });\n            return;\n        }\n        // 8.2.2.1 To and Request-URI\n        // If the Request-URI does not identify an address that the\n        // UAS is willing to accept requests for, it SHOULD reject\n        // the request with a 404 (Not Found) response.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        const ruri = message.ruri;\n        const ruriMatches = (uri) => {\n            return !!uri && uri.user === ruri.user;\n        };\n        if (!ruriMatches(this.configuration.aor) &&\n            !(ruriMatches(this.configuration.contact.uri) ||\n                ruriMatches(this.configuration.contact.pubGruu) ||\n                ruriMatches(this.configuration.contact.tempGruu))) {\n            this.logger.warn(\"Request-URI does not point to us.\");\n            if (message.method !== C.ACK) {\n                this.replyStateless(message, { statusCode: 404 });\n            }\n            return;\n        }\n        // 8.2.2.1 To and Request-URI\n        // Other potential sources of received Request-URIs include\n        // the Contact header fields of requests and responses sent by the UA\n        // that establish or refresh dialogs.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.1\n        if (message.method === C.INVITE) {\n            if (!message.hasHeader(\"Contact\")) {\n                this.replyStateless(message, {\n                    statusCode: 400,\n                    reasonPhrase: \"Missing Contact Header\"\n                });\n                return;\n            }\n        }\n        // 8.2.2.2 Merged Requests\n        // If the request has no tag in the To header field, the UAS core MUST\n        // check the request against ongoing transactions.  If the From tag,\n        // Call-ID, and CSeq exactly match those associated with an ongoing\n        // transaction, but the request does not match that transaction (based\n        // on the matching rules in Section 17.2.3), the UAS core SHOULD\n        // generate a 482 (Loop Detected) response and pass it to the server\n        // transaction.\n        //\n        //    The same request has arrived at the UAS more than once, following\n        //    different paths, most likely due to forking.  The UAS processes\n        //    the first such request received and responds with a 482 (Loop\n        //    Detected) to the rest of them.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.2\n        if (!message.toTag) {\n            const transactionId = message.viaBranch;\n            if (!this.userAgentServers.has(transactionId)) {\n                const mergedRequest = Array.from(this.userAgentServers.values()).some((uas) => uas.transaction.request.fromTag === message.fromTag &&\n                    uas.transaction.request.callId === message.callId &&\n                    uas.transaction.request.cseq === message.cseq);\n                if (mergedRequest) {\n                    this.replyStateless(message, { statusCode: 482 });\n                    return;\n                }\n            }\n        }\n        // 8.2.2.3 Require\n        // https://tools.ietf.org/html/rfc3261#section-8.2.2.3\n        // TODO\n        // 8.2.3 Content Processing\n        // https://tools.ietf.org/html/rfc3261#section-8.2.3\n        // TODO\n        // 8.2.4 Applying Extensions\n        // https://tools.ietf.org/html/rfc3261#section-8.2.4\n        // TODO\n        // 8.2.5 Processing the Request\n        // Assuming all of the checks in the previous subsections are passed,\n        // the UAS processing becomes method-specific.\n        // https://tools.ietf.org/html/rfc3261#section-8.2.5\n        // The UAS will receive the request from the transaction layer.  If the\n        // request has a tag in the To header field, the UAS core computes the\n        // dialog identifier corresponding to the request and compares it with\n        // existing dialogs.  If there is a match, this is a mid-dialog request.\n        // In that case, the UAS first applies the same processing rules for\n        // requests outside of a dialog, discussed in Section 8.2.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (message.toTag) {\n            this.receiveInsideDialogRequest(message);\n        }\n        else {\n            this.receiveOutsideDialogRequest(message);\n        }\n        return;\n    }\n    /**\n     * Once a dialog has been established between two UAs, either of them\n     * MAY initiate new transactions as needed within the dialog.  The UA\n     * sending the request will take the UAC role for the transaction.  The\n     * UA receiving the request will take the UAS role.  Note that these may\n     * be different roles than the UAs held during the transaction that\n     * established the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2\n     * @param message - Incoming request message.\n     */\n    receiveInsideDialogRequest(message) {\n        // NOTIFY requests are matched to such SUBSCRIBE requests if they\n        // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n        // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n        // request, and the same \"Event\" header field.  Rules for comparisons of\n        // the \"Event\" header fields are described in Section 8.2.1.\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        if (message.method === C.NOTIFY) {\n            const event = message.parseHeader(\"Event\");\n            if (!event || !event.event) {\n                this.replyStateless(message, { statusCode: 489 });\n                return;\n            }\n            // FIXME: Subscriber id should also matching on event id.\n            const subscriberId = message.callId + message.toTag + event.event;\n            const subscriber = this.subscribers.get(subscriberId);\n            if (subscriber) {\n                const uas = new NotifyUserAgentServer(this, message);\n                subscriber.onNotify(uas);\n                return;\n            }\n        }\n        // Requests sent within a dialog, as any other requests, are atomic.  If\n        // a particular request is accepted by the UAS, all the state changes\n        // associated with it are performed.  If the request is rejected, none\n        // of the state changes are performed.\n        //\n        //    Note that some requests, such as INVITEs, affect several pieces of\n        //    state.\n        //\n        // The UAS will receive the request from the transaction layer.  If the\n        // request has a tag in the To header field, the UAS core computes the\n        // dialog identifier corresponding to the request and compares it with\n        // existing dialogs.  If there is a match, this is a mid-dialog request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        const dialogId = message.callId + message.toTag + message.fromTag;\n        const dialog = this.dialogs.get(dialogId);\n        if (dialog) {\n            // [Sip-implementors] Reg. SIP reinvite, UPDATE and OPTIONS\n            // You got the question right.\n            //\n            // And you got the right answer too. :-)\n            //\n            //   Thanks,\n            //   Paul\n            //\n            // Robert Sparks wrote:\n            // > So I've lost track of the question during the musing.\n            // >\n            // > I _think_ the fundamental question being asked is this:\n            // >\n            // > Is an endpoint required to reject (with a 481) an OPTIONS request that\n            // > arrives with at to-tag but does not match any existing dialog state.\n            // > (Assuming some earlier requirement hasn't forced another error code). Or\n            // > is it OK if it just sends\n            // > a 200 OK anyhow.\n            // >\n            // > My take on the collection of specs is that its _not_ ok for it to send\n            // > the 200 OK anyhow and that it is required to send\n            // > the 481. I base this primarily on these sentences from 11.2 in 3261:\n            // >\n            // >    The response to an OPTIONS is constructed using the standard rules\n            // >    for a SIP response as discussed in Section 8.2.6.  The response code\n            // >    chosen MUST be the same that would have been chosen had the request\n            // >    been an INVITE.\n            // >\n            // > Did I miss the point of the question?\n            // >\n            // > On May 15, 2008, at 12:48 PM, Paul Kyzivat wrote:\n            // >\n            // >> [Including Robert in hopes of getting his insight on this.]\n            // https://lists.cs.columbia.edu/pipermail/sip-implementors/2008-May/019178.html\n            //\n            // Requests that do not change in any way the state of a dialog may be\n            // received within a dialog (for example, an OPTIONS request).  They are\n            // processed as if they had been received outside the dialog.\n            // https://tools.ietf.org/html/rfc3261#section-12.2.2\n            if (message.method === C.OPTIONS) {\n                const allowHeader = \"Allow: \" + AllowedMethods.toString();\n                const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n                this.replyStateless(message, {\n                    statusCode: 200,\n                    extraHeaders: [allowHeader, acceptHeader]\n                });\n                return;\n            }\n            // Pass the incoming request to the dialog for further handling.\n            dialog.receiveRequest(message);\n            return;\n        }\n        // The most important behaviors of a stateless UAS are the following:\n        // ...\n        // o  A stateless UAS MUST ignore ACK requests.\n        // ...\n        // https://tools.ietf.org/html/rfc3261#section-8.2.7\n        if (message.method === C.ACK) {\n            // If a final response to an INVITE was sent statelessly,\n            // the corresponding ACK:\n            // - will not match an existing transaction\n            // - may have tag in the To header field\n            // - not not match any existing dialogs\n            // Absorb unmatched ACKs.\n            return;\n        }\n        // If the request has a tag in the To header field, but the dialog\n        // identifier does not match any existing dialogs, the UAS may have\n        // crashed and restarted, or it may have received a request for a\n        // different (possibly failed) UAS (the UASs can construct the To tags\n        // so that a UAS can identify that the tag was for a UAS for which it is\n        // providing recovery).  Another possibility is that the incoming\n        // request has been simply mis-routed.  Based on the To tag, the UAS MAY\n        // either accept or reject the request.  Accepting the request for\n        // acceptable To tags provides robustness, so that dialogs can persist\n        // even through crashes.  UAs wishing to support this capability must\n        // take into consideration some issues such as choosing monotonically\n        // increasing CSeq sequence numbers even across reboots, reconstructing\n        // the route set, and accepting out-of-range RTP timestamps and sequence\n        // numbers.\n        //\n        // If the UAS wishes to reject the request because it does not wish to\n        // recreate the dialog, it MUST respond to the request with a 481\n        // (Call/Transaction Does Not Exist) status code and pass that to the\n        // server transaction.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        this.replyStateless(message, { statusCode: 481 });\n        return;\n    }\n    /**\n     * Assuming all of the checks in the previous subsections are passed,\n     * the UAS processing becomes method-specific.\n     *  https://tools.ietf.org/html/rfc3261#section-8.2.5\n     * @param message - Incoming request message.\n     */\n    receiveOutsideDialogRequest(message) {\n        switch (message.method) {\n            case C.ACK:\n                // Absorb stray out of dialog ACKs\n                break;\n            case C.BYE:\n                // If the BYE does not match an existing dialog, the UAS core SHOULD\n                // generate a 481 (Call/Transaction Does Not Exist) response and pass\n                // that to the server transaction. This rule means that a BYE sent\n                // without tags by a UAC will be rejected.\n                // https://tools.ietf.org/html/rfc3261#section-15.1.2\n                this.replyStateless(message, { statusCode: 481 });\n                break;\n            case C.CANCEL:\n                throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n                break;\n            case C.INFO:\n                // Use of the INFO method does not constitute a separate dialog usage.\n                // INFO messages are always part of, and share the fate of, an invite\n                // dialog usage [RFC5057].  INFO messages cannot be sent as part of\n                // other dialog usages, or outside an existing dialog.\n                // https://tools.ietf.org/html/rfc6086#section-1\n                this.replyStateless(message, { statusCode: 405 }); // Should never happen\n                break;\n            case C.INVITE:\n                // https://tools.ietf.org/html/rfc3261#section-13.3.1\n                {\n                    const uas = new InviteUserAgentServer(this, message);\n                    this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject();\n                }\n                break;\n            case C.MESSAGE:\n                // MESSAGE requests are discouraged inside a dialog.  Implementations\n                // are restricted from creating a usage for the purpose of carrying a\n                // sequence of MESSAGE requests (though some implementations use it that\n                // way, against the standard recommendation).\n                // https://tools.ietf.org/html/rfc5057#section-5.3\n                {\n                    const uas = new MessageUserAgentServer(this, message);\n                    this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n                }\n                break;\n            case C.NOTIFY:\n                // Obsoleted by: RFC 6665\n                // If any non-SUBSCRIBE mechanisms are defined to create subscriptions,\n                // it is the responsibility of the parties defining those mechanisms to\n                // ensure that correlation of a NOTIFY message to the corresponding\n                // subscription is possible.  Designers of such mechanisms are also\n                // warned to make a distinction between sending a NOTIFY message to a\n                // subscriber who is aware of the subscription, and sending a NOTIFY\n                // message to an unsuspecting node.  The latter behavior is invalid, and\n                // MUST receive a \"481 Subscription does not exist\" response (unless\n                // some other 400- or 500-class error code is more applicable), as\n                // described in section 3.2.4.  In other words, knowledge of a\n                // subscription must exist in both the subscriber and the notifier to be\n                // valid, even if installed via a non-SUBSCRIBE mechanism.\n                // https://tools.ietf.org/html/rfc3265#section-3.2\n                //\n                // NOTIFY requests are sent to inform subscribers of changes in state to\n                // which the subscriber has a subscription.  Subscriptions are created\n                // using the SUBSCRIBE method.  In legacy implementations, it is\n                // possible that other means of subscription creation have been used.\n                // However, this specification does not allow the creation of\n                // subscriptions except through SUBSCRIBE requests and (for backwards-\n                // compatibility) REFER requests [RFC3515].\n                // https://tools.ietf.org/html/rfc6665#section-3.2\n                {\n                    const uas = new NotifyUserAgentServer(this, message);\n                    this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.OPTIONS:\n                // https://tools.ietf.org/html/rfc3261#section-11.2\n                {\n                    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n                    const acceptHeader = \"Accept: \" + acceptedBodyTypes.toString();\n                    this.replyStateless(message, {\n                        statusCode: 200,\n                        extraHeaders: [allowHeader, acceptHeader]\n                    });\n                }\n                break;\n            case C.REFER:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.2\n                {\n                    const uas = new ReferUserAgentServer(this, message);\n                    this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.REGISTER:\n                // https://tools.ietf.org/html/rfc3261#section-10.3\n                {\n                    const uas = new RegisterUserAgentServer(this, message);\n                    this.delegate.onRegister ? this.delegate.onRegister(uas) : uas.reject({ statusCode: 405 });\n                }\n                break;\n            case C.SUBSCRIBE:\n                // https://tools.ietf.org/html/rfc6665#section-4.2\n                {\n                    const uas = new SubscribeUserAgentServer(this, message);\n                    this.delegate.onSubscribe ? this.delegate.onSubscribe(uas) : uas.reject({ statusCode: 480 });\n                }\n                break;\n            default:\n                throw new Error(`Unexpected out of dialog request method ${message.method}.`);\n        }\n        return;\n    }\n    /**\n     * Responses are first processed by the transport layer and then passed\n     * up to the transaction layer.  The transaction layer performs its\n     * processing and then passes the response up to the TU.  The majority\n     * of response processing in the TU is method specific.  However, there\n     * are some general behaviors independent of the method.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3\n     * @param message - Incoming response message from transport layer.\n     */\n    receiveResponseFromTransport(message) {\n        // 8.1.3.1 Transaction Layer Errors\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n        // Handled by transaction layer callbacks.\n        // 8.1.3.2 Unrecognized Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n        // TODO\n        // 8.1.3.3 Vias\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.3\n        if (message.getHeaders(\"via\").length > 1) {\n            this.logger.warn(\"More than one Via header field present in the response, dropping\");\n            return;\n        }\n        // 8.1.3.4 Processing 3xx Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.4\n        // TODO\n        // 8.1.3.5 Processing 4xx Responses\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n        // TODO\n        // When the transport layer in the client receives a response, it has to\n        // determine which client transaction will handle the response, so that\n        // the processing of Sections 17.1.1 and 17.1.2 can take place.  The\n        // branch parameter in the top Via header field is used for this\n        // purpose.  A response matches a client transaction under two\n        // conditions:\n        //\n        //    1.  If the response has the same value of the branch parameter in\n        //        the top Via header field as the branch parameter in the top\n        //        Via header field of the request that created the transaction.\n        //\n        //    2.  If the method parameter in the CSeq header field matches the\n        //        method of the request that created the transaction.  The\n        //        method is needed since a CANCEL request constitutes a\n        //        different transaction, but shares the same value of the branch\n        //        parameter.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.3\n        const userAgentClientId = message.viaBranch + message.method;\n        const userAgentClient = this.userAgentClients.get(userAgentClientId);\n        // The client transport uses the matching procedures of Section\n        // 17.1.3 to attempt to match the response to an existing\n        // transaction.  If there is a match, the response MUST be passed to\n        // that transaction.  Otherwise, any element other than a stateless\n        // proxy MUST silently discard the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.9\n        if (userAgentClient) {\n            userAgentClient.transaction.receiveResponse(message);\n        }\n        else {\n            this.logger.warn(`Discarding unmatched ${message.statusCode} response to ${message.method} ${userAgentClientId}.`);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}