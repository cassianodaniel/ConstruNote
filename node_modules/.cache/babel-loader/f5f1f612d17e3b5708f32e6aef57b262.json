{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Invitation, Inviter, Messager, Registerer, RegistererState, RequestPendingError, SessionState, UserAgent, UserAgentState } from \"../../../api\";\nimport { holdModifier } from \"../modifiers\";\nimport { SessionDescriptionHandler } from \"../session-description-handler\";\nimport { Transport } from \"../transport\";\n/**\n * A simple SIP user class.\n * @remarks\n * While this class is completely functional for simple use cases, it is not intended\n * to provide an interface which is suitable for most (must less all) applications.\n * While this class has many limitations (for example, it only handles a single concurrent session),\n * it is, however, intended to serve as a simple example of using the SIP.js API.\n * @public\n */\n\nexport var SimpleUser = /*#__PURE__*/function () {\n  /**\n   * Constructs a new instance of the `SimpleUser` class.\n   * @param server - SIP WebSocket Server URL.\n   * @param options - Options bucket. See {@link SimpleUserOptions} for details.\n   */\n  function SimpleUser(server) {\n    var _this = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, SimpleUser);\n\n    this.attemptingReconnection = false;\n    this.connectRequested = false;\n    this.held = false;\n    this.registerer = undefined;\n    this.registerRequested = false;\n    this.session = undefined; // Delegate\n\n    this.delegate = options.delegate; // Copy options\n\n    this.options = Object.assign({}, options); // UserAgentOptions\n\n    var userAgentOptions = Object.assign({}, options.userAgentOptions); // Transport\n\n    if (!userAgentOptions.transportConstructor) {\n      userAgentOptions.transportConstructor = Transport;\n    } // TransportOptions\n\n\n    if (!userAgentOptions.transportOptions) {\n      userAgentOptions.transportOptions = {\n        server: server\n      };\n    } // URI\n\n\n    if (!userAgentOptions.uri) {\n      // If an AOR was provided, convert it to a URI\n      if (options.aor) {\n        var uri = UserAgent.makeURI(options.aor);\n\n        if (!uri) {\n          throw new Error(\"Failed to create valid URI from \".concat(options.aor));\n        }\n\n        userAgentOptions.uri = uri;\n      }\n    } // UserAgent\n\n\n    this.userAgent = new UserAgent(userAgentOptions); // UserAgent's delegate\n\n    this.userAgent.delegate = {\n      // Handle connection with server established\n      onConnect: function onConnect() {\n        _this.logger.log(\"[\".concat(_this.id, \"] Connected\"));\n\n        if (_this.delegate && _this.delegate.onServerConnect) {\n          _this.delegate.onServerConnect();\n        }\n\n        if (_this.registerer && _this.registerRequested) {\n          _this.logger.log(\"[\".concat(_this.id, \"] Registering...\"));\n\n          _this.registerer.register().catch(function (e) {\n            _this.logger.error(\"[\".concat(_this.id, \"] Error occurred registering after connection with server was obtained.\"));\n\n            _this.logger.error(e.toString());\n          });\n        }\n      },\n      // Handle connection with server lost\n      onDisconnect: function onDisconnect(error) {\n        _this.logger.log(\"[\".concat(_this.id, \"] Disconnected\"));\n\n        if (_this.delegate && _this.delegate.onServerDisconnect) {\n          _this.delegate.onServerDisconnect(error);\n        }\n\n        if (_this.session) {\n          _this.logger.log(\"[\".concat(_this.id, \"] Hanging up...\"));\n\n          _this.hangup() // cleanup hung calls\n          .catch(function (e) {\n            _this.logger.error(\"[\".concat(_this.id, \"] Error occurred hanging up call after connection with server was lost.\"));\n\n            _this.logger.error(e.toString());\n          });\n        }\n\n        if (_this.registerer) {\n          _this.logger.log(\"[\".concat(_this.id, \"] Unregistering...\"));\n\n          _this.registerer.unregister() // cleanup invalid registrations\n          .catch(function (e) {\n            _this.logger.error(\"[\".concat(_this.id, \"] Error occurred unregistering after connection with server was lost.\"));\n\n            _this.logger.error(e.toString());\n          });\n        } // Only attempt to reconnect if network/server dropped the connection.\n\n\n        if (error) {\n          _this.attemptReconnection();\n        }\n      },\n      // Handle incoming invitations\n      onInvite: function onInvite(invitation) {\n        _this.logger.log(\"[\".concat(_this.id, \"] Received INVITE\")); // Guard against a pre-existing session. This implementation only supports one session at a time.\n        // However an incoming INVITE request may be received at any time and/or while in the process\n        // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n\n\n        if (_this.session) {\n          _this.logger.warn(\"[\".concat(_this.id, \"] Session already in progress, rejecting INVITE...\"));\n\n          invitation.reject().then(function () {\n            _this.logger.log(\"[\".concat(_this.id, \"] Rejected INVITE\"));\n          }).catch(function (error) {\n            _this.logger.error(\"[\".concat(_this.id, \"] Failed to reject INVITE\"));\n\n            _this.logger.error(error.toString());\n          });\n          return;\n        } // Use our configured constraints as options for any Inviter created as result of a REFER\n\n\n        var referralInviterOptions = {\n          sessionDescriptionHandlerOptions: {\n            constraints: _this.constraints\n          }\n        }; // Initialize our session\n\n        _this.initSession(invitation, referralInviterOptions); // Delegate\n\n\n        if (_this.delegate && _this.delegate.onCallReceived) {\n          _this.delegate.onCallReceived();\n        } else {\n          _this.logger.warn(\"[\".concat(_this.id, \"] No handler available, rejecting INVITE...\"));\n\n          invitation.reject().then(function () {\n            _this.logger.log(\"[\".concat(_this.id, \"] Rejected INVITE\"));\n          }).catch(function (error) {\n            _this.logger.error(\"[\".concat(_this.id, \"] Failed to reject INVITE\"));\n\n            _this.logger.error(error.toString());\n          });\n        }\n      },\n      // Handle incoming messages\n      onMessage: function onMessage(message) {\n        message.accept().then(function () {\n          if (_this.delegate && _this.delegate.onMessageReceived) {\n            _this.delegate.onMessageReceived(message.request.body);\n          }\n        });\n      }\n    }; // Use the SIP.js logger\n\n    this.logger = this.userAgent.getLogger(\"sip.SimpleUser\"); // Monitor network connectivity and attempt reconnection when we come online\n\n    window.addEventListener(\"online\", function () {\n      _this.logger.log(\"[\".concat(_this.id, \"] Online\"));\n\n      _this.attemptReconnection();\n    });\n  }\n  /**\n   * Instance identifier.\n   * @internal\n   */\n\n\n  _createClass(SimpleUser, [{\n    key: \"connect\",\n\n    /**\n     * Connect.\n     * @remarks\n     * Start the UserAgent's WebSocket Transport.\n     */\n    value: function connect() {\n      this.logger.log(\"[\".concat(this.id, \"] Connecting UserAgent...\"));\n      this.connectRequested = true;\n\n      if (this.userAgent.state !== UserAgentState.Started) {\n        return this.userAgent.start();\n      }\n\n      return this.userAgent.reconnect();\n    }\n    /**\n     * Disconnect.\n     * @remarks\n     * Stop the UserAgent's WebSocket Transport.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.logger.log(\"[\".concat(this.id, \"] Disconnecting UserAgent...\"));\n      this.connectRequested = false;\n      return this.userAgent.stop();\n    }\n    /**\n     * Return true if connected.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.userAgent.isConnected();\n    }\n    /**\n     * Start receiving incoming calls.\n     * @remarks\n     * Send a REGISTER request for the UserAgent's AOR.\n     * Resolves when the REGISTER request is sent, otherwise rejects.\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(registererOptions, registererRegisterOptions) {\n      var _this2 = this;\n\n      this.logger.log(\"[\".concat(this.id, \"] Registering UserAgent...\"));\n      this.registerRequested = true;\n\n      if (!this.registerer) {\n        this.registerer = new Registerer(this.userAgent, registererOptions);\n        this.registerer.stateChange.addListener(function (state) {\n          switch (state) {\n            case RegistererState.Initial:\n              break;\n\n            case RegistererState.Registered:\n              if (_this2.delegate && _this2.delegate.onRegistered) {\n                _this2.delegate.onRegistered();\n              }\n\n              break;\n\n            case RegistererState.Unregistered:\n              if (_this2.delegate && _this2.delegate.onUnregistered) {\n                _this2.delegate.onUnregistered();\n              }\n\n              break;\n\n            case RegistererState.Terminated:\n              _this2.registerer = undefined;\n              break;\n\n            default:\n              throw new Error(\"Unknown registerer state.\");\n          }\n        });\n      }\n\n      return this.registerer.register(registererRegisterOptions).then(function () {\n        return;\n      });\n    }\n    /**\n     * Stop receiving incoming calls.\n     * @remarks\n     * Send an un-REGISTER request for the UserAgent's AOR.\n     * Resolves when the un-REGISTER request is sent, otherwise rejects.\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister(registererUnregisterOptions) {\n      this.logger.log(\"[\".concat(this.id, \"] Unregistering UserAgent...\"));\n      this.registerRequested = false;\n\n      if (!this.registerer) {\n        return Promise.resolve();\n      }\n\n      return this.registerer.unregister(registererUnregisterOptions).then(function () {\n        return;\n      });\n    }\n    /**\n     * Make an outgoing call.\n     * @remarks\n     * Send an INVITE request to create a new Session.\n     * Resolves when the INVITE request is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if Session is established.\n     * @param destination - The target destination to call. A SIP address to send the INVITE to.\n     * @param inviterOptions - Optional options for Inviter constructor.\n     * @param inviterInviteOptions - Optional options for Inviter.invite().\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(destination, inviterOptions, inviterInviteOptions) {\n      this.logger.log(\"[\".concat(this.id, \"] Beginning Session...\"));\n\n      if (this.session) {\n        return Promise.reject(new Error(\"Session already exists.\"));\n      }\n\n      var target = UserAgent.makeURI(destination);\n\n      if (!target) {\n        return Promise.reject(new Error(\"Failed to create a valid URI from \\\"\".concat(destination, \"\\\"\")));\n      } // Use our configured constraints as InviterOptions if none provided\n\n\n      if (!inviterOptions) {\n        inviterOptions = {};\n      }\n\n      if (!inviterOptions.sessionDescriptionHandlerOptions) {\n        inviterOptions.sessionDescriptionHandlerOptions = {};\n      }\n\n      if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {\n        inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n      } // Create a new Inviter for the outgoing Session\n\n\n      var inviter = new Inviter(this.userAgent, target, inviterOptions); // Send INVITE\n\n      return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(function () {\n        return;\n      });\n    }\n    /**\n     * Hangup a call.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n\n  }, {\n    key: \"hangup\",\n    value: function hangup() {\n      this.logger.log(\"[\".concat(this.id, \"] Hangup...\"));\n      return this.terminate();\n    }\n    /**\n     * Answer an incoming call.\n     * @remarks\n     * Accept an incoming INVITE request creating a new Session.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if and when call is established.\n     * @param invitationAcceptOptions - Optional options for Inviter.accept().\n     */\n\n  }, {\n    key: \"answer\",\n    value: function answer(invitationAcceptOptions) {\n      this.logger.log(\"[\".concat(this.id, \"] Accepting Invitation...\"));\n\n      if (!this.session) {\n        return Promise.reject(new Error(\"Session does not exist.\"));\n      }\n\n      if (!(this.session instanceof Invitation)) {\n        return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n      } // Use our configured constraints as InvitationAcceptOptions if none provided\n\n\n      if (!invitationAcceptOptions) {\n        invitationAcceptOptions = {};\n      }\n\n      if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {\n        invitationAcceptOptions.sessionDescriptionHandlerOptions = {};\n      }\n\n      if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {\n        invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n      }\n\n      return this.session.accept(invitationAcceptOptions);\n    }\n    /**\n     * Decline an incoming call.\n     * @remarks\n     * Reject an incoming INVITE request.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n\n  }, {\n    key: \"decline\",\n    value: function decline() {\n      this.logger.log(\"[\".concat(this.id, \"] rejecting Invitation...\"));\n\n      if (!this.session) {\n        return Promise.reject(new Error(\"Session does not exist.\"));\n      }\n\n      if (!(this.session instanceof Invitation)) {\n        return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n      }\n\n      return this.session.reject();\n    }\n    /**\n     * Hold call\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"hold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n\n  }, {\n    key: \"hold\",\n    value: function hold() {\n      this.logger.log(\"[\".concat(this.id, \"] holding session...\"));\n      return this.setHold(true);\n    }\n    /**\n     * Unhold call.\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"unhold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n\n  }, {\n    key: \"unhold\",\n    value: function unhold() {\n      this.logger.log(\"[\".concat(this.id, \"] unholding session...\"));\n      return this.setHold(false);\n    }\n    /**\n     * Hold state.\n     * @remarks\n     * True if session media is on hold.\n     */\n\n  }, {\n    key: \"isHeld\",\n    value: function isHeld() {\n      return this.held;\n    }\n    /**\n     * Mute call.\n     * @remarks\n     * Disable sender's media tracks.\n     */\n\n  }, {\n    key: \"mute\",\n    value: function mute() {\n      this.logger.log(\"[\".concat(this.id, \"] disabling media tracks...\"));\n      this.setMute(true);\n    }\n    /**\n     * Unmute call.\n     * @remarks\n     * Enable sender's media tracks.\n     */\n\n  }, {\n    key: \"unmute\",\n    value: function unmute() {\n      this.logger.log(\"[\".concat(this.id, \"] enabling media tracks...\"));\n      this.setMute(false);\n    }\n    /**\n     * Mute state.\n     * @remarks\n     * True if sender's media track is disabled.\n     */\n\n  }, {\n    key: \"isMuted\",\n    value: function isMuted() {\n      var track = this.localAudioTrack || this.localVideoTrack;\n      return track ? !track.enabled : false;\n    }\n    /**\n     * Send DTMF.\n     * @remarks\n     * Send an INFO request with content type application/dtmf-relay.\n     * @param tone - Tone to send.\n     */\n\n  }, {\n    key: \"sendDTMF\",\n    value: function sendDTMF(tone) {\n      this.logger.log(\"[\".concat(this.id, \"] sending DTMF...\")); // As RFC 6086 states, sending DTMF via INFO is not standardized...\n      //\n      // Companies have been using INFO messages in order to transport\n      // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n      // proprietary and have not been standardized.\n      // https://tools.ietf.org/html/rfc6086#section-2\n      //\n      // It is however widely supported based on this draft:\n      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n      // Validate tone\n\n      if (!/^[0-9A-D#*,]$/.exec(tone)) {\n        return Promise.reject(new Error(\"Invalid DTMF tone.\"));\n      }\n\n      if (!this.session) {\n        return Promise.reject(new Error(\"Session does not exist.\"));\n      } // The UA MUST populate the \"application/dtmf-relay\" body, as defined\n      // earlier, with the button pressed and the duration it was pressed\n      // for.  Technically, this actually requires the INFO to be generated\n      // when the user *releases* the button, however if the user has still\n      // not released a button after 5 seconds, which is the maximum duration\n      // supported by this mechanism, the UA should generate the INFO at that\n      // time.\n      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3\n\n\n      this.logger.log(\"[\".concat(this.id, \"] Sending DTMF tone: \").concat(tone));\n      var dtmf = tone;\n      var duration = 2000;\n      var body = {\n        contentDisposition: \"render\",\n        contentType: \"application/dtmf-relay\",\n        content: \"Signal=\" + dtmf + \"\\r\\nDuration=\" + duration\n      };\n      var requestOptions = {\n        body: body\n      };\n      return this.session.info({\n        requestOptions: requestOptions\n      }).then(function () {\n        return;\n      });\n    }\n    /**\n     * Send a message.\n     * @remarks\n     * Send a MESSAGE request.\n     * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n     */\n\n  }, {\n    key: \"message\",\n    value: function message(destination, _message) {\n      this.logger.log(\"[\".concat(this.id, \"] sending message...\"));\n      var target = UserAgent.makeURI(destination);\n\n      if (!target) {\n        return Promise.reject(new Error(\"Failed to create a valid URI from \\\"\".concat(destination, \"\\\"\")));\n      }\n\n      return new Messager(this.userAgent, target, _message).message();\n    }\n    /** Media constraints. */\n\n  }, {\n    key: \"attemptReconnection\",\n\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n    value: function attemptReconnection() {\n      var _this3 = this;\n\n      var reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var reconnectionAttempts = this.options.reconnectionAttempts || 3;\n      var reconnectionDelay = this.options.reconnectionDelay || 4;\n\n      if (!this.connectRequested) {\n        this.logger.log(\"[\".concat(this.id, \"] Reconnection not currently desired\"));\n        return; // If intentionally disconnected, don't reconnect.\n      }\n\n      if (this.attemptingReconnection) {\n        this.logger.log(\"[\".concat(this.id, \"] Reconnection attempt already in progress\"));\n      }\n\n      if (reconnectionAttempt > reconnectionAttempts) {\n        this.logger.log(\"[\".concat(this.id, \"] Reconnection maximum attempts reached\"));\n        return;\n      }\n\n      if (reconnectionAttempt === 1) {\n        this.logger.log(\"[\".concat(this.id, \"] Reconnection attempt \").concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - trying\"));\n      } else {\n        this.logger.log(\"[\".concat(this.id, \"] Reconnection attempt \").concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - trying in \").concat(reconnectionDelay, \" seconds\"));\n      }\n\n      this.attemptingReconnection = true;\n      setTimeout(function () {\n        if (!_this3.connectRequested) {\n          _this3.logger.log(\"[\".concat(_this3.id, \"] Reconnection attempt \").concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - aborted\"));\n\n          _this3.attemptingReconnection = false;\n          return; // If intentionally disconnected, don't reconnect.\n        }\n\n        _this3.userAgent.reconnect().then(function () {\n          _this3.logger.log(\"[\".concat(_this3.id, \"] Reconnection attempt \").concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - succeeded\"));\n\n          _this3.attemptingReconnection = false;\n        }).catch(function (error) {\n          _this3.logger.log(\"[\".concat(_this3.id, \"] Reconnection attempt \").concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - failed\"));\n\n          _this3.logger.error(error.message);\n\n          _this3.attemptingReconnection = false;\n\n          _this3.attemptReconnection(++reconnectionAttempt);\n        });\n      }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /** Helper function to remove media from html elements. */\n\n  }, {\n    key: \"cleanupMedia\",\n    value: function cleanupMedia() {\n      if (this.options.media) {\n        if (this.options.media.local) {\n          if (this.options.media.local.video) {\n            this.options.media.local.video.srcObject = null;\n            this.options.media.local.video.pause();\n          }\n        }\n\n        if (this.options.media.remote) {\n          if (this.options.media.remote.audio) {\n            this.options.media.remote.audio.srcObject = null;\n            this.options.media.remote.audio.pause();\n          }\n\n          if (this.options.media.remote.video) {\n            this.options.media.remote.video.srcObject = null;\n            this.options.media.remote.video.pause();\n          }\n        }\n      }\n    }\n    /** Helper function to enable/disable media tracks. */\n\n  }, {\n    key: \"enableSenderTracks\",\n    value: function enableSenderTracks(enable) {\n      if (!this.session) {\n        throw new Error(\"Session does not exist.\");\n      }\n\n      var sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n\n      if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n        throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n      }\n\n      var peerConnection = sessionDescriptionHandler.peerConnection;\n\n      if (!peerConnection) {\n        throw new Error(\"Peer connection closed.\");\n      }\n\n      peerConnection.getSenders().forEach(function (sender) {\n        if (sender.track) {\n          sender.track.enabled = enable;\n        }\n      });\n    }\n    /**\n     * Setup session delegate and state change handler.\n     * @param session - Session to setup\n     * @param referralInviterOptions - Options for any Inviter created as result of a REFER.\n     */\n\n  }, {\n    key: \"initSession\",\n    value: function initSession(session, referralInviterOptions) {\n      var _this4 = this;\n\n      // Set session\n      this.session = session; // Call session created callback\n\n      if (this.delegate && this.delegate.onCallCreated) {\n        this.delegate.onCallCreated();\n      } // Setup session state change handler\n\n\n      this.session.stateChange.addListener(function (state) {\n        if (_this4.session !== session) {\n          return; // if our session has changed, just return\n        }\n\n        _this4.logger.log(\"[\".concat(_this4.id, \"] session state changed to \").concat(state));\n\n        switch (state) {\n          case SessionState.Initial:\n            break;\n\n          case SessionState.Establishing:\n            break;\n\n          case SessionState.Established:\n            _this4.setupLocalMedia();\n\n            _this4.setupRemoteMedia();\n\n            if (_this4.delegate && _this4.delegate.onCallAnswered) {\n              _this4.delegate.onCallAnswered();\n            }\n\n            break;\n\n          case SessionState.Terminating: // fall through\n\n          case SessionState.Terminated:\n            _this4.session = undefined;\n\n            _this4.cleanupMedia();\n\n            if (_this4.delegate && _this4.delegate.onCallHangup) {\n              _this4.delegate.onCallHangup();\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Unknown session state.\");\n        }\n      }); // Setup delegate\n\n      this.session.delegate = {\n        onInfo: function onInfo(info) {\n          // As RFC 6086 states, sending DTMF via INFO is not standardized...\n          //\n          // Companies have been using INFO messages in order to transport\n          // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n          // proprietary and have not been standardized.\n          // https://tools.ietf.org/html/rfc6086#section-2\n          //\n          // It is however widely supported based on this draft:\n          // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n          var _a; // FIXME: TODO: We should reject correctly...\n          //\n          // If a UA receives an INFO request associated with an Info Package that\n          // the UA has not indicated willingness to receive, the UA MUST send a\n          // 469 (Bad Info Package) response (see Section 11.6), which contains a\n          // Recv-Info header field with Info Packages for which the UA is willing\n          // to receive INFO requests.\n          // https://tools.ietf.org/html/rfc6086#section-4.2.2\n          // No delegate\n\n\n          if (((_a = _this4.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {\n            info.reject();\n            return;\n          } // Invalid content type\n\n\n          var contentType = info.request.getHeader(\"content-type\");\n\n          if (!contentType || !/^application\\/dtmf-relay/i.exec(contentType)) {\n            info.reject();\n            return;\n          } // Invalid body\n\n\n          var body = info.request.body.split(\"\\r\\n\", 2);\n\n          if (body.length !== 2) {\n            info.reject();\n            return;\n          } // Invalid tone\n\n\n          var tone;\n          var toneRegExp = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n\n          if (toneRegExp.test(body[0])) {\n            tone = body[0].replace(toneRegExp, \"$2\");\n          }\n\n          if (!tone) {\n            info.reject();\n            return;\n          } // Invalid duration\n\n\n          var duration;\n          var durationRegExp = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n          if (durationRegExp.test(body[1])) {\n            duration = parseInt(body[1].replace(durationRegExp, \"$2\"), 10);\n          }\n\n          if (!duration) {\n            info.reject();\n            return;\n          }\n\n          info.accept().then(function () {\n            if (_this4.delegate && _this4.delegate.onCallDTMFReceived) {\n              if (!tone || !duration) {\n                throw new Error(\"Tone or duration undefined.\");\n              }\n\n              _this4.delegate.onCallDTMFReceived(tone, duration);\n            }\n          }).catch(function (error) {\n            _this4.logger.error(error.message);\n          });\n        },\n        onRefer: function onRefer(referral) {\n          referral.accept().then(function () {\n            return _this4.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions);\n          }).catch(function (error) {\n            _this4.logger.error(error.message);\n          });\n        }\n      };\n    }\n    /** Helper function to init send then send invite. */\n\n  }, {\n    key: \"sendInvite\",\n    value: function sendInvite(inviter, inviterOptions, inviterInviteOptions) {\n      var _this5 = this;\n\n      // Initialize our session\n      this.initSession(inviter, inviterOptions); // Send the INVITE\n\n      return inviter.invite(inviterInviteOptions).then(function () {\n        _this5.logger.log(\"[\".concat(_this5.id, \"] sent INVITE\"));\n      });\n    }\n    /**\n     * Puts Session on hold.\n     * @param hold - Hold on if true, off if false.\n     */\n\n  }, {\n    key: \"setHold\",\n    value: function setHold(hold) {\n      var _this6 = this;\n\n      if (!this.session) {\n        return Promise.reject(new Error(\"Session does not exist.\"));\n      }\n\n      var session = this.session; // Just resolve if we are already in correct state\n\n      if (this.held === hold) {\n        return Promise.resolve();\n      }\n\n      var sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n\n      if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n        throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n      }\n\n      var options = {\n        requestDelegate: {\n          onAccept: function onAccept() {\n            _this6.held = hold;\n\n            if (_this6.delegate && _this6.delegate.onCallHold) {\n              _this6.delegate.onCallHold(_this6.held);\n            }\n          },\n          onReject: function onReject() {\n            _this6.logger.warn(\"[\".concat(_this6.id, \"] re-invite request was rejected\"));\n\n            if (_this6.delegate && _this6.delegate.onCallHold) {\n              _this6.delegate.onCallHold(_this6.held);\n            }\n          }\n        }\n      }; // Session properties used to pass modifiers to the SessionDescriptionHandler:\n      //\n      // 1) Session.sessionDescriptionHandlerModifiers\n      //    - used in all cases when handling the initial INVITE transaction as either UAC or UAS\n      //    - may be set directly at anytime\n      //    - may optionally be set via constructor option\n      //    - may optionally be set via options passed to Inviter.invite() or Invitation.accept()\n      //\n      // 2) Session.sessionDescriptionHandlerModifiersReInvite\n      //    - used in all cases when handling a re-INVITE transaction as either UAC or UAS\n      //    - may be set directly at anytime\n      //    - may optionally be set via constructor option\n      //    - may optionally be set via options passed to Session.invite()\n      // Set the session's SDH re-INVITE modifiers to produce the appropriate SDP offer to place call on hold\n\n      session.sessionDescriptionHandlerModifiersReInvite = hold ? [holdModifier] : []; // Send re-INVITE\n\n      return this.session.invite(options).then(function () {\n        // Reset the session's SDH re-INVITE modifiers.\n        // Note that if the modifiers are not reset, they will be applied\n        // to the SDP answer as well (which we do not want in this case).\n        session.sessionDescriptionHandlerModifiersReInvite = [];\n\n        _this6.enableSenderTracks(!hold); // mute/unmute\n\n      }).catch(function (error) {\n        if (error instanceof RequestPendingError) {\n          _this6.logger.error(\"[\".concat(_this6.id, \"] A hold request is already in progress.\"));\n        }\n\n        throw error;\n      });\n    }\n    /**\n     * Puts Session on mute.\n     * @param mute - Mute on if true, off if false.\n     */\n\n  }, {\n    key: \"setMute\",\n    value: function setMute(mute) {\n      if (!this.session) {\n        this.logger.warn(\"[\".concat(this.id, \"] A session is required to enabled/disable media tracks\"));\n        return;\n      }\n\n      if (this.session.state !== SessionState.Established) {\n        this.logger.warn(\"[\".concat(this.id, \"] An established session is required to enable/disable media tracks\"));\n        return;\n      }\n\n      this.enableSenderTracks(!mute);\n    }\n    /** Helper function to attach local media to html elements. */\n\n  }, {\n    key: \"setupLocalMedia\",\n    value: function setupLocalMedia() {\n      var _this7 = this;\n\n      var _a, _b;\n\n      if (!this.session) {\n        throw new Error(\"Session does not exist.\");\n      }\n\n      var mediaElement = (_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.local) === null || _b === void 0 ? void 0 : _b.video;\n\n      if (mediaElement) {\n        var localStream = this.localMediaStream;\n\n        if (!localStream) {\n          throw new Error(\"Local media stream undefiend.\");\n        }\n\n        mediaElement.srcObject = localStream;\n        mediaElement.volume = 0;\n        mediaElement.play().catch(function (error) {\n          _this7.logger.error(\"[\".concat(_this7.id, \"] Failed to play local media\"));\n\n          _this7.logger.error(error.message);\n        });\n      }\n    }\n    /** Helper function to attach remote media to html elements. */\n\n  }, {\n    key: \"setupRemoteMedia\",\n    value: function setupRemoteMedia() {\n      var _this8 = this;\n\n      var _a, _b, _c, _d;\n\n      if (!this.session) {\n        throw new Error(\"Session does not exist.\");\n      }\n\n      var mediaElement = ((_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.video) || ((_d = (_c = this.options.media) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.audio);\n\n      if (mediaElement) {\n        var remoteStream = this.remoteMediaStream;\n\n        if (!remoteStream) {\n          throw new Error(\"Remote media stream undefiend.\");\n        }\n\n        mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action\n\n        mediaElement.srcObject = remoteStream;\n        mediaElement.play().catch(function (error) {\n          _this8.logger.error(\"[\".concat(_this8.id, \"] Failed to play remote media\"));\n\n          _this8.logger.error(error.message);\n        });\n\n        remoteStream.onaddtrack = function () {\n          _this8.logger.log(\"[\".concat(_this8.id, \"] Remote media onaddtrack\"));\n\n          mediaElement.load(); // Safari hack, as it doesn't work otheriwse\n\n          mediaElement.play().catch(function (error) {\n            _this8.logger.error(\"[\".concat(_this8.id, \"] Failed to play remote media\"));\n\n            _this8.logger.error(error.message);\n          });\n        };\n      }\n    }\n    /**\n     * End a session.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when Session is terminated.\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      var _this9 = this;\n\n      this.logger.log(\"[\".concat(this.id, \"] Terminating...\"));\n\n      if (!this.session) {\n        return Promise.reject(new Error(\"Session does not exist.\"));\n      }\n\n      switch (this.session.state) {\n        case SessionState.Initial:\n          if (this.session instanceof Inviter) {\n            return this.session.cancel().then(function () {\n              _this9.logger.log(\"[\".concat(_this9.id, \"] Inviter never sent INVITE (canceled)\"));\n            });\n          } else if (this.session instanceof Invitation) {\n            return this.session.reject().then(function () {\n              _this9.logger.log(\"[\".concat(_this9.id, \"] Invitation rejected (sent 480)\"));\n            });\n          } else {\n            throw new Error(\"Unknown session type.\");\n          }\n\n        case SessionState.Establishing:\n          if (this.session instanceof Inviter) {\n            return this.session.cancel().then(function () {\n              _this9.logger.log(\"[\".concat(_this9.id, \"] Inviter canceled (sent CANCEL)\"));\n            });\n          } else if (this.session instanceof Invitation) {\n            return this.session.reject().then(function () {\n              _this9.logger.log(\"[\".concat(_this9.id, \"] Invitation rejected (sent 480)\"));\n            });\n          } else {\n            throw new Error(\"Unknown session type.\");\n          }\n\n        case SessionState.Established:\n          return this.session.bye().then(function () {\n            _this9.logger.log(\"[\".concat(_this9.id, \"] Session ended (sent BYE)\"));\n          });\n\n        case SessionState.Terminating:\n          break;\n\n        case SessionState.Terminated:\n          break;\n\n        default:\n          throw new Error(\"Unknown state\");\n      }\n\n      this.logger.log(\"[\".concat(this.id, \"] Terminating in state \").concat(this.session.state, \", no action taken\"));\n      return Promise.resolve();\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.options.userAgentOptions && this.options.userAgentOptions.displayName || \"Anonymous\";\n    }\n    /** The local media stream. Undefined if call not answered. */\n\n  }, {\n    key: \"localMediaStream\",\n    get: function get() {\n      var _a;\n\n      var sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n\n      if (!sdh) {\n        return undefined;\n      }\n\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n      }\n\n      return sdh.localMediaStream;\n    }\n    /** The remote media stream. Undefined if call not answered. */\n\n  }, {\n    key: \"remoteMediaStream\",\n    get: function get() {\n      var _a;\n\n      var sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n\n      if (!sdh) {\n        return undefined;\n      }\n\n      if (!(sdh instanceof SessionDescriptionHandler)) {\n        throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n      }\n\n      return sdh.remoteMediaStream;\n    }\n    /**\n     * The local audio track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n\n  }, {\n    key: \"localAudioTrack\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {\n        return track.kind === \"audio\";\n      });\n    }\n    /**\n     * The local video track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n\n  }, {\n    key: \"localVideoTrack\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {\n        return track.kind === \"video\";\n      });\n    }\n    /**\n     * The remote audio track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n\n  }, {\n    key: \"remoteAudioTrack\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {\n        return track.kind === \"audio\";\n      });\n    }\n    /**\n     * The remote video track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n\n  }, {\n    key: \"remoteVideoTrack\",\n    get: function get() {\n      var _a;\n\n      return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(function (track) {\n        return track.kind === \"video\";\n      });\n    }\n  }, {\n    key: \"constraints\",\n    get: function get() {\n      var _a;\n\n      var constraints = {\n        audio: true,\n        video: false\n      }; // default to audio only calls\n\n      if ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.constraints) {\n        constraints = Object.assign({}, this.options.media.constraints);\n      }\n\n      return constraints;\n    }\n  }]);\n\n  return SimpleUser;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/simple-user/simple-user.js"],"names":["Invitation","Inviter","Messager","Registerer","RegistererState","RequestPendingError","SessionState","UserAgent","UserAgentState","holdModifier","SessionDescriptionHandler","Transport","SimpleUser","server","options","attemptingReconnection","connectRequested","held","registerer","undefined","registerRequested","session","delegate","Object","assign","userAgentOptions","transportConstructor","transportOptions","uri","aor","makeURI","Error","userAgent","onConnect","logger","log","id","onServerConnect","register","catch","e","error","toString","onDisconnect","onServerDisconnect","hangup","unregister","attemptReconnection","onInvite","invitation","warn","reject","then","referralInviterOptions","sessionDescriptionHandlerOptions","constraints","initSession","onCallReceived","onMessage","message","accept","onMessageReceived","request","body","getLogger","window","addEventListener","state","Started","start","reconnect","stop","isConnected","registererOptions","registererRegisterOptions","stateChange","addListener","Initial","Registered","onRegistered","Unregistered","onUnregistered","Terminated","registererUnregisterOptions","Promise","resolve","destination","inviterOptions","inviterInviteOptions","target","inviter","sendInvite","terminate","invitationAcceptOptions","setHold","setMute","track","localAudioTrack","localVideoTrack","enabled","tone","exec","dtmf","duration","contentDisposition","contentType","content","requestOptions","info","reconnectionAttempt","reconnectionAttempts","reconnectionDelay","setTimeout","media","local","video","srcObject","pause","remote","audio","enable","sessionDescriptionHandler","peerConnection","getSenders","forEach","sender","onCallCreated","Establishing","Established","setupLocalMedia","setupRemoteMedia","onCallAnswered","Terminating","cleanupMedia","onCallHangup","onInfo","_a","onCallDTMFReceived","getHeader","split","length","toneRegExp","test","replace","durationRegExp","parseInt","onRefer","referral","makeInviter","invite","hold","requestDelegate","onAccept","onCallHold","onReject","sessionDescriptionHandlerModifiersReInvite","enableSenderTracks","mute","_b","mediaElement","localStream","localMediaStream","volume","play","_c","_d","remoteStream","remoteMediaStream","autoplay","onaddtrack","load","cancel","bye","displayName","sdh","getTracks","find","kind"],"mappings":"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","sourcesContent":["import { Invitation, Inviter, Messager, Registerer, RegistererState, RequestPendingError, SessionState, UserAgent, UserAgentState } from \"../../../api\";\nimport { holdModifier } from \"../modifiers\";\nimport { SessionDescriptionHandler } from \"../session-description-handler\";\nimport { Transport } from \"../transport\";\n/**\n * A simple SIP user class.\n * @remarks\n * While this class is completely functional for simple use cases, it is not intended\n * to provide an interface which is suitable for most (must less all) applications.\n * While this class has many limitations (for example, it only handles a single concurrent session),\n * it is, however, intended to serve as a simple example of using the SIP.js API.\n * @public\n */\nexport class SimpleUser {\n    /**\n     * Constructs a new instance of the `SimpleUser` class.\n     * @param server - SIP WebSocket Server URL.\n     * @param options - Options bucket. See {@link SimpleUserOptions} for details.\n     */\n    constructor(server, options = {}) {\n        this.attemptingReconnection = false;\n        this.connectRequested = false;\n        this.held = false;\n        this.registerer = undefined;\n        this.registerRequested = false;\n        this.session = undefined;\n        // Delegate\n        this.delegate = options.delegate;\n        // Copy options\n        this.options = Object.assign({}, options);\n        // UserAgentOptions\n        const userAgentOptions = Object.assign({}, options.userAgentOptions);\n        // Transport\n        if (!userAgentOptions.transportConstructor) {\n            userAgentOptions.transportConstructor = Transport;\n        }\n        // TransportOptions\n        if (!userAgentOptions.transportOptions) {\n            userAgentOptions.transportOptions = {\n                server\n            };\n        }\n        // URI\n        if (!userAgentOptions.uri) {\n            // If an AOR was provided, convert it to a URI\n            if (options.aor) {\n                const uri = UserAgent.makeURI(options.aor);\n                if (!uri) {\n                    throw new Error(`Failed to create valid URI from ${options.aor}`);\n                }\n                userAgentOptions.uri = uri;\n            }\n        }\n        // UserAgent\n        this.userAgent = new UserAgent(userAgentOptions);\n        // UserAgent's delegate\n        this.userAgent.delegate = {\n            // Handle connection with server established\n            onConnect: () => {\n                this.logger.log(`[${this.id}] Connected`);\n                if (this.delegate && this.delegate.onServerConnect) {\n                    this.delegate.onServerConnect();\n                }\n                if (this.registerer && this.registerRequested) {\n                    this.logger.log(`[${this.id}] Registering...`);\n                    this.registerer.register().catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred registering after connection with server was obtained.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n            },\n            // Handle connection with server lost\n            onDisconnect: (error) => {\n                this.logger.log(`[${this.id}] Disconnected`);\n                if (this.delegate && this.delegate.onServerDisconnect) {\n                    this.delegate.onServerDisconnect(error);\n                }\n                if (this.session) {\n                    this.logger.log(`[${this.id}] Hanging up...`);\n                    this.hangup() // cleanup hung calls\n                        .catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred hanging up call after connection with server was lost.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n                if (this.registerer) {\n                    this.logger.log(`[${this.id}] Unregistering...`);\n                    this.registerer\n                        .unregister() // cleanup invalid registrations\n                        .catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred unregistering after connection with server was lost.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n                // Only attempt to reconnect if network/server dropped the connection.\n                if (error) {\n                    this.attemptReconnection();\n                }\n            },\n            // Handle incoming invitations\n            onInvite: (invitation) => {\n                this.logger.log(`[${this.id}] Received INVITE`);\n                // Guard against a pre-existing session. This implementation only supports one session at a time.\n                // However an incoming INVITE request may be received at any time and/or while in the process\n                // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n                if (this.session) {\n                    this.logger.warn(`[${this.id}] Session already in progress, rejecting INVITE...`);\n                    invitation\n                        .reject()\n                        .then(() => {\n                        this.logger.log(`[${this.id}] Rejected INVITE`);\n                    })\n                        .catch((error) => {\n                        this.logger.error(`[${this.id}] Failed to reject INVITE`);\n                        this.logger.error(error.toString());\n                    });\n                    return;\n                }\n                // Use our configured constraints as options for any Inviter created as result of a REFER\n                const referralInviterOptions = {\n                    sessionDescriptionHandlerOptions: { constraints: this.constraints }\n                };\n                // Initialize our session\n                this.initSession(invitation, referralInviterOptions);\n                // Delegate\n                if (this.delegate && this.delegate.onCallReceived) {\n                    this.delegate.onCallReceived();\n                }\n                else {\n                    this.logger.warn(`[${this.id}] No handler available, rejecting INVITE...`);\n                    invitation\n                        .reject()\n                        .then(() => {\n                        this.logger.log(`[${this.id}] Rejected INVITE`);\n                    })\n                        .catch((error) => {\n                        this.logger.error(`[${this.id}] Failed to reject INVITE`);\n                        this.logger.error(error.toString());\n                    });\n                }\n            },\n            // Handle incoming messages\n            onMessage: (message) => {\n                message.accept().then(() => {\n                    if (this.delegate && this.delegate.onMessageReceived) {\n                        this.delegate.onMessageReceived(message.request.body);\n                    }\n                });\n            }\n        };\n        // Use the SIP.js logger\n        this.logger = this.userAgent.getLogger(\"sip.SimpleUser\");\n        // Monitor network connectivity and attempt reconnection when we come online\n        window.addEventListener(\"online\", () => {\n            this.logger.log(`[${this.id}] Online`);\n            this.attemptReconnection();\n        });\n    }\n    /**\n     * Instance identifier.\n     * @internal\n     */\n    get id() {\n        return (this.options.userAgentOptions && this.options.userAgentOptions.displayName) || \"Anonymous\";\n    }\n    /** The local media stream. Undefined if call not answered. */\n    get localMediaStream() {\n        var _a;\n        const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n        if (!sdh) {\n            return undefined;\n        }\n        if (!(sdh instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n        }\n        return sdh.localMediaStream;\n    }\n    /** The remote media stream. Undefined if call not answered. */\n    get remoteMediaStream() {\n        var _a;\n        const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n        if (!sdh) {\n            return undefined;\n        }\n        if (!(sdh instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n        }\n        return sdh.remoteMediaStream;\n    }\n    /**\n     * The local audio track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n    get localAudioTrack() {\n        var _a;\n        return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"audio\");\n    }\n    /**\n     * The local video track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n    get localVideoTrack() {\n        var _a;\n        return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"video\");\n    }\n    /**\n     * The remote audio track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n    get remoteAudioTrack() {\n        var _a;\n        return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"audio\");\n    }\n    /**\n     * The remote video track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n    get remoteVideoTrack() {\n        var _a;\n        return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"video\");\n    }\n    /**\n     * Connect.\n     * @remarks\n     * Start the UserAgent's WebSocket Transport.\n     */\n    connect() {\n        this.logger.log(`[${this.id}] Connecting UserAgent...`);\n        this.connectRequested = true;\n        if (this.userAgent.state !== UserAgentState.Started) {\n            return this.userAgent.start();\n        }\n        return this.userAgent.reconnect();\n    }\n    /**\n     * Disconnect.\n     * @remarks\n     * Stop the UserAgent's WebSocket Transport.\n     */\n    disconnect() {\n        this.logger.log(`[${this.id}] Disconnecting UserAgent...`);\n        this.connectRequested = false;\n        return this.userAgent.stop();\n    }\n    /**\n     * Return true if connected.\n     */\n    isConnected() {\n        return this.userAgent.isConnected();\n    }\n    /**\n     * Start receiving incoming calls.\n     * @remarks\n     * Send a REGISTER request for the UserAgent's AOR.\n     * Resolves when the REGISTER request is sent, otherwise rejects.\n     */\n    register(registererOptions, registererRegisterOptions) {\n        this.logger.log(`[${this.id}] Registering UserAgent...`);\n        this.registerRequested = true;\n        if (!this.registerer) {\n            this.registerer = new Registerer(this.userAgent, registererOptions);\n            this.registerer.stateChange.addListener((state) => {\n                switch (state) {\n                    case RegistererState.Initial:\n                        break;\n                    case RegistererState.Registered:\n                        if (this.delegate && this.delegate.onRegistered) {\n                            this.delegate.onRegistered();\n                        }\n                        break;\n                    case RegistererState.Unregistered:\n                        if (this.delegate && this.delegate.onUnregistered) {\n                            this.delegate.onUnregistered();\n                        }\n                        break;\n                    case RegistererState.Terminated:\n                        this.registerer = undefined;\n                        break;\n                    default:\n                        throw new Error(\"Unknown registerer state.\");\n                }\n            });\n        }\n        return this.registerer.register(registererRegisterOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Stop receiving incoming calls.\n     * @remarks\n     * Send an un-REGISTER request for the UserAgent's AOR.\n     * Resolves when the un-REGISTER request is sent, otherwise rejects.\n     */\n    unregister(registererUnregisterOptions) {\n        this.logger.log(`[${this.id}] Unregistering UserAgent...`);\n        this.registerRequested = false;\n        if (!this.registerer) {\n            return Promise.resolve();\n        }\n        return this.registerer.unregister(registererUnregisterOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Make an outgoing call.\n     * @remarks\n     * Send an INVITE request to create a new Session.\n     * Resolves when the INVITE request is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if Session is established.\n     * @param destination - The target destination to call. A SIP address to send the INVITE to.\n     * @param inviterOptions - Optional options for Inviter constructor.\n     * @param inviterInviteOptions - Optional options for Inviter.invite().\n     */\n    call(destination, inviterOptions, inviterInviteOptions) {\n        this.logger.log(`[${this.id}] Beginning Session...`);\n        if (this.session) {\n            return Promise.reject(new Error(\"Session already exists.\"));\n        }\n        const target = UserAgent.makeURI(destination);\n        if (!target) {\n            return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n        }\n        // Use our configured constraints as InviterOptions if none provided\n        if (!inviterOptions) {\n            inviterOptions = {};\n        }\n        if (!inviterOptions.sessionDescriptionHandlerOptions) {\n            inviterOptions.sessionDescriptionHandlerOptions = {};\n        }\n        if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {\n            inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n        }\n        // Create a new Inviter for the outgoing Session\n        const inviter = new Inviter(this.userAgent, target, inviterOptions);\n        // Send INVITE\n        return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Hangup a call.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n    hangup() {\n        this.logger.log(`[${this.id}] Hangup...`);\n        return this.terminate();\n    }\n    /**\n     * Answer an incoming call.\n     * @remarks\n     * Accept an incoming INVITE request creating a new Session.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if and when call is established.\n     * @param invitationAcceptOptions - Optional options for Inviter.accept().\n     */\n    answer(invitationAcceptOptions) {\n        this.logger.log(`[${this.id}] Accepting Invitation...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        if (!(this.session instanceof Invitation)) {\n            return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n        }\n        // Use our configured constraints as InvitationAcceptOptions if none provided\n        if (!invitationAcceptOptions) {\n            invitationAcceptOptions = {};\n        }\n        if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {\n            invitationAcceptOptions.sessionDescriptionHandlerOptions = {};\n        }\n        if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {\n            invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n        }\n        return this.session.accept(invitationAcceptOptions);\n    }\n    /**\n     * Decline an incoming call.\n     * @remarks\n     * Reject an incoming INVITE request.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n    decline() {\n        this.logger.log(`[${this.id}] rejecting Invitation...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        if (!(this.session instanceof Invitation)) {\n            return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n        }\n        return this.session.reject();\n    }\n    /**\n     * Hold call\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"hold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n    hold() {\n        this.logger.log(`[${this.id}] holding session...`);\n        return this.setHold(true);\n    }\n    /**\n     * Unhold call.\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"unhold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n    unhold() {\n        this.logger.log(`[${this.id}] unholding session...`);\n        return this.setHold(false);\n    }\n    /**\n     * Hold state.\n     * @remarks\n     * True if session media is on hold.\n     */\n    isHeld() {\n        return this.held;\n    }\n    /**\n     * Mute call.\n     * @remarks\n     * Disable sender's media tracks.\n     */\n    mute() {\n        this.logger.log(`[${this.id}] disabling media tracks...`);\n        this.setMute(true);\n    }\n    /**\n     * Unmute call.\n     * @remarks\n     * Enable sender's media tracks.\n     */\n    unmute() {\n        this.logger.log(`[${this.id}] enabling media tracks...`);\n        this.setMute(false);\n    }\n    /**\n     * Mute state.\n     * @remarks\n     * True if sender's media track is disabled.\n     */\n    isMuted() {\n        const track = this.localAudioTrack || this.localVideoTrack;\n        return track ? !track.enabled : false;\n    }\n    /**\n     * Send DTMF.\n     * @remarks\n     * Send an INFO request with content type application/dtmf-relay.\n     * @param tone - Tone to send.\n     */\n    sendDTMF(tone) {\n        this.logger.log(`[${this.id}] sending DTMF...`);\n        // As RFC 6086 states, sending DTMF via INFO is not standardized...\n        //\n        // Companies have been using INFO messages in order to transport\n        // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n        // proprietary and have not been standardized.\n        // https://tools.ietf.org/html/rfc6086#section-2\n        //\n        // It is however widely supported based on this draft:\n        // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n        // Validate tone\n        if (!/^[0-9A-D#*,]$/.exec(tone)) {\n            return Promise.reject(new Error(\"Invalid DTMF tone.\"));\n        }\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        // The UA MUST populate the \"application/dtmf-relay\" body, as defined\n        // earlier, with the button pressed and the duration it was pressed\n        // for.  Technically, this actually requires the INFO to be generated\n        // when the user *releases* the button, however if the user has still\n        // not released a button after 5 seconds, which is the maximum duration\n        // supported by this mechanism, the UA should generate the INFO at that\n        // time.\n        // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3\n        this.logger.log(`[${this.id}] Sending DTMF tone: ${tone}`);\n        const dtmf = tone;\n        const duration = 2000;\n        const body = {\n            contentDisposition: \"render\",\n            contentType: \"application/dtmf-relay\",\n            content: \"Signal=\" + dtmf + \"\\r\\nDuration=\" + duration\n        };\n        const requestOptions = { body };\n        return this.session.info({ requestOptions }).then(() => {\n            return;\n        });\n    }\n    /**\n     * Send a message.\n     * @remarks\n     * Send a MESSAGE request.\n     * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n     */\n    message(destination, message) {\n        this.logger.log(`[${this.id}] sending message...`);\n        const target = UserAgent.makeURI(destination);\n        if (!target) {\n            return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n        }\n        return new Messager(this.userAgent, target, message).message();\n    }\n    /** Media constraints. */\n    get constraints() {\n        var _a;\n        let constraints = { audio: true, video: false }; // default to audio only calls\n        if ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.constraints) {\n            constraints = Object.assign({}, this.options.media.constraints);\n        }\n        return constraints;\n    }\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n    attemptReconnection(reconnectionAttempt = 1) {\n        const reconnectionAttempts = this.options.reconnectionAttempts || 3;\n        const reconnectionDelay = this.options.reconnectionDelay || 4;\n        if (!this.connectRequested) {\n            this.logger.log(`[${this.id}] Reconnection not currently desired`);\n            return; // If intentionally disconnected, don't reconnect.\n        }\n        if (this.attemptingReconnection) {\n            this.logger.log(`[${this.id}] Reconnection attempt already in progress`);\n        }\n        if (reconnectionAttempt > reconnectionAttempts) {\n            this.logger.log(`[${this.id}] Reconnection maximum attempts reached`);\n            return;\n        }\n        if (reconnectionAttempt === 1) {\n            this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n        }\n        else {\n            this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying in ${reconnectionDelay} seconds`);\n        }\n        this.attemptingReconnection = true;\n        setTimeout(() => {\n            if (!this.connectRequested) {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - aborted`);\n                this.attemptingReconnection = false;\n                return; // If intentionally disconnected, don't reconnect.\n            }\n            this.userAgent\n                .reconnect()\n                .then(() => {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n                this.attemptingReconnection = false;\n            })\n                .catch((error) => {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n                this.logger.error(error.message);\n                this.attemptingReconnection = false;\n                this.attemptReconnection(++reconnectionAttempt);\n            });\n        }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /** Helper function to remove media from html elements. */\n    cleanupMedia() {\n        if (this.options.media) {\n            if (this.options.media.local) {\n                if (this.options.media.local.video) {\n                    this.options.media.local.video.srcObject = null;\n                    this.options.media.local.video.pause();\n                }\n            }\n            if (this.options.media.remote) {\n                if (this.options.media.remote.audio) {\n                    this.options.media.remote.audio.srcObject = null;\n                    this.options.media.remote.audio.pause();\n                }\n                if (this.options.media.remote.video) {\n                    this.options.media.remote.video.srcObject = null;\n                    this.options.media.remote.video.pause();\n                }\n            }\n        }\n    }\n    /** Helper function to enable/disable media tracks. */\n    enableSenderTracks(enable) {\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n        }\n        const peerConnection = sessionDescriptionHandler.peerConnection;\n        if (!peerConnection) {\n            throw new Error(\"Peer connection closed.\");\n        }\n        peerConnection.getSenders().forEach((sender) => {\n            if (sender.track) {\n                sender.track.enabled = enable;\n            }\n        });\n    }\n    /**\n     * Setup session delegate and state change handler.\n     * @param session - Session to setup\n     * @param referralInviterOptions - Options for any Inviter created as result of a REFER.\n     */\n    initSession(session, referralInviterOptions) {\n        // Set session\n        this.session = session;\n        // Call session created callback\n        if (this.delegate && this.delegate.onCallCreated) {\n            this.delegate.onCallCreated();\n        }\n        // Setup session state change handler\n        this.session.stateChange.addListener((state) => {\n            if (this.session !== session) {\n                return; // if our session has changed, just return\n            }\n            this.logger.log(`[${this.id}] session state changed to ${state}`);\n            switch (state) {\n                case SessionState.Initial:\n                    break;\n                case SessionState.Establishing:\n                    break;\n                case SessionState.Established:\n                    this.setupLocalMedia();\n                    this.setupRemoteMedia();\n                    if (this.delegate && this.delegate.onCallAnswered) {\n                        this.delegate.onCallAnswered();\n                    }\n                    break;\n                case SessionState.Terminating:\n                // fall through\n                case SessionState.Terminated:\n                    this.session = undefined;\n                    this.cleanupMedia();\n                    if (this.delegate && this.delegate.onCallHangup) {\n                        this.delegate.onCallHangup();\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unknown session state.\");\n            }\n        });\n        // Setup delegate\n        this.session.delegate = {\n            onInfo: (info) => {\n                // As RFC 6086 states, sending DTMF via INFO is not standardized...\n                //\n                // Companies have been using INFO messages in order to transport\n                // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n                // proprietary and have not been standardized.\n                // https://tools.ietf.org/html/rfc6086#section-2\n                //\n                // It is however widely supported based on this draft:\n                // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n                var _a;\n                // FIXME: TODO: We should reject correctly...\n                //\n                // If a UA receives an INFO request associated with an Info Package that\n                // the UA has not indicated willingness to receive, the UA MUST send a\n                // 469 (Bad Info Package) response (see Section 11.6), which contains a\n                // Recv-Info header field with Info Packages for which the UA is willing\n                // to receive INFO requests.\n                // https://tools.ietf.org/html/rfc6086#section-4.2.2\n                // No delegate\n                if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {\n                    info.reject();\n                    return;\n                }\n                // Invalid content type\n                const contentType = info.request.getHeader(\"content-type\");\n                if (!contentType || !/^application\\/dtmf-relay/i.exec(contentType)) {\n                    info.reject();\n                    return;\n                }\n                // Invalid body\n                const body = info.request.body.split(\"\\r\\n\", 2);\n                if (body.length !== 2) {\n                    info.reject();\n                    return;\n                }\n                // Invalid tone\n                let tone;\n                const toneRegExp = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n                if (toneRegExp.test(body[0])) {\n                    tone = body[0].replace(toneRegExp, \"$2\");\n                }\n                if (!tone) {\n                    info.reject();\n                    return;\n                }\n                // Invalid duration\n                let duration;\n                const durationRegExp = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n                if (durationRegExp.test(body[1])) {\n                    duration = parseInt(body[1].replace(durationRegExp, \"$2\"), 10);\n                }\n                if (!duration) {\n                    info.reject();\n                    return;\n                }\n                info\n                    .accept()\n                    .then(() => {\n                    if (this.delegate && this.delegate.onCallDTMFReceived) {\n                        if (!tone || !duration) {\n                            throw new Error(\"Tone or duration undefined.\");\n                        }\n                        this.delegate.onCallDTMFReceived(tone, duration);\n                    }\n                })\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                });\n            },\n            onRefer: (referral) => {\n                referral\n                    .accept()\n                    .then(() => this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions))\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                });\n            }\n        };\n    }\n    /** Helper function to init send then send invite. */\n    sendInvite(inviter, inviterOptions, inviterInviteOptions) {\n        // Initialize our session\n        this.initSession(inviter, inviterOptions);\n        // Send the INVITE\n        return inviter.invite(inviterInviteOptions).then(() => {\n            this.logger.log(`[${this.id}] sent INVITE`);\n        });\n    }\n    /**\n     * Puts Session on hold.\n     * @param hold - Hold on if true, off if false.\n     */\n    setHold(hold) {\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        const session = this.session;\n        // Just resolve if we are already in correct state\n        if (this.held === hold) {\n            return Promise.resolve();\n        }\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n        }\n        const options = {\n            requestDelegate: {\n                onAccept: () => {\n                    this.held = hold;\n                    if (this.delegate && this.delegate.onCallHold) {\n                        this.delegate.onCallHold(this.held);\n                    }\n                },\n                onReject: () => {\n                    this.logger.warn(`[${this.id}] re-invite request was rejected`);\n                    if (this.delegate && this.delegate.onCallHold) {\n                        this.delegate.onCallHold(this.held);\n                    }\n                }\n            }\n        };\n        // Session properties used to pass modifiers to the SessionDescriptionHandler:\n        //\n        // 1) Session.sessionDescriptionHandlerModifiers\n        //    - used in all cases when handling the initial INVITE transaction as either UAC or UAS\n        //    - may be set directly at anytime\n        //    - may optionally be set via constructor option\n        //    - may optionally be set via options passed to Inviter.invite() or Invitation.accept()\n        //\n        // 2) Session.sessionDescriptionHandlerModifiersReInvite\n        //    - used in all cases when handling a re-INVITE transaction as either UAC or UAS\n        //    - may be set directly at anytime\n        //    - may optionally be set via constructor option\n        //    - may optionally be set via options passed to Session.invite()\n        // Set the session's SDH re-INVITE modifiers to produce the appropriate SDP offer to place call on hold\n        session.sessionDescriptionHandlerModifiersReInvite = hold ? [holdModifier] : [];\n        // Send re-INVITE\n        return this.session\n            .invite(options)\n            .then(() => {\n            // Reset the session's SDH re-INVITE modifiers.\n            // Note that if the modifiers are not reset, they will be applied\n            // to the SDP answer as well (which we do not want in this case).\n            session.sessionDescriptionHandlerModifiersReInvite = [];\n            this.enableSenderTracks(!hold); // mute/unmute\n        })\n            .catch((error) => {\n            if (error instanceof RequestPendingError) {\n                this.logger.error(`[${this.id}] A hold request is already in progress.`);\n            }\n            throw error;\n        });\n    }\n    /**\n     * Puts Session on mute.\n     * @param mute - Mute on if true, off if false.\n     */\n    setMute(mute) {\n        if (!this.session) {\n            this.logger.warn(`[${this.id}] A session is required to enabled/disable media tracks`);\n            return;\n        }\n        if (this.session.state !== SessionState.Established) {\n            this.logger.warn(`[${this.id}] An established session is required to enable/disable media tracks`);\n            return;\n        }\n        this.enableSenderTracks(!mute);\n    }\n    /** Helper function to attach local media to html elements. */\n    setupLocalMedia() {\n        var _a, _b;\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const mediaElement = (_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.local) === null || _b === void 0 ? void 0 : _b.video;\n        if (mediaElement) {\n            const localStream = this.localMediaStream;\n            if (!localStream) {\n                throw new Error(\"Local media stream undefiend.\");\n            }\n            mediaElement.srcObject = localStream;\n            mediaElement.volume = 0;\n            mediaElement.play().catch((error) => {\n                this.logger.error(`[${this.id}] Failed to play local media`);\n                this.logger.error(error.message);\n            });\n        }\n    }\n    /** Helper function to attach remote media to html elements. */\n    setupRemoteMedia() {\n        var _a, _b, _c, _d;\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const mediaElement = ((_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.video) || ((_d = (_c = this.options.media) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.audio);\n        if (mediaElement) {\n            const remoteStream = this.remoteMediaStream;\n            if (!remoteStream) {\n                throw new Error(\"Remote media stream undefiend.\");\n            }\n            mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action\n            mediaElement.srcObject = remoteStream;\n            mediaElement.play().catch((error) => {\n                this.logger.error(`[${this.id}] Failed to play remote media`);\n                this.logger.error(error.message);\n            });\n            remoteStream.onaddtrack = () => {\n                this.logger.log(`[${this.id}] Remote media onaddtrack`);\n                mediaElement.load(); // Safari hack, as it doesn't work otheriwse\n                mediaElement.play().catch((error) => {\n                    this.logger.error(`[${this.id}] Failed to play remote media`);\n                    this.logger.error(error.message);\n                });\n            };\n        }\n    }\n    /**\n     * End a session.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when Session is terminated.\n     */\n    terminate() {\n        this.logger.log(`[${this.id}] Terminating...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        switch (this.session.state) {\n            case SessionState.Initial:\n                if (this.session instanceof Inviter) {\n                    return this.session.cancel().then(() => {\n                        this.logger.log(`[${this.id}] Inviter never sent INVITE (canceled)`);\n                    });\n                }\n                else if (this.session instanceof Invitation) {\n                    return this.session.reject().then(() => {\n                        this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n                    });\n                }\n                else {\n                    throw new Error(\"Unknown session type.\");\n                }\n            case SessionState.Establishing:\n                if (this.session instanceof Inviter) {\n                    return this.session.cancel().then(() => {\n                        this.logger.log(`[${this.id}] Inviter canceled (sent CANCEL)`);\n                    });\n                }\n                else if (this.session instanceof Invitation) {\n                    return this.session.reject().then(() => {\n                        this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n                    });\n                }\n                else {\n                    throw new Error(\"Unknown session type.\");\n                }\n            case SessionState.Established:\n                return this.session.bye().then(() => {\n                    this.logger.log(`[${this.id}] Session ended (sent BYE)`);\n                });\n            case SessionState.Terminating:\n                break;\n            case SessionState.Terminated:\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        this.logger.log(`[${this.id}] Terminating in state ${this.session.state}, no action taken`);\n        return Promise.resolve();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}