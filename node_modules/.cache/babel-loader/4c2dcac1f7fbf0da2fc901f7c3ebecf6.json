{"ast":null,"code":"import { C, getBody, IncomingRequestMessage, IncomingResponseMessage, isBody, NameAddrHeader, OutgoingRequestMessage } from \"../messages\";\nimport { SessionState, SignalingState } from \"../session\";\nimport { Timers } from \"../timers\";\nimport { InviteClientTransaction, InviteServerTransaction, TransactionState } from \"../transactions\";\nimport { ByeUserAgentClient } from \"../user-agents/bye-user-agent-client\";\nimport { ByeUserAgentServer } from \"../user-agents/bye-user-agent-server\";\nimport { InfoUserAgentClient } from \"../user-agents/info-user-agent-client\";\nimport { InfoUserAgentServer } from \"../user-agents/info-user-agent-server\";\nimport { MessageUserAgentClient } from \"../user-agents/message-user-agent-client\";\nimport { MessageUserAgentServer } from \"../user-agents/message-user-agent-server\";\nimport { NotifyUserAgentClient } from \"../user-agents/notify-user-agent-client\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { PrackUserAgentClient } from \"../user-agents/prack-user-agent-client\";\nimport { PrackUserAgentServer } from \"../user-agents/prack-user-agent-server\";\nimport { ReInviteUserAgentClient } from \"../user-agents/re-invite-user-agent-client\";\nimport { ReInviteUserAgentServer } from \"../user-agents/re-invite-user-agent-server\";\nimport { ReferUserAgentClient } from \"../user-agents/refer-user-agent-client\";\nimport { ReferUserAgentServer } from \"../user-agents/refer-user-agent-server\";\nimport { Dialog } from \"./dialog\";\n/**\n * Session Dialog.\n * @public\n */\n\nexport class SessionDialog extends Dialog {\n  constructor(initialTransaction, core, state, delegate) {\n    super(core, state);\n    this.initialTransaction = initialTransaction;\n    /** The state of the offer/answer exchange. */\n\n    this._signalingState = SignalingState.Initial;\n    /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */\n\n    this.ackWait = false;\n    /** True if processing an ACK to the initial transaction 2xx (UAS only). */\n\n    this.ackProcessing = false;\n    this.delegate = delegate;\n\n    if (initialTransaction instanceof InviteServerTransaction) {\n      // If we're created by an invite server transaction, we're\n      // going to be waiting for an ACK if are to be confirmed.\n      this.ackWait = true;\n    } // If we're confirmed upon creation start the retransmitting whatever\n    // the 2xx final response was that confirmed us into existence.\n\n\n    if (!this.early) {\n      this.start2xxRetransmissionTimer();\n    }\n\n    this.signalingStateTransition(initialTransaction.request);\n    this.logger = core.loggerFactory.getLogger(\"sip.invite-dialog\");\n    this.logger.log(`INVITE dialog ${this.id} constructed`);\n  }\n\n  dispose() {\n    super.dispose();\n    this._signalingState = SignalingState.Closed;\n    this._offer = undefined;\n    this._answer = undefined;\n\n    if (this.invite2xxTimer) {\n      clearTimeout(this.invite2xxTimer);\n      this.invite2xxTimer = undefined;\n    } // The UAS MUST still respond to any pending requests received for that\n    // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n    // be generated to those pending requests.\n    // https://tools.ietf.org/html/rfc3261#section-15.1.2\n    // TODO:\n    // this.userAgentServers.forEach((uas) => uas.reply(487));\n\n\n    this.logger.log(`INVITE dialog ${this.id} destroyed`);\n  } // FIXME: Need real state machine\n\n\n  get sessionState() {\n    if (this.early) {\n      return SessionState.Early;\n    } else if (this.ackWait) {\n      return SessionState.AckWait;\n    } else if (this._signalingState === SignalingState.Closed) {\n      return SessionState.Terminated;\n    } else {\n      return SessionState.Confirmed;\n    }\n  }\n  /** The state of the offer/answer exchange. */\n\n\n  get signalingState() {\n    return this._signalingState;\n  }\n  /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */\n\n\n  get offer() {\n    return this._offer;\n  }\n  /** The current answer. Undefined unless signaling state Stable. */\n\n\n  get answer() {\n    return this._answer;\n  }\n  /** Confirm the dialog. Only matters if dialog is currently early. */\n\n\n  confirm() {\n    // When we're confirmed start the retransmitting whatever\n    // the 2xx final response that may have confirmed us.\n    if (this.early) {\n      this.start2xxRetransmissionTimer();\n    }\n\n    super.confirm();\n  }\n  /** Re-confirm the dialog. Only matters if handling re-INVITE request. */\n\n\n  reConfirm() {\n    // When we're confirmed start the retransmitting whatever\n    // the 2xx final response that may have confirmed us.\n    if (this.reinviteUserAgentServer) {\n      this.startReInvite2xxRetransmissionTimer();\n    }\n  }\n  /**\n   * The UAC core MUST generate an ACK request for each 2xx received from\n   * the transaction layer.  The header fields of the ACK are constructed\n   * in the same way as for any request sent within a dialog (see Section\n   * 12) with the exception of the CSeq and the header fields related to\n   * authentication.  The sequence number of the CSeq header field MUST be\n   * the same as the INVITE being acknowledged, but the CSeq method MUST\n   * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n   * the 2xx contains an offer (based on the rules above), the ACK MUST\n   * carry an answer in its body.  If the offer in the 2xx response is not\n   * acceptable, the UAC core MUST generate a valid answer in the ACK and\n   * then send a BYE immediately.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n   * @param options - ACK options bucket.\n   */\n\n\n  ack(options = {}) {\n    this.logger.log(`INVITE dialog ${this.id} sending ACK request`);\n    let transaction;\n\n    if (this.reinviteUserAgentClient) {\n      // We're sending ACK for a re-INVITE\n      if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction)) {\n        throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n      }\n\n      transaction = this.reinviteUserAgentClient.transaction;\n      this.reinviteUserAgentClient = undefined;\n    } else {\n      // We're sending ACK for the initial INVITE\n      if (!(this.initialTransaction instanceof InviteClientTransaction)) {\n        throw new Error(\"Initial transaction not instance of InviteClientTransaction.\");\n      }\n\n      transaction = this.initialTransaction;\n    }\n\n    const message = this.createOutgoingRequestMessage(C.ACK, {\n      cseq: transaction.request.cseq,\n      extraHeaders: options.extraHeaders,\n      body: options.body\n    });\n    transaction.ackResponse(message); // See InviteClientTransaction for details.\n\n    this.signalingStateTransition(message);\n    return {\n      message\n    };\n  }\n  /**\n   * Terminating a Session\n   *\n   * This section describes the procedures for terminating a session\n   * established by SIP.  The state of the session and the state of the\n   * dialog are very closely related.  When a session is initiated with an\n   * INVITE, each 1xx or 2xx response from a distinct UAS creates a\n   * dialog, and if that response completes the offer/answer exchange, it\n   * also creates a session.  As a result, each session is \"associated\"\n   * with a single dialog - the one which resulted in its creation.  If an\n   * initial INVITE generates a non-2xx final response, that terminates\n   * all sessions (if any) and all dialogs (if any) that were created\n   * through responses to the request.  By virtue of completing the\n   * transaction, a non-2xx final response also prevents further sessions\n   * from being created as a result of the INVITE.  The BYE request is\n   * used to terminate a specific session or attempted session.  In this\n   * case, the specific session is the one with the peer UA on the other\n   * side of the dialog.  When a BYE is received on a dialog, any session\n   * associated with that dialog SHOULD terminate.  A UA MUST NOT send a\n   * BYE outside of a dialog.  The caller's UA MAY send a BYE for either\n   * confirmed or early dialogs, and the callee's UA MAY send a BYE on\n   * confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n   *\n   * However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n   * until it has received an ACK for its 2xx response or until the server\n   * transaction times out.  If no SIP extensions have defined other\n   * application layer states associated with the dialog, the BYE also\n   * terminates the dialog.\n   *\n   * https://tools.ietf.org/html/rfc3261#section-15\n   * FIXME: Make these proper Exceptions...\n   * @param options - BYE options bucket.\n   * @returns\n   * Throws `Error` if callee's UA attempts a BYE on an early dialog.\n   * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog\n   *                while it's waiting on the ACK for its 2xx response.\n   */\n\n\n  bye(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending BYE request`); // The caller's UA MAY send a BYE for either\n    // confirmed or early dialogs, and the callee's UA MAY send a BYE on\n    // confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n    //\n    // However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n    // until it has received an ACK for its 2xx response or until the server\n    // transaction times out.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n    if (this.initialTransaction instanceof InviteServerTransaction) {\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"UAS MUST NOT send a BYE on early dialogs.\");\n      }\n\n      if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"UAS MUST NOT send a BYE on a confirmed dialog \" + \"until it has received an ACK for its 2xx response \" + \"or until the server transaction times out.\");\n      }\n    } // A BYE request is constructed as would any other request within a\n    // dialog, as described in Section 12.\n    //\n    // Once the BYE is constructed, the UAC core creates a new non-INVITE\n    // client transaction, and passes it the BYE request.  The UAC MUST\n    // consider the session terminated (and therefore stop sending or\n    // listening for media) as soon as the BYE request is passed to the\n    // client transaction.  If the response for the BYE is a 481\n    // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no\n    // response at all is received for the BYE (that is, a timeout is\n    // returned by the client transaction), the UAC MUST consider the\n    // session and the dialog terminated.\n    // https://tools.ietf.org/html/rfc3261#section-15.1.1\n\n\n    return new ByeUserAgentClient(this, delegate, options);\n  }\n  /**\n   * An INFO request can be associated with an Info Package (see\n   * Section 5), or associated with a legacy INFO usage (see Section 2).\n   *\n   * The construction of the INFO request is the same as any other\n   * non-target refresh request within an existing invite dialog usage as\n   * described in Section 12.2 of RFC 3261.\n   * https://tools.ietf.org/html/rfc6086#section-4.2.1\n   * @param options - Options bucket.\n   */\n\n\n  info(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending INFO request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    return new InfoUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Modifying an Existing Session\n   *\n   * A successful INVITE request (see Section 13) establishes both a\n   * dialog between two user agents and a session using the offer-answer\n   * model.  Section 12 explains how to modify an existing dialog using a\n   * target refresh request (for example, changing the remote target URI\n   * of the dialog).  This section describes how to modify the actual\n   * session.  This modification can involve changing addresses or ports,\n   * adding a media stream, deleting a media stream, and so on.  This is\n   * accomplished by sending a new INVITE request within the same dialog\n   * that established the session.  An INVITE request sent within an\n   * existing dialog is known as a re-INVITE.\n   *\n   *    Note that a single re-INVITE can modify the dialog and the\n   *    parameters of the session at the same time.\n   *\n   * Either the caller or callee can modify an existing session.\n   * https://tools.ietf.org/html/rfc3261#section-14\n   * @param options - Options bucket\n   */\n\n\n  invite(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    } // Note that a UAC MUST NOT initiate a new INVITE transaction within a\n    // dialog while another INVITE transaction is in progress in either\n    // direction.\n    //\n    //    1. If there is an ongoing INVITE client transaction, the TU MUST\n    //       wait until the transaction reaches the completed or terminated\n    //       state before initiating the new INVITE.\n    //\n    //    2. If there is an ongoing INVITE server transaction, the TU MUST\n    //       wait until the transaction reaches the confirmed or terminated\n    //       state before initiating the new INVITE.\n    //\n    // However, a UA MAY initiate a regular transaction while an INVITE\n    // transaction is in progress.  A UA MAY also initiate an INVITE\n    // transaction while a regular transaction is in progress.\n    // https://tools.ietf.org/html/rfc3261#section-14.1\n\n\n    if (this.reinviteUserAgentClient) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"There is an ongoing re-INVITE client transaction.\");\n    }\n\n    if (this.reinviteUserAgentServer) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"There is an ongoing re-INVITE server transaction.\");\n    }\n\n    return new ReInviteUserAgentClient(this, delegate, options);\n  }\n  /**\n   * A UAC MAY associate a MESSAGE request with an existing dialog.  If a\n   * MESSAGE request is sent within a dialog, it is \"associated\" with any\n   * media session or sessions associated with that dialog.\n   * https://tools.ietf.org/html/rfc3428#section-4\n   * @param options - Options bucket.\n   */\n\n\n  message(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    const message = this.createOutgoingRequestMessage(C.MESSAGE, options);\n    return new MessageUserAgentClient(this.core, message, delegate);\n  }\n  /**\n   * The NOTIFY mechanism defined in [2] MUST be used to inform the agent\n   * sending the REFER of the status of the reference.\n   * https://tools.ietf.org/html/rfc3515#section-2.4.4\n   * @param options - Options bucket.\n   */\n\n\n  notify(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    return new NotifyUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Assuming the response is to be transmitted reliably, the UAC MUST\n   * create a new request with method PRACK.  This request is sent within\n   * the dialog associated with the provisional response (indeed, the\n   * provisional response may have created the dialog).  PRACK requests\n   * MAY contain bodies, which are interpreted according to their type and\n   * disposition.\n   * https://tools.ietf.org/html/rfc3262#section-4\n   * @param options - Options bucket.\n   */\n\n\n  prack(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);\n    return new PrackUserAgentClient(this, delegate, options);\n  }\n  /**\n   * REFER is a SIP request and is constructed as defined in [1].  A REFER\n   * request MUST contain exactly one Refer-To header field value.\n   * https://tools.ietf.org/html/rfc3515#section-2.4.1\n   * @param options - Options bucket.\n   */\n\n\n  refer(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending REFER request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    } // FIXME: TODO: Validate Refer-To header field value.\n\n\n    return new ReferUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Requests sent within a dialog, as any other requests, are atomic.  If\n   * a particular request is accepted by the UAS, all the state changes\n   * associated with it are performed.  If the request is rejected, none\n   * of the state changes are performed.\n   * https://tools.ietf.org/html/rfc3261#section-12.2.2\n   * @param message - Incoming request message within this dialog.\n   */\n\n\n  receiveRequest(message) {\n    this.logger.log(`INVITE dialog ${this.id} received ${message.method} request`); // Response retransmissions cease when an ACK request for the\n    // response is received.  This is independent of whatever transport\n    // protocols are used to send the response.\n    // https://tools.ietf.org/html/rfc6026#section-8.1\n\n    if (message.method === C.ACK) {\n      // If ackWait is true, then this is the ACK to the initial INVITE,\n      // otherwise this is an ACK to an in dialog INVITE. In either case,\n      // guard to make sure the sequence number of the ACK matches the INVITE.\n      if (this.ackWait) {\n        if (this.initialTransaction instanceof InviteClientTransaction) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        if (this.initialTransaction.request.cseq !== message.cseq) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        } // Update before the delegate has a chance to handle the\n        // message as delegate may callback into this dialog.\n\n\n        this.ackWait = false;\n      } else {\n        if (!this.reinviteUserAgentServer) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        this.reinviteUserAgentServer = undefined;\n      }\n\n      this.signalingStateTransition(message);\n\n      if (this.delegate && this.delegate.onAck) {\n        const promiseOrVoid = this.delegate.onAck({\n          message\n        });\n\n        if (promiseOrVoid instanceof Promise) {\n          this.ackProcessing = true; // make sure this is always reset to false\n\n          promiseOrVoid.then(() => this.ackProcessing = false).catch(() => this.ackProcessing = false);\n        }\n      }\n\n      return;\n    } // Request within a dialog out of sequence guard.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    if (!this.sequenceGuard(message)) {\n      this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message.method} request.`);\n      return;\n    } // Request within a dialog common processing.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    super.receiveRequest(message); // Handle various INVITE related cross-over, glare and race conditions\n\n    if (message.method === C.INVITE) {\n      // Hopefully this message is helpful...\n      const warning = () => {\n        const reason = this.ackWait ? \"waiting for initial ACK\" : \"processing initial ACK\";\n        this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);\n        let msg = \"RFC 5407 suggests the following to avoid this race condition... \";\n        msg += \" Note: Implementation issues are outside the scope of this document,\";\n        msg += \" but the following tip is provided for avoiding race conditions of\";\n        msg += \" this type.  The caller can delay sending re-INVITE F6 for some period\";\n        msg += \" of time (2 seconds, perhaps), after which the caller can reasonably\";\n        msg += \" assume that its ACK has been received.  Implementors can decouple the\";\n        msg += \" actions of the user (e.g., pressing the hold button) from the actions\";\n        msg += \" of the protocol (the sending of re-INVITE F6), so that the UA can\";\n        msg += \" behave like this.  In this case, it is the implementor's choice as to\";\n        msg += \" how long to wait.  In most cases, such an implementation may be\";\n        msg += \" useful to prevent the type of race condition shown in this section.\";\n        msg += \" This document expresses no preference about whether or not they\";\n        msg += \" should wait for an ACK to be delivered.  After considering the impact\";\n        msg += \" on user experience, implementors should decide whether or not to wait\";\n        msg += \" for a while, because the user experience depends on the\";\n        msg += \" implementation and has no direct bearing on protocol behavior.\";\n        this.logger.warn(msg);\n        return; // drop re-INVITE request message\n      }; // A UAS that receives a second INVITE before it sends the final\n      // response to a first INVITE with a lower CSeq sequence number on the\n      // same dialog MUST return a 500 (Server Internal Error) response to the\n      // second INVITE and MUST include a Retry-After header field with a\n      // randomly chosen value of between 0 and 10 seconds.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      const retryAfter = Math.floor(Math.random() * 10) + 1;\n      const extraHeaders = [`Retry-After: ${retryAfter}`]; // There may be ONLY ONE offer/answer negotiation in progress for a\n      // single dialog at any point in time.  Section 4 explains how to ensure\n      // this.\n      // https://tools.ietf.org/html/rfc6337#section-2.2\n\n      if (this.ackProcessing) {\n        // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n        //           transaction associated with an offer/answer is incomplete,\n        //           a UA must reject another INVITE request with a 500\n        //           response.\n        // https://tools.ietf.org/html/rfc6337#section-4.3\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        warning();\n        return;\n      } // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the\n      // Moratorium State (Case 1)\n      // https://tools.ietf.org/html/rfc5407#section-3.1.4\n      // 3.1.5.  Callee Receives re-INVITE (Established State) While in the\n      // Moratorium State (Case 2)\n      // https://tools.ietf.org/html/rfc5407#section-3.1.5\n\n\n      if (this.ackWait && this.signalingState !== SignalingState.Stable) {\n        // This scenario is basically the same as that of Section 3.1.4, but\n        // differs in sending an offer in the 200 and an answer in the ACK.  In\n        // contrast to the previous case, the offer in the 200 (F3) and the\n        // offer in the re-INVITE (F6) collide with each other.\n        //\n        // Bob sends a 491 to the re-INVITE (F6) since he is not able to\n        // properly handle a new request until he receives an answer.  (Note:\n        // 500 with a Retry-After header may be returned if the 491 response is\n        // understood to indicate request collision.  However, 491 is\n        // recommended here because 500 applies to so many cases that it is\n        // difficult to determine what the real problem was.)\n        // https://tools.ietf.org/html/rfc5407#section-3.1.5\n        // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n        //           transaction associated with an offer/answer is incomplete,\n        //           a UA must reject another INVITE request with a 500\n        //           response.\n        // https://tools.ietf.org/html/rfc6337#section-4.3\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        warning();\n        return;\n      } // A UAS that receives a second INVITE before it sends the final\n      // response to a first INVITE with a lower CSeq sequence number on the\n      // same dialog MUST return a 500 (Server Internal Error) response to the\n      // second INVITE and MUST include a Retry-After header field with a\n      // randomly chosen value of between 0 and 10 seconds.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      if (this.reinviteUserAgentServer) {\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        return;\n      } // A UAS that receives an INVITE on a dialog while an INVITE it had sent\n      // on that dialog is in progress MUST return a 491 (Request Pending)\n      // response to the received INVITE.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      if (this.reinviteUserAgentClient) {\n        this.core.replyStateless(message, {\n          statusCode: 491\n        });\n        return;\n      }\n    } // Requests within a dialog MAY contain Record-Route and Contact header\n    // fields.  However, these requests do not cause the dialog's route set\n    // to be modified, although they may modify the remote target URI.\n    // Specifically, requests that are not target refresh requests do not\n    // modify the dialog's remote target URI, and requests that are target\n    // refresh requests do.  For dialogs that have been established with an\n    // INVITE, the only target refresh request defined is re-INVITE (see\n    // Section 14).  Other extensions may define different target refresh\n    // requests for dialogs established in other ways.\n    //\n    //    Note that an ACK is NOT a target refresh request.\n    //\n    // Target refresh requests only update the dialog's remote target URI,\n    // and not the route set formed from the Record-Route.  Updating the\n    // latter would introduce severe backwards compatibility problems with\n    // RFC 2543-compliant systems.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n\n    if (message.method === C.INVITE) {\n      // FIXME: parser needs to be typed...\n      const contact = message.parseHeader(\"contact\");\n\n      if (!contact) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Contact undefined.\");\n      }\n\n      if (!(contact instanceof NameAddrHeader)) {\n        throw new Error(\"Contact not instance of NameAddrHeader.\");\n      }\n\n      this.dialogState.remoteTarget = contact.uri;\n    } // Switch on method and then delegate.\n\n\n    switch (message.method) {\n      case C.BYE:\n        // A UAS core receiving a BYE request for an existing dialog MUST follow\n        // the procedures of Section 12.2.2 to process the request.  Once done,\n        // the UAS SHOULD terminate the session (and therefore stop sending and\n        // listening for media).  The only case where it can elect not to are\n        // multicast sessions, where participation is possible even if the other\n        // participant in the dialog has terminated its involvement in the\n        // session.  Whether or not it ends its participation on the session,\n        // the UAS core MUST generate a 2xx response to the BYE, and MUST pass\n        // that to the server transaction for transmission.\n        //\n        // The UAS MUST still respond to any pending requests received for that\n        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n        // be generated to those pending requests.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.2\n        {\n          const uas = new ByeUserAgentServer(this, message);\n          this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();\n          this.dispose();\n        }\n        break;\n\n      case C.INFO:\n        // If a UA receives an INFO request associated with an Info Package that\n        // the UA has not indicated willingness to receive, the UA MUST send a\n        // 469 (Bad Info Package) response (see Section 11.6), which contains a\n        // Recv-Info header field with Info Packages for which the UA is willing\n        // to receive INFO requests.\n        {\n          const uas = new InfoUserAgentServer(this, message);\n          this.delegate && this.delegate.onInfo ? this.delegate.onInfo(uas) : uas.reject({\n            statusCode: 469,\n            extraHeaders: [\"Recv-Info :\"]\n          });\n        }\n        break;\n\n      case C.INVITE:\n        // If the new session description is not acceptable, the UAS can reject\n        // it by returning a 488 (Not Acceptable Here) response for the re-\n        // INVITE.  This response SHOULD include a Warning header field.\n        // https://tools.ietf.org/html/rfc3261#section-14.2\n        {\n          const uas = new ReInviteUserAgentServer(this, message);\n          this.signalingStateTransition(message);\n          this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({\n            statusCode: 488\n          }); // TODO: Warning header field.\n        }\n        break;\n\n      case C.MESSAGE:\n        {\n          const uas = new MessageUserAgentServer(this.core, message);\n          this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n        }\n        break;\n\n      case C.NOTIFY:\n        // https://tools.ietf.org/html/rfc3515#section-2.4.4\n        {\n          const uas = new NotifyUserAgentServer(this, message);\n          this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();\n        }\n        break;\n\n      case C.PRACK:\n        // https://tools.ietf.org/html/rfc3262#section-4\n        {\n          const uas = new PrackUserAgentServer(this, message);\n          this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();\n        }\n        break;\n\n      case C.REFER:\n        // https://tools.ietf.org/html/rfc3515#section-2.4.2\n        {\n          const uas = new ReferUserAgentServer(this, message);\n          this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();\n        }\n        break;\n\n      default:\n        {\n          this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message.method} request`);\n          this.core.replyStateless(message, {\n            statusCode: 501\n          });\n        }\n        break;\n    }\n  }\n  /**\n   * Guard against out of order reliable provisional responses and retransmissions.\n   * Returns false if the response should be discarded, otherwise true.\n   * @param message - Incoming response message within this dialog.\n   */\n\n\n  reliableSequenceGuard(message) {\n    const statusCode = message.statusCode;\n\n    if (!statusCode) {\n      throw new Error(\"Status code undefined\");\n    }\n\n    if (statusCode > 100 && statusCode < 200) {\n      // If a provisional response is received for an initial request, and\n      // that response contains a Require header field containing the option\n      // tag 100rel, the response is to be sent reliably.  If the response is\n      // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n      // ignored, and the procedures below MUST NOT be used.\n      // https://tools.ietf.org/html/rfc3262#section-4\n      const requireHeader = message.getHeader(\"require\");\n      const rseqHeader = message.getHeader(\"rseq\");\n      const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n\n      if (rseq) {\n        // Handling of subsequent reliable provisional responses for the same\n        // initial request follows the same rules as above, with the following\n        // difference: reliable provisional responses are guaranteed to be in\n        // order.  As a result, if the UAC receives another reliable provisional\n        // response to the same request, and its RSeq value is not one higher\n        // than the value of the sequence number, that response MUST NOT be\n        // acknowledged with a PRACK, and MUST NOT be processed further by the\n        // UAC.  An implementation MAY discard the response, or MAY cache the\n        // response in the hopes of receiving the missing responses.\n        // https://tools.ietf.org/html/rfc3262#section-4\n        if (this.rseq && this.rseq + 1 !== rseq) {\n          return false;\n        } // Once a reliable provisional response is received, retransmissions of\n        // that response MUST be discarded.  A response is a retransmission when\n        // its dialog ID, CSeq, and RSeq match the original response.  The UAC\n        // MUST maintain a sequence number that indicates the most recently\n        // received in-order reliable provisional response for the initial\n        // request.  This sequence number MUST be maintained until a final\n        // response is received for the initial request.  Its value MUST be\n        // initialized to the RSeq header field in the first reliable\n        // provisional response received for the initial request.\n        // https://tools.ietf.org/html/rfc3262#section-4\n\n\n        this.rseq = this.rseq ? this.rseq + 1 : rseq;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * If not in a stable signaling state, rollback to prior stable signaling state.\n   */\n\n\n  signalingStateRollback() {\n    if (this._signalingState === SignalingState.HaveLocalOffer || this.signalingState === SignalingState.HaveRemoteOffer) {\n      if (this._rollbackOffer && this._rollbackAnswer) {\n        this._signalingState = SignalingState.Stable;\n        this._offer = this._rollbackOffer;\n        this._answer = this._rollbackAnswer;\n      }\n    }\n  }\n  /**\n   * Update the signaling state of the dialog.\n   * @param message - The message to base the update off of.\n   */\n\n\n  signalingStateTransition(message) {\n    const body = getBody(message); // No body, no session. No, woman, no cry.\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return;\n    } // We've got an existing offer and answer which we may wish to rollback to\n\n\n    if (this._signalingState === SignalingState.Stable) {\n      this._rollbackOffer = this._offer;\n      this._rollbackAnswer = this._answer;\n    } // We're in UAS role, receiving incoming request with session description\n\n\n    if (message instanceof IncomingRequestMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveRemoteOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAC role, receiving incoming response with session description\n\n\n    if (message instanceof IncomingResponseMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveRemoteOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAC role, sending outgoing request with session description\n\n\n    if (message instanceof OutgoingRequestMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveLocalOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAS role, sending outgoing response with session description\n\n\n    if (isBody(message)) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveLocalOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    }\n  }\n\n  start2xxRetransmissionTimer() {\n    if (this.initialTransaction instanceof InviteServerTransaction) {\n      const transaction = this.initialTransaction; // Once the response has been constructed, it is passed to the INVITE\n      // server transaction.  In order to ensure reliable end-to-end\n      // transport of the response, it is necessary to periodically pass\n      // the response directly to the transport until the ACK arrives.  The\n      // 2xx response is passed to the transport with an interval that\n      // starts at T1 seconds and doubles for each retransmission until it\n      // reaches T2 seconds (T1 and T2 are defined in Section 17).\n      // Response retransmissions cease when an ACK request for the\n      // response is received.  This is independent of whatever transport\n      // protocols are used to send the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.1\n\n      let timeout = Timers.T1;\n\n      const retransmission = () => {\n        if (!this.ackWait) {\n          this.invite2xxTimer = undefined;\n          return;\n        }\n\n        this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n        transaction.retransmitAcceptedResponse();\n        timeout = Math.min(timeout * 2, Timers.T2);\n        this.invite2xxTimer = setTimeout(retransmission, timeout);\n      };\n\n      this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n      // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n      // terminated.  This is accomplished with a BYE, as described in Section 15.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n      const stateChanged = () => {\n        if (transaction.state === TransactionState.Terminated) {\n          transaction.removeStateChangeListener(stateChanged);\n\n          if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n          }\n\n          if (this.ackWait) {\n            if (this.delegate && this.delegate.onAckTimeout) {\n              this.delegate.onAckTimeout();\n            } else {\n              this.bye();\n            }\n          }\n        }\n      };\n\n      transaction.addStateChangeListener(stateChanged);\n    }\n  } // FIXME: Refactor\n\n\n  startReInvite2xxRetransmissionTimer() {\n    if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction) {\n      const transaction = this.reinviteUserAgentServer.transaction; // Once the response has been constructed, it is passed to the INVITE\n      // server transaction.  In order to ensure reliable end-to-end\n      // transport of the response, it is necessary to periodically pass\n      // the response directly to the transport until the ACK arrives.  The\n      // 2xx response is passed to the transport with an interval that\n      // starts at T1 seconds and doubles for each retransmission until it\n      // reaches T2 seconds (T1 and T2 are defined in Section 17).\n      // Response retransmissions cease when an ACK request for the\n      // response is received.  This is independent of whatever transport\n      // protocols are used to send the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.1\n\n      let timeout = Timers.T1;\n\n      const retransmission = () => {\n        if (!this.reinviteUserAgentServer) {\n          this.invite2xxTimer = undefined;\n          return;\n        }\n\n        this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n        transaction.retransmitAcceptedResponse();\n        timeout = Math.min(timeout * 2, Timers.T2);\n        this.invite2xxTimer = setTimeout(retransmission, timeout);\n      };\n\n      this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n      // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n      // terminated.  This is accomplished with a BYE, as described in Section 15.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n      const stateChanged = () => {\n        if (transaction.state === TransactionState.Terminated) {\n          transaction.removeStateChangeListener(stateChanged);\n\n          if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n          }\n\n          if (this.reinviteUserAgentServer) {// FIXME: TODO: What to do here\n          }\n        }\n      };\n\n      transaction.addStateChangeListener(stateChanged);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/session-dialog.js"],"names":["C","getBody","IncomingRequestMessage","IncomingResponseMessage","isBody","NameAddrHeader","OutgoingRequestMessage","SessionState","SignalingState","Timers","InviteClientTransaction","InviteServerTransaction","TransactionState","ByeUserAgentClient","ByeUserAgentServer","InfoUserAgentClient","InfoUserAgentServer","MessageUserAgentClient","MessageUserAgentServer","NotifyUserAgentClient","NotifyUserAgentServer","PrackUserAgentClient","PrackUserAgentServer","ReInviteUserAgentClient","ReInviteUserAgentServer","ReferUserAgentClient","ReferUserAgentServer","Dialog","SessionDialog","constructor","initialTransaction","core","state","delegate","_signalingState","Initial","ackWait","ackProcessing","early","start2xxRetransmissionTimer","signalingStateTransition","request","logger","loggerFactory","getLogger","log","id","dispose","Closed","_offer","undefined","_answer","invite2xxTimer","clearTimeout","sessionState","Early","AckWait","Terminated","Confirmed","signalingState","offer","answer","confirm","reConfirm","reinviteUserAgentServer","startReInvite2xxRetransmissionTimer","ack","options","transaction","reinviteUserAgentClient","Error","message","createOutgoingRequestMessage","ACK","cseq","extraHeaders","body","ackResponse","bye","info","invite","MESSAGE","notify","prack","refer","receiveRequest","method","warn","onAck","promiseOrVoid","Promise","then","catch","sequenceGuard","INVITE","warning","reason","msg","retryAfter","Math","floor","random","replyStateless","statusCode","Stable","contact","parseHeader","dialogState","remoteTarget","uri","BYE","uas","onBye","accept","INFO","onInfo","reject","onInvite","onMessage","NOTIFY","onNotify","PRACK","onPrack","REFER","onRefer","reliableSequenceGuard","requireHeader","getHeader","rseqHeader","rseq","includes","Number","signalingStateRollback","HaveLocalOffer","HaveRemoteOffer","_rollbackOffer","_rollbackAnswer","contentDisposition","timeout","T1","retransmission","retransmitAcceptedResponse","min","T2","setTimeout","stateChanged","removeStateChangeListener","onAckTimeout","addStateChangeListener"],"mappings":"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","sourcesContent":["import { C, getBody, IncomingRequestMessage, IncomingResponseMessage, isBody, NameAddrHeader, OutgoingRequestMessage } from \"../messages\";\nimport { SessionState, SignalingState } from \"../session\";\nimport { Timers } from \"../timers\";\nimport { InviteClientTransaction, InviteServerTransaction, TransactionState } from \"../transactions\";\nimport { ByeUserAgentClient } from \"../user-agents/bye-user-agent-client\";\nimport { ByeUserAgentServer } from \"../user-agents/bye-user-agent-server\";\nimport { InfoUserAgentClient } from \"../user-agents/info-user-agent-client\";\nimport { InfoUserAgentServer } from \"../user-agents/info-user-agent-server\";\nimport { MessageUserAgentClient } from \"../user-agents/message-user-agent-client\";\nimport { MessageUserAgentServer } from \"../user-agents/message-user-agent-server\";\nimport { NotifyUserAgentClient } from \"../user-agents/notify-user-agent-client\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { PrackUserAgentClient } from \"../user-agents/prack-user-agent-client\";\nimport { PrackUserAgentServer } from \"../user-agents/prack-user-agent-server\";\nimport { ReInviteUserAgentClient } from \"../user-agents/re-invite-user-agent-client\";\nimport { ReInviteUserAgentServer } from \"../user-agents/re-invite-user-agent-server\";\nimport { ReferUserAgentClient } from \"../user-agents/refer-user-agent-client\";\nimport { ReferUserAgentServer } from \"../user-agents/refer-user-agent-server\";\nimport { Dialog } from \"./dialog\";\n/**\n * Session Dialog.\n * @public\n */\nexport class SessionDialog extends Dialog {\n    constructor(initialTransaction, core, state, delegate) {\n        super(core, state);\n        this.initialTransaction = initialTransaction;\n        /** The state of the offer/answer exchange. */\n        this._signalingState = SignalingState.Initial;\n        /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */\n        this.ackWait = false;\n        /** True if processing an ACK to the initial transaction 2xx (UAS only). */\n        this.ackProcessing = false;\n        this.delegate = delegate;\n        if (initialTransaction instanceof InviteServerTransaction) {\n            // If we're created by an invite server transaction, we're\n            // going to be waiting for an ACK if are to be confirmed.\n            this.ackWait = true;\n        }\n        // If we're confirmed upon creation start the retransmitting whatever\n        // the 2xx final response was that confirmed us into existence.\n        if (!this.early) {\n            this.start2xxRetransmissionTimer();\n        }\n        this.signalingStateTransition(initialTransaction.request);\n        this.logger = core.loggerFactory.getLogger(\"sip.invite-dialog\");\n        this.logger.log(`INVITE dialog ${this.id} constructed`);\n    }\n    dispose() {\n        super.dispose();\n        this._signalingState = SignalingState.Closed;\n        this._offer = undefined;\n        this._answer = undefined;\n        if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n        }\n        // The UAS MUST still respond to any pending requests received for that\n        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n        // be generated to those pending requests.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.2\n        // TODO:\n        // this.userAgentServers.forEach((uas) => uas.reply(487));\n        this.logger.log(`INVITE dialog ${this.id} destroyed`);\n    }\n    // FIXME: Need real state machine\n    get sessionState() {\n        if (this.early) {\n            return SessionState.Early;\n        }\n        else if (this.ackWait) {\n            return SessionState.AckWait;\n        }\n        else if (this._signalingState === SignalingState.Closed) {\n            return SessionState.Terminated;\n        }\n        else {\n            return SessionState.Confirmed;\n        }\n    }\n    /** The state of the offer/answer exchange. */\n    get signalingState() {\n        return this._signalingState;\n    }\n    /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */\n    get offer() {\n        return this._offer;\n    }\n    /** The current answer. Undefined unless signaling state Stable. */\n    get answer() {\n        return this._answer;\n    }\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    confirm() {\n        // When we're confirmed start the retransmitting whatever\n        // the 2xx final response that may have confirmed us.\n        if (this.early) {\n            this.start2xxRetransmissionTimer();\n        }\n        super.confirm();\n    }\n    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */\n    reConfirm() {\n        // When we're confirmed start the retransmitting whatever\n        // the 2xx final response that may have confirmed us.\n        if (this.reinviteUserAgentServer) {\n            this.startReInvite2xxRetransmissionTimer();\n        }\n    }\n    /**\n     * The UAC core MUST generate an ACK request for each 2xx received from\n     * the transaction layer.  The header fields of the ACK are constructed\n     * in the same way as for any request sent within a dialog (see Section\n     * 12) with the exception of the CSeq and the header fields related to\n     * authentication.  The sequence number of the CSeq header field MUST be\n     * the same as the INVITE being acknowledged, but the CSeq method MUST\n     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n     * the 2xx contains an offer (based on the rules above), the ACK MUST\n     * carry an answer in its body.  If the offer in the 2xx response is not\n     * acceptable, the UAC core MUST generate a valid answer in the ACK and\n     * then send a BYE immediately.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     * @param options - ACK options bucket.\n     */\n    ack(options = {}) {\n        this.logger.log(`INVITE dialog ${this.id} sending ACK request`);\n        let transaction;\n        if (this.reinviteUserAgentClient) {\n            // We're sending ACK for a re-INVITE\n            if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n            transaction = this.reinviteUserAgentClient.transaction;\n            this.reinviteUserAgentClient = undefined;\n        }\n        else {\n            // We're sending ACK for the initial INVITE\n            if (!(this.initialTransaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Initial transaction not instance of InviteClientTransaction.\");\n            }\n            transaction = this.initialTransaction;\n        }\n        const message = this.createOutgoingRequestMessage(C.ACK, {\n            cseq: transaction.request.cseq,\n            extraHeaders: options.extraHeaders,\n            body: options.body\n        });\n        transaction.ackResponse(message); // See InviteClientTransaction for details.\n        this.signalingStateTransition(message);\n        return { message };\n    }\n    /**\n     * Terminating a Session\n     *\n     * This section describes the procedures for terminating a session\n     * established by SIP.  The state of the session and the state of the\n     * dialog are very closely related.  When a session is initiated with an\n     * INVITE, each 1xx or 2xx response from a distinct UAS creates a\n     * dialog, and if that response completes the offer/answer exchange, it\n     * also creates a session.  As a result, each session is \"associated\"\n     * with a single dialog - the one which resulted in its creation.  If an\n     * initial INVITE generates a non-2xx final response, that terminates\n     * all sessions (if any) and all dialogs (if any) that were created\n     * through responses to the request.  By virtue of completing the\n     * transaction, a non-2xx final response also prevents further sessions\n     * from being created as a result of the INVITE.  The BYE request is\n     * used to terminate a specific session or attempted session.  In this\n     * case, the specific session is the one with the peer UA on the other\n     * side of the dialog.  When a BYE is received on a dialog, any session\n     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a\n     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either\n     * confirmed or early dialogs, and the callee's UA MAY send a BYE on\n     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n     *\n     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n     * until it has received an ACK for its 2xx response or until the server\n     * transaction times out.  If no SIP extensions have defined other\n     * application layer states associated with the dialog, the BYE also\n     * terminates the dialog.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-15\n     * FIXME: Make these proper Exceptions...\n     * @param options - BYE options bucket.\n     * @returns\n     * Throws `Error` if callee's UA attempts a BYE on an early dialog.\n     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog\n     *                while it's waiting on the ACK for its 2xx response.\n     */\n    bye(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending BYE request`);\n        // The caller's UA MAY send a BYE for either\n        // confirmed or early dialogs, and the callee's UA MAY send a BYE on\n        // confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n        //\n        // However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n        // until it has received an ACK for its 2xx response or until the server\n        // transaction times out.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        if (this.initialTransaction instanceof InviteServerTransaction) {\n            if (this.early) {\n                // FIXME: TODO: This should throw a proper exception.\n                throw new Error(\"UAS MUST NOT send a BYE on early dialogs.\");\n            }\n            if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {\n                // FIXME: TODO: This should throw a proper exception.\n                throw new Error(\"UAS MUST NOT send a BYE on a confirmed dialog \" +\n                    \"until it has received an ACK for its 2xx response \" +\n                    \"or until the server transaction times out.\");\n            }\n        }\n        // A BYE request is constructed as would any other request within a\n        // dialog, as described in Section 12.\n        //\n        // Once the BYE is constructed, the UAC core creates a new non-INVITE\n        // client transaction, and passes it the BYE request.  The UAC MUST\n        // consider the session terminated (and therefore stop sending or\n        // listening for media) as soon as the BYE request is passed to the\n        // client transaction.  If the response for the BYE is a 481\n        // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no\n        // response at all is received for the BYE (that is, a timeout is\n        // returned by the client transaction), the UAC MUST consider the\n        // session and the dialog terminated.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.1\n        return new ByeUserAgentClient(this, delegate, options);\n    }\n    /**\n     * An INFO request can be associated with an Info Package (see\n     * Section 5), or associated with a legacy INFO usage (see Section 2).\n     *\n     * The construction of the INFO request is the same as any other\n     * non-target refresh request within an existing invite dialog usage as\n     * described in Section 12.2 of RFC 3261.\n     * https://tools.ietf.org/html/rfc6086#section-4.2.1\n     * @param options - Options bucket.\n     */\n    info(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending INFO request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        return new InfoUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Modifying an Existing Session\n     *\n     * A successful INVITE request (see Section 13) establishes both a\n     * dialog between two user agents and a session using the offer-answer\n     * model.  Section 12 explains how to modify an existing dialog using a\n     * target refresh request (for example, changing the remote target URI\n     * of the dialog).  This section describes how to modify the actual\n     * session.  This modification can involve changing addresses or ports,\n     * adding a media stream, deleting a media stream, and so on.  This is\n     * accomplished by sending a new INVITE request within the same dialog\n     * that established the session.  An INVITE request sent within an\n     * existing dialog is known as a re-INVITE.\n     *\n     *    Note that a single re-INVITE can modify the dialog and the\n     *    parameters of the session at the same time.\n     *\n     * Either the caller or callee can modify an existing session.\n     * https://tools.ietf.org/html/rfc3261#section-14\n     * @param options - Options bucket\n     */\n    invite(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        // Note that a UAC MUST NOT initiate a new INVITE transaction within a\n        // dialog while another INVITE transaction is in progress in either\n        // direction.\n        //\n        //    1. If there is an ongoing INVITE client transaction, the TU MUST\n        //       wait until the transaction reaches the completed or terminated\n        //       state before initiating the new INVITE.\n        //\n        //    2. If there is an ongoing INVITE server transaction, the TU MUST\n        //       wait until the transaction reaches the confirmed or terminated\n        //       state before initiating the new INVITE.\n        //\n        // However, a UA MAY initiate a regular transaction while an INVITE\n        // transaction is in progress.  A UA MAY also initiate an INVITE\n        // transaction while a regular transaction is in progress.\n        // https://tools.ietf.org/html/rfc3261#section-14.1\n        if (this.reinviteUserAgentClient) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"There is an ongoing re-INVITE client transaction.\");\n        }\n        if (this.reinviteUserAgentServer) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"There is an ongoing re-INVITE server transaction.\");\n        }\n        return new ReInviteUserAgentClient(this, delegate, options);\n    }\n    /**\n     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a\n     * MESSAGE request is sent within a dialog, it is \"associated\" with any\n     * media session or sessions associated with that dialog.\n     * https://tools.ietf.org/html/rfc3428#section-4\n     * @param options - Options bucket.\n     */\n    message(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        const message = this.createOutgoingRequestMessage(C.MESSAGE, options);\n        return new MessageUserAgentClient(this.core, message, delegate);\n    }\n    /**\n     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent\n     * sending the REFER of the status of the reference.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.4\n     * @param options - Options bucket.\n     */\n    notify(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        return new NotifyUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Assuming the response is to be transmitted reliably, the UAC MUST\n     * create a new request with method PRACK.  This request is sent within\n     * the dialog associated with the provisional response (indeed, the\n     * provisional response may have created the dialog).  PRACK requests\n     * MAY contain bodies, which are interpreted according to their type and\n     * disposition.\n     * https://tools.ietf.org/html/rfc3262#section-4\n     * @param options - Options bucket.\n     */\n    prack(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);\n        return new PrackUserAgentClient(this, delegate, options);\n    }\n    /**\n     * REFER is a SIP request and is constructed as defined in [1].  A REFER\n     * request MUST contain exactly one Refer-To header field value.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.1\n     * @param options - Options bucket.\n     */\n    refer(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending REFER request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        // FIXME: TODO: Validate Refer-To header field value.\n        return new ReferUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n    receiveRequest(message) {\n        this.logger.log(`INVITE dialog ${this.id} received ${message.method} request`);\n        // Response retransmissions cease when an ACK request for the\n        // response is received.  This is independent of whatever transport\n        // protocols are used to send the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.1\n        if (message.method === C.ACK) {\n            // If ackWait is true, then this is the ACK to the initial INVITE,\n            // otherwise this is an ACK to an in dialog INVITE. In either case,\n            // guard to make sure the sequence number of the ACK matches the INVITE.\n            if (this.ackWait) {\n                if (this.initialTransaction instanceof InviteClientTransaction) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                if (this.initialTransaction.request.cseq !== message.cseq) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                // Update before the delegate has a chance to handle the\n                // message as delegate may callback into this dialog.\n                this.ackWait = false;\n            }\n            else {\n                if (!this.reinviteUserAgentServer) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                this.reinviteUserAgentServer = undefined;\n            }\n            this.signalingStateTransition(message);\n            if (this.delegate && this.delegate.onAck) {\n                const promiseOrVoid = this.delegate.onAck({ message });\n                if (promiseOrVoid instanceof Promise) {\n                    this.ackProcessing = true; // make sure this is always reset to false\n                    promiseOrVoid.then(() => (this.ackProcessing = false)).catch(() => (this.ackProcessing = false));\n                }\n            }\n            return;\n        }\n        // Request within a dialog out of sequence guard.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.sequenceGuard(message)) {\n            this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message.method} request.`);\n            return;\n        }\n        // Request within a dialog common processing.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        super.receiveRequest(message);\n        // Handle various INVITE related cross-over, glare and race conditions\n        if (message.method === C.INVITE) {\n            // Hopefully this message is helpful...\n            const warning = () => {\n                const reason = this.ackWait ? \"waiting for initial ACK\" : \"processing initial ACK\";\n                this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);\n                let msg = \"RFC 5407 suggests the following to avoid this race condition... \";\n                msg += \" Note: Implementation issues are outside the scope of this document,\";\n                msg += \" but the following tip is provided for avoiding race conditions of\";\n                msg += \" this type.  The caller can delay sending re-INVITE F6 for some period\";\n                msg += \" of time (2 seconds, perhaps), after which the caller can reasonably\";\n                msg += \" assume that its ACK has been received.  Implementors can decouple the\";\n                msg += \" actions of the user (e.g., pressing the hold button) from the actions\";\n                msg += \" of the protocol (the sending of re-INVITE F6), so that the UA can\";\n                msg += \" behave like this.  In this case, it is the implementor's choice as to\";\n                msg += \" how long to wait.  In most cases, such an implementation may be\";\n                msg += \" useful to prevent the type of race condition shown in this section.\";\n                msg += \" This document expresses no preference about whether or not they\";\n                msg += \" should wait for an ACK to be delivered.  After considering the impact\";\n                msg += \" on user experience, implementors should decide whether or not to wait\";\n                msg += \" for a while, because the user experience depends on the\";\n                msg += \" implementation and has no direct bearing on protocol behavior.\";\n                this.logger.warn(msg);\n                return; // drop re-INVITE request message\n            };\n            // A UAS that receives a second INVITE before it sends the final\n            // response to a first INVITE with a lower CSeq sequence number on the\n            // same dialog MUST return a 500 (Server Internal Error) response to the\n            // second INVITE and MUST include a Retry-After header field with a\n            // randomly chosen value of between 0 and 10 seconds.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            const retryAfter = Math.floor(Math.random() * 10) + 1;\n            const extraHeaders = [`Retry-After: ${retryAfter}`];\n            // There may be ONLY ONE offer/answer negotiation in progress for a\n            // single dialog at any point in time.  Section 4 explains how to ensure\n            // this.\n            // https://tools.ietf.org/html/rfc6337#section-2.2\n            if (this.ackProcessing) {\n                // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n                //           transaction associated with an offer/answer is incomplete,\n                //           a UA must reject another INVITE request with a 500\n                //           response.\n                // https://tools.ietf.org/html/rfc6337#section-4.3\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                warning();\n                return;\n            }\n            // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the\n            // Moratorium State (Case 1)\n            // https://tools.ietf.org/html/rfc5407#section-3.1.4\n            // 3.1.5.  Callee Receives re-INVITE (Established State) While in the\n            // Moratorium State (Case 2)\n            // https://tools.ietf.org/html/rfc5407#section-3.1.5\n            if (this.ackWait && this.signalingState !== SignalingState.Stable) {\n                // This scenario is basically the same as that of Section 3.1.4, but\n                // differs in sending an offer in the 200 and an answer in the ACK.  In\n                // contrast to the previous case, the offer in the 200 (F3) and the\n                // offer in the re-INVITE (F6) collide with each other.\n                //\n                // Bob sends a 491 to the re-INVITE (F6) since he is not able to\n                // properly handle a new request until he receives an answer.  (Note:\n                // 500 with a Retry-After header may be returned if the 491 response is\n                // understood to indicate request collision.  However, 491 is\n                // recommended here because 500 applies to so many cases that it is\n                // difficult to determine what the real problem was.)\n                // https://tools.ietf.org/html/rfc5407#section-3.1.5\n                // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n                //           transaction associated with an offer/answer is incomplete,\n                //           a UA must reject another INVITE request with a 500\n                //           response.\n                // https://tools.ietf.org/html/rfc6337#section-4.3\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                warning();\n                return;\n            }\n            // A UAS that receives a second INVITE before it sends the final\n            // response to a first INVITE with a lower CSeq sequence number on the\n            // same dialog MUST return a 500 (Server Internal Error) response to the\n            // second INVITE and MUST include a Retry-After header field with a\n            // randomly chosen value of between 0 and 10 seconds.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            if (this.reinviteUserAgentServer) {\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                return;\n            }\n            // A UAS that receives an INVITE on a dialog while an INVITE it had sent\n            // on that dialog is in progress MUST return a 491 (Request Pending)\n            // response to the received INVITE.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            if (this.reinviteUserAgentClient) {\n                this.core.replyStateless(message, { statusCode: 491 });\n                return;\n            }\n        }\n        // Requests within a dialog MAY contain Record-Route and Contact header\n        // fields.  However, these requests do not cause the dialog's route set\n        // to be modified, although they may modify the remote target URI.\n        // Specifically, requests that are not target refresh requests do not\n        // modify the dialog's remote target URI, and requests that are target\n        // refresh requests do.  For dialogs that have been established with an\n        // INVITE, the only target refresh request defined is re-INVITE (see\n        // Section 14).  Other extensions may define different target refresh\n        // requests for dialogs established in other ways.\n        //\n        //    Note that an ACK is NOT a target refresh request.\n        //\n        // Target refresh requests only update the dialog's remote target URI,\n        // and not the route set formed from the Record-Route.  Updating the\n        // latter would introduce severe backwards compatibility problems with\n        // RFC 2543-compliant systems.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        if (message.method === C.INVITE) {\n            // FIXME: parser needs to be typed...\n            const contact = message.parseHeader(\"contact\");\n            if (!contact) {\n                // TODO: Review to make sure this will never happen\n                throw new Error(\"Contact undefined.\");\n            }\n            if (!(contact instanceof NameAddrHeader)) {\n                throw new Error(\"Contact not instance of NameAddrHeader.\");\n            }\n            this.dialogState.remoteTarget = contact.uri;\n        }\n        // Switch on method and then delegate.\n        switch (message.method) {\n            case C.BYE:\n                // A UAS core receiving a BYE request for an existing dialog MUST follow\n                // the procedures of Section 12.2.2 to process the request.  Once done,\n                // the UAS SHOULD terminate the session (and therefore stop sending and\n                // listening for media).  The only case where it can elect not to are\n                // multicast sessions, where participation is possible even if the other\n                // participant in the dialog has terminated its involvement in the\n                // session.  Whether or not it ends its participation on the session,\n                // the UAS core MUST generate a 2xx response to the BYE, and MUST pass\n                // that to the server transaction for transmission.\n                //\n                // The UAS MUST still respond to any pending requests received for that\n                // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n                // be generated to those pending requests.\n                // https://tools.ietf.org/html/rfc3261#section-15.1.2\n                {\n                    const uas = new ByeUserAgentServer(this, message);\n                    this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();\n                    this.dispose();\n                }\n                break;\n            case C.INFO:\n                // If a UA receives an INFO request associated with an Info Package that\n                // the UA has not indicated willingness to receive, the UA MUST send a\n                // 469 (Bad Info Package) response (see Section 11.6), which contains a\n                // Recv-Info header field with Info Packages for which the UA is willing\n                // to receive INFO requests.\n                {\n                    const uas = new InfoUserAgentServer(this, message);\n                    this.delegate && this.delegate.onInfo\n                        ? this.delegate.onInfo(uas)\n                        : uas.reject({\n                            statusCode: 469,\n                            extraHeaders: [\"Recv-Info :\"]\n                        });\n                }\n                break;\n            case C.INVITE:\n                // If the new session description is not acceptable, the UAS can reject\n                // it by returning a 488 (Not Acceptable Here) response for the re-\n                // INVITE.  This response SHOULD include a Warning header field.\n                // https://tools.ietf.org/html/rfc3261#section-14.2\n                {\n                    const uas = new ReInviteUserAgentServer(this, message);\n                    this.signalingStateTransition(message);\n                    this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({ statusCode: 488 }); // TODO: Warning header field.\n                }\n                break;\n            case C.MESSAGE:\n                {\n                    const uas = new MessageUserAgentServer(this.core, message);\n                    this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n                }\n                break;\n            case C.NOTIFY:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.4\n                {\n                    const uas = new NotifyUserAgentServer(this, message);\n                    this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();\n                }\n                break;\n            case C.PRACK:\n                // https://tools.ietf.org/html/rfc3262#section-4\n                {\n                    const uas = new PrackUserAgentServer(this, message);\n                    this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();\n                }\n                break;\n            case C.REFER:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.2\n                {\n                    const uas = new ReferUserAgentServer(this, message);\n                    this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();\n                }\n                break;\n            default:\n                {\n                    this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message.method} request`);\n                    this.core.replyStateless(message, { statusCode: 501 });\n                }\n                break;\n        }\n    }\n    /**\n     * Guard against out of order reliable provisional responses and retransmissions.\n     * Returns false if the response should be discarded, otherwise true.\n     * @param message - Incoming response message within this dialog.\n     */\n    reliableSequenceGuard(message) {\n        const statusCode = message.statusCode;\n        if (!statusCode) {\n            throw new Error(\"Status code undefined\");\n        }\n        if (statusCode > 100 && statusCode < 200) {\n            // If a provisional response is received for an initial request, and\n            // that response contains a Require header field containing the option\n            // tag 100rel, the response is to be sent reliably.  If the response is\n            // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n            // ignored, and the procedures below MUST NOT be used.\n            // https://tools.ietf.org/html/rfc3262#section-4\n            const requireHeader = message.getHeader(\"require\");\n            const rseqHeader = message.getHeader(\"rseq\");\n            const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n            if (rseq) {\n                // Handling of subsequent reliable provisional responses for the same\n                // initial request follows the same rules as above, with the following\n                // difference: reliable provisional responses are guaranteed to be in\n                // order.  As a result, if the UAC receives another reliable provisional\n                // response to the same request, and its RSeq value is not one higher\n                // than the value of the sequence number, that response MUST NOT be\n                // acknowledged with a PRACK, and MUST NOT be processed further by the\n                // UAC.  An implementation MAY discard the response, or MAY cache the\n                // response in the hopes of receiving the missing responses.\n                // https://tools.ietf.org/html/rfc3262#section-4\n                if (this.rseq && this.rseq + 1 !== rseq) {\n                    return false;\n                }\n                // Once a reliable provisional response is received, retransmissions of\n                // that response MUST be discarded.  A response is a retransmission when\n                // its dialog ID, CSeq, and RSeq match the original response.  The UAC\n                // MUST maintain a sequence number that indicates the most recently\n                // received in-order reliable provisional response for the initial\n                // request.  This sequence number MUST be maintained until a final\n                // response is received for the initial request.  Its value MUST be\n                // initialized to the RSeq header field in the first reliable\n                // provisional response received for the initial request.\n                // https://tools.ietf.org/html/rfc3262#section-4\n                this.rseq = this.rseq ? this.rseq + 1 : rseq;\n            }\n        }\n        return true;\n    }\n    /**\n     * If not in a stable signaling state, rollback to prior stable signaling state.\n     */\n    signalingStateRollback() {\n        if (this._signalingState === SignalingState.HaveLocalOffer ||\n            this.signalingState === SignalingState.HaveRemoteOffer) {\n            if (this._rollbackOffer && this._rollbackAnswer) {\n                this._signalingState = SignalingState.Stable;\n                this._offer = this._rollbackOffer;\n                this._answer = this._rollbackAnswer;\n            }\n        }\n    }\n    /**\n     * Update the signaling state of the dialog.\n     * @param message - The message to base the update off of.\n     */\n    signalingStateTransition(message) {\n        const body = getBody(message);\n        // No body, no session. No, woman, no cry.\n        if (!body || body.contentDisposition !== \"session\") {\n            return;\n        }\n        // We've got an existing offer and answer which we may wish to rollback to\n        if (this._signalingState === SignalingState.Stable) {\n            this._rollbackOffer = this._offer;\n            this._rollbackAnswer = this._answer;\n        }\n        // We're in UAS role, receiving incoming request with session description\n        if (message instanceof IncomingRequestMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveRemoteOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAC role, receiving incoming response with session description\n        if (message instanceof IncomingResponseMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveRemoteOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAC role, sending outgoing request with session description\n        if (message instanceof OutgoingRequestMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveLocalOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAS role, sending outgoing response with session description\n        if (isBody(message)) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveLocalOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n    }\n    start2xxRetransmissionTimer() {\n        if (this.initialTransaction instanceof InviteServerTransaction) {\n            const transaction = this.initialTransaction;\n            // Once the response has been constructed, it is passed to the INVITE\n            // server transaction.  In order to ensure reliable end-to-end\n            // transport of the response, it is necessary to periodically pass\n            // the response directly to the transport until the ACK arrives.  The\n            // 2xx response is passed to the transport with an interval that\n            // starts at T1 seconds and doubles for each retransmission until it\n            // reaches T2 seconds (T1 and T2 are defined in Section 17).\n            // Response retransmissions cease when an ACK request for the\n            // response is received.  This is independent of whatever transport\n            // protocols are used to send the response.\n            // https://tools.ietf.org/html/rfc6026#section-8.1\n            let timeout = Timers.T1;\n            const retransmission = () => {\n                if (!this.ackWait) {\n                    this.invite2xxTimer = undefined;\n                    return;\n                }\n                this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n                transaction.retransmitAcceptedResponse();\n                timeout = Math.min(timeout * 2, Timers.T2);\n                this.invite2xxTimer = setTimeout(retransmission, timeout);\n            };\n            this.invite2xxTimer = setTimeout(retransmission, timeout);\n            // If the server retransmits the 2xx response for 64*T1 seconds without\n            // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n            // terminated.  This is accomplished with a BYE, as described in Section 15.\n            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n            const stateChanged = () => {\n                if (transaction.state === TransactionState.Terminated) {\n                    transaction.removeStateChangeListener(stateChanged);\n                    if (this.invite2xxTimer) {\n                        clearTimeout(this.invite2xxTimer);\n                        this.invite2xxTimer = undefined;\n                    }\n                    if (this.ackWait) {\n                        if (this.delegate && this.delegate.onAckTimeout) {\n                            this.delegate.onAckTimeout();\n                        }\n                        else {\n                            this.bye();\n                        }\n                    }\n                }\n            };\n            transaction.addStateChangeListener(stateChanged);\n        }\n    }\n    // FIXME: Refactor\n    startReInvite2xxRetransmissionTimer() {\n        if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction) {\n            const transaction = this.reinviteUserAgentServer.transaction;\n            // Once the response has been constructed, it is passed to the INVITE\n            // server transaction.  In order to ensure reliable end-to-end\n            // transport of the response, it is necessary to periodically pass\n            // the response directly to the transport until the ACK arrives.  The\n            // 2xx response is passed to the transport with an interval that\n            // starts at T1 seconds and doubles for each retransmission until it\n            // reaches T2 seconds (T1 and T2 are defined in Section 17).\n            // Response retransmissions cease when an ACK request for the\n            // response is received.  This is independent of whatever transport\n            // protocols are used to send the response.\n            // https://tools.ietf.org/html/rfc6026#section-8.1\n            let timeout = Timers.T1;\n            const retransmission = () => {\n                if (!this.reinviteUserAgentServer) {\n                    this.invite2xxTimer = undefined;\n                    return;\n                }\n                this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n                transaction.retransmitAcceptedResponse();\n                timeout = Math.min(timeout * 2, Timers.T2);\n                this.invite2xxTimer = setTimeout(retransmission, timeout);\n            };\n            this.invite2xxTimer = setTimeout(retransmission, timeout);\n            // If the server retransmits the 2xx response for 64*T1 seconds without\n            // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n            // terminated.  This is accomplished with a BYE, as described in Section 15.\n            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n            const stateChanged = () => {\n                if (transaction.state === TransactionState.Terminated) {\n                    transaction.removeStateChangeListener(stateChanged);\n                    if (this.invite2xxTimer) {\n                        clearTimeout(this.invite2xxTimer);\n                        this.invite2xxTimer = undefined;\n                    }\n                    if (this.reinviteUserAgentServer) {\n                        // FIXME: TODO: What to do here\n                    }\n                }\n            };\n            transaction.addStateChangeListener(stateChanged);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}