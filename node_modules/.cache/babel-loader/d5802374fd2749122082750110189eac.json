{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _require = require('@xmpp/base64'),\n    encode = _require.encode,\n    decode = _require.decode;\n\nvar SASLError = require('./lib/SASLError');\n\nvar xml = require('@xmpp/xml');\n\nvar SASLFactory = require('saslmechanisms'); // https://xmpp.org/rfcs/rfc6120.html#sasl\n\n\nvar NS = 'urn:ietf:params:xml:ns:xmpp-sasl';\n\nfunction getMechanismNames(features) {\n  return features.getChild('mechanisms', NS).children.map(function (el) {\n    return el.text();\n  });\n}\n\nfunction authenticate(_x, _x2, _x3, _x4) {\n  return _authenticate.apply(this, arguments);\n}\n\nfunction _authenticate() {\n  _authenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(SASL, entity, mechname, credentials) {\n    var mech, domain, creds;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            mech = SASL.create([mechname]);\n\n            if (mech) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw new Error('No compatible mechanism');\n\n          case 3:\n            domain = entity.options.domain;\n            creds = _objectSpread({\n              username: null,\n              password: null,\n              server: domain,\n              host: domain,\n              realm: domain,\n              serviceType: 'xmpp',\n              serviceName: domain\n            }, credentials);\n            return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n              var handler = function handler(element) {\n                if (element.attrs.xmlns !== NS) {\n                  return;\n                }\n\n                if (element.name === 'challenge') {\n                  mech.challenge(decode(element.text()));\n                  var resp = mech.response(creds);\n                  entity.send(xml('response', {\n                    xmlns: NS,\n                    mechanism: mech.name\n                  }, typeof resp === 'string' ? encode(resp) : ''));\n                  return;\n                }\n\n                if (element.name === 'failure') {\n                  reject(SASLError.fromElement(element));\n                } else if (element.name === 'success') {\n                  resolve();\n                }\n\n                entity.removeListener('nonza', handler);\n              };\n\n              entity.on('nonza', handler);\n\n              if (mech.clientFirst) {\n                entity.send(xml('auth', {\n                  xmlns: NS,\n                  mechanism: mech.name\n                }, encode(mech.response(creds))));\n              }\n            }));\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _authenticate.apply(this, arguments);\n}\n\nmodule.exports = function sasl(_ref, credentials) {\n  var streamFeatures = _ref.streamFeatures;\n  var SASL = new SASLFactory();\n  streamFeatures.use('mechanisms', NS, /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n      var stanza, entity, offered, supported, intersection, mech;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              stanza = _ref2.stanza, entity = _ref2.entity;\n              offered = getMechanismNames(stanza);\n              supported = SASL._mechs.map(function (_ref4) {\n                var name = _ref4.name;\n                return name;\n              });\n              intersection = supported.filter(function (mech) {\n                return offered.includes(mech);\n              });\n              mech = intersection[0];\n\n              if (!(typeof credentials === 'function')) {\n                _context.next = 10;\n                break;\n              }\n\n              _context.next = 8;\n              return credentials(function (creds) {\n                return authenticate(SASL, entity, mech, creds, stanza);\n              }, mech);\n\n            case 8:\n              _context.next = 13;\n              break;\n\n            case 10:\n              if (!credentials.username && !credentials.password) {\n                mech = 'ANONYMOUS';\n              }\n\n              _context.next = 13;\n              return authenticate(SASL, entity, mech, credentials, stanza);\n\n            case 13:\n              _context.next = 15;\n              return entity.restart();\n\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }());\n  return {\n    use: function use() {\n      return SASL.use.apply(SASL, arguments);\n    }\n  };\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/sasl/index.js"],"names":["require","encode","decode","SASLError","xml","SASLFactory","NS","getMechanismNames","features","getChild","children","map","el","text","authenticate","SASL","entity","mechname","credentials","mech","create","Error","domain","options","creds","username","password","server","host","realm","serviceType","serviceName","Promise","resolve","reject","handler","element","attrs","xmlns","name","challenge","resp","response","send","mechanism","fromElement","removeListener","on","clientFirst","module","exports","sasl","streamFeatures","use","stanza","offered","supported","_mechs","intersection","filter","includes","restart"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {encode, decode} = require('@xmpp/base64')\nconst SASLError = require('./lib/SASLError')\nconst xml = require('@xmpp/xml')\nconst SASLFactory = require('saslmechanisms')\n\n// https://xmpp.org/rfcs/rfc6120.html#sasl\n\nconst NS = 'urn:ietf:params:xml:ns:xmpp-sasl'\n\nfunction getMechanismNames(features) {\n  return features.getChild('mechanisms', NS).children.map(el => el.text())\n}\n\nasync function authenticate(SASL, entity, mechname, credentials) {\n  const mech = SASL.create([mechname])\n  if (!mech) {\n    throw new Error('No compatible mechanism')\n  }\n\n  const {domain} = entity.options\n  const creds = {\n    username: null,\n    password: null,\n    server: domain,\n    host: domain,\n    realm: domain,\n    serviceType: 'xmpp',\n    serviceName: domain,\n    ...credentials,\n  }\n\n  return new Promise((resolve, reject) => {\n    const handler = element => {\n      if (element.attrs.xmlns !== NS) {\n        return\n      }\n\n      if (element.name === 'challenge') {\n        mech.challenge(decode(element.text()))\n        const resp = mech.response(creds)\n        entity.send(\n          xml(\n            'response',\n            {xmlns: NS, mechanism: mech.name},\n            typeof resp === 'string' ? encode(resp) : ''\n          )\n        )\n        return\n      }\n\n      if (element.name === 'failure') {\n        reject(SASLError.fromElement(element))\n      } else if (element.name === 'success') {\n        resolve()\n      }\n\n      entity.removeListener('nonza', handler)\n    }\n\n    entity.on('nonza', handler)\n\n    if (mech.clientFirst) {\n      entity.send(\n        xml(\n          'auth',\n          {xmlns: NS, mechanism: mech.name},\n          encode(mech.response(creds))\n        )\n      )\n    }\n  })\n}\n\nmodule.exports = function sasl({streamFeatures}, credentials) {\n  const SASL = new SASLFactory()\n\n  streamFeatures.use('mechanisms', NS, async ({stanza, entity}) => {\n    const offered = getMechanismNames(stanza)\n    const supported = SASL._mechs.map(({name}) => name)\n    const intersection = supported.filter(mech => {\n      return offered.includes(mech)\n    })\n    let mech = intersection[0]\n\n    if (typeof credentials === 'function') {\n      await credentials(\n        creds => authenticate(SASL, entity, mech, creds, stanza),\n        mech\n      )\n    } else {\n      if (!credentials.username && !credentials.password) {\n        mech = 'ANONYMOUS'\n      }\n\n      await authenticate(SASL, entity, mech, credentials, stanza)\n    }\n\n    await entity.restart()\n  })\n\n  return {\n    use(...args) {\n      return SASL.use(...args)\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"script"}