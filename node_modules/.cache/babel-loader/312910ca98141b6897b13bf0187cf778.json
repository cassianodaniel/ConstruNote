{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { C, NameAddrHeader } from \"../messages\";\n/**\n * Dialog.\n * @remarks\n * A key concept for a user agent is that of a dialog.  A dialog\n * represents a peer-to-peer SIP relationship between two user agents\n * that persists for some time.  The dialog facilitates sequencing of\n * messages between the user agents and proper routing of requests\n * between both of them.  The dialog represents a context in which to\n * interpret SIP messages.\n * https://tools.ietf.org/html/rfc3261#section-12\n * @public\n */\n\nexport var Dialog = /*#__PURE__*/function () {\n  /**\n   * Dialog constructor.\n   * @param core - User agent core.\n   * @param dialogState - Initial dialog state.\n   */\n  function Dialog(core, dialogState) {\n    _classCallCheck(this, Dialog);\n\n    this.core = core;\n    this.dialogState = dialogState;\n    this.core.dialogs.set(this.id, this);\n  }\n  /**\n   * When a UAC receives a response that establishes a dialog, it\n   * constructs the state of the dialog.  This state MUST be maintained\n   * for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.2\n   * @param outgoingRequestMessage - Outgoing request message for dialog.\n   * @param incomingResponseMessage - Incoming response message creating dialog.\n   */\n\n\n  _createClass(Dialog, [{\n    key: \"dispose\",\n\n    /** Destructor. */\n    value: function dispose() {\n      this.core.dialogs.delete(this.id);\n    }\n    /**\n     * A dialog is identified at each UA with a dialog ID, which consists of\n     * a Call-ID value, a local tag and a remote tag.  The dialog ID at each\n     * UA involved in the dialog is not the same.  Specifically, the local\n     * tag at one UA is identical to the remote tag at the peer UA.  The\n     * tags are opaque tokens that facilitate the generation of unique\n     * dialog IDs.\n     * https://tools.ietf.org/html/rfc3261#section-12\n     */\n\n  }, {\n    key: \"confirm\",\n\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    value: function confirm() {\n      this.dialogState.early = false;\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     *\n     *    Note that some requests, such as INVITEs, affect several pieces of\n     *    state.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n\n  }, {\n    key: \"receiveRequest\",\n    value: function receiveRequest(message) {\n      // ACK guard.\n      // By convention, the handling of ACKs is the responsibility\n      // the particular dialog implementation. For example, see SessionDialog.\n      // Furthermore, ACKs have same sequence number as the associated INVITE.\n      if (message.method === C.ACK) {\n        return;\n      } // If the remote sequence number was not empty, but the sequence number\n      // of the request is lower than the remote sequence number, the request\n      // is out of order and MUST be rejected with a 500 (Server Internal\n      // Error) response.  If the remote sequence number was not empty, and\n      // the sequence number of the request is greater than the remote\n      // sequence number, the request is in order.  It is possible for the\n      // CSeq sequence number to be higher than the remote sequence number by\n      // more than one.  This is not an error condition, and a UAS SHOULD be\n      // prepared to receive and process requests with CSeq values more than\n      // one higher than the previous received request.  The UAS MUST then set\n      // the remote sequence number to the value of the sequence number in the\n      // CSeq header field value in the request.\n      //\n      //    If a proxy challenges a request generated by the UAC, the UAC has\n      //    to resubmit the request with credentials.  The resubmitted request\n      //    will have a new CSeq number.  The UAS will never see the first\n      //    request, and thus, it will notice a gap in the CSeq number space.\n      //    Such a gap does not represent any error condition.\n      //\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      if (this.remoteSequenceNumber) {\n        if (message.cseq <= this.remoteSequenceNumber) {\n          throw new Error(\"Out of sequence in dialog request. Did you forget to call sequenceGuard()?\");\n        }\n\n        this.dialogState.remoteSequenceNumber = message.cseq;\n      } // If the remote sequence number is empty, it MUST be set to the value\n      // of the sequence number in the CSeq header field value in the request.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      if (!this.remoteSequenceNumber) {\n        this.dialogState.remoteSequenceNumber = message.cseq;\n      } // When a UAS receives a target refresh request, it MUST replace the\n      // dialog's remote target URI with the URI from the Contact header field\n      // in that request, if present.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n      // Note: \"target refresh request\" processing delegated to sub-class.\n\n    }\n    /**\n     * If the dialog identifier in the 2xx response matches the dialog\n     * identifier of an existing dialog, the dialog MUST be transitioned to\n     * the \"confirmed\" state, and the route set for the dialog MUST be\n     * recomputed based on the 2xx response using the procedures of Section\n     * 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n     * constructed using the procedures of Section 12.1.2.\n     *\n     * Note that the only piece of state that is recomputed is the route\n     * set.  Other pieces of state such as the highest sequence numbers\n     * (remote and local) sent within the dialog are not recomputed.  The\n     * route set only is recomputed for backwards compatibility.  RFC\n     * 2543 did not mandate mirroring of the Record-Route header field in\n     * a 1xx, only 2xx.  However, we cannot update the entire state of\n     * the dialog, since mid-dialog requests may have been sent within\n     * the early dialog, modifying the sequence numbers, for example.\n     *\n     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     */\n\n  }, {\n    key: \"recomputeRouteSet\",\n    value: function recomputeRouteSet(message) {\n      this.dialogState.routeSet = message.getHeaders(\"record-route\").reverse();\n    }\n    /**\n     * A request within a dialog is constructed by using many of the\n     * components of the state stored as part of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n     * @param method - Outgoing request method.\n     */\n\n  }, {\n    key: \"createOutgoingRequestMessage\",\n    value: function createOutgoingRequestMessage(method, options) {\n      // The URI in the To field of the request MUST be set to the remote URI\n      // from the dialog state.  The tag in the To header field of the request\n      // MUST be set to the remote tag of the dialog ID.  The From URI of the\n      // request MUST be set to the local URI from the dialog state.  The tag\n      // in the From header field of the request MUST be set to the local tag\n      // of the dialog ID.  If the value of the remote or local tags is null,\n      // the tag parameter MUST be omitted from the To or From header fields,\n      // respectively.\n      //\n      //    Usage of the URI from the To and From fields in the original\n      //    request within subsequent requests is done for backwards\n      //    compatibility with RFC 2543, which used the URI for dialog\n      //    identification.  In this specification, only the tags are used for\n      //    dialog identification.  It is expected that mandatory reflection\n      //    of the original To and From URI in mid-dialog requests will be\n      //    deprecated in a subsequent revision of this specification.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n      var toUri = this.remoteURI;\n      var toTag = this.remoteTag;\n      var fromUri = this.localURI;\n      var fromTag = this.localTag; // The Call-ID of the request MUST be set to the Call-ID of the dialog.\n      // Requests within a dialog MUST contain strictly monotonically\n      // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n      // in each direction (excepting ACK and CANCEL of course, whose numbers\n      // equal the requests being acknowledged or cancelled).  Therefore, if\n      // the local sequence number is not empty, the value of the local\n      // sequence number MUST be incremented by one, and this value MUST be\n      // placed into the CSeq header field.  If the local sequence number is\n      // empty, an initial value MUST be chosen using the guidelines of\n      // Section 8.1.1.5.  The method field in the CSeq header field value\n      // MUST match the method of the request.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n\n      var callId = this.callId;\n      var cseq;\n\n      if (options && options.cseq) {\n        cseq = options.cseq;\n      } else if (!this.dialogState.localSequenceNumber) {\n        cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5\n      } else {\n        cseq = this.dialogState.localSequenceNumber += 1;\n      } // The UAC uses the remote target and route set to build the Request-URI\n      // and Route header field of the request.\n      //\n      // If the route set is empty, the UAC MUST place the remote target URI\n      // into the Request-URI.  The UAC MUST NOT add a Route header field to\n      // the request.\n      //\n      // If the route set is not empty, and the first URI in the route set\n      // contains the lr parameter (see Section 19.1.1), the UAC MUST place\n      // the remote target URI into the Request-URI and MUST include a Route\n      // header field containing the route set values in order, including all\n      // parameters.\n      //\n      // If the route set is not empty, and its first URI does not contain the\n      // lr parameter, the UAC MUST place the first URI from the route set\n      // into the Request-URI, stripping any parameters that are not allowed\n      // in a Request-URI.  The UAC MUST add a Route header field containing\n      // the remainder of the route set values in order, including all\n      // parameters.  The UAC MUST then place the remote target URI into the\n      // Route header field as the last value.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n      // The lr parameter, when present, indicates that the element\n      // responsible for this resource implements the routing mechanisms\n      // specified in this document.  This parameter will be used in the\n      // URIs proxies place into Record-Route header field values, and\n      // may appear in the URIs in a pre-existing route set.\n      //\n      // This parameter is used to achieve backwards compatibility with\n      // systems implementing the strict-routing mechanisms of RFC 2543\n      // and the rfc2543bis drafts up to bis-05.  An element preparing\n      // to send a request based on a URI not containing this parameter\n      // can assume the receiving element implements strict-routing and\n      // reformat the message to preserve the information in the\n      // Request-URI.\n      // https://tools.ietf.org/html/rfc3261#section-19.1.1\n      // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n\n\n      var ruri = this.remoteTarget;\n      var routeSet = this.routeSet;\n      var extraHeaders = options && options.extraHeaders;\n      var body = options && options.body; // The relative order of header fields with different field names is not\n      // significant.  However, it is RECOMMENDED that header fields which are\n      // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n      // Max-Forwards, and Proxy-Authorization, for example) appear towards\n      // the top of the message to facilitate rapid parsing.\n      // https://tools.ietf.org/html/rfc3261#section-7.3.1\n\n      var message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {\n        callId: callId,\n        cseq: cseq,\n        fromTag: fromTag,\n        toTag: toTag,\n        routeSet: routeSet\n      }, extraHeaders, body);\n      return message;\n    }\n    /**\n     * Increment the local sequence number by one.\n     * It feels like this should be protected, but the current authentication handling currently\n     * needs this to keep the dialog in sync when \"auto re-sends\" request messages.\n     * @internal\n     */\n\n  }, {\n    key: \"incrementLocalSequenceNumber\",\n    value: function incrementLocalSequenceNumber() {\n      if (!this.dialogState.localSequenceNumber) {\n        throw new Error(\"Local sequence number undefined.\");\n      }\n\n      this.dialogState.localSequenceNumber += 1;\n    }\n    /**\n     * If the remote sequence number was not empty, but the sequence number\n     * of the request is lower than the remote sequence number, the request\n     * is out of order and MUST be rejected with a 500 (Server Internal\n     * Error) response.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param request - Incoming request to guard.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.\n     */\n\n  }, {\n    key: \"sequenceGuard\",\n    value: function sequenceGuard(message) {\n      // ACK guard.\n      // By convention, handling of unexpected ACKs is responsibility\n      // the particular dialog implementation. For example, see SessionDialog.\n      // Furthermore, we cannot reply to an \"out of sequence\" ACK.\n      if (message.method === C.ACK) {\n        return true;\n      } // Note: We are rejecting on \"less than or equal to\" the remote\n      // sequence number (excepting ACK whose numbers equal the requests\n      // being acknowledged or cancelled), which is the correct thing to\n      // do in our case. The only time a request with the same sequence number\n      // will show up here if is a) it is a very late retransmission of a\n      // request we already handled or b) it is a different request with the\n      // same sequence number which would be violation of the standard.\n      // Request retransmissions are absorbed by the transaction layer,\n      // so any request with a duplicate sequence number getting here\n      // would have to be a retransmission after the transaction terminated\n      // or a broken request (with unique via branch value).\n      // Requests within a dialog MUST contain strictly monotonically\n      // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n      // in each direction (excepting ACK and CANCEL of course, whose numbers\n      // equal the requests being acknowledged or cancelled).  Therefore, if\n      // the local sequence number is not empty, the value of the local\n      // sequence number MUST be incremented by one, and this value MUST be\n      // placed into the CSeq header field.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n\n\n      if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {\n        this.core.replyStateless(message, {\n          statusCode: 500\n        });\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.dialogState.id;\n    }\n    /**\n     * A dialog can also be in the \"early\" state, which occurs when it is\n     * created with a provisional response, and then it transition to the\n     * \"confirmed\" state when a 2xx final response received or is sent.\n     *\n     * Note: RFC 3261 is concise on when a dialog is \"confirmed\", but it\n     * can be a point of confusion if an INVITE dialog is \"confirmed\" after\n     * a 2xx is sent or after receiving the ACK for the 2xx response.\n     * With careful reading it can be inferred a dialog is always is\n     * \"confirmed\" when the 2xx is sent (regardless of type of dialog).\n     * However a INVITE dialog does have additional considerations\n     * when it is confirmed but an ACK has not yet been received (in\n     * particular with regard to a callee sending BYE requests).\n     */\n\n  }, {\n    key: \"early\",\n    get: function get() {\n      return this.dialogState.early;\n    }\n    /** Call identifier component of the dialog id. */\n\n  }, {\n    key: \"callId\",\n    get: function get() {\n      return this.dialogState.callId;\n    }\n    /** Local tag component of the dialog id. */\n\n  }, {\n    key: \"localTag\",\n    get: function get() {\n      return this.dialogState.localTag;\n    }\n    /** Remote tag component of the dialog id. */\n\n  }, {\n    key: \"remoteTag\",\n    get: function get() {\n      return this.dialogState.remoteTag;\n    }\n    /** Local sequence number (used to order requests from the UA to its peer). */\n\n  }, {\n    key: \"localSequenceNumber\",\n    get: function get() {\n      return this.dialogState.localSequenceNumber;\n    }\n    /** Remote sequence number (used to order requests from its peer to the UA). */\n\n  }, {\n    key: \"remoteSequenceNumber\",\n    get: function get() {\n      return this.dialogState.remoteSequenceNumber;\n    }\n    /** Local URI. */\n\n  }, {\n    key: \"localURI\",\n    get: function get() {\n      return this.dialogState.localURI;\n    }\n    /** Remote URI. */\n\n  }, {\n    key: \"remoteURI\",\n    get: function get() {\n      return this.dialogState.remoteURI;\n    }\n    /** Remote target. */\n\n  }, {\n    key: \"remoteTarget\",\n    get: function get() {\n      return this.dialogState.remoteTarget;\n    }\n    /**\n     * Route set, which is an ordered list of URIs. The route set is the\n     * list of servers that need to be traversed to send a request to the peer.\n     */\n\n  }, {\n    key: \"routeSet\",\n    get: function get() {\n      return this.dialogState.routeSet;\n    }\n    /**\n     * If the request was sent over TLS, and the Request-URI contained\n     * a SIPS URI, the \"secure\" flag is set to true. *NOT IMPLEMENTED*\n     */\n\n  }, {\n    key: \"secure\",\n    get: function get() {\n      return this.dialogState.secure;\n    }\n    /** The user agent core servicing this dialog. */\n\n  }, {\n    key: \"userAgentCore\",\n    get: function get() {\n      return this.core;\n    }\n  }], [{\n    key: \"initialDialogStateForUserAgentClient\",\n    value: function initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {\n      // If the request was sent over TLS, and the Request-URI contained a\n      // SIPS URI, the \"secure\" flag is set to TRUE.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n      var secure = false; // FIXME: Currently no support for TLS.\n      // The route set MUST be set to the list of URIs in the Record-Route\n      // header field from the response, taken in reverse order and preserving\n      // all URI parameters.  If no Record-Route header field is present in\n      // the response, the route set MUST be set to the empty set.  This route\n      // set, even if empty, overrides any pre-existing route set for future\n      // requests in this dialog.  The remote target MUST be set to the URI\n      // from the Contact header field of the response.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n      var routeSet = incomingResponseMessage.getHeaders(\"record-route\").reverse(); // When a UAS responds to a request with a response that establishes a\n      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n      // header field values from the request into the response (including the\n      // URIs, URI parameters, and any Record-Route header field parameters,\n      // whether they are known or unknown to the UAS) and MUST maintain the\n      // order of those values.  The UAS MUST add a Contact header field to\n      // the response.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n      var contact = incomingResponseMessage.parseHeader(\"contact\");\n\n      if (!contact) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Contact undefined.\");\n      }\n\n      if (!(contact instanceof NameAddrHeader)) {\n        throw new Error(\"Contact not instance of NameAddrHeader.\");\n      }\n\n      var remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence\n      // number in the CSeq header field of the request.  The remote sequence\n      // number MUST be empty (it is established when the remote UA sends a\n      // request within the dialog).  The call identifier component of the\n      // dialog ID MUST be set to the value of the Call-ID in the request.\n      // The local tag component of the dialog ID MUST be set to the tag in\n      // the From field in the request, and the remote tag component of the\n      // dialog ID MUST be set to the tag in the To field of the response.  A\n      // UAC MUST be prepared to receive a response without a tag in the To\n      // field, in which case the tag is considered to have a value of null.\n      //\n      //    This is to maintain backwards compatibility with RFC 2543, which\n      //    did not mandate To tags.\n      //\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n      var localSequenceNumber = outgoingRequestMessage.cseq;\n      var remoteSequenceNumber = undefined;\n      var callId = outgoingRequestMessage.callId;\n      var localTag = outgoingRequestMessage.fromTag;\n      var remoteTag = incomingResponseMessage.toTag;\n\n      if (!callId) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Call id undefined.\");\n      }\n\n      if (!localTag) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"From tag undefined.\");\n      }\n\n      if (!remoteTag) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n      } // The remote URI MUST be set to the URI in the To field, and the local\n      // URI MUST be set to the URI in the From field.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n\n      if (!outgoingRequestMessage.from) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"From undefined.\");\n      }\n\n      if (!outgoingRequestMessage.to) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"To undefined.\");\n      }\n\n      var localURI = outgoingRequestMessage.from.uri;\n      var remoteURI = outgoingRequestMessage.to.uri; // A dialog can also be in the \"early\" state, which occurs when it is\n      // created with a provisional response, and then transition to the\n      // \"confirmed\" state when a 2xx final response arrives.\n      // https://tools.ietf.org/html/rfc3261#section-12\n\n      if (!incomingResponseMessage.statusCode) {\n        throw new Error(\"Incoming response status code undefined.\");\n      }\n\n      var early = incomingResponseMessage.statusCode < 200 ? true : false;\n      var dialogState = {\n        id: callId + localTag + remoteTag,\n        early: early,\n        callId: callId,\n        localTag: localTag,\n        remoteTag: remoteTag,\n        localSequenceNumber: localSequenceNumber,\n        remoteSequenceNumber: remoteSequenceNumber,\n        localURI: localURI,\n        remoteURI: remoteURI,\n        remoteTarget: remoteTarget,\n        routeSet: routeSet,\n        secure: secure\n      };\n      return dialogState;\n    }\n    /**\n     * The UAS then constructs the state of the dialog.  This state MUST be\n     * maintained for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.1\n     * @param incomingRequestMessage - Incoming request message creating dialog.\n     * @param toTag - Tag in the To field in the response to the incoming request.\n     */\n\n  }, {\n    key: \"initialDialogStateForUserAgentServer\",\n    value: function initialDialogStateForUserAgentServer(incomingRequestMessage, toTag) {\n      var early = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // If the request arrived over TLS, and the Request-URI contained a SIPS\n      // URI, the \"secure\" flag is set to TRUE.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n      var secure = false; // FIXME: Currently no support for TLS.\n      // The route set MUST be set to the list of URIs in the Record-Route\n      // header field from the request, taken in order and preserving all URI\n      // parameters.  If no Record-Route header field is present in the\n      // request, the route set MUST be set to the empty set.  This route set,\n      // even if empty, overrides any pre-existing route set for future\n      // requests in this dialog.  The remote target MUST be set to the URI\n      // from the Contact header field of the request.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n      var routeSet = incomingRequestMessage.getHeaders(\"record-route\");\n      var contact = incomingRequestMessage.parseHeader(\"contact\");\n\n      if (!contact) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Contact undefined.\");\n      }\n\n      if (!(contact instanceof NameAddrHeader)) {\n        throw new Error(\"Contact not instance of NameAddrHeader.\");\n      }\n\n      var remoteTarget = contact.uri; // The remote sequence number MUST be set to the value of the sequence\n      // number in the CSeq header field of the request.  The local sequence\n      // number MUST be empty.  The call identifier component of the dialog ID\n      // MUST be set to the value of the Call-ID in the request.  The local\n      // tag component of the dialog ID MUST be set to the tag in the To field\n      // in the response to the request (which always includes a tag), and the\n      // remote tag component of the dialog ID MUST be set to the tag from the\n      // From field in the request.  A UAS MUST be prepared to receive a\n      // request without a tag in the From field, in which case the tag is\n      // considered to have a value of null.\n      //\n      //    This is to maintain backwards compatibility with RFC 2543, which\n      //    did not mandate From tags.\n      //\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n      var remoteSequenceNumber = incomingRequestMessage.cseq;\n      var localSequenceNumber = undefined;\n      var callId = incomingRequestMessage.callId;\n      var localTag = toTag;\n      var remoteTag = incomingRequestMessage.fromTag; // The remote URI MUST be set to the URI in the From field, and the\n      // local URI MUST be set to the URI in the To field.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n      var remoteURI = incomingRequestMessage.from.uri;\n      var localURI = incomingRequestMessage.to.uri;\n      var dialogState = {\n        id: callId + localTag + remoteTag,\n        early: early,\n        callId: callId,\n        localTag: localTag,\n        remoteTag: remoteTag,\n        localSequenceNumber: localSequenceNumber,\n        remoteSequenceNumber: remoteSequenceNumber,\n        localURI: localURI,\n        remoteURI: remoteURI,\n        remoteTarget: remoteTarget,\n        routeSet: routeSet,\n        secure: secure\n      };\n      return dialogState;\n    }\n  }]);\n\n  return Dialog;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/dialog.js"],"names":["C","NameAddrHeader","Dialog","core","dialogState","dialogs","set","id","delete","early","message","method","ACK","remoteSequenceNumber","cseq","Error","routeSet","getHeaders","reverse","options","toUri","remoteURI","toTag","remoteTag","fromUri","localURI","fromTag","localTag","callId","localSequenceNumber","ruri","remoteTarget","extraHeaders","body","userAgentCore","makeOutgoingRequestMessage","replyStateless","statusCode","secure","outgoingRequestMessage","incomingResponseMessage","contact","parseHeader","uri","undefined","from","to","incomingRequestMessage"],"mappings":";;AAAA,SAASA,CAAT,EAAYC,cAAZ,QAAkC,aAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,MAAb;AACI;AACJ;AACA;AACA;AACA;AACI,kBAAYC,IAAZ,EAAkBC,WAAlB,EAA+B;AAAA;;AAC3B,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKD,IAAL,CAAUE,OAAV,CAAkBC,GAAlB,CAAsB,KAAKC,EAA3B,EAA+B,IAA/B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAlBA;AAAA;;AA8LI;AA9LJ,8BA+Lc;AACN,WAAKJ,IAAL,CAAUE,OAAV,CAAkBG,MAAlB,CAAyB,KAAKD,EAA9B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1MA;AAAA;;AAiRI;AAjRJ,8BAkRc;AACN,WAAKH,WAAL,CAAiBK,KAAjB,GAAyB,KAAzB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhSA;AAAA;AAAA,mCAiSmBC,OAjSnB,EAiS4B;AACpB;AACA;AACA;AACA;AACA,UAAIA,OAAO,CAACC,MAAR,KAAmBX,CAAC,CAACY,GAAzB,EAA8B;AAC1B;AACH,OAPmB,CAQpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAI,KAAKC,oBAAT,EAA+B;AAC3B,YAAIH,OAAO,CAACI,IAAR,IAAgB,KAAKD,oBAAzB,EAA+C;AAC3C,gBAAM,IAAIE,KAAJ,CAAU,4EAAV,CAAN;AACH;;AACD,aAAKX,WAAL,CAAiBS,oBAAjB,GAAwCH,OAAO,CAACI,IAAhD;AACH,OAjCmB,CAkCpB;AACA;AACA;;;AACA,UAAI,CAAC,KAAKD,oBAAV,EAAgC;AAC5B,aAAKT,WAAL,CAAiBS,oBAAjB,GAAwCH,OAAO,CAACI,IAAhD;AACH,OAvCmB,CAwCpB;AACA;AACA;AACA;AACA;;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjWA;AAAA;AAAA,sCAkWsBJ,OAlWtB,EAkW+B;AACvB,WAAKN,WAAL,CAAiBY,QAAjB,GAA4BN,OAAO,CAACO,UAAR,CAAmB,cAAnB,EAAmCC,OAAnC,EAA5B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;AA1WA;AAAA;AAAA,iDA2WiCP,MA3WjC,EA2WyCQ,OA3WzC,EA2WkD;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,KAAK,GAAG,KAAKC,SAAnB;AACA,UAAMC,KAAK,GAAG,KAAKC,SAAnB;AACA,UAAMC,OAAO,GAAG,KAAKC,QAArB;AACA,UAAMC,OAAO,GAAG,KAAKC,QAArB,CArB0C,CAsB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAId,IAAJ;;AACA,UAAIK,OAAO,IAAIA,OAAO,CAACL,IAAvB,EAA6B;AACzBA,QAAAA,IAAI,GAAGK,OAAO,CAACL,IAAf;AACH,OAFD,MAGK,IAAI,CAAC,KAAKV,WAAL,CAAiByB,mBAAtB,EAA2C;AAC5Cf,QAAAA,IAAI,GAAG,KAAKV,WAAL,CAAiByB,mBAAjB,GAAuC,CAA9C,CAD4C,CACK;AACpD,OAFI,MAGA;AACDf,QAAAA,IAAI,GAAG,KAAKV,WAAL,CAAiByB,mBAAjB,IAAwC,CAA/C;AACH,OA5CyC,CA6C1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMC,IAAI,GAAG,KAAKC,YAAlB;AACA,UAAMf,QAAQ,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","sourcesContent":["import { C, NameAddrHeader } from \"../messages\";\n/**\n * Dialog.\n * @remarks\n * A key concept for a user agent is that of a dialog.  A dialog\n * represents a peer-to-peer SIP relationship between two user agents\n * that persists for some time.  The dialog facilitates sequencing of\n * messages between the user agents and proper routing of requests\n * between both of them.  The dialog represents a context in which to\n * interpret SIP messages.\n * https://tools.ietf.org/html/rfc3261#section-12\n * @public\n */\nexport class Dialog {\n    /**\n     * Dialog constructor.\n     * @param core - User agent core.\n     * @param dialogState - Initial dialog state.\n     */\n    constructor(core, dialogState) {\n        this.core = core;\n        this.dialogState = dialogState;\n        this.core.dialogs.set(this.id, this);\n    }\n    /**\n     * When a UAC receives a response that establishes a dialog, it\n     * constructs the state of the dialog.  This state MUST be maintained\n     * for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.2\n     * @param outgoingRequestMessage - Outgoing request message for dialog.\n     * @param incomingResponseMessage - Incoming response message creating dialog.\n     */\n    static initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {\n        // If the request was sent over TLS, and the Request-URI contained a\n        // SIPS URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the response, taken in reverse order and preserving\n        // all URI parameters.  If no Record-Route header field is present in\n        // the response, the route set MUST be set to the empty set.  This route\n        // set, even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const routeSet = incomingResponseMessage.getHeaders(\"record-route\").reverse();\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const contact = incomingResponseMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The local sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The remote sequence\n        // number MUST be empty (it is established when the remote UA sends a\n        // request within the dialog).  The call identifier component of the\n        // dialog ID MUST be set to the value of the Call-ID in the request.\n        // The local tag component of the dialog ID MUST be set to the tag in\n        // the From field in the request, and the remote tag component of the\n        // dialog ID MUST be set to the tag in the To field of the response.  A\n        // UAC MUST be prepared to receive a response without a tag in the To\n        // field, in which case the tag is considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate To tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const localSequenceNumber = outgoingRequestMessage.cseq;\n        const remoteSequenceNumber = undefined;\n        const callId = outgoingRequestMessage.callId;\n        const localTag = outgoingRequestMessage.fromTag;\n        const remoteTag = incomingResponseMessage.toTag;\n        if (!callId) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Call id undefined.\");\n        }\n        if (!localTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From tag undefined.\");\n        }\n        if (!remoteTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n        }\n        // The remote URI MUST be set to the URI in the To field, and the local\n        // URI MUST be set to the URI in the From field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        if (!outgoingRequestMessage.from) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From undefined.\");\n        }\n        if (!outgoingRequestMessage.to) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To undefined.\");\n        }\n        const localURI = outgoingRequestMessage.from.uri;\n        const remoteURI = outgoingRequestMessage.to.uri;\n        // A dialog can also be in the \"early\" state, which occurs when it is\n        // created with a provisional response, and then transition to the\n        // \"confirmed\" state when a 2xx final response arrives.\n        // https://tools.ietf.org/html/rfc3261#section-12\n        if (!incomingResponseMessage.statusCode) {\n            throw new Error(\"Incoming response status code undefined.\");\n        }\n        const early = incomingResponseMessage.statusCode < 200 ? true : false;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    /**\n     * The UAS then constructs the state of the dialog.  This state MUST be\n     * maintained for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.1\n     * @param incomingRequestMessage - Incoming request message creating dialog.\n     * @param toTag - Tag in the To field in the response to the incoming request.\n     */\n    static initialDialogStateForUserAgentServer(incomingRequestMessage, toTag, early = false) {\n        // If the request arrived over TLS, and the Request-URI contained a SIPS\n        // URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the request, taken in order and preserving all URI\n        // parameters.  If no Record-Route header field is present in the\n        // request, the route set MUST be set to the empty set.  This route set,\n        // even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const routeSet = incomingRequestMessage.getHeaders(\"record-route\");\n        const contact = incomingRequestMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The remote sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The local sequence\n        // number MUST be empty.  The call identifier component of the dialog ID\n        // MUST be set to the value of the Call-ID in the request.  The local\n        // tag component of the dialog ID MUST be set to the tag in the To field\n        // in the response to the request (which always includes a tag), and the\n        // remote tag component of the dialog ID MUST be set to the tag from the\n        // From field in the request.  A UAS MUST be prepared to receive a\n        // request without a tag in the From field, in which case the tag is\n        // considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate From tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const remoteSequenceNumber = incomingRequestMessage.cseq;\n        const localSequenceNumber = undefined;\n        const callId = incomingRequestMessage.callId;\n        const localTag = toTag;\n        const remoteTag = incomingRequestMessage.fromTag;\n        // The remote URI MUST be set to the URI in the From field, and the\n        // local URI MUST be set to the URI in the To field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const remoteURI = incomingRequestMessage.from.uri;\n        const localURI = incomingRequestMessage.to.uri;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    /** Destructor. */\n    dispose() {\n        this.core.dialogs.delete(this.id);\n    }\n    /**\n     * A dialog is identified at each UA with a dialog ID, which consists of\n     * a Call-ID value, a local tag and a remote tag.  The dialog ID at each\n     * UA involved in the dialog is not the same.  Specifically, the local\n     * tag at one UA is identical to the remote tag at the peer UA.  The\n     * tags are opaque tokens that facilitate the generation of unique\n     * dialog IDs.\n     * https://tools.ietf.org/html/rfc3261#section-12\n     */\n    get id() {\n        return this.dialogState.id;\n    }\n    /**\n     * A dialog can also be in the \"early\" state, which occurs when it is\n     * created with a provisional response, and then it transition to the\n     * \"confirmed\" state when a 2xx final response received or is sent.\n     *\n     * Note: RFC 3261 is concise on when a dialog is \"confirmed\", but it\n     * can be a point of confusion if an INVITE dialog is \"confirmed\" after\n     * a 2xx is sent or after receiving the ACK for the 2xx response.\n     * With careful reading it can be inferred a dialog is always is\n     * \"confirmed\" when the 2xx is sent (regardless of type of dialog).\n     * However a INVITE dialog does have additional considerations\n     * when it is confirmed but an ACK has not yet been received (in\n     * particular with regard to a callee sending BYE requests).\n     */\n    get early() {\n        return this.dialogState.early;\n    }\n    /** Call identifier component of the dialog id. */\n    get callId() {\n        return this.dialogState.callId;\n    }\n    /** Local tag component of the dialog id. */\n    get localTag() {\n        return this.dialogState.localTag;\n    }\n    /** Remote tag component of the dialog id. */\n    get remoteTag() {\n        return this.dialogState.remoteTag;\n    }\n    /** Local sequence number (used to order requests from the UA to its peer). */\n    get localSequenceNumber() {\n        return this.dialogState.localSequenceNumber;\n    }\n    /** Remote sequence number (used to order requests from its peer to the UA). */\n    get remoteSequenceNumber() {\n        return this.dialogState.remoteSequenceNumber;\n    }\n    /** Local URI. */\n    get localURI() {\n        return this.dialogState.localURI;\n    }\n    /** Remote URI. */\n    get remoteURI() {\n        return this.dialogState.remoteURI;\n    }\n    /** Remote target. */\n    get remoteTarget() {\n        return this.dialogState.remoteTarget;\n    }\n    /**\n     * Route set, which is an ordered list of URIs. The route set is the\n     * list of servers that need to be traversed to send a request to the peer.\n     */\n    get routeSet() {\n        return this.dialogState.routeSet;\n    }\n    /**\n     * If the request was sent over TLS, and the Request-URI contained\n     * a SIPS URI, the \"secure\" flag is set to true. *NOT IMPLEMENTED*\n     */\n    get secure() {\n        return this.dialogState.secure;\n    }\n    /** The user agent core servicing this dialog. */\n    get userAgentCore() {\n        return this.core;\n    }\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    confirm() {\n        this.dialogState.early = false;\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     *\n     *    Note that some requests, such as INVITEs, affect several pieces of\n     *    state.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n    receiveRequest(message) {\n        // ACK guard.\n        // By convention, the handling of ACKs is the responsibility\n        // the particular dialog implementation. For example, see SessionDialog.\n        // Furthermore, ACKs have same sequence number as the associated INVITE.\n        if (message.method === C.ACK) {\n            return;\n        }\n        // If the remote sequence number was not empty, but the sequence number\n        // of the request is lower than the remote sequence number, the request\n        // is out of order and MUST be rejected with a 500 (Server Internal\n        // Error) response.  If the remote sequence number was not empty, and\n        // the sequence number of the request is greater than the remote\n        // sequence number, the request is in order.  It is possible for the\n        // CSeq sequence number to be higher than the remote sequence number by\n        // more than one.  This is not an error condition, and a UAS SHOULD be\n        // prepared to receive and process requests with CSeq values more than\n        // one higher than the previous received request.  The UAS MUST then set\n        // the remote sequence number to the value of the sequence number in the\n        // CSeq header field value in the request.\n        //\n        //    If a proxy challenges a request generated by the UAC, the UAC has\n        //    to resubmit the request with credentials.  The resubmitted request\n        //    will have a new CSeq number.  The UAS will never see the first\n        //    request, and thus, it will notice a gap in the CSeq number space.\n        //    Such a gap does not represent any error condition.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (this.remoteSequenceNumber) {\n            if (message.cseq <= this.remoteSequenceNumber) {\n                throw new Error(\"Out of sequence in dialog request. Did you forget to call sequenceGuard()?\");\n            }\n            this.dialogState.remoteSequenceNumber = message.cseq;\n        }\n        // If the remote sequence number is empty, it MUST be set to the value\n        // of the sequence number in the CSeq header field value in the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.remoteSequenceNumber) {\n            this.dialogState.remoteSequenceNumber = message.cseq;\n        }\n        // When a UAS receives a target refresh request, it MUST replace the\n        // dialog's remote target URI with the URI from the Contact header field\n        // in that request, if present.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        // Note: \"target refresh request\" processing delegated to sub-class.\n    }\n    /**\n     * If the dialog identifier in the 2xx response matches the dialog\n     * identifier of an existing dialog, the dialog MUST be transitioned to\n     * the \"confirmed\" state, and the route set for the dialog MUST be\n     * recomputed based on the 2xx response using the procedures of Section\n     * 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n     * constructed using the procedures of Section 12.1.2.\n     *\n     * Note that the only piece of state that is recomputed is the route\n     * set.  Other pieces of state such as the highest sequence numbers\n     * (remote and local) sent within the dialog are not recomputed.  The\n     * route set only is recomputed for backwards compatibility.  RFC\n     * 2543 did not mandate mirroring of the Record-Route header field in\n     * a 1xx, only 2xx.  However, we cannot update the entire state of\n     * the dialog, since mid-dialog requests may have been sent within\n     * the early dialog, modifying the sequence numbers, for example.\n     *\n     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     */\n    recomputeRouteSet(message) {\n        this.dialogState.routeSet = message.getHeaders(\"record-route\").reverse();\n    }\n    /**\n     * A request within a dialog is constructed by using many of the\n     * components of the state stored as part of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n     * @param method - Outgoing request method.\n     */\n    createOutgoingRequestMessage(method, options) {\n        // The URI in the To field of the request MUST be set to the remote URI\n        // from the dialog state.  The tag in the To header field of the request\n        // MUST be set to the remote tag of the dialog ID.  The From URI of the\n        // request MUST be set to the local URI from the dialog state.  The tag\n        // in the From header field of the request MUST be set to the local tag\n        // of the dialog ID.  If the value of the remote or local tags is null,\n        // the tag parameter MUST be omitted from the To or From header fields,\n        // respectively.\n        //\n        //    Usage of the URI from the To and From fields in the original\n        //    request within subsequent requests is done for backwards\n        //    compatibility with RFC 2543, which used the URI for dialog\n        //    identification.  In this specification, only the tags are used for\n        //    dialog identification.  It is expected that mandatory reflection\n        //    of the original To and From URI in mid-dialog requests will be\n        //    deprecated in a subsequent revision of this specification.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        const toUri = this.remoteURI;\n        const toTag = this.remoteTag;\n        const fromUri = this.localURI;\n        const fromTag = this.localTag;\n        // The Call-ID of the request MUST be set to the Call-ID of the dialog.\n        // Requests within a dialog MUST contain strictly monotonically\n        // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n        // in each direction (excepting ACK and CANCEL of course, whose numbers\n        // equal the requests being acknowledged or cancelled).  Therefore, if\n        // the local sequence number is not empty, the value of the local\n        // sequence number MUST be incremented by one, and this value MUST be\n        // placed into the CSeq header field.  If the local sequence number is\n        // empty, an initial value MUST be chosen using the guidelines of\n        // Section 8.1.1.5.  The method field in the CSeq header field value\n        // MUST match the method of the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        const callId = this.callId;\n        let cseq;\n        if (options && options.cseq) {\n            cseq = options.cseq;\n        }\n        else if (!this.dialogState.localSequenceNumber) {\n            cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5\n        }\n        else {\n            cseq = this.dialogState.localSequenceNumber += 1;\n        }\n        // The UAC uses the remote target and route set to build the Request-URI\n        // and Route header field of the request.\n        //\n        // If the route set is empty, the UAC MUST place the remote target URI\n        // into the Request-URI.  The UAC MUST NOT add a Route header field to\n        // the request.\n        //\n        // If the route set is not empty, and the first URI in the route set\n        // contains the lr parameter (see Section 19.1.1), the UAC MUST place\n        // the remote target URI into the Request-URI and MUST include a Route\n        // header field containing the route set values in order, including all\n        // parameters.\n        //\n        // If the route set is not empty, and its first URI does not contain the\n        // lr parameter, the UAC MUST place the first URI from the route set\n        // into the Request-URI, stripping any parameters that are not allowed\n        // in a Request-URI.  The UAC MUST add a Route header field containing\n        // the remainder of the route set values in order, including all\n        // parameters.  The UAC MUST then place the remote target URI into the\n        // Route header field as the last value.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        // The lr parameter, when present, indicates that the element\n        // responsible for this resource implements the routing mechanisms\n        // specified in this document.  This parameter will be used in the\n        // URIs proxies place into Record-Route header field values, and\n        // may appear in the URIs in a pre-existing route set.\n        //\n        // This parameter is used to achieve backwards compatibility with\n        // systems implementing the strict-routing mechanisms of RFC 2543\n        // and the rfc2543bis drafts up to bis-05.  An element preparing\n        // to send a request based on a URI not containing this parameter\n        // can assume the receiving element implements strict-routing and\n        // reformat the message to preserve the information in the\n        // Request-URI.\n        // https://tools.ietf.org/html/rfc3261#section-19.1.1\n        // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n        const ruri = this.remoteTarget;\n        const routeSet = this.routeSet;\n        const extraHeaders = options && options.extraHeaders;\n        const body = options && options.body;\n        // The relative order of header fields with different field names is not\n        // significant.  However, it is RECOMMENDED that header fields which are\n        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n        // Max-Forwards, and Proxy-Authorization, for example) appear towards\n        // the top of the message to facilitate rapid parsing.\n        // https://tools.ietf.org/html/rfc3261#section-7.3.1\n        const message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {\n            callId,\n            cseq,\n            fromTag,\n            toTag,\n            routeSet\n        }, extraHeaders, body);\n        return message;\n    }\n    /**\n     * Increment the local sequence number by one.\n     * It feels like this should be protected, but the current authentication handling currently\n     * needs this to keep the dialog in sync when \"auto re-sends\" request messages.\n     * @internal\n     */\n    incrementLocalSequenceNumber() {\n        if (!this.dialogState.localSequenceNumber) {\n            throw new Error(\"Local sequence number undefined.\");\n        }\n        this.dialogState.localSequenceNumber += 1;\n    }\n    /**\n     * If the remote sequence number was not empty, but the sequence number\n     * of the request is lower than the remote sequence number, the request\n     * is out of order and MUST be rejected with a 500 (Server Internal\n     * Error) response.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param request - Incoming request to guard.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.\n     */\n    sequenceGuard(message) {\n        // ACK guard.\n        // By convention, handling of unexpected ACKs is responsibility\n        // the particular dialog implementation. For example, see SessionDialog.\n        // Furthermore, we cannot reply to an \"out of sequence\" ACK.\n        if (message.method === C.ACK) {\n            return true;\n        }\n        // Note: We are rejecting on \"less than or equal to\" the remote\n        // sequence number (excepting ACK whose numbers equal the requests\n        // being acknowledged or cancelled), which is the correct thing to\n        // do in our case. The only time a request with the same sequence number\n        // will show up here if is a) it is a very late retransmission of a\n        // request we already handled or b) it is a different request with the\n        // same sequence number which would be violation of the standard.\n        // Request retransmissions are absorbed by the transaction layer,\n        // so any request with a duplicate sequence number getting here\n        // would have to be a retransmission after the transaction terminated\n        // or a broken request (with unique via branch value).\n        // Requests within a dialog MUST contain strictly monotonically\n        // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n        // in each direction (excepting ACK and CANCEL of course, whose numbers\n        // equal the requests being acknowledged or cancelled).  Therefore, if\n        // the local sequence number is not empty, the value of the local\n        // sequence number MUST be incremented by one, and this value MUST be\n        // placed into the CSeq header field.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {\n            this.core.replyStateless(message, { statusCode: 500 });\n            return false;\n        }\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}