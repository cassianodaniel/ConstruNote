{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { C } from \"../messages\";\nimport { Timers } from \"../timers\";\nimport { ServerTransaction } from \"./server-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.1\n * @public\n */\n\nexport var InviteServerTransaction = /*#__PURE__*/function (_ServerTransaction) {\n  _inherits(InviteServerTransaction, _ServerTransaction);\n\n  var _super = _createSuper(InviteServerTransaction);\n\n  /**\n   * Constructor.\n   * Upon construction, a \"100 Trying\" reply will be immediately sent.\n   * After construction the transaction will be in the \"proceeding\" state and the transaction\n   * `id` will equal the branch parameter set in the Via header of the incoming request.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   * @param request - Incoming INVITE request from the transport.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  function InviteServerTransaction(request, transport, user) {\n    _classCallCheck(this, InviteServerTransaction);\n\n    return _super.call(this, request, transport, user, TransactionState.Proceeding, \"sip.transaction.ist\");\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(InviteServerTransaction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.stopProgressExtensionTimer();\n\n      if (this.H) {\n        clearTimeout(this.H);\n        this.H = undefined;\n      }\n\n      if (this.I) {\n        clearTimeout(this.I);\n        this.I = undefined;\n      }\n\n      if (this.L) {\n        clearTimeout(this.L);\n        this.L = undefined;\n      }\n\n      _get(_getPrototypeOf(InviteServerTransaction.prototype), \"dispose\", this).call(this);\n    }\n    /** Transaction kind. Deprecated. */\n\n  }, {\n    key: \"receiveRequest\",\n\n    /**\n     * Receive requests from transport matching this transaction.\n     * @param request - Request matching this transaction.\n     */\n    value: function receiveRequest(request) {\n      var _this = this;\n\n      switch (this.state) {\n        case TransactionState.Proceeding:\n          // If a request retransmission is received while in the \"Proceeding\" state, the most\n          // recent provisional response that was received from the TU MUST be passed to the\n          // transport layer for retransmission.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n          if (request.method === C.INVITE) {\n            if (this.lastProvisionalResponse) {\n              this.send(this.lastProvisionalResponse).catch(function (error) {\n                _this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n              });\n            }\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Accepted:\n          // While in the \"Accepted\" state, any retransmissions of the INVITE\n          // received will match this transaction state machine and will be\n          // absorbed by the machine without changing its state. These\n          // retransmissions are not passed onto the TU.\n          // https://tools.ietf.org/html/rfc6026#section-7.1\n          if (request.method === C.INVITE) {\n            return;\n          }\n\n          break;\n\n        case TransactionState.Completed:\n          // Furthermore, while in the \"Completed\" state, if a request retransmission is\n          // received, the server SHOULD pass the response to the transport for retransmission.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n          if (request.method === C.INVITE) {\n            if (!this.lastFinalResponse) {\n              throw new Error(\"Last final response undefined.\");\n            }\n\n            this.send(this.lastFinalResponse).catch(function (error) {\n              _this.logTransportError(error, \"Failed to send retransmission of final response.\");\n            });\n            return;\n          } // If an ACK is received while the server transaction is in the \"Completed\" state,\n          // the server transaction MUST transition to the \"Confirmed\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n          if (request.method === C.ACK) {\n            this.stateTransition(TransactionState.Confirmed);\n            return;\n          }\n\n          break;\n\n        case TransactionState.Confirmed:\n          // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n          // triggered from retransmissions of the final response.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n          if (request.method === C.INVITE || request.method === C.ACK) {\n            return;\n          }\n\n          break;\n\n        case TransactionState.Terminated:\n          // For good measure absorb any additional messages that arrive (should not happen).\n          if (request.method === C.INVITE || request.method === C.ACK) {\n            return;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Invalid state \".concat(this.state));\n      }\n\n      var message = \"INVITE server transaction received unexpected \".concat(request.method, \" request while in state \").concat(this.state, \".\");\n      this.logger.warn(message);\n      return;\n    }\n    /**\n     * Receive responses from TU for this transaction.\n     * @param statusCode - Status code of response.\n     * @param response - Response.\n     */\n\n  }, {\n    key: \"receiveResponse\",\n    value: function receiveResponse(statusCode, response) {\n      var _this2 = this;\n\n      if (statusCode < 100 || statusCode > 699) {\n        throw new Error(\"Invalid status code \".concat(statusCode));\n      }\n\n      switch (this.state) {\n        case TransactionState.Proceeding:\n          // The TU passes any number of provisional responses to the server\n          // transaction. So long as the server transaction is in the\n          // \"Proceeding\" state, each of these MUST be passed to the transport\n          // layer for transmission. They are not sent reliably by the\n          // transaction layer (they are not retransmitted by it) and do not cause\n          // a change in the state of the server transaction.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n          if (statusCode >= 100 && statusCode <= 199) {\n            this.lastProvisionalResponse = response; // Start the progress extension timer only for a non-100 provisional response.\n\n            if (statusCode > 100) {\n              this.startProgressExtensionTimer(); // FIXME: remove\n            }\n\n            this.send(response).catch(function (error) {\n              _this2.logTransportError(error, \"Failed to send 1xx response.\");\n            });\n            return;\n          } // If, while in the \"Proceeding\" state, the TU passes a 2xx response\n          // to the server transaction, the server transaction MUST pass this\n          // response to the transport layer for transmission. It is not\n          // retransmitted by the server transaction; retransmissions of 2xx\n          // responses are handled by the TU. The server transaction MUST then\n          // transition to the \"Accepted\" state.\n          // https://tools.ietf.org/html/rfc6026#section-8.5\n\n\n          if (statusCode >= 200 && statusCode <= 299) {\n            this.lastFinalResponse = response;\n            this.stateTransition(TransactionState.Accepted);\n            this.send(response).catch(function (error) {\n              _this2.logTransportError(error, \"Failed to send 2xx response.\");\n            });\n            return;\n          } // While in the \"Proceeding\" state, if the TU passes a response with\n          // status code from 300 to 699 to the server transaction, the response\n          // MUST be passed to the transport layer for transmission, and the state\n          // machine MUST enter the \"Completed\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n          if (statusCode >= 300 && statusCode <= 699) {\n            this.lastFinalResponse = response;\n            this.stateTransition(TransactionState.Completed);\n            this.send(response).catch(function (error) {\n              _this2.logTransportError(error, \"Failed to send non-2xx final response.\");\n            });\n            return;\n          }\n\n          break;\n\n        case TransactionState.Accepted:\n          // While in the \"Accepted\" state, if the TU passes a 2xx response,\n          // the server transaction MUST pass the response to the transport layer for transmission.\n          // https://tools.ietf.org/html/rfc6026#section-8.7\n          if (statusCode >= 200 && statusCode <= 299) {\n            this.send(response).catch(function (error) {\n              _this2.logTransportError(error, \"Failed to send 2xx response.\");\n            });\n            return;\n          }\n\n          break;\n\n        case TransactionState.Completed:\n          break;\n\n        case TransactionState.Confirmed:\n          break;\n\n        case TransactionState.Terminated:\n          break;\n\n        default:\n          throw new Error(\"Invalid state \".concat(this.state));\n      }\n\n      var message = \"INVITE server transaction received unexpected \".concat(statusCode, \" response from TU while in state \").concat(this.state, \".\");\n      this.logger.error(message);\n      throw new Error(message);\n    }\n    /**\n     * Retransmit the last 2xx response. This is a noop if not in the \"accepted\" state.\n     */\n\n  }, {\n    key: \"retransmitAcceptedResponse\",\n    value: function retransmitAcceptedResponse() {\n      var _this3 = this;\n\n      if (this.state === TransactionState.Accepted && this.lastFinalResponse) {\n        this.send(this.lastFinalResponse).catch(function (error) {\n          _this3.logTransportError(error, \"Failed to send 2xx response.\");\n        });\n      }\n    }\n    /**\n     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n     * inform the TU that a failure has occurred, and MUST remain in the current state.\n     * https://tools.ietf.org/html/rfc6026#section-8.8\n     */\n\n  }, {\n    key: \"onTransportError\",\n    value: function onTransportError(error) {\n      if (this.user.onTransportError) {\n        this.user.onTransportError(error);\n      }\n    }\n    /** For logging. */\n\n  }, {\n    key: \"typeToString\",\n    value: function typeToString() {\n      return \"INVITE server transaction\";\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState) {\n      var _this4 = this;\n\n      // Assert valid state transitions.\n      var invalidStateTransition = function invalidStateTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this4.state, \" to \").concat(newState));\n      };\n\n      switch (newState) {\n        case TransactionState.Proceeding:\n          invalidStateTransition();\n          break;\n\n        case TransactionState.Accepted:\n        case TransactionState.Completed:\n          if (this.state !== TransactionState.Proceeding) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Confirmed:\n          if (this.state !== TransactionState.Completed) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Terminated:\n          if (this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed && this.state !== TransactionState.Confirmed) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        default:\n          invalidStateTransition();\n      } // On any state transition, stop resending provisional responses\n\n\n      this.stopProgressExtensionTimer(); // The purpose of the \"Accepted\" state is to absorb retransmissions of an accepted INVITE request.\n      // Any such retransmissions are absorbed entirely within the server transaction.\n      // They are not passed up to the TU since any downstream UAS cores that accepted the request have\n      // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.\n      // https://tools.ietf.org/html/rfc6026#section-8.7\n\n      if (newState === TransactionState.Accepted) {\n        this.L = setTimeout(function () {\n          return _this4.timerL();\n        }, Timers.TIMER_L);\n      } // When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.\n      // Timer H determines when the server transaction abandons retransmitting the response.\n      // If an ACK is received while the server transaction is in the \"Completed\" state,\n      // the server transaction MUST transition to the \"Confirmed\" state.\n      // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n      if (newState === TransactionState.Completed) {\n        // FIXME: Missing timer G for unreliable transports.\n        this.H = setTimeout(function () {\n          return _this4.timerH();\n        }, Timers.TIMER_H);\n      } // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n      // triggered from retransmissions of the final response. When this state is entered, timer I\n      // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable\n      // transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.\n      // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n      if (newState === TransactionState.Confirmed) {\n        // FIXME: This timer is not getting set correctly for unreliable transports.\n        this.I = setTimeout(function () {\n          return _this4.timerI();\n        }, Timers.TIMER_I);\n      } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n      // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n      if (newState === TransactionState.Terminated) {\n        this.dispose();\n      } // Update state.\n\n\n      this.setState(newState);\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n\n  }, {\n    key: \"startProgressExtensionTimer\",\n    value: function startProgressExtensionTimer() {\n      var _this5 = this;\n\n      // Start the progress extension timer only for the first non-100 provisional response.\n      if (this.progressExtensionTimer === undefined) {\n        this.progressExtensionTimer = setInterval(function () {\n          _this5.logger.debug(\"Progress extension timer expired for INVITE server transaction \".concat(_this5.id, \".\"));\n\n          if (!_this5.lastProvisionalResponse) {\n            throw new Error(\"Last provisional response undefined.\");\n          }\n\n          _this5.send(_this5.lastProvisionalResponse).catch(function (error) {\n            _this5.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n          });\n        }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n      }\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n\n  }, {\n    key: \"stopProgressExtensionTimer\",\n    value: function stopProgressExtensionTimer() {\n      if (this.progressExtensionTimer !== undefined) {\n        clearInterval(this.progressExtensionTimer);\n        this.progressExtensionTimer = undefined;\n      }\n    }\n    /**\n     * While in the \"Proceeding\" state, if the TU passes a response with status code\n     * from 300 to 699 to the server transaction, the response MUST be passed to the\n     * transport layer for transmission, and the state machine MUST enter the \"Completed\" state.\n     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for\n     * reliable transports. If timer G fires, the response is passed to the transport layer once\n     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,\n     * when timer G fires, the response is passed to the transport again for transmission, and\n     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case\n     * it is reset with the value of T2.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n\n  }, {\n    key: \"timerG\",\n    value: function timerG() {// TODO\n    }\n    /**\n     * If timer H fires while in the \"Completed\" state, it implies that the ACK was never received.\n     * In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST\n     * indicate to the TU that a transaction failure has occurred.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n\n  }, {\n    key: \"timerH\",\n    value: function timerH() {\n      this.logger.debug(\"Timer H expired for INVITE server transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Completed) {\n        this.logger.warn(\"ACK to negative final response was never received, terminating transaction.\");\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n    /**\n     * Once timer I fires, the server MUST transition to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n\n  }, {\n    key: \"timerI\",\n    value: function timerI() {\n      this.logger.debug(\"Timer I expired for INVITE server transaction \".concat(this.id, \".\"));\n      this.stateTransition(TransactionState.Terminated);\n    }\n    /**\n     * When Timer L fires and the state machine is in the \"Accepted\" state, the machine MUST\n     * transition to the \"Terminated\" state. Once the transaction is in the \"Terminated\" state,\n     * it MUST be destroyed immediately. Timer L reflects the amount of time the server\n     * transaction could receive 2xx responses for retransmission from the\n     * TU while it is waiting to receive an ACK.\n     * https://tools.ietf.org/html/rfc6026#section-7.1\n     * https://tools.ietf.org/html/rfc6026#section-8.7\n     */\n\n  }, {\n    key: \"timerL\",\n    value: function timerL() {\n      this.logger.debug(\"Timer L expired for INVITE server transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Accepted) {\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n  }, {\n    key: \"kind\",\n    get: function get() {\n      return \"ist\";\n    }\n  }]);\n\n  return InviteServerTransaction;\n}(ServerTransaction);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"],"names":["C","Timers","ServerTransaction","TransactionState","InviteServerTransaction","request","transport","user","Proceeding","stopProgressExtensionTimer","H","clearTimeout","undefined","I","L","state","method","INVITE","lastProvisionalResponse","send","catch","error","logTransportError","Accepted","Completed","lastFinalResponse","Error","ACK","stateTransition","Confirmed","Terminated","message","logger","warn","statusCode","response","startProgressExtensionTimer","onTransportError","newState","invalidStateTransition","setTimeout","timerL","TIMER_L","timerH","TIMER_H","timerI","TIMER_I","dispose","setState","progressExtensionTimer","setInterval","debug","id","PROVISIONAL_RESPONSE_INTERVAL","clearInterval"],"mappings":"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","sourcesContent":["import { C } from \"../messages\";\nimport { Timers } from \"../timers\";\nimport { ServerTransaction } from \"./server-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.1\n * @public\n */\nexport class InviteServerTransaction extends ServerTransaction {\n    /**\n     * Constructor.\n     * Upon construction, a \"100 Trying\" reply will be immediately sent.\n     * After construction the transaction will be in the \"proceeding\" state and the transaction\n     * `id` will equal the branch parameter set in the Via header of the incoming request.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     * @param request - Incoming INVITE request from the transport.\n     * @param transport - The transport.\n     * @param user - The transaction user.\n     */\n    constructor(request, transport, user) {\n        super(request, transport, user, TransactionState.Proceeding, \"sip.transaction.ist\");\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        this.stopProgressExtensionTimer();\n        if (this.H) {\n            clearTimeout(this.H);\n            this.H = undefined;\n        }\n        if (this.I) {\n            clearTimeout(this.I);\n            this.I = undefined;\n        }\n        if (this.L) {\n            clearTimeout(this.L);\n            this.L = undefined;\n        }\n        super.dispose();\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        return \"ist\";\n    }\n    /**\n     * Receive requests from transport matching this transaction.\n     * @param request - Request matching this transaction.\n     */\n    receiveRequest(request) {\n        switch (this.state) {\n            case TransactionState.Proceeding:\n                // If a request retransmission is received while in the \"Proceeding\" state, the most\n                // recent provisional response that was received from the TU MUST be passed to the\n                // transport layer for retransmission.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE) {\n                    if (this.lastProvisionalResponse) {\n                        this.send(this.lastProvisionalResponse).catch((error) => {\n                            this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n                        });\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // While in the \"Accepted\" state, any retransmissions of the INVITE\n                // received will match this transaction state machine and will be\n                // absorbed by the machine without changing its state. These\n                // retransmissions are not passed onto the TU.\n                // https://tools.ietf.org/html/rfc6026#section-7.1\n                if (request.method === C.INVITE) {\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                // Furthermore, while in the \"Completed\" state, if a request retransmission is\n                // received, the server SHOULD pass the response to the transport for retransmission.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE) {\n                    if (!this.lastFinalResponse) {\n                        throw new Error(\"Last final response undefined.\");\n                    }\n                    this.send(this.lastFinalResponse).catch((error) => {\n                        this.logTransportError(error, \"Failed to send retransmission of final response.\");\n                    });\n                    return;\n                }\n                // If an ACK is received while the server transaction is in the \"Completed\" state,\n                // the server transaction MUST transition to the \"Confirmed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.ACK) {\n                    this.stateTransition(TransactionState.Confirmed);\n                    return;\n                }\n                break;\n            case TransactionState.Confirmed:\n                // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n                // triggered from retransmissions of the final response.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE || request.method === C.ACK) {\n                    return;\n                }\n                break;\n            case TransactionState.Terminated:\n                // For good measure absorb any additional messages that arrive (should not happen).\n                if (request.method === C.INVITE || request.method === C.ACK) {\n                    return;\n                }\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        const message = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;\n        this.logger.warn(message);\n        return;\n    }\n    /**\n     * Receive responses from TU for this transaction.\n     * @param statusCode - Status code of response.\n     * @param response - Response.\n     */\n    receiveResponse(statusCode, response) {\n        if (statusCode < 100 || statusCode > 699) {\n            throw new Error(`Invalid status code ${statusCode}`);\n        }\n        switch (this.state) {\n            case TransactionState.Proceeding:\n                // The TU passes any number of provisional responses to the server\n                // transaction. So long as the server transaction is in the\n                // \"Proceeding\" state, each of these MUST be passed to the transport\n                // layer for transmission. They are not sent reliably by the\n                // transaction layer (they are not retransmitted by it) and do not cause\n                // a change in the state of the server transaction.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (statusCode >= 100 && statusCode <= 199) {\n                    this.lastProvisionalResponse = response;\n                    // Start the progress extension timer only for a non-100 provisional response.\n                    if (statusCode > 100) {\n                        this.startProgressExtensionTimer(); // FIXME: remove\n                    }\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 1xx response.\");\n                    });\n                    return;\n                }\n                // If, while in the \"Proceeding\" state, the TU passes a 2xx response\n                // to the server transaction, the server transaction MUST pass this\n                // response to the transport layer for transmission. It is not\n                // retransmitted by the server transaction; retransmissions of 2xx\n                // responses are handled by the TU. The server transaction MUST then\n                // transition to the \"Accepted\" state.\n                // https://tools.ietf.org/html/rfc6026#section-8.5\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.lastFinalResponse = response;\n                    this.stateTransition(TransactionState.Accepted);\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 2xx response.\");\n                    });\n                    return;\n                }\n                // While in the \"Proceeding\" state, if the TU passes a response with\n                // status code from 300 to 699 to the server transaction, the response\n                // MUST be passed to the transport layer for transmission, and the state\n                // machine MUST enter the \"Completed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.lastFinalResponse = response;\n                    this.stateTransition(TransactionState.Completed);\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send non-2xx final response.\");\n                    });\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // While in the \"Accepted\" state, if the TU passes a 2xx response,\n                // the server transaction MUST pass the response to the transport layer for transmission.\n                // https://tools.ietf.org/html/rfc6026#section-8.7\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 2xx response.\");\n                    });\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                break;\n            case TransactionState.Confirmed:\n                break;\n            case TransactionState.Terminated:\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        const message = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;\n        this.logger.error(message);\n        throw new Error(message);\n    }\n    /**\n     * Retransmit the last 2xx response. This is a noop if not in the \"accepted\" state.\n     */\n    retransmitAcceptedResponse() {\n        if (this.state === TransactionState.Accepted && this.lastFinalResponse) {\n            this.send(this.lastFinalResponse).catch((error) => {\n                this.logTransportError(error, \"Failed to send 2xx response.\");\n            });\n        }\n    }\n    /**\n     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n     * inform the TU that a failure has occurred, and MUST remain in the current state.\n     * https://tools.ietf.org/html/rfc6026#section-8.8\n     */\n    onTransportError(error) {\n        if (this.user.onTransportError) {\n            this.user.onTransportError(error);\n        }\n    }\n    /** For logging. */\n    typeToString() {\n        return \"INVITE server transaction\";\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n    stateTransition(newState) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n        };\n        switch (newState) {\n            case TransactionState.Proceeding:\n                invalidStateTransition();\n                break;\n            case TransactionState.Accepted:\n            case TransactionState.Completed:\n                if (this.state !== TransactionState.Proceeding) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Confirmed:\n                if (this.state !== TransactionState.Completed) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Terminated:\n                if (this.state !== TransactionState.Accepted &&\n                    this.state !== TransactionState.Completed &&\n                    this.state !== TransactionState.Confirmed) {\n                    invalidStateTransition();\n                }\n                break;\n            default:\n                invalidStateTransition();\n        }\n        // On any state transition, stop resending provisional responses\n        this.stopProgressExtensionTimer();\n        // The purpose of the \"Accepted\" state is to absorb retransmissions of an accepted INVITE request.\n        // Any such retransmissions are absorbed entirely within the server transaction.\n        // They are not passed up to the TU since any downstream UAS cores that accepted the request have\n        // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Accepted) {\n            this.L = setTimeout(() => this.timerL(), Timers.TIMER_L);\n        }\n        // When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.\n        // Timer H determines when the server transaction abandons retransmitting the response.\n        // If an ACK is received while the server transaction is in the \"Completed\" state,\n        // the server transaction MUST transition to the \"Confirmed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (newState === TransactionState.Completed) {\n            // FIXME: Missing timer G for unreliable transports.\n            this.H = setTimeout(() => this.timerH(), Timers.TIMER_H);\n        }\n        // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n        // triggered from retransmissions of the final response. When this state is entered, timer I\n        // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable\n        // transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (newState === TransactionState.Confirmed) {\n            // FIXME: This timer is not getting set correctly for unreliable transports.\n            this.I = setTimeout(() => this.timerI(), Timers.TIMER_I);\n        }\n        // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Terminated) {\n            this.dispose();\n        }\n        // Update state.\n        this.setState(newState);\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n    startProgressExtensionTimer() {\n        // Start the progress extension timer only for the first non-100 provisional response.\n        if (this.progressExtensionTimer === undefined) {\n            this.progressExtensionTimer = setInterval(() => {\n                this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);\n                if (!this.lastProvisionalResponse) {\n                    throw new Error(\"Last provisional response undefined.\");\n                }\n                this.send(this.lastProvisionalResponse).catch((error) => {\n                    this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n                });\n            }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n        }\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n    stopProgressExtensionTimer() {\n        if (this.progressExtensionTimer !== undefined) {\n            clearInterval(this.progressExtensionTimer);\n            this.progressExtensionTimer = undefined;\n        }\n    }\n    /**\n     * While in the \"Proceeding\" state, if the TU passes a response with status code\n     * from 300 to 699 to the server transaction, the response MUST be passed to the\n     * transport layer for transmission, and the state machine MUST enter the \"Completed\" state.\n     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for\n     * reliable transports. If timer G fires, the response is passed to the transport layer once\n     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,\n     * when timer G fires, the response is passed to the transport again for transmission, and\n     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case\n     * it is reset with the value of T2.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerG() {\n        // TODO\n    }\n    /**\n     * If timer H fires while in the \"Completed\" state, it implies that the ACK was never received.\n     * In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST\n     * indicate to the TU that a transaction failure has occurred.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerH() {\n        this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);\n        if (this.state === TransactionState.Completed) {\n            this.logger.warn(\"ACK to negative final response was never received, terminating transaction.\");\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * Once timer I fires, the server MUST transition to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerI() {\n        this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);\n        this.stateTransition(TransactionState.Terminated);\n    }\n    /**\n     * When Timer L fires and the state machine is in the \"Accepted\" state, the machine MUST\n     * transition to the \"Terminated\" state. Once the transaction is in the \"Terminated\" state,\n     * it MUST be destroyed immediately. Timer L reflects the amount of time the server\n     * transaction could receive 2xx responses for retransmission from the\n     * TU while it is waiting to receive an ACK.\n     * https://tools.ietf.org/html/rfc6026#section-7.1\n     * https://tools.ietf.org/html/rfc6026#section-8.7\n     */\n    timerL() {\n        this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);\n        if (this.state === TransactionState.Accepted) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}