{"ast":null,"code":"import { TransactionStateError } from \"../exceptions\";\nimport { constructOutgoingResponse } from \"../messages\";\nimport { newTag } from \"../messages/utils\";\nimport { InviteServerTransaction, NonInviteServerTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Server (UAS).\n * @remarks\n * A user agent server is a logical entity\n * that generates a response to a SIP request.  The response\n * accepts, rejects, or redirects the request.  This role lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software responds to a request, it acts as a UAS for\n * the duration of that transaction.  If it generates a request\n * later, it assumes the role of a user agent client for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport class UserAgentServer {\n  constructor(transactionConstructor, core, message, delegate) {\n    this.transactionConstructor = transactionConstructor;\n    this.core = core;\n    this.message = message;\n    this.delegate = delegate;\n    this.logger = this.loggerFactory.getLogger(\"sip.user-agent-server\");\n    this.toTag = message.toTag ? message.toTag : newTag();\n    this.init();\n  }\n\n  dispose() {\n    this.transaction.dispose();\n  }\n\n  get loggerFactory() {\n    return this.core.loggerFactory;\n  }\n  /** The transaction associated with this request. */\n\n\n  get transaction() {\n    if (!this._transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    return this._transaction;\n  }\n\n  accept(options = {\n    statusCode: 200\n  }) {\n    if (!this.acceptable) {\n      throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 200 || statusCode > 299) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  }\n\n  progress(options = {\n    statusCode: 180\n  }) {\n    if (!this.progressable) {\n      throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 101 || statusCode > 199) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  }\n\n  redirect(contacts, options = {\n    statusCode: 302\n  }) {\n    if (!this.redirectable) {\n      throw new TransactionStateError(`${this.message.method} not redirectable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 300 || statusCode > 399) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const contactHeaders = new Array();\n    contacts.forEach(contact => contactHeaders.push(`Contact: ${contact.toString()}`));\n    options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);\n    const response = this.reply(options);\n    return response;\n  }\n\n  reject(options = {\n    statusCode: 480\n  }) {\n    if (!this.rejectable) {\n      throw new TransactionStateError(`${this.message.method} not rejectable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 400 || statusCode > 699) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  trying(options) {\n    if (!this.tryingable) {\n      throw new TransactionStateError(`${this.message.method} not tryingable in state ${this.transaction.state}.`);\n    }\n\n    const response = this.reply({\n      statusCode: 100\n    });\n    return response;\n  }\n  /**\n   * If the UAS did not find a matching transaction for the CANCEL\n   * according to the procedure above, it SHOULD respond to the CANCEL\n   * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction\n   * for the original request still exists, the behavior of the UAS on\n   * receiving a CANCEL request depends on whether it has already sent a\n   * final response for the original request.  If it has, the CANCEL\n   * request has no effect on the processing of the original request, no\n   * effect on any session state, and no effect on the responses generated\n   * for the original request.  If the UAS has not issued a final response\n   * for the original request, its behavior depends on the method of the\n   * original request.  If the original request was an INVITE, the UAS\n   * SHOULD immediately respond to the INVITE with a 487 (Request\n   * Terminated).  A CANCEL request has no impact on the processing of\n   * transactions with any other method defined in this specification.\n   * https://tools.ietf.org/html/rfc3261#section-9.2\n   * @param request - Incoming CANCEL request.\n   */\n\n\n  receiveCancel(message) {\n    // Note: Currently CANCEL is being handled as a special case.\n    // No UAS is created to handle the CANCEL and the response to\n    // it CANCEL is being handled statelessly by the user agent core.\n    // As such, there is currently no way to externally impact the\n    // response to the a CANCEL request.\n    if (this.delegate && this.delegate.onCancel) {\n      this.delegate.onCancel(message);\n    }\n  }\n\n  get acceptable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding || this.transaction.state === TransactionState.Accepted;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get progressable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return false; // https://tools.ietf.org/html/rfc4320#section-4.1\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get redirectable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get rejectable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get tryingable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n  /**\n   * When a UAS wishes to construct a response to a request, it follows\n   * the general procedures detailed in the following subsections.\n   * Additional behaviors specific to the response code in question, which\n   * are not detailed in this section, may also be required.\n   *\n   * Once all procedures associated with the creation of a response have\n   * been completed, the UAS hands the response back to the server\n   * transaction from which it received the request.\n   * https://tools.ietf.org/html/rfc3261#section-8.2.6\n   * @param statusCode - Status code to reply with.\n   * @param options - Reply options bucket.\n   */\n\n\n  reply(options) {\n    if (!options.toTag && options.statusCode !== 100) {\n      options.toTag = this.toTag;\n    }\n\n    options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;\n    options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;\n    const response = constructOutgoingResponse(this.message, options);\n    this.transaction.receiveResponse(options.statusCode, response.message);\n    return response;\n  }\n\n  init() {\n    // We are the transaction user.\n    const user = {\n      loggerFactory: this.loggerFactory,\n      onStateChange: newState => {\n        if (newState === TransactionState.Terminated) {\n          // Remove the terminated transaction from the core.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          this.core.userAgentServers.delete(userAgentServerId);\n          this.dispose();\n        }\n      },\n      onTransportError: error => {\n        this.logger.error(error.message);\n\n        if (this.delegate && this.delegate.onTransportError) {\n          this.delegate.onTransportError(error);\n        } else {\n          this.logger.error(\"User agent server response transport error.\");\n        }\n      }\n    }; // Create a new transaction with us as the user.\n\n    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n    this._transaction = transaction; // Add the new transaction to the core.\n\n    const userAgentServerId = transaction.id;\n    this.core.userAgentServers.set(transaction.id, this);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/user-agent-server.js"],"names":["TransactionStateError","constructOutgoingResponse","newTag","InviteServerTransaction","NonInviteServerTransaction","TransactionState","UserAgentServer","constructor","transactionConstructor","core","message","delegate","logger","loggerFactory","getLogger","toTag","init","dispose","transaction","_transaction","Error","accept","options","statusCode","acceptable","method","state","TypeError","response","reply","progress","progressable","redirect","contacts","redirectable","contactHeaders","Array","forEach","contact","push","toString","extraHeaders","concat","reject","rejectable","trying","tryingable","receiveCancel","onCancel","Proceeding","Accepted","Trying","userAgent","configuration","userAgentHeaderFieldValue","supported","supportedOptionTagsResponse","receiveResponse","user","onStateChange","newState","Terminated","userAgentServers","delete","userAgentServerId","onTransportError","error","transport","id","set"],"mappings":"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","sourcesContent":["import { TransactionStateError } from \"../exceptions\";\nimport { constructOutgoingResponse } from \"../messages\";\nimport { newTag } from \"../messages/utils\";\nimport { InviteServerTransaction, NonInviteServerTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Server (UAS).\n * @remarks\n * A user agent server is a logical entity\n * that generates a response to a SIP request.  The response\n * accepts, rejects, or redirects the request.  This role lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software responds to a request, it acts as a UAS for\n * the duration of that transaction.  If it generates a request\n * later, it assumes the role of a user agent client for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\nexport class UserAgentServer {\n    constructor(transactionConstructor, core, message, delegate) {\n        this.transactionConstructor = transactionConstructor;\n        this.core = core;\n        this.message = message;\n        this.delegate = delegate;\n        this.logger = this.loggerFactory.getLogger(\"sip.user-agent-server\");\n        this.toTag = message.toTag ? message.toTag : newTag();\n        this.init();\n    }\n    dispose() {\n        this.transaction.dispose();\n    }\n    get loggerFactory() {\n        return this.core.loggerFactory;\n    }\n    /** The transaction associated with this request. */\n    get transaction() {\n        if (!this._transaction) {\n            throw new Error(\"Transaction undefined.\");\n        }\n        return this._transaction;\n    }\n    accept(options = { statusCode: 200 }) {\n        if (!this.acceptable) {\n            throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n        }\n        const statusCode = options.statusCode;\n        if (statusCode < 200 || statusCode > 299) {\n            throw new TypeError(`Invalid statusCode: ${statusCode}`);\n        }\n        const response = this.reply(options);\n        return response;\n    }\n    progress(options = { statusCode: 180 }) {\n        if (!this.progressable) {\n            throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n        }\n        const statusCode = options.statusCode;\n        if (statusCode < 101 || statusCode > 199) {\n            throw new TypeError(`Invalid statusCode: ${statusCode}`);\n        }\n        const response = this.reply(options);\n        return response;\n    }\n    redirect(contacts, options = { statusCode: 302 }) {\n        if (!this.redirectable) {\n            throw new TransactionStateError(`${this.message.method} not redirectable in state ${this.transaction.state}.`);\n        }\n        const statusCode = options.statusCode;\n        if (statusCode < 300 || statusCode > 399) {\n            throw new TypeError(`Invalid statusCode: ${statusCode}`);\n        }\n        const contactHeaders = new Array();\n        contacts.forEach((contact) => contactHeaders.push(`Contact: ${contact.toString()}`));\n        options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);\n        const response = this.reply(options);\n        return response;\n    }\n    reject(options = { statusCode: 480 }) {\n        if (!this.rejectable) {\n            throw new TransactionStateError(`${this.message.method} not rejectable in state ${this.transaction.state}.`);\n        }\n        const statusCode = options.statusCode;\n        if (statusCode < 400 || statusCode > 699) {\n            throw new TypeError(`Invalid statusCode: ${statusCode}`);\n        }\n        const response = this.reply(options);\n        return response;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    trying(options) {\n        if (!this.tryingable) {\n            throw new TransactionStateError(`${this.message.method} not tryingable in state ${this.transaction.state}.`);\n        }\n        const response = this.reply({ statusCode: 100 });\n        return response;\n    }\n    /**\n     * If the UAS did not find a matching transaction for the CANCEL\n     * according to the procedure above, it SHOULD respond to the CANCEL\n     * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction\n     * for the original request still exists, the behavior of the UAS on\n     * receiving a CANCEL request depends on whether it has already sent a\n     * final response for the original request.  If it has, the CANCEL\n     * request has no effect on the processing of the original request, no\n     * effect on any session state, and no effect on the responses generated\n     * for the original request.  If the UAS has not issued a final response\n     * for the original request, its behavior depends on the method of the\n     * original request.  If the original request was an INVITE, the UAS\n     * SHOULD immediately respond to the INVITE with a 487 (Request\n     * Terminated).  A CANCEL request has no impact on the processing of\n     * transactions with any other method defined in this specification.\n     * https://tools.ietf.org/html/rfc3261#section-9.2\n     * @param request - Incoming CANCEL request.\n     */\n    receiveCancel(message) {\n        // Note: Currently CANCEL is being handled as a special case.\n        // No UAS is created to handle the CANCEL and the response to\n        // it CANCEL is being handled statelessly by the user agent core.\n        // As such, there is currently no way to externally impact the\n        // response to the a CANCEL request.\n        if (this.delegate && this.delegate.onCancel) {\n            this.delegate.onCancel(message);\n        }\n    }\n    get acceptable() {\n        if (this.transaction instanceof InviteServerTransaction) {\n            return (this.transaction.state === TransactionState.Proceeding || this.transaction.state === TransactionState.Accepted);\n        }\n        if (this.transaction instanceof NonInviteServerTransaction) {\n            return (this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding);\n        }\n        throw new Error(\"Unknown transaction type.\");\n    }\n    get progressable() {\n        if (this.transaction instanceof InviteServerTransaction) {\n            return this.transaction.state === TransactionState.Proceeding;\n        }\n        if (this.transaction instanceof NonInviteServerTransaction) {\n            return false; // https://tools.ietf.org/html/rfc4320#section-4.1\n        }\n        throw new Error(\"Unknown transaction type.\");\n    }\n    get redirectable() {\n        if (this.transaction instanceof InviteServerTransaction) {\n            return this.transaction.state === TransactionState.Proceeding;\n        }\n        if (this.transaction instanceof NonInviteServerTransaction) {\n            return (this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding);\n        }\n        throw new Error(\"Unknown transaction type.\");\n    }\n    get rejectable() {\n        if (this.transaction instanceof InviteServerTransaction) {\n            return this.transaction.state === TransactionState.Proceeding;\n        }\n        if (this.transaction instanceof NonInviteServerTransaction) {\n            return (this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding);\n        }\n        throw new Error(\"Unknown transaction type.\");\n    }\n    get tryingable() {\n        if (this.transaction instanceof InviteServerTransaction) {\n            return this.transaction.state === TransactionState.Proceeding;\n        }\n        if (this.transaction instanceof NonInviteServerTransaction) {\n            return this.transaction.state === TransactionState.Trying;\n        }\n        throw new Error(\"Unknown transaction type.\");\n    }\n    /**\n     * When a UAS wishes to construct a response to a request, it follows\n     * the general procedures detailed in the following subsections.\n     * Additional behaviors specific to the response code in question, which\n     * are not detailed in this section, may also be required.\n     *\n     * Once all procedures associated with the creation of a response have\n     * been completed, the UAS hands the response back to the server\n     * transaction from which it received the request.\n     * https://tools.ietf.org/html/rfc3261#section-8.2.6\n     * @param statusCode - Status code to reply with.\n     * @param options - Reply options bucket.\n     */\n    reply(options) {\n        if (!options.toTag && options.statusCode !== 100) {\n            options.toTag = this.toTag;\n        }\n        options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;\n        options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;\n        const response = constructOutgoingResponse(this.message, options);\n        this.transaction.receiveResponse(options.statusCode, response.message);\n        return response;\n    }\n    init() {\n        // We are the transaction user.\n        const user = {\n            loggerFactory: this.loggerFactory,\n            onStateChange: (newState) => {\n                if (newState === TransactionState.Terminated) {\n                    // Remove the terminated transaction from the core.\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    this.core.userAgentServers.delete(userAgentServerId);\n                    this.dispose();\n                }\n            },\n            onTransportError: (error) => {\n                this.logger.error(error.message);\n                if (this.delegate && this.delegate.onTransportError) {\n                    this.delegate.onTransportError(error);\n                }\n                else {\n                    this.logger.error(\"User agent server response transport error.\");\n                }\n            }\n        };\n        // Create a new transaction with us as the user.\n        const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n        this._transaction = transaction;\n        // Add the new transaction to the core.\n        const userAgentServerId = transaction.id;\n        this.core.userAgentServers.set(transaction.id, this);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}