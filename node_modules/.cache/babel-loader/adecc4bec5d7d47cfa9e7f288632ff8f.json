{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar unescapeXML = require('../escape').unescapeXML;\n\nvar STATE_TEXT = 0;\nvar STATE_IGNORE_COMMENT = 1;\nvar STATE_IGNORE_INSTRUCTION = 2;\nvar STATE_TAG_NAME = 3;\nvar STATE_TAG = 4;\nvar STATE_ATTR_NAME = 5;\nvar STATE_ATTR_EQ = 6;\nvar STATE_ATTR_QUOT = 7;\nvar STATE_ATTR_VALUE = 8;\nvar STATE_CDATA = 9;\nvar STATE_IGNORE_CDATA = 10;\n\nvar SaxLtx = module.exports = function SaxLtx() {\n  EventEmitter.call(this);\n  var state = STATE_TEXT;\n  var remainder;\n  var tagName;\n  var attrs;\n  var endTag;\n  var selfClosing;\n  var attrQuote;\n  var attrQuoteChar;\n  var recordStart = 0;\n  var attrName;\n\n  this._handleTagOpening = function (endTag, tagName, attrs) {\n    if (!endTag) {\n      this.emit('startElement', tagName, attrs);\n\n      if (selfClosing) {\n        this.emit('endElement', tagName);\n      }\n    } else {\n      this.emit('endElement', tagName);\n    }\n  };\n\n  this.write = function (data) {\n    if (typeof data !== 'string') {\n      data = data.toString();\n    }\n\n    var pos = 0;\n    /* Anything from previous write()? */\n\n    if (remainder) {\n      data = remainder + data;\n      pos += remainder.length;\n      remainder = null;\n    }\n\n    function endRecording() {\n      if (typeof recordStart === 'number') {\n        var recorded = data.substring(recordStart, pos);\n        recordStart = undefined;\n        return recorded;\n      }\n    }\n\n    for (; pos < data.length; pos++) {\n      if (state === STATE_TEXT) {\n        // if we're looping through text, fast-forward using indexOf to\n        // the next '<' character\n        var lt = data.indexOf('<', pos);\n\n        if (lt !== -1 && pos !== lt) {\n          pos = lt;\n        }\n      } else if (state === STATE_ATTR_VALUE) {\n        // if we're looping through an attribute, fast-forward using\n        // indexOf to the next end quote character\n        var quot = data.indexOf(attrQuoteChar, pos);\n\n        if (quot !== -1) {\n          pos = quot;\n        }\n      } else if (state === STATE_IGNORE_COMMENT) {\n        // if we're looping through a comment, fast-forward using\n        // indexOf to the first end-comment character\n        var endcomment = data.indexOf('-->', pos);\n\n        if (endcomment !== -1) {\n          pos = endcomment + 2; // target the '>' character\n        }\n      } else if (state === STATE_IGNORE_CDATA) {\n        // if we're looping through a CDATA, fast-forward using\n        // indexOf to the first end-CDATA character ]]>\n        var endCDATA = data.indexOf(']]>', pos);\n\n        if (endCDATA !== -1) {\n          pos = endCDATA + 2; // target the '>' character\n        }\n      }\n\n      var c = data.charCodeAt(pos);\n\n      switch (state) {\n        case STATE_TEXT:\n          if (c === 60\n          /* < */\n          ) {\n              var text = endRecording();\n\n              if (text) {\n                this.emit('text', unescapeXML(text));\n              }\n\n              state = STATE_TAG_NAME;\n              recordStart = pos + 1;\n              attrs = {};\n            }\n\n          break;\n\n        case STATE_CDATA:\n          if (c === 93\n          /* ] */\n          && data.substr(pos + 1, 2) === ']>') {\n            var cData = endRecording();\n\n            if (cData) {\n              this.emit('text', cData);\n            }\n\n            state = STATE_TEXT;\n          }\n\n          break;\n\n        case STATE_TAG_NAME:\n          if (c === 47\n          /* / */\n          && recordStart === pos) {\n            recordStart = pos + 1;\n            endTag = true;\n          } else if (c === 33\n          /* ! */\n          ) {\n              if (data.substr(pos + 1, 7) === '[CDATA[') {\n                recordStart = pos + 8;\n                state = STATE_CDATA;\n              } else {\n                recordStart = undefined;\n                state = STATE_IGNORE_COMMENT;\n              }\n            } else if (c === 63\n          /* ? */\n          ) {\n              recordStart = undefined;\n              state = STATE_IGNORE_INSTRUCTION;\n            } else if (c <= 32 || c === 47\n          /* / */\n          || c === 62\n          /* > */\n          ) {\n              tagName = endRecording();\n              pos--;\n              state = STATE_TAG;\n            }\n\n          break;\n\n        case STATE_IGNORE_COMMENT:\n          if (c === 62\n          /* > */\n          ) {\n              var prevFirst = data.charCodeAt(pos - 1);\n              var prevSecond = data.charCodeAt(pos - 2);\n\n              if (prevFirst === 45\n              /* - */\n              && prevSecond === 45\n              /* - */\n              || prevFirst === 93\n              /* ] */\n              && prevSecond === 93\n              /* ] */\n              ) {\n                state = STATE_TEXT;\n              }\n            }\n\n          break;\n\n        case STATE_IGNORE_INSTRUCTION:\n          if (c === 62\n          /* > */\n          ) {\n              var prev = data.charCodeAt(pos - 1);\n\n              if (prev === 63\n              /* ? */\n              ) {\n                  state = STATE_TEXT;\n                }\n            }\n\n          break;\n\n        case STATE_TAG:\n          if (c === 62\n          /* > */\n          ) {\n              this._handleTagOpening(endTag, tagName, attrs);\n\n              tagName = undefined;\n              attrs = undefined;\n              endTag = undefined;\n              selfClosing = undefined;\n              state = STATE_TEXT;\n              recordStart = pos + 1;\n            } else if (c === 47\n          /* / */\n          ) {\n              selfClosing = true;\n            } else if (c > 32) {\n            recordStart = pos;\n            state = STATE_ATTR_NAME;\n          }\n\n          break;\n\n        case STATE_ATTR_NAME:\n          if (c <= 32 || c === 61\n          /* = */\n          ) {\n              attrName = endRecording();\n              pos--;\n              state = STATE_ATTR_EQ;\n            }\n\n          break;\n\n        case STATE_ATTR_EQ:\n          if (c === 61\n          /* = */\n          ) {\n              state = STATE_ATTR_QUOT;\n            }\n\n          break;\n\n        case STATE_ATTR_QUOT:\n          if (c === 34\n          /* \" */\n          || c === 39\n          /* ' */\n          ) {\n              attrQuote = c;\n              attrQuoteChar = c === 34 ? '\"' : \"'\";\n              state = STATE_ATTR_VALUE;\n              recordStart = pos + 1;\n            }\n\n          break;\n\n        case STATE_ATTR_VALUE:\n          if (c === attrQuote) {\n            var value = unescapeXML(endRecording());\n            attrs[attrName] = value;\n            attrName = undefined;\n            state = STATE_TAG;\n          }\n\n          break;\n      }\n    }\n\n    if (typeof recordStart === 'number' && recordStart <= data.length) {\n      remainder = data.slice(recordStart);\n      recordStart = 0;\n    }\n  };\n};\n\ninherits(SaxLtx, EventEmitter);\n\nSaxLtx.prototype.end = function (data) {\n  if (data) {\n    this.write(data);\n  }\n  /* Uh, yeah */\n\n\n  this.write = function () {};\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/ltx/lib/parsers/ltx.js"],"names":["inherits","require","EventEmitter","unescapeXML","STATE_TEXT","STATE_IGNORE_COMMENT","STATE_IGNORE_INSTRUCTION","STATE_TAG_NAME","STATE_TAG","STATE_ATTR_NAME","STATE_ATTR_EQ","STATE_ATTR_QUOT","STATE_ATTR_VALUE","STATE_CDATA","STATE_IGNORE_CDATA","SaxLtx","module","exports","call","state","remainder","tagName","attrs","endTag","selfClosing","attrQuote","attrQuoteChar","recordStart","attrName","_handleTagOpening","emit","write","data","toString","pos","length","endRecording","recorded","substring","undefined","lt","indexOf","quot","endcomment","endCDATA","c","charCodeAt","text","substr","cData","prevFirst","prevSecond","prev","value","slice","prototype","end"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBC,YAArC;;AACA,IAAIC,WAAW,GAAGF,OAAO,CAAC,WAAD,CAAP,CAAqBE,WAAvC;;AAEA,IAAIC,UAAU,GAAG,CAAjB;AACA,IAAIC,oBAAoB,GAAG,CAA3B;AACA,IAAIC,wBAAwB,GAAG,CAA/B;AACA,IAAIC,cAAc,GAAG,CAArB;AACA,IAAIC,SAAS,GAAG,CAAhB;AACA,IAAIC,eAAe,GAAG,CAAtB;AACA,IAAIC,aAAa,GAAG,CAApB;AACA,IAAIC,eAAe,GAAG,CAAtB;AACA,IAAIC,gBAAgB,GAAG,CAAvB;AACA,IAAIC,WAAW,GAAG,CAAlB;AACA,IAAIC,kBAAkB,GAAG,EAAzB;;AAEA,IAAIC,MAAM,GAAGC,MAAM,CAACC,OAAP,GAAiB,SAASF,MAAT,GAAmB;AAC/Cb,EAAAA,YAAY,CAACgB,IAAb,CAAkB,IAAlB;AAEA,MAAIC,KAAK,GAAGf,UAAZ;AACA,MAAIgB,SAAJ;AACA,MAAIC,OAAJ;AACA,MAAIC,KAAJ;AACA,MAAIC,MAAJ;AACA,MAAIC,WAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,aAAJ;AACA,MAAIC,WAAW,GAAG,CAAlB;AACA,MAAIC,QAAJ;;AAEA,OAAKC,iBAAL,GAAyB,UAAUN,MAAV,EAAkBF,OAAlB,EAA2BC,KAA3B,EAAkC;AACzD,QAAI,CAACC,MAAL,EAAa;AACX,WAAKO,IAAL,CAAU,cAAV,EAA0BT,OAA1B,EAAmCC,KAAnC;;AACA,UAAIE,WAAJ,EAAiB;AACf,aAAKM,IAAL,CAAU,YAAV,EAAwBT,OAAxB;AACD;AACF,KALD,MAKO;AACL,WAAKS,IAAL,CAAU,YAAV,EAAwBT,OAAxB;AACD;AACF,GATD;;AAWA,OAAKU,KAAL,GAAa,UAAUC,IAAV,EAAgB;AAC3B,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BA,MAAAA,IAAI,GAAGA,IAAI,CAACC,QAAL,EAAP;AACD;;AACD,QAAIC,GAAG,GAAG,CAAV;AAEA;;AACA,QAAId,SAAJ,EAAe;AACbY,MAAAA,IAAI,GAAGZ,SAAS,GAAGY,IAAnB;AACAE,MAAAA,GAAG,IAAId,SAAS,CAACe,MAAjB;AACAf,MAAAA,SAAS,GAAG,IAAZ;AACD;;AAED,aAASgB,YAAT,GAAyB;AACvB,UAAI,OAAOT,WAAP,KAAuB,QAA3B,EAAqC;AACnC,YAAIU,QAAQ,GAAGL,IAAI,CAACM,SAAL,CAAeX,WAAf,EAA4BO,GAA5B,CAAf;AACAP,QAAAA,WAAW,GAAGY,SAAd;AACA,eAAOF,QAAP;AACD;AACF;;AAED,WAAOH,GAAG,GAAGF,IAAI,CAACG,MAAlB,EAA0BD,GAAG,EAA7B,EAAiC;AAC/B,UAAIf,KAAK,KAAKf,UAAd,EAA0B;AACxB;AACA;AACA,YAAIoC,EAAE,GAAGR,IAAI,CAACS,OAAL,CAAa,GAAb,EAAkBP,GAAlB,CAAT;;AACA,YAAIM,EAAE,KAAK,CAAC,CAAR,IAAaN,GAAG,KAAKM,EAAzB,EAA6B;AAC3BN,UAAAA,GAAG,GAAGM,EAAN;AACD;AACF,OAPD,MAOO,IAAIrB,KAAK,KAAKP,gBAAd,EAAgC;AACrC;AACA;AACA,YAAI8B,IAAI,GAAGV,IAAI,CAACS,OAAL,CAAaf,aAAb,EAA4BQ,GAA5B,CAAX;;AACA,YAAIQ,IAAI,KAAK,CAAC,CAAd,EAAiB;AACfR,UAAAA,GAAG,GAAGQ,IAAN;AACD;AACF,OAPM,MAOA,IAAIvB,KAAK,KAAKd,oBAAd,EAAoC;AACzC;AACA;AACA,YAAIsC,UAAU,GAAGX,IAAI,CAACS,OAAL,CAAa,KAAb,EAAoBP,GAApB,CAAjB;;AACA,YAAIS,UAAU,KAAK,CAAC,CAApB,EAAuB;AACrBT,UAAAA,GAAG,GAAGS,UAAU,GAAG,CAAnB,CADqB,CACA;AACtB;AACF,OAPM,MAOA,IAAIxB,KAAK,KAAKL,kBAAd,EAAkC;AACvC;AACA;AACA,YAAI8B,QAAQ,GAAGZ,IAAI,CAACS,OAAL,CAAa,KAAb,EAAoBP,GAApB,CAAf;;AACA,YAAIU,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACnBV,UAAAA,GAAG,GAAGU,QAAQ,GAAG,CAAjB,CADmB,CACA;AACpB;AACF;;AAED,UAAIC,CAAC,GAAGb,IAAI,CAACc,UAAL,CAAgBZ,GAAhB,CAAR;;AACA,cAAQf,KAAR;AACE,aAAKf,UAAL;AACE,cAAIyC,CAAC,KAAK;AAAG;AAAb,YAAsB;AACpB,kBAAIE,IAAI,GAAGX,YAAY,EAAvB;;AACA,kBAAIW,IAAJ,EAAU;AACR,qBAAKjB,IAAL,CAAU,MAAV,EAAkB3B,WAAW,CAAC4C,IAAD,CAA7B;AACD;;AACD5B,cAAAA,KAAK,GAAGZ,cAAR;AACAoB,cAAAA,WAAW,GAAGO,GAAG,GAAG,CAApB;AACAZ,cAAAA,KAAK,GAAG,EAAR;AACD;;AACD;;AACF,aAAKT,WAAL;AACE,cAAIgC,CAAC,KAAK;AAAG;AAAT,aAAoBb,IAAI,CAACgB,MAAL,CAAYd,GAAG,GAAG,CAAlB,EAAqB,CAArB,MAA4B,IAApD,EAA0D;AACxD,gBAAIe,KAAK,GAAGb,YAAY,EAAxB;;AACA,gBAAIa,KAAJ,EAAW;AACT,mBAAKnB,IAAL,CAAU,MAAV,EAAkBmB,KAAlB;AACD;;AACD9B,YAAAA,KAAK,GAAGf,UAAR;AACD;;AACD;;AACF,aAAKG,cAAL;AACE,cAAIsC,CAAC,KAAK;AAAG;AAAT,aAAoBlB,WAAW,KAAKO,GAAxC,EAA6C;AAC3CP,YAAAA,WAAW,GAAGO,GAAG,GAAG,CAApB;AACAX,YAAAA,MAAM,GAAG,IAAT;AACD,WAHD,MAGO,IAAIsB,CAAC,KAAK;AAAG;AAAb,YAAsB;AAC3B,kBAAIb,IAAI,CAACgB,MAAL,CAAYd,GAAG,GAAG,CAAlB,EAAqB,CAArB,MAA4B,SAAhC,EAA2C;AACzCP,gBAAAA,WAAW,GAAGO,GAAG,GAAG,CAApB;AACAf,gBAAAA,KAAK,GAAGN,WAAR;AACD,eAHD,MAGO;AACLc,gBAAAA,WAAW,GAAGY,SAAd;AACApB,gBAAAA,KAAK,GAAGd,oBAAR;AACD;AACF,aARM,MAQA,IAAIwC,CAAC,KAAK;AAAG;AAAb,YAAsB;AAC3BlB,cAAAA,WAAW,GAAGY,SAAd;AACApB,cAAAA,KAAK,GAAGb,wBAAR;AACD,aAHM,MAGA,IAAIuC,CAAC,IAAI,EAAL,IAAWA,CAAC,KAAK;AAAG;AAApB,aAA+BA,CAAC,KAAK;AAAG;AAA5C,YAAqD;AAC1DxB,cAAAA,OAAO,GAAGe,YAAY,EAAtB;AACAF,cAAAA,GAAG;AACHf,cAAAA,KAAK,GAAGX,SAAR;AACD;;AACD;;AACF,aAAKH,oBAAL;AACE,cAAIwC,CAAC,KAAK;AAAG;AAAb,YAAsB;AACpB,kBAAIK,SAAS,GAAGlB,IAAI,CAACc,UAAL,CAAgBZ,GAAG,GAAG,CAAtB,CAAhB;AACA,kBAAIiB,UAAU,GAAGnB,IAAI,CAACc,UAAL,CAAgBZ,GAAG,GAAG,CAAtB,CAAjB;;AACA,kBAAKgB,SAAS,KAAK;AAAG;AAAjB,iBAA4BC,UAAU,KAAK;AAAG;AAA/C,iBACCD,SAAS,KAAK;AAAG;AAAjB,iBAA4BC,UAAU,KAAK;AAAG;AADnD,gBAC6D;AAC3DhC,gBAAAA,KAAK,GAAGf,UAAR;AACD;AACF;;AACD;;AACF,aAAKE,wBAAL;AACE,cAAIuC,CAAC,KAAK;AAAG;AAAb,YAAsB;AACpB,kBAAIO,IAAI,GAAGpB,IAAI,CAACc,UAAL,CAAgBZ,GAAG,GAAG,CAAtB,CAAX;;AACA,kBAAIkB,IAAI,KAAK;AAAG;AAAhB,gBAAyB;AACvBjC,kBAAAA,KAAK,GAAGf,UAAR;AACD;AACF;;AACD;;AACF,aAAKI,SAAL;AACE,cAAIqC,CAAC,KAAK;AAAG;AAAb,YAAsB;AACpB,mBAAKhB,iBAAL,CAAuBN,MAAvB,EAA+BF,OAA/B,EAAwCC,KAAxC;;AACAD,cAAAA,OAAO,GAAGkB,SAAV;AACAjB,cAAAA,KAAK,GAAGiB,SAAR;AACAhB,cAAAA,MAAM,GAAGgB,SAAT;AACAf,cAAAA,WAAW,GAAGe,SAAd;AACApB,cAAAA,KAAK,GAAGf,UAAR;AACAuB,cAAAA,WAAW,GAAGO,GAAG,GAAG,CAApB;AACD,aARD,MAQO,IAAIW,CAAC,KAAK;AAAG;AAAb,YAAsB;AAC3BrB,cAAAA,WAAW,GAAG,IAAd;AACD,aAFM,MAEA,IAAIqB,CAAC,GAAG,EAAR,EAAY;AACjBlB,YAAAA,WAAW,GAAGO,GAAd;AACAf,YAAAA,KAAK,GAAGV,eAAR;AACD;;AACD;;AACF,aAAKA,eAAL;AACE,cAAIoC,CAAC,IAAI,EAAL,IAAWA,CAAC,KAAK;AAAG;AAAxB,YAAiC;AAC/BjB,cAAAA,QAAQ,GAAGQ,YAAY,EAAvB;AACAF,cAAAA,GAAG;AACHf,cAAAA,KAAK,GAAGT,aAAR;AACD;;AACD;;AACF,aAAKA,aAAL;AACE,cAAImC,CAAC,KAAK;AAAG;AAAb,YAAsB;AACpB1B,cAAAA,KAAK,GAAGR,eAAR;AACD;;AACD;;AACF,aAAKA,eAAL;AACE,cAAIkC,CAAC,KAAK;AAAG;AAAT,aAAoBA,CAAC,KAAK;AAAG;AAAjC,YAA0C;AACxCpB,cAAAA,SAAS,GAAGoB,CAAZ;AACAnB,cAAAA,aAAa,GAAGmB,CAAC,KAAK,EAAN,GAAW,GAAX,GAAiB,GAAjC;AACA1B,cAAAA,KAAK,GAAGP,gBAAR;AACAe,cAAAA,WAAW,GAAGO,GAAG,GAAG,CAApB;AACD;;AACD;;AACF,aAAKtB,gBAAL;AACE,cAAIiC,CAAC,KAAKpB,SAAV,EAAqB;AACnB,gBAAI4B,KAAK,GAAGlD,WAAW,CAACiC,YAAY,EAAb,CAAvB;AACAd,YAAAA,KAAK,CAACM,QAAD,CAAL,GAAkByB,KAAlB;AACAzB,YAAAA,QAAQ,GAAGW,SAAX;AACApB,YAAAA,KAAK,GAAGX,SAAR;AACD;;AACD;AAvGJ;AAyGD;;AAED,QAAI,OAAOmB,WAAP,KAAuB,QAAvB,IACFA,WAAW,IAAIK,IAAI,CAACG,MADtB,EAC8B;AAC5Bf,MAAAA,SAAS,GAAGY,IAAI,CAACsB,KAAL,CAAW3B,WAAX,CAAZ;AACAA,MAAAA,WAAW,GAAG,CAAd;AACD;AACF,GArKD;AAsKD,CA/LD;;AAgMA3B,QAAQ,CAACe,MAAD,EAASb,YAAT,CAAR;;AAEAa,MAAM,CAACwC,SAAP,CAAiBC,GAAjB,GAAuB,UAAUxB,IAAV,EAAgB;AACrC,MAAIA,IAAJ,EAAU;AACR,SAAKD,KAAL,CAAWC,IAAX;AACD;AAED;;;AACA,OAAKD,KAAL,GAAa,YAAY,CAAE,CAA3B;AACD,CAPD","sourcesContent":["'use strict'\n\nvar inherits = require('inherits')\nvar EventEmitter = require('events').EventEmitter\nvar unescapeXML = require('../escape').unescapeXML\n\nvar STATE_TEXT = 0\nvar STATE_IGNORE_COMMENT = 1\nvar STATE_IGNORE_INSTRUCTION = 2\nvar STATE_TAG_NAME = 3\nvar STATE_TAG = 4\nvar STATE_ATTR_NAME = 5\nvar STATE_ATTR_EQ = 6\nvar STATE_ATTR_QUOT = 7\nvar STATE_ATTR_VALUE = 8\nvar STATE_CDATA = 9\nvar STATE_IGNORE_CDATA = 10\n\nvar SaxLtx = module.exports = function SaxLtx () {\n  EventEmitter.call(this)\n\n  var state = STATE_TEXT\n  var remainder\n  var tagName\n  var attrs\n  var endTag\n  var selfClosing\n  var attrQuote\n  var attrQuoteChar\n  var recordStart = 0\n  var attrName\n\n  this._handleTagOpening = function (endTag, tagName, attrs) {\n    if (!endTag) {\n      this.emit('startElement', tagName, attrs)\n      if (selfClosing) {\n        this.emit('endElement', tagName)\n      }\n    } else {\n      this.emit('endElement', tagName)\n    }\n  }\n\n  this.write = function (data) {\n    if (typeof data !== 'string') {\n      data = data.toString()\n    }\n    var pos = 0\n\n    /* Anything from previous write()? */\n    if (remainder) {\n      data = remainder + data\n      pos += remainder.length\n      remainder = null\n    }\n\n    function endRecording () {\n      if (typeof recordStart === 'number') {\n        var recorded = data.substring(recordStart, pos)\n        recordStart = undefined\n        return recorded\n      }\n    }\n\n    for (; pos < data.length; pos++) {\n      if (state === STATE_TEXT) {\n        // if we're looping through text, fast-forward using indexOf to\n        // the next '<' character\n        var lt = data.indexOf('<', pos)\n        if (lt !== -1 && pos !== lt) {\n          pos = lt\n        }\n      } else if (state === STATE_ATTR_VALUE) {\n        // if we're looping through an attribute, fast-forward using\n        // indexOf to the next end quote character\n        var quot = data.indexOf(attrQuoteChar, pos)\n        if (quot !== -1) {\n          pos = quot\n        }\n      } else if (state === STATE_IGNORE_COMMENT) {\n        // if we're looping through a comment, fast-forward using\n        // indexOf to the first end-comment character\n        var endcomment = data.indexOf('-->', pos)\n        if (endcomment !== -1) {\n          pos = endcomment + 2 // target the '>' character\n        }\n      } else if (state === STATE_IGNORE_CDATA) {\n        // if we're looping through a CDATA, fast-forward using\n        // indexOf to the first end-CDATA character ]]>\n        var endCDATA = data.indexOf(']]>', pos)\n        if (endCDATA !== -1) {\n          pos = endCDATA + 2 // target the '>' character\n        }\n      }\n\n      var c = data.charCodeAt(pos)\n      switch (state) {\n        case STATE_TEXT:\n          if (c === 60 /* < */) {\n            var text = endRecording()\n            if (text) {\n              this.emit('text', unescapeXML(text))\n            }\n            state = STATE_TAG_NAME\n            recordStart = pos + 1\n            attrs = {}\n          }\n          break\n        case STATE_CDATA:\n          if (c === 93 /* ] */ && data.substr(pos + 1, 2) === ']>') {\n            var cData = endRecording()\n            if (cData) {\n              this.emit('text', cData)\n            }\n            state = STATE_TEXT\n          }\n          break\n        case STATE_TAG_NAME:\n          if (c === 47 /* / */ && recordStart === pos) {\n            recordStart = pos + 1\n            endTag = true\n          } else if (c === 33 /* ! */) {\n            if (data.substr(pos + 1, 7) === '[CDATA[') {\n              recordStart = pos + 8\n              state = STATE_CDATA\n            } else {\n              recordStart = undefined\n              state = STATE_IGNORE_COMMENT\n            }\n          } else if (c === 63 /* ? */) {\n            recordStart = undefined\n            state = STATE_IGNORE_INSTRUCTION\n          } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {\n            tagName = endRecording()\n            pos--\n            state = STATE_TAG\n          }\n          break\n        case STATE_IGNORE_COMMENT:\n          if (c === 62 /* > */) {\n            var prevFirst = data.charCodeAt(pos - 1)\n            var prevSecond = data.charCodeAt(pos - 2)\n            if ((prevFirst === 45 /* - */ && prevSecond === 45 /* - */) ||\n                (prevFirst === 93 /* ] */ && prevSecond === 93 /* ] */)) {\n              state = STATE_TEXT\n            }\n          }\n          break\n        case STATE_IGNORE_INSTRUCTION:\n          if (c === 62 /* > */) {\n            var prev = data.charCodeAt(pos - 1)\n            if (prev === 63 /* ? */) {\n              state = STATE_TEXT\n            }\n          }\n          break\n        case STATE_TAG:\n          if (c === 62 /* > */) {\n            this._handleTagOpening(endTag, tagName, attrs)\n            tagName = undefined\n            attrs = undefined\n            endTag = undefined\n            selfClosing = undefined\n            state = STATE_TEXT\n            recordStart = pos + 1\n          } else if (c === 47 /* / */) {\n            selfClosing = true\n          } else if (c > 32) {\n            recordStart = pos\n            state = STATE_ATTR_NAME\n          }\n          break\n        case STATE_ATTR_NAME:\n          if (c <= 32 || c === 61 /* = */) {\n            attrName = endRecording()\n            pos--\n            state = STATE_ATTR_EQ\n          }\n          break\n        case STATE_ATTR_EQ:\n          if (c === 61 /* = */) {\n            state = STATE_ATTR_QUOT\n          }\n          break\n        case STATE_ATTR_QUOT:\n          if (c === 34 /* \" */ || c === 39 /* ' */) {\n            attrQuote = c\n            attrQuoteChar = c === 34 ? '\"' : \"'\"\n            state = STATE_ATTR_VALUE\n            recordStart = pos + 1\n          }\n          break\n        case STATE_ATTR_VALUE:\n          if (c === attrQuote) {\n            var value = unescapeXML(endRecording())\n            attrs[attrName] = value\n            attrName = undefined\n            state = STATE_TAG\n          }\n          break\n      }\n    }\n\n    if (typeof recordStart === 'number' &&\n      recordStart <= data.length) {\n      remainder = data.slice(recordStart)\n      recordStart = 0\n    }\n  }\n}\ninherits(SaxLtx, EventEmitter)\n\nSaxLtx.prototype.end = function (data) {\n  if (data) {\n    this.write(data)\n  }\n\n  /* Uh, yeah */\n  this.write = function () {}\n}\n"]},"metadata":{},"sourceType":"script"}