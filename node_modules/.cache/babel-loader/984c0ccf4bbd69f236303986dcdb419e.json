{"ast":null,"code":"import { NameAddrHeader } from \"../../grammar\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils\";\n/**\n * Outgoing SIP request message.\n * @public\n */\n\nexport class OutgoingRequestMessage {\n  constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n    this.headers = {};\n    this.extraHeaders = []; // Initialize default options\n\n    this.options = OutgoingRequestMessage.getDefaultOptions(); // Options - merge a deep copy\n\n    if (options) {\n      this.options = Object.assign(Object.assign({}, this.options), options);\n\n      if (this.options.optionTags && this.options.optionTags.length) {\n        this.options.optionTags = this.options.optionTags.slice();\n      }\n\n      if (this.options.routeSet && this.options.routeSet.length) {\n        this.options.routeSet = this.options.routeSet.slice();\n      }\n    } // Extra headers - deep copy\n\n\n    if (extraHeaders && extraHeaders.length) {\n      this.extraHeaders = extraHeaders.slice();\n    } // Body - deep copy\n\n\n    if (body) {\n      // TODO: internal representation should be Body\n      // this.body = { ...body };\n      this.body = {\n        body: body.content,\n        contentType: body.contentType\n      };\n    } // Method\n\n\n    this.method = method; // RURI\n\n    this.ruri = ruri.clone(); // From\n\n    this.fromURI = fromURI.clone();\n    this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n    this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag); // To\n\n    this.toURI = toURI.clone();\n    this.toTag = this.options.toTag;\n    this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag); // Call-ID\n\n    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15); // CSeq\n\n    this.cseq = this.options.cseq; // The relative order of header fields with different field names is not\n    // significant.  However, it is RECOMMENDED that header fields which are\n    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n    // Max-Forwards, and Proxy-Authorization, for example) appear towards\n    // the top of the message to facilitate rapid parsing.\n    // https://tools.ietf.org/html/rfc3261#section-7.3.1\n\n    this.setHeader(\"route\", this.options.routeSet);\n    this.setHeader(\"via\", \"\");\n    this.setHeader(\"to\", this.to.toString());\n    this.setHeader(\"from\", this.from.toString());\n    this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n    this.setHeader(\"call-id\", this.callId);\n    this.setHeader(\"max-forwards\", \"70\");\n  }\n  /** Get a copy of the default options. */\n\n\n  static getDefaultOptions() {\n    return {\n      callId: \"\",\n      callIdPrefix: \"\",\n      cseq: 1,\n      toDisplayName: \"\",\n      toTag: \"\",\n      fromDisplayName: \"\",\n      fromTag: \"\",\n      forceRport: false,\n      hackViaTcp: false,\n      optionTags: [\"outbound\"],\n      routeSet: [],\n      userAgentString: \"sip.js\",\n      viaHost: \"\"\n    };\n  }\n\n  static makeNameAddrHeader(uri, displayName, tag) {\n    const parameters = {};\n\n    if (tag) {\n      parameters.tag = tag;\n    }\n\n    return new NameAddrHeader(uri, displayName, parameters);\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   * @param name - header name\n   * @returns Returns the specified header, undefined if header doesn't exist.\n   */\n\n\n  getHeader(name) {\n    const header = this.headers[headerize(name)];\n\n    if (header) {\n      if (header[0]) {\n        return header[0];\n      }\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const exHeader of this.extraHeaders) {\n        if (regexp.test(exHeader)) {\n          return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n        }\n      }\n    }\n\n    return;\n  }\n  /**\n   * Get the header/s of the given name.\n   * @param name - header name\n   * @returns Array with all the headers of the specified name.\n   */\n\n\n  getHeaders(name) {\n    const result = [];\n    const headerArray = this.headers[headerize(name)];\n\n    if (headerArray) {\n      for (const headerPart of headerArray) {\n        result.push(headerPart);\n      }\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const exHeader of this.extraHeaders) {\n        if (regexp.test(exHeader)) {\n          result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Verify the existence of the given header.\n   * @param name - header name\n   * @returns true if header with given name exists, false otherwise\n   */\n\n\n  hasHeader(name) {\n    if (this.headers[headerize(name)]) {\n      return true;\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const extraHeader of this.extraHeaders) {\n        if (regexp.test(extraHeader)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Replace the the given header by the given value.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  setHeader(name, value) {\n    this.headers[headerize(name)] = value instanceof Array ? value : [value];\n  }\n  /**\n   * The Via header field indicates the transport used for the transaction\n   * and identifies the location where the response is to be sent.  A Via\n   * header field value is added only after the transport that will be\n   * used to reach the next hop has been selected (which may involve the\n   * usage of the procedures in [4]).\n   *\n   * When the UAC creates a request, it MUST insert a Via into that\n   * request.  The protocol name and protocol version in the header field\n   * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n   * contain a branch parameter.  This parameter is used to identify the\n   * transaction created by that request.  This parameter is used by both\n   * the client and the server.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n   * @param branchParameter - The branch parameter.\n   * @param transport - The sent protocol transport.\n   */\n\n\n  setViaHeader(branch, transport) {\n    // FIXME: Hack\n    if (this.options.hackViaTcp) {\n      transport = \"TCP\";\n    }\n\n    let via = \"SIP/2.0/\" + transport;\n    via += \" \" + this.options.viaHost + \";branch=\" + branch;\n\n    if (this.options.forceRport) {\n      via += \";rport\";\n    }\n\n    this.setHeader(\"via\", via);\n    this.branch = branch;\n  }\n\n  toString() {\n    let msg = \"\";\n    msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n\n    for (const header in this.headers) {\n      if (this.headers[header]) {\n        for (const headerPart of this.headers[header]) {\n          msg += header + \": \" + headerPart + \"\\r\\n\";\n        }\n      }\n    }\n\n    for (const header of this.extraHeaders) {\n      msg += header.trim() + \"\\r\\n\";\n    }\n\n    msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n    msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n\n    if (this.body) {\n      if (typeof this.body === \"string\") {\n        msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n        msg += this.body;\n      } else {\n        if (this.body.body && this.body.contentType) {\n          msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n          msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n          msg += this.body.body;\n        } else {\n          msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n        }\n      }\n    } else {\n      msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n    }\n\n    return msg;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/outgoing-request-message.js"],"names":["NameAddrHeader","createRandomToken","headerize","newTag","utf8Length","OutgoingRequestMessage","constructor","method","ruri","fromURI","toURI","options","extraHeaders","body","headers","getDefaultOptions","Object","assign","optionTags","length","slice","routeSet","content","contentType","clone","fromTag","from","makeNameAddrHeader","fromDisplayName","toTag","to","toDisplayName","callId","callIdPrefix","cseq","setHeader","toString","forceRport","hackViaTcp","userAgentString","viaHost","uri","displayName","tag","parameters","getHeader","name","header","regexp","RegExp","exHeader","test","substring","indexOf","trim","getHeaders","result","headerArray","headerPart","push","hasHeader","extraHeader","value","Array","setViaHeader","branch","transport","via","msg","toRaw","join"],"mappings":"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","sourcesContent":["import { NameAddrHeader } from \"../../grammar\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils\";\n/**\n * Outgoing SIP request message.\n * @public\n */\nexport class OutgoingRequestMessage {\n    constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n        this.headers = {};\n        this.extraHeaders = [];\n        // Initialize default options\n        this.options = OutgoingRequestMessage.getDefaultOptions();\n        // Options - merge a deep copy\n        if (options) {\n            this.options = Object.assign(Object.assign({}, this.options), options);\n            if (this.options.optionTags && this.options.optionTags.length) {\n                this.options.optionTags = this.options.optionTags.slice();\n            }\n            if (this.options.routeSet && this.options.routeSet.length) {\n                this.options.routeSet = this.options.routeSet.slice();\n            }\n        }\n        // Extra headers - deep copy\n        if (extraHeaders && extraHeaders.length) {\n            this.extraHeaders = extraHeaders.slice();\n        }\n        // Body - deep copy\n        if (body) {\n            // TODO: internal representation should be Body\n            // this.body = { ...body };\n            this.body = {\n                body: body.content,\n                contentType: body.contentType\n            };\n        }\n        // Method\n        this.method = method;\n        // RURI\n        this.ruri = ruri.clone();\n        // From\n        this.fromURI = fromURI.clone();\n        this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n        this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);\n        // To\n        this.toURI = toURI.clone();\n        this.toTag = this.options.toTag;\n        this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);\n        // Call-ID\n        this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15);\n        // CSeq\n        this.cseq = this.options.cseq;\n        // The relative order of header fields with different field names is not\n        // significant.  However, it is RECOMMENDED that header fields which are\n        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n        // Max-Forwards, and Proxy-Authorization, for example) appear towards\n        // the top of the message to facilitate rapid parsing.\n        // https://tools.ietf.org/html/rfc3261#section-7.3.1\n        this.setHeader(\"route\", this.options.routeSet);\n        this.setHeader(\"via\", \"\");\n        this.setHeader(\"to\", this.to.toString());\n        this.setHeader(\"from\", this.from.toString());\n        this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n        this.setHeader(\"call-id\", this.callId);\n        this.setHeader(\"max-forwards\", \"70\");\n    }\n    /** Get a copy of the default options. */\n    static getDefaultOptions() {\n        return {\n            callId: \"\",\n            callIdPrefix: \"\",\n            cseq: 1,\n            toDisplayName: \"\",\n            toTag: \"\",\n            fromDisplayName: \"\",\n            fromTag: \"\",\n            forceRport: false,\n            hackViaTcp: false,\n            optionTags: [\"outbound\"],\n            routeSet: [],\n            userAgentString: \"sip.js\",\n            viaHost: \"\"\n        };\n    }\n    static makeNameAddrHeader(uri, displayName, tag) {\n        const parameters = {};\n        if (tag) {\n            parameters.tag = tag;\n        }\n        return new NameAddrHeader(uri, displayName, parameters);\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0];\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        const result = [];\n        const headerArray = this.headers[headerize(name)];\n        if (headerArray) {\n            for (const headerPart of headerArray) {\n                result.push(headerPart);\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        if (this.headers[headerize(name)]) {\n            return true;\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const extraHeader of this.extraHeaders) {\n                if (regexp.test(extraHeader)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Replace the the given header by the given value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = value instanceof Array ? value : [value];\n    }\n    /**\n     * The Via header field indicates the transport used for the transaction\n     * and identifies the location where the response is to be sent.  A Via\n     * header field value is added only after the transport that will be\n     * used to reach the next hop has been selected (which may involve the\n     * usage of the procedures in [4]).\n     *\n     * When the UAC creates a request, it MUST insert a Via into that\n     * request.  The protocol name and protocol version in the header field\n     * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n     * contain a branch parameter.  This parameter is used to identify the\n     * transaction created by that request.  This parameter is used by both\n     * the client and the server.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n     * @param branchParameter - The branch parameter.\n     * @param transport - The sent protocol transport.\n     */\n    setViaHeader(branch, transport) {\n        // FIXME: Hack\n        if (this.options.hackViaTcp) {\n            transport = \"TCP\";\n        }\n        let via = \"SIP/2.0/\" + transport;\n        via += \" \" + this.options.viaHost + \";branch=\" + branch;\n        if (this.options.forceRport) {\n            via += \";rport\";\n        }\n        this.setHeader(\"via\", via);\n        this.branch = branch;\n    }\n    toString() {\n        let msg = \"\";\n        msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers[header]) {\n                for (const headerPart of this.headers[header]) {\n                    msg += header + \": \" + headerPart + \"\\r\\n\";\n                }\n            }\n        }\n        for (const header of this.extraHeaders) {\n            msg += header.trim() + \"\\r\\n\";\n        }\n        msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n        msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n        if (this.body) {\n            if (typeof this.body === \"string\") {\n                msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n                msg += this.body;\n            }\n            else {\n                if (this.body.body && this.body.contentType) {\n                    msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n                    msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n                    msg += this.body.body;\n                }\n                else {\n                    msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n                }\n            }\n        }\n        else {\n            msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n        }\n        return msg;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}