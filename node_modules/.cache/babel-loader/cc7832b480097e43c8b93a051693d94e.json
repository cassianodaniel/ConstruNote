{"ast":null,"code":"'use strict';\n\nconst {\n  encode,\n  decode\n} = require('@xmpp/base64');\n\nconst SASLError = require('./lib/SASLError');\n\nconst xml = require('@xmpp/xml');\n\nconst SASLFactory = require('saslmechanisms'); // https://xmpp.org/rfcs/rfc6120.html#sasl\n\n\nconst NS = 'urn:ietf:params:xml:ns:xmpp-sasl';\n\nfunction getMechanismNames(features) {\n  return features.getChild('mechanisms', NS).children.map(el => el.text());\n}\n\nasync function authenticate(SASL, entity, mechname, credentials) {\n  const mech = SASL.create([mechname]);\n\n  if (!mech) {\n    throw new Error('No compatible mechanism');\n  }\n\n  const {\n    domain\n  } = entity.options;\n  const creds = {\n    username: null,\n    password: null,\n    server: domain,\n    host: domain,\n    realm: domain,\n    serviceType: 'xmpp',\n    serviceName: domain,\n    ...credentials\n  };\n  return new Promise((resolve, reject) => {\n    const handler = element => {\n      if (element.attrs.xmlns !== NS) {\n        return;\n      }\n\n      if (element.name === 'challenge') {\n        mech.challenge(decode(element.text()));\n        const resp = mech.response(creds);\n        entity.send(xml('response', {\n          xmlns: NS,\n          mechanism: mech.name\n        }, typeof resp === 'string' ? encode(resp) : ''));\n        return;\n      }\n\n      if (element.name === 'failure') {\n        reject(SASLError.fromElement(element));\n      } else if (element.name === 'success') {\n        resolve();\n      }\n\n      entity.removeListener('nonza', handler);\n    };\n\n    entity.on('nonza', handler);\n\n    if (mech.clientFirst) {\n      entity.send(xml('auth', {\n        xmlns: NS,\n        mechanism: mech.name\n      }, encode(mech.response(creds))));\n    }\n  });\n}\n\nmodule.exports = function sasl({\n  streamFeatures\n}, credentials) {\n  const SASL = new SASLFactory();\n  streamFeatures.use('mechanisms', NS, async ({\n    stanza,\n    entity\n  }) => {\n    const offered = getMechanismNames(stanza);\n\n    const supported = SASL._mechs.map(({\n      name\n    }) => name);\n\n    const intersection = supported.filter(mech => {\n      return offered.includes(mech);\n    });\n    let mech = intersection[0];\n\n    if (typeof credentials === 'function') {\n      await credentials(creds => authenticate(SASL, entity, mech, creds, stanza), mech);\n    } else {\n      if (!credentials.username && !credentials.password) {\n        mech = 'ANONYMOUS';\n      }\n\n      await authenticate(SASL, entity, mech, credentials, stanza);\n    }\n\n    await entity.restart();\n  });\n  return {\n    use(...args) {\n      return SASL.use(...args);\n    }\n\n  };\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/sasl/index.js"],"names":["encode","decode","require","SASLError","xml","SASLFactory","NS","getMechanismNames","features","getChild","children","map","el","text","authenticate","SASL","entity","mechname","credentials","mech","create","Error","domain","options","creds","username","password","server","host","realm","serviceType","serviceName","Promise","resolve","reject","handler","element","attrs","xmlns","name","challenge","resp","response","send","mechanism","fromElement","removeListener","on","clientFirst","module","exports","sasl","streamFeatures","use","stanza","offered","supported","_mechs","intersection","filter","includes","restart","args"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {encode, decode} = require('@xmpp/base64')\nconst SASLError = require('./lib/SASLError')\nconst xml = require('@xmpp/xml')\nconst SASLFactory = require('saslmechanisms')\n\n// https://xmpp.org/rfcs/rfc6120.html#sasl\n\nconst NS = 'urn:ietf:params:xml:ns:xmpp-sasl'\n\nfunction getMechanismNames(features) {\n  return features.getChild('mechanisms', NS).children.map(el => el.text())\n}\n\nasync function authenticate(SASL, entity, mechname, credentials) {\n  const mech = SASL.create([mechname])\n  if (!mech) {\n    throw new Error('No compatible mechanism')\n  }\n\n  const {domain} = entity.options\n  const creds = {\n    username: null,\n    password: null,\n    server: domain,\n    host: domain,\n    realm: domain,\n    serviceType: 'xmpp',\n    serviceName: domain,\n    ...credentials,\n  }\n\n  return new Promise((resolve, reject) => {\n    const handler = element => {\n      if (element.attrs.xmlns !== NS) {\n        return\n      }\n\n      if (element.name === 'challenge') {\n        mech.challenge(decode(element.text()))\n        const resp = mech.response(creds)\n        entity.send(\n          xml(\n            'response',\n            {xmlns: NS, mechanism: mech.name},\n            typeof resp === 'string' ? encode(resp) : ''\n          )\n        )\n        return\n      }\n\n      if (element.name === 'failure') {\n        reject(SASLError.fromElement(element))\n      } else if (element.name === 'success') {\n        resolve()\n      }\n\n      entity.removeListener('nonza', handler)\n    }\n\n    entity.on('nonza', handler)\n\n    if (mech.clientFirst) {\n      entity.send(\n        xml(\n          'auth',\n          {xmlns: NS, mechanism: mech.name},\n          encode(mech.response(creds))\n        )\n      )\n    }\n  })\n}\n\nmodule.exports = function sasl({streamFeatures}, credentials) {\n  const SASL = new SASLFactory()\n\n  streamFeatures.use('mechanisms', NS, async ({stanza, entity}) => {\n    const offered = getMechanismNames(stanza)\n    const supported = SASL._mechs.map(({name}) => name)\n    const intersection = supported.filter(mech => {\n      return offered.includes(mech)\n    })\n    let mech = intersection[0]\n\n    if (typeof credentials === 'function') {\n      await credentials(\n        creds => authenticate(SASL, entity, mech, creds, stanza),\n        mech\n      )\n    } else {\n      if (!credentials.username && !credentials.password) {\n        mech = 'ANONYMOUS'\n      }\n\n      await authenticate(SASL, entity, mech, credentials, stanza)\n    }\n\n    await entity.restart()\n  })\n\n  return {\n    use(...args) {\n      return SASL.use(...args)\n    },\n  }\n}\n"]},"metadata":{},"sourceType":"script"}