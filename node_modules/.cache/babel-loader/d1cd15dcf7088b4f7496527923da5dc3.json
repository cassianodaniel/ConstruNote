{"ast":null,"code":"import { C } from \"../messages\";\nimport { Timers } from \"../timers\";\nimport { ServerTransaction } from \"./server-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.1\n * @public\n */\n\nexport class InviteServerTransaction extends ServerTransaction {\n  /**\n   * Constructor.\n   * Upon construction, a \"100 Trying\" reply will be immediately sent.\n   * After construction the transaction will be in the \"proceeding\" state and the transaction\n   * `id` will equal the branch parameter set in the Via header of the incoming request.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   * @param request - Incoming INVITE request from the transport.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Proceeding, \"sip.transaction.ist\");\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    this.stopProgressExtensionTimer();\n\n    if (this.H) {\n      clearTimeout(this.H);\n      this.H = undefined;\n    }\n\n    if (this.I) {\n      clearTimeout(this.I);\n      this.I = undefined;\n    }\n\n    if (this.L) {\n      clearTimeout(this.L);\n      this.L = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"ist\";\n  }\n  /**\n   * Receive requests from transport matching this transaction.\n   * @param request - Request matching this transaction.\n   */\n\n\n  receiveRequest(request) {\n    switch (this.state) {\n      case TransactionState.Proceeding:\n        // If a request retransmission is received while in the \"Proceeding\" state, the most\n        // recent provisional response that was received from the TU MUST be passed to the\n        // transport layer for retransmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE) {\n          if (this.lastProvisionalResponse) {\n            this.send(this.lastProvisionalResponse).catch(error => {\n              this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n            });\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // While in the \"Accepted\" state, any retransmissions of the INVITE\n        // received will match this transaction state machine and will be\n        // absorbed by the machine without changing its state. These\n        // retransmissions are not passed onto the TU.\n        // https://tools.ietf.org/html/rfc6026#section-7.1\n        if (request.method === C.INVITE) {\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // Furthermore, while in the \"Completed\" state, if a request retransmission is\n        // received, the server SHOULD pass the response to the transport for retransmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE) {\n          if (!this.lastFinalResponse) {\n            throw new Error(\"Last final response undefined.\");\n          }\n\n          this.send(this.lastFinalResponse).catch(error => {\n            this.logTransportError(error, \"Failed to send retransmission of final response.\");\n          });\n          return;\n        } // If an ACK is received while the server transaction is in the \"Completed\" state,\n        // the server transaction MUST transition to the \"Confirmed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n        if (request.method === C.ACK) {\n          this.stateTransition(TransactionState.Confirmed);\n          return;\n        }\n\n        break;\n\n      case TransactionState.Confirmed:\n        // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n        // triggered from retransmissions of the final response.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE || request.method === C.ACK) {\n          return;\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        // For good measure absorb any additional messages that arrive (should not happen).\n        if (request.method === C.INVITE || request.method === C.ACK) {\n          return;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;\n    this.logger.warn(message);\n    return;\n  }\n  /**\n   * Receive responses from TU for this transaction.\n   * @param statusCode - Status code of response.\n   * @param response - Response.\n   */\n\n\n  receiveResponse(statusCode, response) {\n    if (statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    switch (this.state) {\n      case TransactionState.Proceeding:\n        // The TU passes any number of provisional responses to the server\n        // transaction. So long as the server transaction is in the\n        // \"Proceeding\" state, each of these MUST be passed to the transport\n        // layer for transmission. They are not sent reliably by the\n        // transaction layer (they are not retransmitted by it) and do not cause\n        // a change in the state of the server transaction.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (statusCode >= 100 && statusCode <= 199) {\n          this.lastProvisionalResponse = response; // Start the progress extension timer only for a non-100 provisional response.\n\n          if (statusCode > 100) {\n            this.startProgressExtensionTimer(); // FIXME: remove\n          }\n\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 1xx response.\");\n          });\n          return;\n        } // If, while in the \"Proceeding\" state, the TU passes a 2xx response\n        // to the server transaction, the server transaction MUST pass this\n        // response to the transport layer for transmission. It is not\n        // retransmitted by the server transaction; retransmissions of 2xx\n        // responses are handled by the TU. The server transaction MUST then\n        // transition to the \"Accepted\" state.\n        // https://tools.ietf.org/html/rfc6026#section-8.5\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.lastFinalResponse = response;\n          this.stateTransition(TransactionState.Accepted);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 2xx response.\");\n          });\n          return;\n        } // While in the \"Proceeding\" state, if the TU passes a response with\n        // status code from 300 to 699 to the server transaction, the response\n        // MUST be passed to the transport layer for transmission, and the state\n        // machine MUST enter the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.lastFinalResponse = response;\n          this.stateTransition(TransactionState.Completed);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send non-2xx final response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // While in the \"Accepted\" state, if the TU passes a 2xx response,\n        // the server transaction MUST pass the response to the transport layer for transmission.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 2xx response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        break;\n\n      case TransactionState.Confirmed:\n        break;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;\n    this.logger.error(message);\n    throw new Error(message);\n  }\n  /**\n   * Retransmit the last 2xx response. This is a noop if not in the \"accepted\" state.\n   */\n\n\n  retransmitAcceptedResponse() {\n    if (this.state === TransactionState.Accepted && this.lastFinalResponse) {\n      this.send(this.lastFinalResponse).catch(error => {\n        this.logTransportError(error, \"Failed to send 2xx response.\");\n      });\n    }\n  }\n  /**\n   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n   * inform the TU that a failure has occurred, and MUST remain in the current state.\n   * https://tools.ietf.org/html/rfc6026#section-8.8\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"INVITE server transaction\";\n  }\n  /**\n   * Execute a state transition.\n   * @param newState - New state.\n   */\n\n\n  stateTransition(newState) {\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Proceeding:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Accepted:\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Confirmed:\n        if (this.state !== TransactionState.Completed) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed && this.state !== TransactionState.Confirmed) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // On any state transition, stop resending provisional responses\n\n\n    this.stopProgressExtensionTimer(); // The purpose of the \"Accepted\" state is to absorb retransmissions of an accepted INVITE request.\n    // Any such retransmissions are absorbed entirely within the server transaction.\n    // They are not passed up to the TU since any downstream UAS cores that accepted the request have\n    // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n    if (newState === TransactionState.Accepted) {\n      this.L = setTimeout(() => this.timerL(), Timers.TIMER_L);\n    } // When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.\n    // Timer H determines when the server transaction abandons retransmitting the response.\n    // If an ACK is received while the server transaction is in the \"Completed\" state,\n    // the server transaction MUST transition to the \"Confirmed\" state.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n    if (newState === TransactionState.Completed) {\n      // FIXME: Missing timer G for unreliable transports.\n      this.H = setTimeout(() => this.timerH(), Timers.TIMER_H);\n    } // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n    // triggered from retransmissions of the final response. When this state is entered, timer I\n    // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable\n    // transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n    if (newState === TransactionState.Confirmed) {\n      // FIXME: This timer is not getting set correctly for unreliable transports.\n      this.I = setTimeout(() => this.timerI(), Timers.TIMER_I);\n    } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    } // Update state.\n\n\n    this.setState(newState);\n  }\n  /**\n   * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1\n   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n   */\n\n\n  startProgressExtensionTimer() {\n    // Start the progress extension timer only for the first non-100 provisional response.\n    if (this.progressExtensionTimer === undefined) {\n      this.progressExtensionTimer = setInterval(() => {\n        this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);\n\n        if (!this.lastProvisionalResponse) {\n          throw new Error(\"Last provisional response undefined.\");\n        }\n\n        this.send(this.lastProvisionalResponse).catch(error => {\n          this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n        });\n      }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n    }\n  }\n  /**\n   * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1\n   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n   */\n\n\n  stopProgressExtensionTimer() {\n    if (this.progressExtensionTimer !== undefined) {\n      clearInterval(this.progressExtensionTimer);\n      this.progressExtensionTimer = undefined;\n    }\n  }\n  /**\n   * While in the \"Proceeding\" state, if the TU passes a response with status code\n   * from 300 to 699 to the server transaction, the response MUST be passed to the\n   * transport layer for transmission, and the state machine MUST enter the \"Completed\" state.\n   * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for\n   * reliable transports. If timer G fires, the response is passed to the transport layer once\n   * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,\n   * when timer G fires, the response is passed to the transport again for transmission, and\n   * timer G is reset with a value that doubles, unless that value exceeds T2, in which case\n   * it is reset with the value of T2.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerG() {// TODO\n  }\n  /**\n   * If timer H fires while in the \"Completed\" state, it implies that the ACK was never received.\n   * In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST\n   * indicate to the TU that a transaction failure has occurred.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerH() {\n    this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Completed) {\n      this.logger.warn(\"ACK to negative final response was never received, terminating transaction.\");\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * Once timer I fires, the server MUST transition to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerI() {\n    this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);\n    this.stateTransition(TransactionState.Terminated);\n  }\n  /**\n   * When Timer L fires and the state machine is in the \"Accepted\" state, the machine MUST\n   * transition to the \"Terminated\" state. Once the transaction is in the \"Terminated\" state,\n   * it MUST be destroyed immediately. Timer L reflects the amount of time the server\n   * transaction could receive 2xx responses for retransmission from the\n   * TU while it is waiting to receive an ACK.\n   * https://tools.ietf.org/html/rfc6026#section-7.1\n   * https://tools.ietf.org/html/rfc6026#section-8.7\n   */\n\n\n  timerL() {\n    this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Accepted) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/invite-server-transaction.js"],"names":["C","Timers","ServerTransaction","TransactionState","InviteServerTransaction","constructor","request","transport","user","Proceeding","dispose","stopProgressExtensionTimer","H","clearTimeout","undefined","I","L","kind","receiveRequest","state","method","INVITE","lastProvisionalResponse","send","catch","error","logTransportError","Accepted","Completed","lastFinalResponse","Error","ACK","stateTransition","Confirmed","Terminated","message","logger","warn","receiveResponse","statusCode","response","startProgressExtensionTimer","retransmitAcceptedResponse","onTransportError","typeToString","newState","invalidStateTransition","setTimeout","timerL","TIMER_L","timerH","TIMER_H","timerI","TIMER_I","setState","progressExtensionTimer","setInterval","debug","id","PROVISIONAL_RESPONSE_INTERVAL","clearInterval","timerG"],"mappings":"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","sourcesContent":["import { C } from \"../messages\";\nimport { Timers } from \"../timers\";\nimport { ServerTransaction } from \"./server-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.1\n * @public\n */\nexport class InviteServerTransaction extends ServerTransaction {\n    /**\n     * Constructor.\n     * Upon construction, a \"100 Trying\" reply will be immediately sent.\n     * After construction the transaction will be in the \"proceeding\" state and the transaction\n     * `id` will equal the branch parameter set in the Via header of the incoming request.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     * @param request - Incoming INVITE request from the transport.\n     * @param transport - The transport.\n     * @param user - The transaction user.\n     */\n    constructor(request, transport, user) {\n        super(request, transport, user, TransactionState.Proceeding, \"sip.transaction.ist\");\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        this.stopProgressExtensionTimer();\n        if (this.H) {\n            clearTimeout(this.H);\n            this.H = undefined;\n        }\n        if (this.I) {\n            clearTimeout(this.I);\n            this.I = undefined;\n        }\n        if (this.L) {\n            clearTimeout(this.L);\n            this.L = undefined;\n        }\n        super.dispose();\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        return \"ist\";\n    }\n    /**\n     * Receive requests from transport matching this transaction.\n     * @param request - Request matching this transaction.\n     */\n    receiveRequest(request) {\n        switch (this.state) {\n            case TransactionState.Proceeding:\n                // If a request retransmission is received while in the \"Proceeding\" state, the most\n                // recent provisional response that was received from the TU MUST be passed to the\n                // transport layer for retransmission.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE) {\n                    if (this.lastProvisionalResponse) {\n                        this.send(this.lastProvisionalResponse).catch((error) => {\n                            this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n                        });\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // While in the \"Accepted\" state, any retransmissions of the INVITE\n                // received will match this transaction state machine and will be\n                // absorbed by the machine without changing its state. These\n                // retransmissions are not passed onto the TU.\n                // https://tools.ietf.org/html/rfc6026#section-7.1\n                if (request.method === C.INVITE) {\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                // Furthermore, while in the \"Completed\" state, if a request retransmission is\n                // received, the server SHOULD pass the response to the transport for retransmission.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE) {\n                    if (!this.lastFinalResponse) {\n                        throw new Error(\"Last final response undefined.\");\n                    }\n                    this.send(this.lastFinalResponse).catch((error) => {\n                        this.logTransportError(error, \"Failed to send retransmission of final response.\");\n                    });\n                    return;\n                }\n                // If an ACK is received while the server transaction is in the \"Completed\" state,\n                // the server transaction MUST transition to the \"Confirmed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.ACK) {\n                    this.stateTransition(TransactionState.Confirmed);\n                    return;\n                }\n                break;\n            case TransactionState.Confirmed:\n                // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n                // triggered from retransmissions of the final response.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (request.method === C.INVITE || request.method === C.ACK) {\n                    return;\n                }\n                break;\n            case TransactionState.Terminated:\n                // For good measure absorb any additional messages that arrive (should not happen).\n                if (request.method === C.INVITE || request.method === C.ACK) {\n                    return;\n                }\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        const message = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;\n        this.logger.warn(message);\n        return;\n    }\n    /**\n     * Receive responses from TU for this transaction.\n     * @param statusCode - Status code of response.\n     * @param response - Response.\n     */\n    receiveResponse(statusCode, response) {\n        if (statusCode < 100 || statusCode > 699) {\n            throw new Error(`Invalid status code ${statusCode}`);\n        }\n        switch (this.state) {\n            case TransactionState.Proceeding:\n                // The TU passes any number of provisional responses to the server\n                // transaction. So long as the server transaction is in the\n                // \"Proceeding\" state, each of these MUST be passed to the transport\n                // layer for transmission. They are not sent reliably by the\n                // transaction layer (they are not retransmitted by it) and do not cause\n                // a change in the state of the server transaction.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (statusCode >= 100 && statusCode <= 199) {\n                    this.lastProvisionalResponse = response;\n                    // Start the progress extension timer only for a non-100 provisional response.\n                    if (statusCode > 100) {\n                        this.startProgressExtensionTimer(); // FIXME: remove\n                    }\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 1xx response.\");\n                    });\n                    return;\n                }\n                // If, while in the \"Proceeding\" state, the TU passes a 2xx response\n                // to the server transaction, the server transaction MUST pass this\n                // response to the transport layer for transmission. It is not\n                // retransmitted by the server transaction; retransmissions of 2xx\n                // responses are handled by the TU. The server transaction MUST then\n                // transition to the \"Accepted\" state.\n                // https://tools.ietf.org/html/rfc6026#section-8.5\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.lastFinalResponse = response;\n                    this.stateTransition(TransactionState.Accepted);\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 2xx response.\");\n                    });\n                    return;\n                }\n                // While in the \"Proceeding\" state, if the TU passes a response with\n                // status code from 300 to 699 to the server transaction, the response\n                // MUST be passed to the transport layer for transmission, and the state\n                // machine MUST enter the \"Completed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.lastFinalResponse = response;\n                    this.stateTransition(TransactionState.Completed);\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send non-2xx final response.\");\n                    });\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // While in the \"Accepted\" state, if the TU passes a 2xx response,\n                // the server transaction MUST pass the response to the transport layer for transmission.\n                // https://tools.ietf.org/html/rfc6026#section-8.7\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.send(response).catch((error) => {\n                        this.logTransportError(error, \"Failed to send 2xx response.\");\n                    });\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                break;\n            case TransactionState.Confirmed:\n                break;\n            case TransactionState.Terminated:\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        const message = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;\n        this.logger.error(message);\n        throw new Error(message);\n    }\n    /**\n     * Retransmit the last 2xx response. This is a noop if not in the \"accepted\" state.\n     */\n    retransmitAcceptedResponse() {\n        if (this.state === TransactionState.Accepted && this.lastFinalResponse) {\n            this.send(this.lastFinalResponse).catch((error) => {\n                this.logTransportError(error, \"Failed to send 2xx response.\");\n            });\n        }\n    }\n    /**\n     * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n     * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n     * inform the TU that a failure has occurred, and MUST remain in the current state.\n     * https://tools.ietf.org/html/rfc6026#section-8.8\n     */\n    onTransportError(error) {\n        if (this.user.onTransportError) {\n            this.user.onTransportError(error);\n        }\n    }\n    /** For logging. */\n    typeToString() {\n        return \"INVITE server transaction\";\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n    stateTransition(newState) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n        };\n        switch (newState) {\n            case TransactionState.Proceeding:\n                invalidStateTransition();\n                break;\n            case TransactionState.Accepted:\n            case TransactionState.Completed:\n                if (this.state !== TransactionState.Proceeding) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Confirmed:\n                if (this.state !== TransactionState.Completed) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Terminated:\n                if (this.state !== TransactionState.Accepted &&\n                    this.state !== TransactionState.Completed &&\n                    this.state !== TransactionState.Confirmed) {\n                    invalidStateTransition();\n                }\n                break;\n            default:\n                invalidStateTransition();\n        }\n        // On any state transition, stop resending provisional responses\n        this.stopProgressExtensionTimer();\n        // The purpose of the \"Accepted\" state is to absorb retransmissions of an accepted INVITE request.\n        // Any such retransmissions are absorbed entirely within the server transaction.\n        // They are not passed up to the TU since any downstream UAS cores that accepted the request have\n        // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Accepted) {\n            this.L = setTimeout(() => this.timerL(), Timers.TIMER_L);\n        }\n        // When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.\n        // Timer H determines when the server transaction abandons retransmitting the response.\n        // If an ACK is received while the server transaction is in the \"Completed\" state,\n        // the server transaction MUST transition to the \"Confirmed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (newState === TransactionState.Completed) {\n            // FIXME: Missing timer G for unreliable transports.\n            this.H = setTimeout(() => this.timerH(), Timers.TIMER_H);\n        }\n        // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n        // triggered from retransmissions of the final response. When this state is entered, timer I\n        // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable\n        // transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (newState === TransactionState.Confirmed) {\n            // FIXME: This timer is not getting set correctly for unreliable transports.\n            this.I = setTimeout(() => this.timerI(), Timers.TIMER_I);\n        }\n        // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Terminated) {\n            this.dispose();\n        }\n        // Update state.\n        this.setState(newState);\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n    startProgressExtensionTimer() {\n        // Start the progress extension timer only for the first non-100 provisional response.\n        if (this.progressExtensionTimer === undefined) {\n            this.progressExtensionTimer = setInterval(() => {\n                this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);\n                if (!this.lastProvisionalResponse) {\n                    throw new Error(\"Last provisional response undefined.\");\n                }\n                this.send(this.lastProvisionalResponse).catch((error) => {\n                    this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n                });\n            }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n        }\n    }\n    /**\n     * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1\n     * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n     */\n    stopProgressExtensionTimer() {\n        if (this.progressExtensionTimer !== undefined) {\n            clearInterval(this.progressExtensionTimer);\n            this.progressExtensionTimer = undefined;\n        }\n    }\n    /**\n     * While in the \"Proceeding\" state, if the TU passes a response with status code\n     * from 300 to 699 to the server transaction, the response MUST be passed to the\n     * transport layer for transmission, and the state machine MUST enter the \"Completed\" state.\n     * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for\n     * reliable transports. If timer G fires, the response is passed to the transport layer once\n     * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,\n     * when timer G fires, the response is passed to the transport again for transmission, and\n     * timer G is reset with a value that doubles, unless that value exceeds T2, in which case\n     * it is reset with the value of T2.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerG() {\n        // TODO\n    }\n    /**\n     * If timer H fires while in the \"Completed\" state, it implies that the ACK was never received.\n     * In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST\n     * indicate to the TU that a transaction failure has occurred.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerH() {\n        this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);\n        if (this.state === TransactionState.Completed) {\n            this.logger.warn(\"ACK to negative final response was never received, terminating transaction.\");\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * Once timer I fires, the server MUST transition to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.2.1\n     */\n    timerI() {\n        this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);\n        this.stateTransition(TransactionState.Terminated);\n    }\n    /**\n     * When Timer L fires and the state machine is in the \"Accepted\" state, the machine MUST\n     * transition to the \"Terminated\" state. Once the transaction is in the \"Terminated\" state,\n     * it MUST be destroyed immediately. Timer L reflects the amount of time the server\n     * transaction could receive 2xx responses for retransmission from the\n     * TU while it is waiting to receive an ACK.\n     * https://tools.ietf.org/html/rfc6026#section-7.1\n     * https://tools.ietf.org/html/rfc6026#section-8.7\n     */\n    timerL() {\n        this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);\n        if (this.state === TransactionState.Accepted) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}