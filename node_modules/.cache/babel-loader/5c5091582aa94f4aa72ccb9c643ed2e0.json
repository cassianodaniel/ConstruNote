{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { DigestAuthentication, Grammar, IncomingRequestMessage, IncomingResponseMessage, Levels, LoggerFactory, Parser, URI, UserAgentCore } from \"../core\";\nimport { createRandomToken, utf8Length } from \"../core/messages/utils\";\nimport { defaultSessionDescriptionHandlerFactory } from \"../platform/web/session-description-handler\";\nimport { Transport as WebTransport } from \"../platform/web/transport\";\nimport { LIBRARY_VERSION } from \"../version\";\nimport { EmitterImpl } from \"./emitter\";\nimport { Invitation } from \"./invitation\";\nimport { Inviter } from \"./inviter\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { SIPExtension, UserAgentRegisteredOptionTags } from \"./user-agent-options\";\nimport { UserAgentState } from \"./user-agent-state\";\n/**\n * A user agent sends and receives requests using a `Transport`.\n *\n * @remarks\n * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)\n * and acts on behalf of that user to send and receive SIP requests. The user agent can\n * register to receive incoming requests, as well as create and send outbound messages.\n * The user agent also maintains the Transport over which its signaling travels.\n *\n * @public\n */\n\nexport var UserAgent = /*#__PURE__*/function () {\n  /**\n   * Constructs a new instance of the `UserAgent` class.\n   * @param options - Options bucket. See {@link UserAgentOptions} for details.\n   */\n  function UserAgent() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, UserAgent);\n\n    /** @internal */\n    this._publishers = {};\n    /** @internal */\n\n    this._registerers = {};\n    /** @internal */\n\n    this._sessions = {};\n    /** @internal */\n\n    this._subscriptions = {};\n    this._state = UserAgentState.Stopped;\n    /** Unload listener. */\n\n    this.unloadListener = function () {\n      _this.stop();\n    }; // state emitter\n\n\n    this._stateEventEmitter = new EmitterImpl(); // initialize delegate\n\n    this.delegate = options.delegate; // initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), {\n      sipjsId: createRandomToken(5)\n    }), {\n      uri: new URI(\"sip\", \"anonymous.\" + createRandomToken(6), \"anonymous.invalid\")\n    }), {\n      viaHost: createRandomToken(12) + \".invalid\"\n    }), UserAgent.stripUndefinedProperties(options)); // viaHost is hack\n\n    if (this.options.hackIpInContact) {\n      if (typeof this.options.hackIpInContact === \"boolean\" && this.options.hackIpInContact) {\n        var from = 1;\n        var to = 254;\n        var octet = Math.floor(Math.random() * (to - from + 1) + from); // random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n\n        this.options.viaHost = \"192.0.2.\" + octet;\n      } else if (this.options.hackIpInContact) {\n        this.options.viaHost = this.options.hackIpInContact;\n      }\n    } // initialize logger & logger factory\n\n\n    this.loggerFactory = new LoggerFactory();\n    this.logger = this.loggerFactory.getLogger(\"sip.UserAgent\");\n    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;\n    this.loggerFactory.connector = this.options.logConnector;\n\n    switch (this.options.logLevel) {\n      case \"error\":\n        this.loggerFactory.level = Levels.error;\n        break;\n\n      case \"warn\":\n        this.loggerFactory.level = Levels.warn;\n        break;\n\n      case \"log\":\n        this.loggerFactory.level = Levels.log;\n        break;\n\n      case \"debug\":\n        this.loggerFactory.level = Levels.debug;\n        break;\n\n      default:\n        break;\n    }\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(function (key) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var value = _this.options[key];\n\n        switch (key) {\n          case \"uri\":\n          case \"sessionDescriptionHandlerFactory\":\n            _this.logger.log(\"路 \" + key + \": \" + value);\n\n            break;\n\n          case \"authorizationPassword\":\n            _this.logger.log(\"路 \" + key + \": \" + \"NOT SHOWN\");\n\n            break;\n\n          case \"transportConstructor\":\n            _this.logger.log(\"路 \" + key + \": \" + value.name);\n\n            break;\n\n          default:\n            _this.logger.log(\"路 \" + key + \": \" + JSON.stringify(value));\n\n        }\n      });\n    } // guard deprecated transport options (remove this in version 16.x)\n\n\n    if (this.options.transportOptions) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var optionsDeprecated = this.options.transportOptions;\n      var maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;\n      var reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        var deprecatedMessage = \"The transport option \\\"maxReconnectionAttempts\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (reconnectionTimeoutDeprecated !== undefined) {\n        var _deprecatedMessage = \"The transport option \\\"reconnectionTimeout\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n\n        this.logger.warn(_deprecatedMessage);\n      } // hack\n\n\n      if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {\n        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;\n      }\n\n      if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {\n        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;\n      }\n    } // guard deprecated user agent options (remove this in version 16.x)\n\n\n    if (options.reconnectionDelay !== undefined) {\n      var _deprecatedMessage2 = \"The user agent option \\\"reconnectionDelay\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n\n      this.logger.warn(_deprecatedMessage2);\n    }\n\n    if (options.reconnectionAttempts !== undefined) {\n      var _deprecatedMessage3 = \"The user agent option \\\"reconnectionAttempts\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n\n      this.logger.warn(_deprecatedMessage3);\n    } // Initialize Transport\n\n\n    this._transport = new this.options.transportConstructor(this.getLogger(\"sip.Transport\"), this.options.transportOptions);\n    this.initTransportCallbacks(); // Initialize Contact\n\n    this._contact = this.initContact(); // Initialize UserAgentCore\n\n    this._userAgentCore = this.initCore();\n\n    if (this.options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Create a URI instance from a string.\n   * @param uri - The string to parse.\n   *\n   * @example\n   * ```ts\n   * const uri = UserAgent.makeURI(\"sip:edgar@example.com\");\n   * ```\n   */\n\n\n  _createClass(UserAgent, [{\n    key: \"getLogger\",\n\n    /**\n     * The logger.\n     */\n    value: function getLogger(category, label) {\n      return this.loggerFactory.getLogger(category, label);\n    }\n    /**\n     * The logger factory.\n     */\n\n  }, {\n    key: \"getLoggerFactory\",\n    value: function getLoggerFactory() {\n      return this.loggerFactory;\n    }\n    /**\n     * True if transport is connected.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.transport.isConnected();\n    }\n    /**\n     * Reconnect the transport.\n     */\n\n  }, {\n    key: \"reconnect\",\n    value: function reconnect() {\n      var _this2 = this;\n\n      if (this.state === UserAgentState.Stopped) {\n        return Promise.reject(new Error(\"User agent stopped.\"));\n      } // Make sure we don't call synchronously\n\n\n      return Promise.resolve().then(function () {\n        return _this2.transport.connect();\n      });\n    }\n    /**\n     * Start the user agent.\n     *\n     * @remarks\n     * Resolves if transport connects, otherwise rejects.\n     *\n     * @example\n     * ```ts\n     * userAgent.start()\n     *   .then(() => {\n     *     // userAgent.isConnected() === true\n     *   })\n     *   .catch((error: Error) => {\n     *     // userAgent.isConnected() === false\n     *   });\n     * ```\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.state === UserAgentState.Started) {\n        this.logger.warn(\"User agent already started\");\n        return Promise.resolve();\n      }\n\n      this.logger.log(\"Starting \".concat(this.configuration.uri)); // Transition state\n\n      this.transitionState(UserAgentState.Started); // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.\n      // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this\n      // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.\n      // Should this perhaps be deprecated?\n      //\n      // Add window unload event listener\n\n      if (this.options.autoStop) {\n        // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n        var googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n\n        if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && !googleChromePackagedApp) {\n          window.addEventListener(\"unload\", this.unloadListener);\n        }\n      }\n\n      return this.transport.connect();\n    }\n    /**\n     * Stop the user agent.\n     *\n     * @remarks\n     * Resolves when the user agent has completed a graceful shutdown.\n     * ```txt\n     * 1) Sessions terminate.\n     * 2) Registerers unregister.\n     * 3) Subscribers unsubscribe.\n     * 4) Publishers unpublish.\n     * 5) Transport disconnects.\n     * 6) User Agent Core resets.\n     * ```\n     * NOTE: While this is a \"graceful shutdown\", it can also be very slow one if you\n     * are waiting for the returned Promise to resolve. The disposal of the clients and\n     * dialogs is done serially - waiting on one to finish before moving on to the next.\n     * This can be slow if there are lot of subscriptions to unsubscribe for example.\n     *\n     * THE SLOW PACE IS INTENTIONAL!\n     * While one could spin them all down in parallel, this could slam the remote server.\n     * It is bad practice to denial of service attack (DoS attack) servers!!!\n     * Moreover, production servers will automatically blacklist clients which send too\n     * many requests in too short a period of time - dropping any additional requests.\n     *\n     * If a different approach to disposing is needed, one can implement whatever is\n     * needed and execute that prior to calling `stop()`. Alternatively one may simply\n     * not wait for the Promise returned by `stop()` to complete.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var googleChromePackagedApp, publishers, registerers, sessions, subscriptions, transport, userAgentCore, _loop, id, _loop2, _id, _loop3, _id2, _loop4, _id3;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this.state === UserAgentState.Stopped)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                this.logger.warn(\"User agent already stopped\");\n                return _context5.abrupt(\"return\", Promise.resolve());\n\n              case 3:\n                this.logger.log(\"Stopping \".concat(this.configuration.uri)); // Transition state\n\n                this.transitionState(UserAgentState.Stopped); // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?\n                // Remove window unload event listener\n\n                if (this.options.autoStop) {\n                  // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n                  googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n\n                  if (typeof window !== \"undefined\" && window.removeEventListener && !googleChromePackagedApp) {\n                    window.removeEventListener(\"unload\", this.unloadListener);\n                  }\n                } // Be careful here to use a local references as start() can be called\n                // again before we complete and we don't want to touch new clients\n                // and we don't want to step on the new instances (or vice versa).\n\n\n                publishers = Object.assign({}, this._publishers);\n                registerers = Object.assign({}, this._registerers);\n                sessions = Object.assign({}, this._sessions);\n                subscriptions = Object.assign({}, this._subscriptions);\n                transport = this.transport;\n                userAgentCore = this.userAgentCore; //\n                // At this point we have completed the state transition and everything\n                // following will effectively run async and MUST NOT cause any issues\n                // if UserAgent.start() is called while the following code continues.\n                //\n                // TODO: Minor optimization.\n                // The disposal in all cases involves, in part, sending messages which\n                // is not worth doing if the transport is not connected as we know attempting\n                // to send messages will be futile. But none of these disposal methods check\n                // if that's is the case and it would be easy for them to do so at this point.\n                // Dispose of Registerers\n\n                this.logger.log(\"Dispose of registerers\");\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop(id) {\n                  return _regeneratorRuntime.wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          if (!registerers[id]) {\n                            _context.next = 3;\n                            break;\n                          }\n\n                          _context.next = 3;\n                          return registerers[id].dispose().catch(function (error) {\n                            _this3.logger.error(error.message);\n\n                            delete _this3._registerers[id];\n                            throw error;\n                          });\n\n                        case 3:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _context5.t0 = _regeneratorRuntime.keys(registerers);\n\n              case 15:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 20;\n                  break;\n                }\n\n                id = _context5.t1.value;\n                return _context5.delegateYield(_loop(id), \"t2\", 18);\n\n              case 18:\n                _context5.next = 15;\n                break;\n\n              case 20:\n                // Dispose of Sessions\n                this.logger.log(\"Dispose of sessions\");\n                _loop2 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop2(_id) {\n                  return _regeneratorRuntime.wrap(function _loop2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          if (!sessions[_id]) {\n                            _context2.next = 3;\n                            break;\n                          }\n\n                          _context2.next = 3;\n                          return sessions[_id].dispose().catch(function (error) {\n                            _this3.logger.error(error.message);\n\n                            delete _this3._sessions[_id];\n                            throw error;\n                          });\n\n                        case 3:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _loop2);\n                });\n                _context5.t3 = _regeneratorRuntime.keys(sessions);\n\n              case 23:\n                if ((_context5.t4 = _context5.t3()).done) {\n                  _context5.next = 28;\n                  break;\n                }\n\n                _id = _context5.t4.value;\n                return _context5.delegateYield(_loop2(_id), \"t5\", 26);\n\n              case 26:\n                _context5.next = 23;\n                break;\n\n              case 28:\n                // Dispose of Subscriptions\n                this.logger.log(\"Dispose of subscriptions\");\n                _loop3 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop3(_id2) {\n                  return _regeneratorRuntime.wrap(function _loop3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          if (!subscriptions[_id2]) {\n                            _context3.next = 3;\n                            break;\n                          }\n\n                          _context3.next = 3;\n                          return subscriptions[_id2].dispose().catch(function (error) {\n                            _this3.logger.error(error.message);\n\n                            delete _this3._subscriptions[_id2];\n                            throw error;\n                          });\n\n                        case 3:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _loop3);\n                });\n                _context5.t6 = _regeneratorRuntime.keys(subscriptions);\n\n              case 31:\n                if ((_context5.t7 = _context5.t6()).done) {\n                  _context5.next = 36;\n                  break;\n                }\n\n                _id2 = _context5.t7.value;\n                return _context5.delegateYield(_loop3(_id2), \"t8\", 34);\n\n              case 34:\n                _context5.next = 31;\n                break;\n\n              case 36:\n                // Dispose of Publishers\n                this.logger.log(\"Dispose of publishers\");\n                _loop4 = /*#__PURE__*/_regeneratorRuntime.mark(function _loop4(_id3) {\n                  return _regeneratorRuntime.wrap(function _loop4$(_context4) {\n                    while (1) {\n                      switch (_context4.prev = _context4.next) {\n                        case 0:\n                          if (!publishers[_id3]) {\n                            _context4.next = 3;\n                            break;\n                          }\n\n                          _context4.next = 3;\n                          return publishers[_id3].dispose().catch(function (error) {\n                            _this3.logger.error(error.message);\n\n                            delete _this3._publishers[_id3];\n                            throw error;\n                          });\n\n                        case 3:\n                        case \"end\":\n                          return _context4.stop();\n                      }\n                    }\n                  }, _loop4);\n                });\n                _context5.t9 = _regeneratorRuntime.keys(publishers);\n\n              case 39:\n                if ((_context5.t10 = _context5.t9()).done) {\n                  _context5.next = 44;\n                  break;\n                }\n\n                _id3 = _context5.t10.value;\n                return _context5.delegateYield(_loop4(_id3), \"t11\", 42);\n\n              case 42:\n                _context5.next = 39;\n                break;\n\n              case 44:\n                // Dispose of the transport (disconnecting)\n                this.logger.log(\"Dispose of transport\");\n                _context5.next = 47;\n                return transport.dispose().catch(function (error) {\n                  _this3.logger.error(error.message);\n\n                  throw error;\n                });\n\n              case 47:\n                // Dispose of the user agent core (resetting)\n                this.logger.log(\"Dispose of core\");\n                userAgentCore.dispose();\n\n              case 49:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Used to avoid circular references.\n     * @internal\n     */\n\n  }, {\n    key: \"_makeInviter\",\n    value: function _makeInviter(targetURI, options) {\n      return new Inviter(this, targetURI, options);\n    }\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n\n  }, {\n    key: \"attemptReconnection\",\n    value: function attemptReconnection() {\n      var _this4 = this;\n\n      var reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var reconnectionAttempts = this.options.reconnectionAttempts;\n      var reconnectionDelay = this.options.reconnectionDelay;\n\n      if (reconnectionAttempt > reconnectionAttempts) {\n        this.logger.log(\"Maximum reconnection attempts reached\");\n        return;\n      }\n\n      this.logger.log(\"Reconnection attempt \".concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - trying\"));\n      setTimeout(function () {\n        _this4.reconnect().then(function () {\n          _this4.logger.log(\"Reconnection attempt \".concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - succeeded\"));\n        }).catch(function (error) {\n          _this4.logger.error(error.message);\n\n          _this4.logger.log(\"Reconnection attempt \".concat(reconnectionAttempt, \" of \").concat(reconnectionAttempts, \" - failed\"));\n\n          _this4.attemptReconnection(++reconnectionAttempt);\n        });\n      }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /**\n     * Initialize contact.\n     */\n\n  }, {\n    key: \"initContact\",\n    value: function initContact() {\n      var _this5 = this;\n\n      var contactName = this.options.contactName !== \"\" ? this.options.contactName : createRandomToken(8);\n      var contactParams = this.options.contactParams;\n      var contact = {\n        pubGruu: undefined,\n        tempGruu: undefined,\n        uri: new URI(\"sip\", contactName, this.options.viaHost, undefined, contactParams),\n        toString: function toString() {\n          var contactToStringOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var anonymous = contactToStringOptions.anonymous || false;\n          var outbound = contactToStringOptions.outbound || false;\n          var contactString = \"<\";\n\n          if (anonymous) {\n            contactString += _this5.contact.tempGruu || \"sip:anonymous@anonymous.invalid;transport=\".concat(contactParams.transport ? contactParams.transport : \"ws\");\n          } else {\n            contactString += _this5.contact.pubGruu || _this5.contact.uri;\n          }\n\n          if (outbound) {\n            contactString += \";ob\";\n          }\n\n          contactString += \">\";\n          return contactString;\n        }\n      };\n      return contact;\n    }\n    /**\n     * Initialize user agent core.\n     */\n\n  }, {\n    key: \"initCore\",\n    value: function initCore() {\n      var _this6 = this;\n\n      // supported options\n      var supportedOptionTags = [];\n      supportedOptionTags.push(\"outbound\"); // TODO: is this really supported?\n\n      if (this.options.sipExtension100rel === SIPExtension.Supported) {\n        supportedOptionTags.push(\"100rel\");\n      }\n\n      if (this.options.sipExtensionReplaces === SIPExtension.Supported) {\n        supportedOptionTags.push(\"replaces\");\n      }\n\n      if (this.options.sipExtensionExtraSupported) {\n        var _supportedOptionTags;\n\n        (_supportedOptionTags = supportedOptionTags).push.apply(_supportedOptionTags, _toConsumableArray(this.options.sipExtensionExtraSupported));\n      }\n\n      if (!this.options.hackAllowUnregisteredOptionTags) {\n        supportedOptionTags = supportedOptionTags.filter(function (optionTag) {\n          return UserAgentRegisteredOptionTags[optionTag];\n        });\n      }\n\n      supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values\n      // FIXME: TODO: This was ported, but this is and was just plain broken.\n\n      var supportedOptionTagsResponse = supportedOptionTags.slice();\n\n      if (this.contact.pubGruu || this.contact.tempGruu) {\n        supportedOptionTagsResponse.push(\"gruu\");\n      } // core configuration\n\n\n      var userAgentCoreConfiguration = {\n        aor: this.options.uri,\n        contact: this.contact,\n        displayName: this.options.displayName,\n        loggerFactory: this.loggerFactory,\n        hackViaTcp: this.options.hackViaTcp,\n        routeSet: this.options.preloadedRouteSet,\n        supportedOptionTags: supportedOptionTags,\n        supportedOptionTagsResponse: supportedOptionTagsResponse,\n        sipjsId: this.options.sipjsId,\n        userAgentHeaderFieldValue: this.options.userAgentString,\n        viaForceRport: this.options.forceRport,\n        viaHost: this.options.viaHost,\n        authenticationFactory: function authenticationFactory() {\n          var username = _this6.options.authorizationUsername ? _this6.options.authorizationUsername : _this6.options.uri.user; // if authorization username not provided, use uri user as username\n\n          var password = _this6.options.authorizationPassword ? _this6.options.authorizationPassword : undefined;\n          var ha1 = _this6.options.authorizationHa1 ? _this6.options.authorizationHa1 : undefined;\n          return new DigestAuthentication(_this6.getLoggerFactory(), ha1, username, password);\n        },\n        transportAccessor: function transportAccessor() {\n          return _this6.transport;\n        }\n      };\n      var userAgentCoreDelegate = {\n        onInvite: function onInvite(incomingInviteRequest) {\n          var _a;\n\n          var invitation = new Invitation(_this6, incomingInviteRequest);\n          incomingInviteRequest.delegate = {\n            onCancel: function onCancel(cancel) {\n              invitation._onCancel(cancel);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onTransportError: function onTransportError(error) {\n              // A server transaction MUST NOT discard transaction state based only on\n              // encountering a non-recoverable transport error when sending a\n              // response.  Instead, the associated INVITE server transaction state\n              // machine MUST remain in its current state.  (Timers will eventually\n              // cause it to transition to the \"Terminated\" state).\n              // https://tools.ietf.org/html/rfc6026#section-7.1\n              // As noted in the comment above, we are to leaving it to the transaction\n              // timers to eventually cause the transaction to sort itself out in the case\n              // of a transport failure in an invite server transaction. This delegate method\n              // is here simply here for completeness and to make it clear that it provides\n              // nothing more than informational hook into the core. That is, if you think\n              // you should be trying to deal with a transport error here, you are likely wrong.\n              _this6.logger.error(\"A transport error has occurred while handling an incoming INVITE request.\");\n            }\n          }; // FIXME: Ported - 100 Trying send should be configurable.\n          // Only required if TU will not respond in 200ms.\n          // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n          incomingInviteRequest.trying(); // The Replaces header contains information used to match an existing\n          // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE\n          // with a Replaces header, the User Agent (UA) attempts to match this\n          // information with a confirmed or early dialog.\n          // https://tools.ietf.org/html/rfc3891#section-3\n\n          if (_this6.options.sipExtensionReplaces !== SIPExtension.Unsupported) {\n            var message = incomingInviteRequest.message;\n            var replaces = message.parseHeader(\"replaces\");\n\n            if (replaces) {\n              var callId = replaces.call_id;\n\n              if (typeof callId !== \"string\") {\n                throw new Error(\"Type of call id is not string\");\n              }\n\n              var toTag = replaces.replaces_to_tag;\n\n              if (typeof toTag !== \"string\") {\n                throw new Error(\"Type of to tag is not string\");\n              }\n\n              var fromTag = replaces.replaces_from_tag;\n\n              if (typeof fromTag !== \"string\") {\n                throw new Error(\"type of from tag is not string\");\n              }\n\n              var targetDialogId = callId + toTag + fromTag;\n\n              var targetDialog = _this6.userAgentCore.dialogs.get(targetDialogId); // If no match is found, the UAS rejects the INVITE and returns a 481\n              // Call/Transaction Does Not Exist response.  Likewise, if the Replaces\n              // header field matches a dialog which was not created with an INVITE,\n              // the UAS MUST reject the request with a 481 response.\n              // https://tools.ietf.org/html/rfc3891#section-3\n\n\n              if (!targetDialog) {\n                invitation.reject({\n                  statusCode: 481\n                });\n                return;\n              } // If the Replaces header field matches a confirmed dialog, it checks\n              // for the presence of the \"early-only\" flag in the Replaces header\n              // field.  (This flag allows the UAC to prevent a potentially\n              // undesirable race condition described in Section 7.1.) If the flag is\n              // present, the UA rejects the request with a 486 Busy response.\n              // https://tools.ietf.org/html/rfc3891#section-3\n\n\n              if (!targetDialog.early && replaces.early_only === true) {\n                invitation.reject({\n                  statusCode: 486\n                });\n                return;\n              } // Provide a handle on the session being replaced.\n\n\n              var targetSession = _this6._sessions[callId + fromTag] || _this6._sessions[callId + toTag] || undefined;\n\n              if (!targetSession) {\n                throw new Error(\"Session does not exist.\");\n              }\n\n              invitation._replacee = targetSession;\n            }\n          } // Delegate invitation handling.\n\n\n          if ((_a = _this6.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {\n            if (invitation.autoSendAnInitialProvisionalResponse) {\n              invitation.progress().then(function () {\n                var _a;\n\n                if (((_a = _this6.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {\n                  throw new Error(\"onInvite undefined.\");\n                }\n\n                _this6.delegate.onInvite(invitation);\n              });\n              return;\n            }\n\n            _this6.delegate.onInvite(invitation);\n\n            return;\n          } // A common scenario occurs when the callee is currently not willing or\n          // able to take additional calls at this end system.  A 486 (Busy Here)\n          // SHOULD be returned in such a scenario.\n          // https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n\n\n          invitation.reject({\n            statusCode: 486\n          });\n        },\n        onMessage: function onMessage(incomingMessageRequest) {\n          if (_this6.delegate && _this6.delegate.onMessage) {\n            var message = new Message(incomingMessageRequest);\n\n            _this6.delegate.onMessage(message);\n          } else {\n            // Accept the MESSAGE request, but do nothing with it.\n            incomingMessageRequest.accept();\n          }\n        },\n        onNotify: function onNotify(incomingNotifyRequest) {\n          // NOTIFY requests are sent to inform subscribers of changes in state to\n          // which the subscriber has a subscription.  Subscriptions are created\n          // using the SUBSCRIBE method.  In legacy implementations, it is\n          // possible that other means of subscription creation have been used.\n          // However, this specification does not allow the creation of\n          // subscriptions except through SUBSCRIBE requests and (for backwards-\n          // compatibility) REFER requests [RFC3515].\n          // https://tools.ietf.org/html/rfc6665#section-3.2\n          if (_this6.delegate && _this6.delegate.onNotify) {\n            var notification = new Notification(incomingNotifyRequest);\n\n            _this6.delegate.onNotify(notification);\n          } else {\n            // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,\n            // the use of out of dialog NOTIFY is obsolete, but...\n            if (_this6.options.allowLegacyNotifications) {\n              incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.\n            } else {\n              incomingNotifyRequest.reject({\n                statusCode: 481\n              });\n            }\n          }\n        },\n        onRefer: function onRefer(incomingReferRequest) {\n          _this6.logger.warn(\"Received an out of dialog REFER request\"); // TOOD: this.delegate.onRefer(...)\n\n\n          if (_this6.delegate && _this6.delegate.onReferRequest) {\n            _this6.delegate.onReferRequest(incomingReferRequest);\n          } else {\n            incomingReferRequest.reject({\n              statusCode: 405\n            });\n          }\n        },\n        onRegister: function onRegister(incomingRegisterRequest) {\n          _this6.logger.warn(\"Received an out of dialog REGISTER request\"); // TOOD: this.delegate.onRegister(...)\n\n\n          if (_this6.delegate && _this6.delegate.onRegisterRequest) {\n            _this6.delegate.onRegisterRequest(incomingRegisterRequest);\n          } else {\n            incomingRegisterRequest.reject({\n              statusCode: 405\n            });\n          }\n        },\n        onSubscribe: function onSubscribe(incomingSubscribeRequest) {\n          _this6.logger.warn(\"Received an out of dialog SUBSCRIBE request\"); // TOOD: this.delegate.onSubscribe(...)\n\n\n          if (_this6.delegate && _this6.delegate.onSubscribeRequest) {\n            _this6.delegate.onSubscribeRequest(incomingSubscribeRequest);\n          } else {\n            incomingSubscribeRequest.reject({\n              statusCode: 405\n            });\n          }\n        }\n      };\n      return new UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);\n    }\n  }, {\n    key: \"initTransportCallbacks\",\n    value: function initTransportCallbacks() {\n      var _this7 = this;\n\n      this.transport.onConnect = function () {\n        return _this7.onTransportConnect();\n      };\n\n      this.transport.onDisconnect = function (error) {\n        return _this7.onTransportDisconnect(error);\n      };\n\n      this.transport.onMessage = function (message) {\n        return _this7.onTransportMessage(message);\n      };\n    }\n  }, {\n    key: \"onTransportConnect\",\n    value: function onTransportConnect() {\n      if (this.state === UserAgentState.Stopped) {\n        return;\n      }\n\n      if (this.delegate && this.delegate.onConnect) {\n        this.delegate.onConnect();\n      }\n    }\n  }, {\n    key: \"onTransportDisconnect\",\n    value: function onTransportDisconnect(error) {\n      if (this.state === UserAgentState.Stopped) {\n        return;\n      }\n\n      if (this.delegate && this.delegate.onDisconnect) {\n        this.delegate.onDisconnect(error);\n      } // Only attempt to reconnect if network/server dropped the connection.\n\n\n      if (error && this.options.reconnectionAttempts > 0) {\n        this.attemptReconnection();\n      }\n    }\n  }, {\n    key: \"onTransportMessage\",\n    value: function onTransportMessage(messageString) {\n      var _this8 = this;\n\n      var message = Parser.parseMessage(messageString, this.getLogger(\"sip.Parser\"));\n\n      if (!message) {\n        this.logger.warn(\"Failed to parse incoming message. Dropping.\");\n        return;\n      }\n\n      if (this.state === UserAgentState.Stopped && message instanceof IncomingRequestMessage) {\n        this.logger.warn(\"Received \".concat(message.method, \" request while stopped. Dropping.\"));\n        return;\n      } // A valid SIP request formulated by a UAC MUST, at a minimum, contain\n      // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,\n      // and Via; all of these header fields are mandatory in all SIP\n      // requests.\n      // https://tools.ietf.org/html/rfc3261#section-8.1.1\n\n\n      var hasMinimumHeaders = function hasMinimumHeaders() {\n        var mandatoryHeaders = [\"from\", \"to\", \"call_id\", \"cseq\", \"via\"];\n\n        for (var _i = 0, _mandatoryHeaders = mandatoryHeaders; _i < _mandatoryHeaders.length; _i++) {\n          var header = _mandatoryHeaders[_i];\n\n          if (!message.hasHeader(header)) {\n            _this8.logger.warn(\"Missing mandatory header field : \".concat(header, \".\"));\n\n            return false;\n          }\n        }\n\n        return true;\n      }; // Request Checks\n\n\n      if (message instanceof IncomingRequestMessage) {\n        // This is port of SanityCheck.minimumHeaders().\n        if (!hasMinimumHeaders()) {\n          this.logger.warn(\"Request missing mandatory header field. Dropping.\");\n          return;\n        } // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).\n        // Custom SIP.js check to reject request from ourself (this instance of SIP.js).\n        // This is port of SanityCheck.rfc3261_16_3_4().\n\n\n        if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {\n          this.userAgentCore.replyStateless(message, {\n            statusCode: 482\n          });\n          return;\n        } // FIXME: This should be Transport check before we get here (Section 18).\n        // Custom SIP.js check to reject requests if body length wrong.\n        // This is port of SanityCheck.rfc3261_18_3_request().\n\n\n        var len = utf8Length(message.body);\n        var contentLength = message.getHeader(\"content-length\");\n\n        if (contentLength && len < Number(contentLength)) {\n          this.userAgentCore.replyStateless(message, {\n            statusCode: 400\n          });\n          return;\n        }\n      } // Response Checks\n\n\n      if (message instanceof IncomingResponseMessage) {\n        // This is port of SanityCheck.minimumHeaders().\n        if (!hasMinimumHeaders()) {\n          this.logger.warn(\"Response missing mandatory header field. Dropping.\");\n          return;\n        } // Custom SIP.js check to drop responses if multiple Via headers.\n        // This is port of SanityCheck.rfc3261_8_1_3_3().\n\n\n        if (message.getHeaders(\"via\").length > 1) {\n          this.logger.warn(\"More than one Via header field present in the response. Dropping.\");\n          return;\n        } // FIXME: This should be Transport check before we get here (Section 18).\n        // Custom SIP.js check to drop responses if bad Via header.\n        // This is port of SanityCheck.rfc3261_18_1_2().\n\n\n        if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {\n          this.logger.warn(\"Via sent-by in the response does not match UA Via host value. Dropping.\");\n          return;\n        } // FIXME: This should be Transport check before we get here (Section 18).\n        // Custom SIP.js check to reject requests if body length wrong.\n        // This is port of SanityCheck.rfc3261_18_3_response().\n\n\n        var _len = utf8Length(message.body);\n\n        var _contentLength = message.getHeader(\"content-length\");\n\n        if (_contentLength && _len < Number(_contentLength)) {\n          this.logger.warn(\"Message body length is lower than the value in Content-Length header field. Dropping.\");\n          return;\n        }\n      } // Handle Request\n\n\n      if (message instanceof IncomingRequestMessage) {\n        this.userAgentCore.receiveIncomingRequestFromTransport(message);\n        return;\n      } // Handle Response\n\n\n      if (message instanceof IncomingResponseMessage) {\n        this.userAgentCore.receiveIncomingResponseFromTransport(message);\n        return;\n      }\n\n      throw new Error(\"Invalid message type.\");\n    }\n    /**\n     * Transition state.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"transitionState\",\n    value: function transitionState(newState, error) {\n      var _this9 = this;\n\n      var invalidTransition = function invalidTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this9._state, \" to \").concat(newState));\n      }; // Validate state transition\n\n\n      switch (this._state) {\n        case UserAgentState.Started:\n          if (newState !== UserAgentState.Stopped) {\n            invalidTransition();\n          }\n\n          break;\n\n        case UserAgentState.Stopped:\n          if (newState !== UserAgentState.Started) {\n            invalidTransition();\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown state.\");\n      } // Update state\n\n\n      this.logger.log(\"Transitioned from \".concat(this._state, \" to \").concat(newState));\n      this._state = newState;\n\n      this._stateEventEmitter.emit(this._state);\n    }\n  }, {\n    key: \"configuration\",\n\n    /**\n     * User agent configuration.\n     */\n    get: function get() {\n      return this.options;\n    }\n    /**\n     * User agent contact.\n     */\n\n  }, {\n    key: \"contact\",\n    get: function get() {\n      return this._contact;\n    }\n    /**\n     * User agent state.\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n    /**\n     * User agent state change emitter.\n     */\n\n  }, {\n    key: \"stateChange\",\n    get: function get() {\n      return this._stateEventEmitter;\n    }\n    /**\n     * User agent transport.\n     */\n\n  }, {\n    key: \"transport\",\n    get: function get() {\n      return this._transport;\n    }\n    /**\n     * User agent core.\n     */\n\n  }, {\n    key: \"userAgentCore\",\n    get: function get() {\n      return this._userAgentCore;\n    }\n  }], [{\n    key: \"makeURI\",\n    value: function makeURI(uri) {\n      return Grammar.URIParse(uri);\n    }\n    /** Default user agent options. */\n\n  }, {\n    key: \"defaultOptions\",\n    value: function defaultOptions() {\n      return {\n        allowLegacyNotifications: false,\n        authorizationHa1: \"\",\n        authorizationPassword: \"\",\n        authorizationUsername: \"\",\n        autoStart: false,\n        autoStop: true,\n        delegate: {},\n        contactName: \"\",\n        contactParams: {\n          transport: \"ws\"\n        },\n        displayName: \"\",\n        forceRport: false,\n        hackAllowUnregisteredOptionTags: false,\n        hackIpInContact: false,\n        hackViaTcp: false,\n        logBuiltinEnabled: true,\n        logConfiguration: true,\n        logConnector: function logConnector() {\n          /* noop */\n        },\n        logLevel: \"log\",\n        noAnswerTimeout: 60,\n        preloadedRouteSet: [],\n        reconnectionAttempts: 0,\n        reconnectionDelay: 4,\n        sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),\n        sessionDescriptionHandlerFactoryOptions: {},\n        sipExtension100rel: SIPExtension.Unsupported,\n        sipExtensionReplaces: SIPExtension.Unsupported,\n        sipExtensionExtraSupported: [],\n        sipjsId: \"\",\n        transportConstructor: WebTransport,\n        transportOptions: {},\n        uri: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n        userAgentString: \"SIP.js/\" + LIBRARY_VERSION,\n        viaHost: \"\"\n      };\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n\n  }, {\n    key: \"stripUndefinedProperties\",\n    value: function stripUndefinedProperties(options) {\n      return Object.keys(options).reduce(function (object, key) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (options[key] !== undefined) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          object[key] = options[key];\n        }\n\n        return object;\n      }, {});\n    }\n  }]);\n\n  return UserAgent;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/user-agent.js"],"names":["DigestAuthentication","Grammar","IncomingRequestMessage","IncomingResponseMessage","Levels","LoggerFactory","Parser","URI","UserAgentCore","createRandomToken","utf8Length","defaultSessionDescriptionHandlerFactory","Transport","WebTransport","LIBRARY_VERSION","EmitterImpl","Invitation","Inviter","Message","Notification","SIPExtension","UserAgentRegisteredOptionTags","UserAgentState","UserAgent","options","_publishers","_registerers","_sessions","_subscriptions","_state","Stopped","unloadListener","stop","_stateEventEmitter","delegate","Object","assign","defaultOptions","sipjsId","uri","viaHost","stripUndefinedProperties","hackIpInContact","from","to","octet","Math","floor","random","loggerFactory","logger","getLogger","builtinEnabled","logBuiltinEnabled","connector","logConnector","logLevel","level","error","warn","log","debug","logConfiguration","keys","forEach","key","value","name","JSON","stringify","transportOptions","optionsDeprecated","maxReconnectionAttemptsDeprecated","maxReconnectionAttempts","reconnectionTimeoutDeprecated","reconnectionTimeout","undefined","deprecatedMessage","reconnectionDelay","reconnectionAttempts","_transport","transportConstructor","initTransportCallbacks","_contact","initContact","_userAgentCore","initCore","autoStart","start","category","label","transport","isConnected","state","Promise","reject","Error","resolve","then","connect","Started","configuration","transitionState","autoStop","googleChromePackagedApp","chrome","app","runtime","window","addEventListener","removeEventListener","publishers","registerers","sessions","subscriptions","userAgentCore","id","dispose","catch","message","targetURI","reconnectionAttempt","setTimeout","reconnect","attemptReconnection","contactName","contactParams","contact","pubGruu","tempGruu","toString","contactToStringOptions","anonymous","outbound","contactString","supportedOptionTags","push","sipExtension100rel","Supported","sipExtensionReplaces","sipExtensionExtraSupported","hackAllowUnregisteredOptionTags","filter","optionTag","Array","Set","supportedOptionTagsResponse","slice","userAgentCoreConfiguration","aor","displayName","hackViaTcp","routeSet","preloadedRouteSet","userAgentHeaderFieldValue","userAgentString","viaForceRport","forceRport","authenticationFactory","username","authorizationUsername","user","password","authorizationPassword","ha1","authorizationHa1","getLoggerFactory","transportAccessor","userAgentCoreDelegate","onInvite","incomingInviteRequest","_a","invitation","onCancel","cancel","_onCancel","onTransportError","trying","Unsupported","replaces","parseHeader","callId","call_id","toTag","replaces_to_tag","fromTag","replaces_from_tag","targetDialogId","targetDialog","dialogs","get","statusCode","early","early_only","targetSession","_replacee","autoSendAnInitialProvisionalResponse","progress","onMessage","incomingMessageRequest","accept","onNotify","incomingNotifyRequest","notification","allowLegacyNotifications","onRefer","incomingReferRequest","onReferRequest","onRegister","incomingRegisterRequest","onRegisterRequest","onSubscribe","incomingSubscribeRequest","onSubscribeRequest","onConnect","onTransportConnect","onDisconnect","onTransportDisconnect","onTransportMessage","messageString","parseMessage","method","hasMinimumHeaders","mandatoryHeaders","header","hasHeader","substr","replyStateless","len","body","contentLength","getHeader","Number","getHeaders","length","via","host","port","receiveIncomingRequestFromTransport","receiveIncomingResponseFromTransport","newState","invalidTransition","emit","URIParse","noAnswerTimeout","sessionDescriptionHandlerFactory","sessionDescriptionHandlerFactoryOptions","reduce","object"],"mappings":"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","sourcesContent":["import { DigestAuthentication, Grammar, IncomingRequestMessage, IncomingResponseMessage, Levels, LoggerFactory, Parser, URI, UserAgentCore } from \"../core\";\nimport { createRandomToken, utf8Length } from \"../core/messages/utils\";\nimport { defaultSessionDescriptionHandlerFactory } from \"../platform/web/session-description-handler\";\nimport { Transport as WebTransport } from \"../platform/web/transport\";\nimport { LIBRARY_VERSION } from \"../version\";\nimport { EmitterImpl } from \"./emitter\";\nimport { Invitation } from \"./invitation\";\nimport { Inviter } from \"./inviter\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { SIPExtension, UserAgentRegisteredOptionTags } from \"./user-agent-options\";\nimport { UserAgentState } from \"./user-agent-state\";\n/**\n * A user agent sends and receives requests using a `Transport`.\n *\n * @remarks\n * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)\n * and acts on behalf of that user to send and receive SIP requests. The user agent can\n * register to receive incoming requests, as well as create and send outbound messages.\n * The user agent also maintains the Transport over which its signaling travels.\n *\n * @public\n */\nexport class UserAgent {\n    /**\n     * Constructs a new instance of the `UserAgent` class.\n     * @param options - Options bucket. See {@link UserAgentOptions} for details.\n     */\n    constructor(options = {}) {\n        /** @internal */\n        this._publishers = {};\n        /** @internal */\n        this._registerers = {};\n        /** @internal */\n        this._sessions = {};\n        /** @internal */\n        this._subscriptions = {};\n        this._state = UserAgentState.Stopped;\n        /** Unload listener. */\n        this.unloadListener = () => {\n            this.stop();\n        };\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // initialize delegate\n        this.delegate = options.delegate;\n        // initialize configuration\n        this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), { sipjsId: createRandomToken(5) }), { uri: new URI(\"sip\", \"anonymous.\" + createRandomToken(6), \"anonymous.invalid\") }), { viaHost: createRandomToken(12) + \".invalid\" }), UserAgent.stripUndefinedProperties(options));\n        // viaHost is hack\n        if (this.options.hackIpInContact) {\n            if (typeof this.options.hackIpInContact === \"boolean\" && this.options.hackIpInContact) {\n                const from = 1;\n                const to = 254;\n                const octet = Math.floor(Math.random() * (to - from + 1) + from);\n                // random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n                this.options.viaHost = \"192.0.2.\" + octet;\n            }\n            else if (this.options.hackIpInContact) {\n                this.options.viaHost = this.options.hackIpInContact;\n            }\n        }\n        // initialize logger & logger factory\n        this.loggerFactory = new LoggerFactory();\n        this.logger = this.loggerFactory.getLogger(\"sip.UserAgent\");\n        this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;\n        this.loggerFactory.connector = this.options.logConnector;\n        switch (this.options.logLevel) {\n            case \"error\":\n                this.loggerFactory.level = Levels.error;\n                break;\n            case \"warn\":\n                this.loggerFactory.level = Levels.warn;\n                break;\n            case \"log\":\n                this.loggerFactory.level = Levels.log;\n                break;\n            case \"debug\":\n                this.loggerFactory.level = Levels.debug;\n                break;\n            default:\n                break;\n        }\n        if (this.options.logConfiguration) {\n            this.logger.log(\"Configuration:\");\n            Object.keys(this.options).forEach((key) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const value = this.options[key];\n                switch (key) {\n                    case \"uri\":\n                    case \"sessionDescriptionHandlerFactory\":\n                        this.logger.log(\"路 \" + key + \": \" + value);\n                        break;\n                    case \"authorizationPassword\":\n                        this.logger.log(\"路 \" + key + \": \" + \"NOT SHOWN\");\n                        break;\n                    case \"transportConstructor\":\n                        this.logger.log(\"路 \" + key + \": \" + value.name);\n                        break;\n                    default:\n                        this.logger.log(\"路 \" + key + \": \" + JSON.stringify(value));\n                }\n            });\n        }\n        // guard deprecated transport options (remove this in version 16.x)\n        if (this.options.transportOptions) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const optionsDeprecated = this.options.transportOptions;\n            const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;\n            const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;\n            if (maxReconnectionAttemptsDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            if (reconnectionTimeoutDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            // hack\n            if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {\n                this.options.reconnectionDelay = reconnectionTimeoutDeprecated;\n            }\n            if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {\n                this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;\n            }\n        }\n        // guard deprecated user agent options (remove this in version 16.x)\n        if (options.reconnectionDelay !== undefined) {\n            const deprecatedMessage = `The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. ` +\n                \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n            this.logger.warn(deprecatedMessage);\n        }\n        if (options.reconnectionAttempts !== undefined) {\n            const deprecatedMessage = `The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n            this.logger.warn(deprecatedMessage);\n        }\n        // Initialize Transport\n        this._transport = new this.options.transportConstructor(this.getLogger(\"sip.Transport\"), this.options.transportOptions);\n        this.initTransportCallbacks();\n        // Initialize Contact\n        this._contact = this.initContact();\n        // Initialize UserAgentCore\n        this._userAgentCore = this.initCore();\n        if (this.options.autoStart) {\n            this.start();\n        }\n    }\n    /**\n     * Create a URI instance from a string.\n     * @param uri - The string to parse.\n     *\n     * @example\n     * ```ts\n     * const uri = UserAgent.makeURI(\"sip:edgar@example.com\");\n     * ```\n     */\n    static makeURI(uri) {\n        return Grammar.URIParse(uri);\n    }\n    /** Default user agent options. */\n    static defaultOptions() {\n        return {\n            allowLegacyNotifications: false,\n            authorizationHa1: \"\",\n            authorizationPassword: \"\",\n            authorizationUsername: \"\",\n            autoStart: false,\n            autoStop: true,\n            delegate: {},\n            contactName: \"\",\n            contactParams: { transport: \"ws\" },\n            displayName: \"\",\n            forceRport: false,\n            hackAllowUnregisteredOptionTags: false,\n            hackIpInContact: false,\n            hackViaTcp: false,\n            logBuiltinEnabled: true,\n            logConfiguration: true,\n            logConnector: () => {\n                /* noop */\n            },\n            logLevel: \"log\",\n            noAnswerTimeout: 60,\n            preloadedRouteSet: [],\n            reconnectionAttempts: 0,\n            reconnectionDelay: 4,\n            sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),\n            sessionDescriptionHandlerFactoryOptions: {},\n            sipExtension100rel: SIPExtension.Unsupported,\n            sipExtensionReplaces: SIPExtension.Unsupported,\n            sipExtensionExtraSupported: [],\n            sipjsId: \"\",\n            transportConstructor: WebTransport,\n            transportOptions: {},\n            uri: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n            userAgentString: \"SIP.js/\" + LIBRARY_VERSION,\n            viaHost: \"\"\n        };\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n    static stripUndefinedProperties(options) {\n        return Object.keys(options).reduce((object, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (options[key] !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                object[key] = options[key];\n            }\n            return object;\n        }, {});\n    }\n    /**\n     * User agent configuration.\n     */\n    get configuration() {\n        return this.options;\n    }\n    /**\n     * User agent contact.\n     */\n    get contact() {\n        return this._contact;\n    }\n    /**\n     * User agent state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * User agent state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * User agent transport.\n     */\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * User agent core.\n     */\n    get userAgentCore() {\n        return this._userAgentCore;\n    }\n    /**\n     * The logger.\n     */\n    getLogger(category, label) {\n        return this.loggerFactory.getLogger(category, label);\n    }\n    /**\n     * The logger factory.\n     */\n    getLoggerFactory() {\n        return this.loggerFactory;\n    }\n    /**\n     * True if transport is connected.\n     */\n    isConnected() {\n        return this.transport.isConnected();\n    }\n    /**\n     * Reconnect the transport.\n     */\n    reconnect() {\n        if (this.state === UserAgentState.Stopped) {\n            return Promise.reject(new Error(\"User agent stopped.\"));\n        }\n        // Make sure we don't call synchronously\n        return Promise.resolve().then(() => this.transport.connect());\n    }\n    /**\n     * Start the user agent.\n     *\n     * @remarks\n     * Resolves if transport connects, otherwise rejects.\n     *\n     * @example\n     * ```ts\n     * userAgent.start()\n     *   .then(() => {\n     *     // userAgent.isConnected() === true\n     *   })\n     *   .catch((error: Error) => {\n     *     // userAgent.isConnected() === false\n     *   });\n     * ```\n     */\n    start() {\n        if (this.state === UserAgentState.Started) {\n            this.logger.warn(`User agent already started`);\n            return Promise.resolve();\n        }\n        this.logger.log(`Starting ${this.configuration.uri}`);\n        // Transition state\n        this.transitionState(UserAgentState.Started);\n        // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.\n        // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this\n        // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.\n        // Should this perhaps be deprecated?\n        //\n        // Add window unload event listener\n        if (this.options.autoStop) {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n            const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n            if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && !googleChromePackagedApp) {\n                window.addEventListener(\"unload\", this.unloadListener);\n            }\n        }\n        return this.transport.connect();\n    }\n    /**\n     * Stop the user agent.\n     *\n     * @remarks\n     * Resolves when the user agent has completed a graceful shutdown.\n     * ```txt\n     * 1) Sessions terminate.\n     * 2) Registerers unregister.\n     * 3) Subscribers unsubscribe.\n     * 4) Publishers unpublish.\n     * 5) Transport disconnects.\n     * 6) User Agent Core resets.\n     * ```\n     * NOTE: While this is a \"graceful shutdown\", it can also be very slow one if you\n     * are waiting for the returned Promise to resolve. The disposal of the clients and\n     * dialogs is done serially - waiting on one to finish before moving on to the next.\n     * This can be slow if there are lot of subscriptions to unsubscribe for example.\n     *\n     * THE SLOW PACE IS INTENTIONAL!\n     * While one could spin them all down in parallel, this could slam the remote server.\n     * It is bad practice to denial of service attack (DoS attack) servers!!!\n     * Moreover, production servers will automatically blacklist clients which send too\n     * many requests in too short a period of time - dropping any additional requests.\n     *\n     * If a different approach to disposing is needed, one can implement whatever is\n     * needed and execute that prior to calling `stop()`. Alternatively one may simply\n     * not wait for the Promise returned by `stop()` to complete.\n     */\n    async stop() {\n        if (this.state === UserAgentState.Stopped) {\n            this.logger.warn(`User agent already stopped`);\n            return Promise.resolve();\n        }\n        this.logger.log(`Stopping ${this.configuration.uri}`);\n        // Transition state\n        this.transitionState(UserAgentState.Stopped);\n        // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?\n        // Remove window unload event listener\n        if (this.options.autoStop) {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n            const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n            if (typeof window !== \"undefined\" && window.removeEventListener && !googleChromePackagedApp) {\n                window.removeEventListener(\"unload\", this.unloadListener);\n            }\n        }\n        // Be careful here to use a local references as start() can be called\n        // again before we complete and we don't want to touch new clients\n        // and we don't want to step on the new instances (or vice versa).\n        const publishers = Object.assign({}, this._publishers);\n        const registerers = Object.assign({}, this._registerers);\n        const sessions = Object.assign({}, this._sessions);\n        const subscriptions = Object.assign({}, this._subscriptions);\n        const transport = this.transport;\n        const userAgentCore = this.userAgentCore;\n        //\n        // At this point we have completed the state transition and everything\n        // following will effectively run async and MUST NOT cause any issues\n        // if UserAgent.start() is called while the following code continues.\n        //\n        // TODO: Minor optimization.\n        // The disposal in all cases involves, in part, sending messages which\n        // is not worth doing if the transport is not connected as we know attempting\n        // to send messages will be futile. But none of these disposal methods check\n        // if that's is the case and it would be easy for them to do so at this point.\n        // Dispose of Registerers\n        this.logger.log(`Dispose of registerers`);\n        for (const id in registerers) {\n            if (registerers[id]) {\n                await registerers[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._registerers[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Sessions\n        this.logger.log(`Dispose of sessions`);\n        for (const id in sessions) {\n            if (sessions[id]) {\n                await sessions[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._sessions[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Subscriptions\n        this.logger.log(`Dispose of subscriptions`);\n        for (const id in subscriptions) {\n            if (subscriptions[id]) {\n                await subscriptions[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._subscriptions[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Publishers\n        this.logger.log(`Dispose of publishers`);\n        for (const id in publishers) {\n            if (publishers[id]) {\n                await publishers[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._publishers[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of the transport (disconnecting)\n        this.logger.log(`Dispose of transport`);\n        await transport.dispose().catch((error) => {\n            this.logger.error(error.message);\n            throw error;\n        });\n        // Dispose of the user agent core (resetting)\n        this.logger.log(`Dispose of core`);\n        userAgentCore.dispose();\n    }\n    /**\n     * Used to avoid circular references.\n     * @internal\n     */\n    _makeInviter(targetURI, options) {\n        return new Inviter(this, targetURI, options);\n    }\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n    attemptReconnection(reconnectionAttempt = 1) {\n        const reconnectionAttempts = this.options.reconnectionAttempts;\n        const reconnectionDelay = this.options.reconnectionDelay;\n        if (reconnectionAttempt > reconnectionAttempts) {\n            this.logger.log(`Maximum reconnection attempts reached`);\n            return;\n        }\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n        setTimeout(() => {\n            this.reconnect()\n                .then(() => {\n                this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n            })\n                .catch((error) => {\n                this.logger.error(error.message);\n                this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n                this.attemptReconnection(++reconnectionAttempt);\n            });\n        }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /**\n     * Initialize contact.\n     */\n    initContact() {\n        const contactName = this.options.contactName !== \"\" ? this.options.contactName : createRandomToken(8);\n        const contactParams = this.options.contactParams;\n        const contact = {\n            pubGruu: undefined,\n            tempGruu: undefined,\n            uri: new URI(\"sip\", contactName, this.options.viaHost, undefined, contactParams),\n            toString: (contactToStringOptions = {}) => {\n                const anonymous = contactToStringOptions.anonymous || false;\n                const outbound = contactToStringOptions.outbound || false;\n                let contactString = \"<\";\n                if (anonymous) {\n                    contactString +=\n                        this.contact.tempGruu ||\n                            `sip:anonymous@anonymous.invalid;transport=${contactParams.transport ? contactParams.transport : \"ws\"}`;\n                }\n                else {\n                    contactString += this.contact.pubGruu || this.contact.uri;\n                }\n                if (outbound) {\n                    contactString += \";ob\";\n                }\n                contactString += \">\";\n                return contactString;\n            }\n        };\n        return contact;\n    }\n    /**\n     * Initialize user agent core.\n     */\n    initCore() {\n        // supported options\n        let supportedOptionTags = [];\n        supportedOptionTags.push(\"outbound\"); // TODO: is this really supported?\n        if (this.options.sipExtension100rel === SIPExtension.Supported) {\n            supportedOptionTags.push(\"100rel\");\n        }\n        if (this.options.sipExtensionReplaces === SIPExtension.Supported) {\n            supportedOptionTags.push(\"replaces\");\n        }\n        if (this.options.sipExtensionExtraSupported) {\n            supportedOptionTags.push(...this.options.sipExtensionExtraSupported);\n        }\n        if (!this.options.hackAllowUnregisteredOptionTags) {\n            supportedOptionTags = supportedOptionTags.filter((optionTag) => UserAgentRegisteredOptionTags[optionTag]);\n        }\n        supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values\n        // FIXME: TODO: This was ported, but this is and was just plain broken.\n        const supportedOptionTagsResponse = supportedOptionTags.slice();\n        if (this.contact.pubGruu || this.contact.tempGruu) {\n            supportedOptionTagsResponse.push(\"gruu\");\n        }\n        // core configuration\n        const userAgentCoreConfiguration = {\n            aor: this.options.uri,\n            contact: this.contact,\n            displayName: this.options.displayName,\n            loggerFactory: this.loggerFactory,\n            hackViaTcp: this.options.hackViaTcp,\n            routeSet: this.options.preloadedRouteSet,\n            supportedOptionTags,\n            supportedOptionTagsResponse,\n            sipjsId: this.options.sipjsId,\n            userAgentHeaderFieldValue: this.options.userAgentString,\n            viaForceRport: this.options.forceRport,\n            viaHost: this.options.viaHost,\n            authenticationFactory: () => {\n                const username = this.options.authorizationUsername\n                    ? this.options.authorizationUsername\n                    : this.options.uri.user; // if authorization username not provided, use uri user as username\n                const password = this.options.authorizationPassword ? this.options.authorizationPassword : undefined;\n                const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : undefined;\n                return new DigestAuthentication(this.getLoggerFactory(), ha1, username, password);\n            },\n            transportAccessor: () => this.transport\n        };\n        const userAgentCoreDelegate = {\n            onInvite: (incomingInviteRequest) => {\n                var _a;\n                const invitation = new Invitation(this, incomingInviteRequest);\n                incomingInviteRequest.delegate = {\n                    onCancel: (cancel) => {\n                        invitation._onCancel(cancel);\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    onTransportError: (error) => {\n                        // A server transaction MUST NOT discard transaction state based only on\n                        // encountering a non-recoverable transport error when sending a\n                        // response.  Instead, the associated INVITE server transaction state\n                        // machine MUST remain in its current state.  (Timers will eventually\n                        // cause it to transition to the \"Terminated\" state).\n                        // https://tools.ietf.org/html/rfc6026#section-7.1\n                        // As noted in the comment above, we are to leaving it to the transaction\n                        // timers to eventually cause the transaction to sort itself out in the case\n                        // of a transport failure in an invite server transaction. This delegate method\n                        // is here simply here for completeness and to make it clear that it provides\n                        // nothing more than informational hook into the core. That is, if you think\n                        // you should be trying to deal with a transport error here, you are likely wrong.\n                        this.logger.error(\"A transport error has occurred while handling an incoming INVITE request.\");\n                    }\n                };\n                // FIXME: Ported - 100 Trying send should be configurable.\n                // Only required if TU will not respond in 200ms.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                incomingInviteRequest.trying();\n                // The Replaces header contains information used to match an existing\n                // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE\n                // with a Replaces header, the User Agent (UA) attempts to match this\n                // information with a confirmed or early dialog.\n                // https://tools.ietf.org/html/rfc3891#section-3\n                if (this.options.sipExtensionReplaces !== SIPExtension.Unsupported) {\n                    const message = incomingInviteRequest.message;\n                    const replaces = message.parseHeader(\"replaces\");\n                    if (replaces) {\n                        const callId = replaces.call_id;\n                        if (typeof callId !== \"string\") {\n                            throw new Error(\"Type of call id is not string\");\n                        }\n                        const toTag = replaces.replaces_to_tag;\n                        if (typeof toTag !== \"string\") {\n                            throw new Error(\"Type of to tag is not string\");\n                        }\n                        const fromTag = replaces.replaces_from_tag;\n                        if (typeof fromTag !== \"string\") {\n                            throw new Error(\"type of from tag is not string\");\n                        }\n                        const targetDialogId = callId + toTag + fromTag;\n                        const targetDialog = this.userAgentCore.dialogs.get(targetDialogId);\n                        // If no match is found, the UAS rejects the INVITE and returns a 481\n                        // Call/Transaction Does Not Exist response.  Likewise, if the Replaces\n                        // header field matches a dialog which was not created with an INVITE,\n                        // the UAS MUST reject the request with a 481 response.\n                        // https://tools.ietf.org/html/rfc3891#section-3\n                        if (!targetDialog) {\n                            invitation.reject({ statusCode: 481 });\n                            return;\n                        }\n                        // If the Replaces header field matches a confirmed dialog, it checks\n                        // for the presence of the \"early-only\" flag in the Replaces header\n                        // field.  (This flag allows the UAC to prevent a potentially\n                        // undesirable race condition described in Section 7.1.) If the flag is\n                        // present, the UA rejects the request with a 486 Busy response.\n                        // https://tools.ietf.org/html/rfc3891#section-3\n                        if (!targetDialog.early && replaces.early_only === true) {\n                            invitation.reject({ statusCode: 486 });\n                            return;\n                        }\n                        // Provide a handle on the session being replaced.\n                        const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || undefined;\n                        if (!targetSession) {\n                            throw new Error(\"Session does not exist.\");\n                        }\n                        invitation._replacee = targetSession;\n                    }\n                }\n                // Delegate invitation handling.\n                if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {\n                    if (invitation.autoSendAnInitialProvisionalResponse) {\n                        invitation.progress().then(() => {\n                            var _a;\n                            if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {\n                                throw new Error(\"onInvite undefined.\");\n                            }\n                            this.delegate.onInvite(invitation);\n                        });\n                        return;\n                    }\n                    this.delegate.onInvite(invitation);\n                    return;\n                }\n                // A common scenario occurs when the callee is currently not willing or\n                // able to take additional calls at this end system.  A 486 (Busy Here)\n                // SHOULD be returned in such a scenario.\n                // https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n                invitation.reject({ statusCode: 486 });\n            },\n            onMessage: (incomingMessageRequest) => {\n                if (this.delegate && this.delegate.onMessage) {\n                    const message = new Message(incomingMessageRequest);\n                    this.delegate.onMessage(message);\n                }\n                else {\n                    // Accept the MESSAGE request, but do nothing with it.\n                    incomingMessageRequest.accept();\n                }\n            },\n            onNotify: (incomingNotifyRequest) => {\n                // NOTIFY requests are sent to inform subscribers of changes in state to\n                // which the subscriber has a subscription.  Subscriptions are created\n                // using the SUBSCRIBE method.  In legacy implementations, it is\n                // possible that other means of subscription creation have been used.\n                // However, this specification does not allow the creation of\n                // subscriptions except through SUBSCRIBE requests and (for backwards-\n                // compatibility) REFER requests [RFC3515].\n                // https://tools.ietf.org/html/rfc6665#section-3.2\n                if (this.delegate && this.delegate.onNotify) {\n                    const notification = new Notification(incomingNotifyRequest);\n                    this.delegate.onNotify(notification);\n                }\n                else {\n                    // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,\n                    // the use of out of dialog NOTIFY is obsolete, but...\n                    if (this.options.allowLegacyNotifications) {\n                        incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.\n                    }\n                    else {\n                        incomingNotifyRequest.reject({ statusCode: 481 });\n                    }\n                }\n            },\n            onRefer: (incomingReferRequest) => {\n                this.logger.warn(\"Received an out of dialog REFER request\");\n                // TOOD: this.delegate.onRefer(...)\n                if (this.delegate && this.delegate.onReferRequest) {\n                    this.delegate.onReferRequest(incomingReferRequest);\n                }\n                else {\n                    incomingReferRequest.reject({ statusCode: 405 });\n                }\n            },\n            onRegister: (incomingRegisterRequest) => {\n                this.logger.warn(\"Received an out of dialog REGISTER request\");\n                // TOOD: this.delegate.onRegister(...)\n                if (this.delegate && this.delegate.onRegisterRequest) {\n                    this.delegate.onRegisterRequest(incomingRegisterRequest);\n                }\n                else {\n                    incomingRegisterRequest.reject({ statusCode: 405 });\n                }\n            },\n            onSubscribe: (incomingSubscribeRequest) => {\n                this.logger.warn(\"Received an out of dialog SUBSCRIBE request\");\n                // TOOD: this.delegate.onSubscribe(...)\n                if (this.delegate && this.delegate.onSubscribeRequest) {\n                    this.delegate.onSubscribeRequest(incomingSubscribeRequest);\n                }\n                else {\n                    incomingSubscribeRequest.reject({ statusCode: 405 });\n                }\n            }\n        };\n        return new UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);\n    }\n    initTransportCallbacks() {\n        this.transport.onConnect = () => this.onTransportConnect();\n        this.transport.onDisconnect = (error) => this.onTransportDisconnect(error);\n        this.transport.onMessage = (message) => this.onTransportMessage(message);\n    }\n    onTransportConnect() {\n        if (this.state === UserAgentState.Stopped) {\n            return;\n        }\n        if (this.delegate && this.delegate.onConnect) {\n            this.delegate.onConnect();\n        }\n    }\n    onTransportDisconnect(error) {\n        if (this.state === UserAgentState.Stopped) {\n            return;\n        }\n        if (this.delegate && this.delegate.onDisconnect) {\n            this.delegate.onDisconnect(error);\n        }\n        // Only attempt to reconnect if network/server dropped the connection.\n        if (error && this.options.reconnectionAttempts > 0) {\n            this.attemptReconnection();\n        }\n    }\n    onTransportMessage(messageString) {\n        const message = Parser.parseMessage(messageString, this.getLogger(\"sip.Parser\"));\n        if (!message) {\n            this.logger.warn(\"Failed to parse incoming message. Dropping.\");\n            return;\n        }\n        if (this.state === UserAgentState.Stopped && message instanceof IncomingRequestMessage) {\n            this.logger.warn(`Received ${message.method} request while stopped. Dropping.`);\n            return;\n        }\n        // A valid SIP request formulated by a UAC MUST, at a minimum, contain\n        // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,\n        // and Via; all of these header fields are mandatory in all SIP\n        // requests.\n        // https://tools.ietf.org/html/rfc3261#section-8.1.1\n        const hasMinimumHeaders = () => {\n            const mandatoryHeaders = [\"from\", \"to\", \"call_id\", \"cseq\", \"via\"];\n            for (const header of mandatoryHeaders) {\n                if (!message.hasHeader(header)) {\n                    this.logger.warn(`Missing mandatory header field : ${header}.`);\n                    return false;\n                }\n            }\n            return true;\n        };\n        // Request Checks\n        if (message instanceof IncomingRequestMessage) {\n            // This is port of SanityCheck.minimumHeaders().\n            if (!hasMinimumHeaders()) {\n                this.logger.warn(`Request missing mandatory header field. Dropping.`);\n                return;\n            }\n            // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).\n            // Custom SIP.js check to reject request from ourself (this instance of SIP.js).\n            // This is port of SanityCheck.rfc3261_16_3_4().\n            if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {\n                this.userAgentCore.replyStateless(message, { statusCode: 482 });\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to reject requests if body length wrong.\n            // This is port of SanityCheck.rfc3261_18_3_request().\n            const len = utf8Length(message.body);\n            const contentLength = message.getHeader(\"content-length\");\n            if (contentLength && len < Number(contentLength)) {\n                this.userAgentCore.replyStateless(message, { statusCode: 400 });\n                return;\n            }\n        }\n        // Response Checks\n        if (message instanceof IncomingResponseMessage) {\n            // This is port of SanityCheck.minimumHeaders().\n            if (!hasMinimumHeaders()) {\n                this.logger.warn(`Response missing mandatory header field. Dropping.`);\n                return;\n            }\n            // Custom SIP.js check to drop responses if multiple Via headers.\n            // This is port of SanityCheck.rfc3261_8_1_3_3().\n            if (message.getHeaders(\"via\").length > 1) {\n                this.logger.warn(\"More than one Via header field present in the response. Dropping.\");\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to drop responses if bad Via header.\n            // This is port of SanityCheck.rfc3261_18_1_2().\n            if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {\n                this.logger.warn(\"Via sent-by in the response does not match UA Via host value. Dropping.\");\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to reject requests if body length wrong.\n            // This is port of SanityCheck.rfc3261_18_3_response().\n            const len = utf8Length(message.body);\n            const contentLength = message.getHeader(\"content-length\");\n            if (contentLength && len < Number(contentLength)) {\n                this.logger.warn(\"Message body length is lower than the value in Content-Length header field. Dropping.\");\n                return;\n            }\n        }\n        // Handle Request\n        if (message instanceof IncomingRequestMessage) {\n            this.userAgentCore.receiveIncomingRequestFromTransport(message);\n            return;\n        }\n        // Handle Response\n        if (message instanceof IncomingResponseMessage) {\n            this.userAgentCore.receiveIncomingResponseFromTransport(message);\n            return;\n        }\n        throw new Error(\"Invalid message type.\");\n    }\n    /**\n     * Transition state.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transitionState(newState, error) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate state transition\n        switch (this._state) {\n            case UserAgentState.Started:\n                if (newState !== UserAgentState.Stopped) {\n                    invalidTransition();\n                }\n                break;\n            case UserAgentState.Stopped:\n                if (newState !== UserAgentState.Started) {\n                    invalidTransition();\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        // Update state\n        this.logger.log(`Transitioned from ${this._state} to ${newState}`);\n        this._state = newState;\n        this._stateEventEmitter.emit(this._state);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}