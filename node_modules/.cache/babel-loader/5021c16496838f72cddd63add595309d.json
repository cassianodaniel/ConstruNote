{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { fromBodyLegacy, getBody, Grammar, SessionState as SessionDialogState, SignalingState, URI } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Bye } from \"./bye\";\nimport { EmitterImpl } from \"./emitter\";\nimport { ContentTypeUnsupportedError, RequestPendingError } from \"./exceptions\";\nimport { Info } from \"./info\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { Referral } from \"./referral\";\nimport { SessionState } from \"./session-state\";\n/**\n * A session provides real time communication between one or more participants.\n *\n * @remarks\n * The transport behaves in a deterministic manner according to the\n * the state defined in {@link SessionState}.\n * @public\n */\n\nexport var Session = /*#__PURE__*/function () {\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @internal\n   */\n  function Session(userAgent) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Session);\n\n    /** True if there is an outgoing re-INVITE request outstanding. */\n    this.pendingReinvite = false;\n    /** True if there is an incoming re-INVITE ACK request outstanding. */\n\n    this.pendingReinviteAck = false;\n    /** Session state. */\n\n    this._state = SessionState.Initial;\n    this.delegate = options.delegate;\n    this._stateEventEmitter = new EmitterImpl();\n    this._userAgent = userAgent;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(Session, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n\n      this.logger.log(\"Session \".concat(this.id, \" in state \").concat(this._state, \" is being disposed\")); // Remove from the user agent's session collection\n\n      delete this.userAgent._sessions[this.id]; // Dispose of dialog media\n\n      if (this._sessionDescriptionHandler) {\n        this._sessionDescriptionHandler.close(); // TODO: The SDH needs to remain defined as it will be called after it is closed in cases\n        // where an answer/offer arrives while the session is being torn down. There are a variety\n        // of circumstances where this can happen - sending a BYE during a re-INVITE for example.\n        // The code is currently written such that it lazily makes a new SDH when it needs one\n        // and one is not yet defined. Thus if we undefined it here, it will currently make a\n        // new one which is out of sync and then never gets cleaned up.\n        //\n        // The downside of leaving it defined are that calls this closed SDH will continue to be\n        // made (think setDescription) and those should/will fail. These failures are handled, but\n        // it would be nice to have it all coded up in a way where having an undefined SDH where\n        // one is expected throws an error.\n        //\n        // this._sessionDescriptionHandler = undefined;\n\n      }\n\n      switch (this.state) {\n        case SessionState.Initial:\n          break;\n        // the Inviter/Invitation sub class dispose method handles this case\n\n        case SessionState.Establishing:\n          break;\n        // the Inviter/Invitation sub class dispose method handles this case\n\n        case SessionState.Established:\n          return new Promise(function (resolve) {\n            _this._bye({\n              // wait for the response to the BYE before resolving\n              onAccept: function onAccept() {\n                return resolve();\n              },\n              onRedirect: function onRedirect() {\n                return resolve();\n              },\n              onReject: function onReject() {\n                return resolve();\n              }\n            });\n          });\n\n        case SessionState.Terminating:\n          break;\n        // nothing to be done\n\n        case SessionState.Terminated:\n          break;\n        // nothing to be done\n\n        default:\n          throw new Error(\"Unknown state.\");\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * The asserted identity of the remote user.\n     */\n\n  }, {\n    key: \"bye\",\n\n    /**\n     * End the {@link Session}. Sends a BYE.\n     * @param options - Options bucket. See {@link SessionByeOptions} for details.\n     */\n    value: function bye() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var message = \"Session.bye() may only be called if established session.\";\n\n      switch (this.state) {\n        case SessionState.Initial:\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (typeof this.cancel === \"function\") {\n            message += \" However Inviter.invite() has not yet been called.\";\n            message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } else if (typeof this.reject === \"function\") {\n            message += \" However Invitation.accept() has not yet been called.\";\n            message += \" Perhaps you should have called Invitation.reject()?\";\n          }\n\n          break;\n\n        case SessionState.Establishing:\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (typeof this.cancel === \"function\") {\n            message += \" However a dialog does not yet exist.\";\n            message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } else if (typeof this.reject === \"function\") {\n            message += \" However Invitation.accept() has not yet been called (or not yet resolved).\";\n            message += \" Perhaps you should have called Invitation.reject()?\";\n          }\n\n          break;\n\n        case SessionState.Established:\n          {\n            var requestDelegate = options.requestDelegate;\n            var requestOptions = this.copyRequestOptions(options.requestOptions);\n            return this._bye(requestDelegate, requestOptions);\n          }\n\n        case SessionState.Terminating:\n          message += \" However this session is already terminating.\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          if (typeof this.cancel === \"function\") {\n            message += \" Perhaps you have already called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } else if (typeof this.reject === \"function\") {\n            message += \" Perhaps you have already called Session.bye()?\";\n          }\n\n          break;\n\n        case SessionState.Terminated:\n          message += \" However this session is already terminated.\";\n          break;\n\n        default:\n          throw new Error(\"Unknown state\");\n      }\n\n      this.logger.error(message);\n      return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n    }\n    /**\n     * Share {@link Info} with peer. Sends an INFO.\n     * @param options - Options bucket. See {@link SessionInfoOptions} for details.\n     */\n\n  }, {\n    key: \"info\",\n    value: function info() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      // guard session state\n      if (this.state !== SessionState.Established) {\n        var message = \"Session.info() may only be called if established session.\";\n        this.logger.error(message);\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      var requestDelegate = options.requestDelegate;\n      var requestOptions = this.copyRequestOptions(options.requestOptions);\n      return this._info(requestDelegate, requestOptions);\n    }\n    /**\n     * Renegotiate the session. Sends a re-INVITE.\n     * @param options - Options bucket. See {@link SessionInviteOptions} for details.\n     */\n\n  }, {\n    key: \"invite\",\n    value: function invite() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"Session.invite\");\n\n      if (this.state !== SessionState.Established) {\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      if (this.pendingReinvite) {\n        return Promise.reject(new RequestPendingError(\"Reinvite in progress. Please wait until complete, then try again.\"));\n      }\n\n      this.pendingReinvite = true; // Modifiers and options for initial INVITE transaction\n\n      if (options.sessionDescriptionHandlerModifiers) {\n        this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;\n      }\n\n      if (options.sessionDescriptionHandlerOptions) {\n        this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;\n      }\n\n      var delegate = {\n        onAccept: function onAccept(response) {\n          // A re-INVITE transaction has an offer/answer [RFC3264] exchange\n          // associated with it.  The UAC (User Agent Client) generating a given\n          // re-INVITE can act as the offerer or as the answerer.  A UAC willing\n          // to act as the offerer includes an offer in the re-INVITE.  The UAS\n          // (User Agent Server) then provides an answer in a response to the\n          // re-INVITE.  A UAC willing to act as answerer does not include an\n          // offer in the re-INVITE.  The UAS then provides an offer in a response\n          // to the re-INVITE becoming, thus, the offerer.\n          // https://tools.ietf.org/html/rfc6141#section-1\n          var body = getBody(response.message);\n\n          if (!body) {\n            // No way to recover, so terminate session and mark as failed.\n            _this2.logger.error(\"Received 2xx response to re-INVITE without a session description\");\n\n            _this2.ackAndBye(response, 400, \"Missing session description\");\n\n            _this2.stateTransition(SessionState.Terminated);\n\n            _this2.pendingReinvite = false;\n            return;\n          }\n\n          if (options.withoutSdp) {\n            // INVITE without SDP - set remote offer and send an answer in the ACK\n            var answerOptions = {\n              sessionDescriptionHandlerOptions: _this2.sessionDescriptionHandlerOptionsReInvite,\n              sessionDescriptionHandlerModifiers: _this2.sessionDescriptionHandlerModifiersReInvite\n            };\n\n            _this2.setOfferAndGetAnswer(body, answerOptions).then(function (answerBody) {\n              response.ack({\n                body: answerBody\n              });\n            }).catch(function (error) {\n              // No way to recover, so terminate session and mark as failed.\n              _this2.logger.error(\"Failed to handle offer in 2xx response to re-INVITE\");\n\n              _this2.logger.error(error.message);\n\n              if (_this2.state === SessionState.Terminated) {\n                // A BYE should not be sent if already terminated.\n                // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                response.ack();\n              } else {\n                _this2.ackAndBye(response, 488, \"Bad Media Description\");\n\n                _this2.stateTransition(SessionState.Terminated);\n              }\n            }).then(function () {\n              _this2.pendingReinvite = false;\n\n              if (options.requestDelegate && options.requestDelegate.onAccept) {\n                options.requestDelegate.onAccept(response);\n              }\n            });\n          } else {\n            // INVITE with SDP - set remote answer and send an ACK\n            var _answerOptions = {\n              sessionDescriptionHandlerOptions: _this2.sessionDescriptionHandlerOptionsReInvite,\n              sessionDescriptionHandlerModifiers: _this2.sessionDescriptionHandlerModifiersReInvite\n            };\n\n            _this2.setAnswer(body, _answerOptions).then(function () {\n              response.ack();\n            }).catch(function (error) {\n              // No way to recover, so terminate session and mark as failed.\n              _this2.logger.error(\"Failed to handle answer in 2xx response to re-INVITE\");\n\n              _this2.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n              // For example, a BYE may be sent/received while re-INVITE is outstanding.\n              // The ACK needs to be sent regardless as it was not handled by the transaction.\n\n\n              if (_this2.state !== SessionState.Terminated) {\n                _this2.ackAndBye(response, 488, \"Bad Media Description\");\n\n                _this2.stateTransition(SessionState.Terminated);\n              } else {\n                response.ack();\n              }\n            }).then(function () {\n              _this2.pendingReinvite = false;\n\n              if (options.requestDelegate && options.requestDelegate.onAccept) {\n                options.requestDelegate.onAccept(response);\n              }\n            });\n          }\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        onProgress: function onProgress(response) {\n          return;\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        onRedirect: function onRedirect(response) {\n          return;\n        },\n        onReject: function onReject(response) {\n          _this2.logger.warn(\"Received a non-2xx response to re-INVITE\");\n\n          _this2.pendingReinvite = false;\n\n          if (options.withoutSdp) {\n            if (options.requestDelegate && options.requestDelegate.onReject) {\n              options.requestDelegate.onReject(response);\n            }\n          } else {\n            _this2.rollbackOffer().catch(function (error) {\n              // No way to recover, so terminate session and mark as failed.\n              _this2.logger.error(\"Failed to rollback offer on non-2xx response to re-INVITE\");\n\n              _this2.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n              // For example, a BYE may be sent/received while re-INVITE is outstanding.\n              // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n\n              if (_this2.state !== SessionState.Terminated) {\n                if (!_this2.dialog) {\n                  throw new Error(\"Dialog undefined.\");\n                }\n\n                var extraHeaders = [];\n                extraHeaders.push(\"Reason: \" + _this2.getReasonHeaderValue(500, \"Internal Server Error\"));\n\n                _this2.dialog.bye(undefined, {\n                  extraHeaders: extraHeaders\n                });\n\n                _this2.stateTransition(SessionState.Terminated);\n              }\n            }).then(function () {\n              if (options.requestDelegate && options.requestDelegate.onReject) {\n                options.requestDelegate.onReject(response);\n              }\n            });\n          }\n        },\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        onTrying: function onTrying(response) {\n          return;\n        }\n      };\n      var requestOptions = options.requestOptions || {};\n      requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();\n      requestOptions.extraHeaders.push(\"Allow: \" + AllowedMethods.toString());\n      requestOptions.extraHeaders.push(\"Contact: \" + this._contact); // Just send an INVITE with no sdp...\n\n      if (options.withoutSdp) {\n        if (!this.dialog) {\n          this.pendingReinvite = false;\n          throw new Error(\"Dialog undefined.\");\n        }\n\n        return Promise.resolve(this.dialog.invite(delegate, requestOptions));\n      } // Get an offer and send it in an INVITE\n\n\n      var offerOptions = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n      };\n      return this.getOffer(offerOptions).then(function (offerBody) {\n        if (!_this2.dialog) {\n          _this2.pendingReinvite = false;\n          throw new Error(\"Dialog undefined.\");\n        }\n\n        requestOptions.body = offerBody;\n        return _this2.dialog.invite(delegate, requestOptions);\n      }).catch(function (error) {\n        _this2.logger.error(error.message);\n\n        _this2.logger.error(\"Failed to send re-INVITE\");\n\n        _this2.pendingReinvite = false;\n        throw error;\n      });\n    }\n    /**\n     * Deliver a {@link Message}. Sends a MESSAGE.\n     * @param options - Options bucket. See {@link SessionMessageOptions} for details.\n     */\n\n  }, {\n    key: \"message\",\n    value: function message() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      // guard session state\n      if (this.state !== SessionState.Established) {\n        var message = \"Session.message() may only be called if established session.\";\n        this.logger.error(message);\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      var requestDelegate = options.requestDelegate;\n      var requestOptions = this.copyRequestOptions(options.requestOptions);\n      return this._message(requestDelegate, requestOptions);\n    }\n    /**\n     * Proffer a {@link Referral}. Send a REFER.\n     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.\n     * @param options - Options bucket. See {@link SessionReferOptions} for details.\n     */\n\n  }, {\n    key: \"refer\",\n    value: function refer(referTo) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // guard session state\n      if (this.state !== SessionState.Established) {\n        var message = \"Session.refer() may only be called if established session.\";\n        this.logger.error(message);\n        return Promise.reject(new Error(\"Invalid session state \".concat(this.state)));\n      }\n\n      var requestDelegate = options.requestDelegate;\n      var requestOptions = this.copyRequestOptions(options.requestOptions);\n      requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));\n      return this._refer(options.onNotify, requestDelegate, requestOptions);\n    }\n    /**\n     * Send BYE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n\n  }, {\n    key: \"_bye\",\n    value: function _bye(delegate, options) {\n      var _this3 = this;\n\n      // Using core session dialog\n      if (!this.dialog) {\n        return Promise.reject(new Error(\"Session dialog undefined.\"));\n      }\n\n      var dialog = this.dialog; // The caller's UA MAY send a BYE for either confirmed or early dialogs,\n      // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT\n      // send a BYE on early dialogs. However, the callee's UA MUST NOT send a\n      // BYE on a confirmed dialog until it has received an ACK for its 2xx\n      // response or until the server transaction times out.\n      // https://tools.ietf.org/html/rfc3261#section-15\n\n      switch (dialog.sessionState) {\n        case SessionDialogState.Initial:\n          throw new Error(\"Invalid dialog state \".concat(dialog.sessionState));\n\n        case SessionDialogState.Early:\n          // Implementation choice - not sending BYE for early dialogs.\n          throw new Error(\"Invalid dialog state \".concat(dialog.sessionState));\n\n        case SessionDialogState.AckWait:\n          {\n            // This state only occurs if we are the callee.\n            this.stateTransition(SessionState.Terminating); // We're terminating\n\n            return new Promise(function (resolve) {\n              dialog.delegate = {\n                // When ACK shows up, say BYE.\n                onAck: function onAck() {\n                  var request = dialog.bye(delegate, options);\n\n                  _this3.stateTransition(SessionState.Terminated);\n\n                  resolve(request);\n                  return Promise.resolve();\n                },\n                // Or the server transaction times out before the ACK arrives.\n                onAckTimeout: function onAckTimeout() {\n                  var request = dialog.bye(delegate, options);\n\n                  _this3.stateTransition(SessionState.Terminated);\n\n                  resolve(request);\n                }\n              };\n            });\n          }\n\n        case SessionDialogState.Confirmed:\n          {\n            var request = dialog.bye(delegate, options);\n            this.stateTransition(SessionState.Terminated);\n            return Promise.resolve(request);\n          }\n\n        case SessionDialogState.Terminated:\n          throw new Error(\"Invalid dialog state \".concat(dialog.sessionState));\n\n        default:\n          throw new Error(\"Unrecognized state.\");\n      }\n    }\n    /**\n     * Send INFO.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n\n  }, {\n    key: \"_info\",\n    value: function _info(delegate, options) {\n      // Using core session dialog\n      if (!this.dialog) {\n        return Promise.reject(new Error(\"Session dialog undefined.\"));\n      }\n\n      return Promise.resolve(this.dialog.info(delegate, options));\n    }\n    /**\n     * Send MESSAGE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n\n  }, {\n    key: \"_message\",\n    value: function _message(delegate, options) {\n      // Using core session dialog\n      if (!this.dialog) {\n        return Promise.reject(new Error(\"Session dialog undefined.\"));\n      }\n\n      return Promise.resolve(this.dialog.message(delegate, options));\n    }\n    /**\n     * Send REFER.\n     * @param onNotify - Notification callback.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n\n  }, {\n    key: \"_refer\",\n    value: function _refer(onNotify, delegate, options) {\n      // Using core session dialog\n      if (!this.dialog) {\n        return Promise.reject(new Error(\"Session dialog undefined.\"));\n      } // If set, deliver any in-dialog NOTIFY requests here...\n\n\n      this.onNotify = onNotify;\n      return Promise.resolve(this.dialog.refer(delegate, options));\n    }\n    /**\n     * Send ACK and then BYE. There are unrecoverable errors which can occur\n     * while handling dialog forming and in-dialog INVITE responses and when\n     * they occur we ACK the response and send a BYE.\n     * Note that the BYE is sent in the dialog associated with the response\n     * which is not necessarily `this.dialog`. And, accordingly, the\n     * session state is not transitioned to terminated and session is not closed.\n     * @param inviteResponse - The response causing the error.\n     * @param statusCode - Status code for he reason phrase.\n     * @param reasonPhrase - Reason phrase for the BYE.\n     * @internal\n     */\n\n  }, {\n    key: \"ackAndBye\",\n    value: function ackAndBye(response, statusCode, reasonPhrase) {\n      response.ack();\n      var extraHeaders = [];\n\n      if (statusCode) {\n        extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(statusCode, reasonPhrase));\n      } // Using the dialog session associate with the response (which might not be this.dialog)\n\n\n      response.session.bye(undefined, {\n        extraHeaders: extraHeaders\n      });\n    }\n    /**\n     * Handle in dialog ACK request.\n     * @internal\n     */\n\n  }, {\n    key: \"onAckRequest\",\n    value: function onAckRequest(request) {\n      var _this4 = this;\n\n      this.logger.log(\"Session.onAckRequest\");\n\n      if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {\n        this.logger.error(\"ACK received while in state \".concat(this.state, \", dropping request\"));\n        return Promise.resolve();\n      }\n\n      var dialog = this.dialog;\n\n      if (!dialog) {\n        throw new Error(\"Dialog undefined.\");\n      } // if received answer in ACK.\n\n\n      var answerOptions = {\n        sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,\n        sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers\n      }; // reset pending ACK flag\n\n      this.pendingReinviteAck = false;\n\n      switch (dialog.signalingState) {\n        case SignalingState.Initial:\n          {\n            // State should never be reached as first reliable response must have answer/offer.\n            // So we must have never has sent an offer.\n            this.logger.error(\"Invalid signaling state \".concat(dialog.signalingState, \".\"));\n            var extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n            dialog.bye(undefined, {\n              extraHeaders: extraHeaders\n            });\n            this.stateTransition(SessionState.Terminated);\n            return Promise.resolve();\n          }\n\n        case SignalingState.Stable:\n          {\n            // State we should be in.\n            // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.\n            var body = getBody(request.message); // If the ACK doesn't have an answer, nothing to be done.\n\n            if (!body) {\n              return Promise.resolve();\n            }\n\n            if (body.contentDisposition === \"render\") {\n              this._renderbody = body.content;\n              this._rendertype = body.contentType;\n              return Promise.resolve();\n            }\n\n            if (body.contentDisposition !== \"session\") {\n              return Promise.resolve();\n            }\n\n            return this.setAnswer(body, answerOptions).catch(function (error) {\n              _this4.logger.error(error.message);\n\n              var extraHeaders = [\"Reason: \" + _this4.getReasonHeaderValue(488, \"Bad Media Description\")];\n              dialog.bye(undefined, {\n                extraHeaders: extraHeaders\n              });\n\n              _this4.stateTransition(SessionState.Terminated);\n            });\n          }\n\n        case SignalingState.HaveLocalOffer:\n          {\n            // State should never be reached as local offer would be answered by this ACK.\n            // So we must have received an ACK without an answer.\n            this.logger.error(\"Invalid signaling state \".concat(dialog.signalingState, \".\"));\n            var _extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n            dialog.bye(undefined, {\n              extraHeaders: _extraHeaders\n            });\n            this.stateTransition(SessionState.Terminated);\n            return Promise.resolve();\n          }\n\n        case SignalingState.HaveRemoteOffer:\n          {\n            // State should never be reached as remote offer would be answered in first reliable response.\n            // So we must have never has sent an answer.\n            this.logger.error(\"Invalid signaling state \".concat(dialog.signalingState, \".\"));\n            var _extraHeaders2 = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n            dialog.bye(undefined, {\n              extraHeaders: _extraHeaders2\n            });\n            this.stateTransition(SessionState.Terminated);\n            return Promise.resolve();\n          }\n\n        case SignalingState.Closed:\n          throw new Error(\"Invalid signaling state \".concat(dialog.signalingState, \".\"));\n\n        default:\n          throw new Error(\"Invalid signaling state \".concat(dialog.signalingState, \".\"));\n      }\n    }\n    /**\n     * Handle in dialog BYE request.\n     * @internal\n     */\n\n  }, {\n    key: \"onByeRequest\",\n    value: function onByeRequest(request) {\n      this.logger.log(\"Session.onByeRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"BYE received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      }\n\n      if (this.delegate && this.delegate.onBye) {\n        var bye = new Bye(request);\n        this.delegate.onBye(bye);\n      } else {\n        request.accept();\n      }\n\n      this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle in dialog INFO request.\n     * @internal\n     */\n\n  }, {\n    key: \"onInfoRequest\",\n    value: function onInfoRequest(request) {\n      this.logger.log(\"Session.onInfoRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"INFO received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      }\n\n      if (this.delegate && this.delegate.onInfo) {\n        var info = new Info(request);\n        this.delegate.onInfo(info);\n      } else {\n        // FIXME: TODO: We should reject request...\n        //\n        // If a UA receives an INFO request associated with an Info Package that\n        // the UA has not indicated willingness to receive, the UA MUST send a\n        // 469 (Bad Info Package) response (see Section 11.6), which contains a\n        // Recv-Info header field with Info Packages for which the UA is willing\n        // to receive INFO requests.\n        // https://tools.ietf.org/html/rfc6086#section-4.2.2\n        request.accept();\n      }\n    }\n    /**\n     * Handle in dialog INVITE request.\n     * @internal\n     */\n\n  }, {\n    key: \"onInviteRequest\",\n    value: function onInviteRequest(request) {\n      var _this5 = this;\n\n      this.logger.log(\"Session.onInviteRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"INVITE received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      } // set pending ACK flag\n\n\n      this.pendingReinviteAck = true; // TODO: would be nice to have core track and set the Contact header,\n      // but currently the session which is setting it is holding onto it.\n\n      var extraHeaders = [\"Contact: \" + this._contact]; // Handle P-Asserted-Identity\n\n      if (request.message.hasHeader(\"P-Asserted-Identity\")) {\n        var header = request.message.getHeader(\"P-Asserted-Identity\");\n\n        if (!header) {\n          throw new Error(\"Header undefined.\");\n        }\n\n        this._assertedIdentity = Grammar.nameAddrHeaderParse(header);\n      }\n\n      var options = {\n        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n      };\n      this.generateResponseOfferAnswerInDialog(options).then(function (body) {\n        var outgoingResponse = request.accept({\n          statusCode: 200,\n          extraHeaders: extraHeaders,\n          body: body\n        });\n\n        if (_this5.delegate && _this5.delegate.onInvite) {\n          _this5.delegate.onInvite(request.message, outgoingResponse.message, 200);\n        }\n      }).catch(function (error) {\n        _this5.logger.error(error.message);\n\n        _this5.logger.error(\"Failed to handle to re-INVITE request\");\n\n        if (!_this5.dialog) {\n          throw new Error(\"Dialog undefined.\");\n        }\n\n        _this5.logger.error(_this5.dialog.signalingState); // If we don't have a local/remote offer...\n\n\n        if (_this5.dialog.signalingState === SignalingState.Stable) {\n          var outgoingResponse = request.reject({\n            statusCode: 488\n          }); // Not Acceptable Here\n\n          if (_this5.delegate && _this5.delegate.onInvite) {\n            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);\n          }\n\n          return;\n        } // Otherwise rollback\n\n\n        _this5.rollbackOffer().then(function () {\n          var outgoingResponse = request.reject({\n            statusCode: 488\n          }); // Not Acceptable Here\n\n          if (_this5.delegate && _this5.delegate.onInvite) {\n            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);\n          }\n        }).catch(function (errorRollback) {\n          // No way to recover, so terminate session and mark as failed.\n          _this5.logger.error(errorRollback.message);\n\n          _this5.logger.error(\"Failed to rollback offer on re-INVITE request\");\n\n          var outgoingResponse = request.reject({\n            statusCode: 488\n          }); // Not Acceptable Here\n          // A BYE should only be sent if session is not already terminated.\n          // For example, a BYE may be sent/received while re-INVITE is outstanding.\n          // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n          if (_this5.state !== SessionState.Terminated) {\n            if (!_this5.dialog) {\n              throw new Error(\"Dialog undefined.\");\n            }\n\n            var extraHeadersBye = [];\n            extraHeadersBye.push(\"Reason: \" + _this5.getReasonHeaderValue(500, \"Internal Server Error\"));\n\n            _this5.dialog.bye(undefined, {\n              extraHeaders: extraHeaders\n            });\n\n            _this5.stateTransition(SessionState.Terminated);\n          }\n\n          if (_this5.delegate && _this5.delegate.onInvite) {\n            _this5.delegate.onInvite(request.message, outgoingResponse.message, 488);\n          }\n        });\n      });\n    }\n    /**\n     * Handle in dialog MESSAGE request.\n     * @internal\n     */\n\n  }, {\n    key: \"onMessageRequest\",\n    value: function onMessageRequest(request) {\n      this.logger.log(\"Session.onMessageRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"MESSAGE received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      }\n\n      if (this.delegate && this.delegate.onMessage) {\n        var message = new Message(request);\n        this.delegate.onMessage(message);\n      } else {\n        request.accept();\n      }\n    }\n    /**\n     * Handle in dialog NOTIFY request.\n     * @internal\n     */\n\n  }, {\n    key: \"onNotifyRequest\",\n    value: function onNotifyRequest(request) {\n      this.logger.log(\"Session.onNotifyRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"NOTIFY received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      } // If this a NOTIFY associated with the progress of a REFER,\n      // look to delegate handling to the associated callback.\n\n\n      if (this.onNotify) {\n        var notification = new Notification(request);\n        this.onNotify(notification);\n        return;\n      } // Otherwise accept the NOTIFY.\n\n\n      if (this.delegate && this.delegate.onNotify) {\n        var _notification = new Notification(request);\n\n        this.delegate.onNotify(_notification);\n      } else {\n        request.accept();\n      }\n    }\n    /**\n     * Handle in dialog PRACK request.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onPrackRequest\",\n    value: function onPrackRequest(request) {\n      this.logger.log(\"Session.onPrackRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"PRACK received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      }\n\n      throw new Error(\"Unimplemented.\");\n    }\n    /**\n     * Handle in dialog REFER request.\n     * @internal\n     */\n\n  }, {\n    key: \"onReferRequest\",\n    value: function onReferRequest(request) {\n      var _this6 = this;\n\n      this.logger.log(\"Session.onReferRequest\");\n\n      if (this.state !== SessionState.Established) {\n        this.logger.error(\"REFER received while in state \".concat(this.state, \", dropping request\"));\n        return;\n      } // REFER is a SIP request and is constructed as defined in [1].  A REFER\n      // request MUST contain exactly one Refer-To header field value.\n      // https://tools.ietf.org/html/rfc3515#section-2.4.1\n\n\n      if (!request.message.hasHeader(\"refer-to\")) {\n        this.logger.warn(\"Invalid REFER packet. A refer-to header is required. Rejecting.\");\n        request.reject();\n        return;\n      }\n\n      var referral = new Referral(request, this);\n\n      if (this.delegate && this.delegate.onRefer) {\n        this.delegate.onRefer(referral);\n      } else {\n        this.logger.log(\"No delegate available to handle REFER, automatically accepting and following.\");\n        referral.accept().then(function () {\n          return referral.makeInviter(_this6._referralInviterOptions).invite();\n        }).catch(function (error) {\n          // FIXME: logging and eating error...\n          _this6.logger.error(error.message);\n        });\n      }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request.\n     * If a remote offer was provided in the request, set the remote\n     * description and get a local answer. If a remote offer was not\n     * provided, generates a local offer.\n     * @internal\n     */\n\n  }, {\n    key: \"generateResponseOfferAnswer\",\n    value: function generateResponseOfferAnswer(request, options) {\n      if (this.dialog) {\n        return this.generateResponseOfferAnswerInDialog(options);\n      }\n\n      var body = getBody(request.message);\n\n      if (!body || body.contentDisposition !== \"session\") {\n        return this.getOffer(options);\n      } else {\n        return this.setOfferAndGetAnswer(body, options);\n      }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request\n     * when a dialog (early or otherwise) has already been established.\n     * This method may NOT be called if a dialog has yet to be established.\n     * @internal\n     */\n\n  }, {\n    key: \"generateResponseOfferAnswerInDialog\",\n    value: function generateResponseOfferAnswerInDialog(options) {\n      if (!this.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      switch (this.dialog.signalingState) {\n        case SignalingState.Initial:\n          return this.getOffer(options);\n\n        case SignalingState.HaveLocalOffer:\n          // o  Once the UAS has sent or received an answer to the initial\n          // offer, it MUST NOT generate subsequent offers in any responses\n          // to the initial INVITE.  This means that a UAS based on this\n          // specification alone can never generate subsequent offers until\n          // completion of the initial transaction.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          return Promise.resolve(undefined);\n\n        case SignalingState.HaveRemoteOffer:\n          if (!this.dialog.offer) {\n            throw new Error(\"Session offer undefined in signaling state \".concat(this.dialog.signalingState, \".\"));\n          }\n\n          return this.setOfferAndGetAnswer(this.dialog.offer, options);\n\n        case SignalingState.Stable:\n          // o  Once the UAS has sent or received an answer to the initial\n          // offer, it MUST NOT generate subsequent offers in any responses\n          // to the initial INVITE.  This means that a UAS based on this\n          // specification alone can never generate subsequent offers until\n          // completion of the initial transaction.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          if (this.state !== SessionState.Established) {\n            return Promise.resolve(undefined);\n          } // In dialog INVITE without offer, get an offer for the response.\n\n\n          return this.getOffer(options);\n\n        case SignalingState.Closed:\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n\n        default:\n          throw new Error(\"Invalid signaling state \".concat(this.dialog.signalingState, \".\"));\n      }\n    }\n    /**\n     * Get local offer.\n     * @internal\n     */\n\n  }, {\n    key: \"getOffer\",\n    value: function getOffer(options) {\n      var _this7 = this;\n\n      var sdh = this.setupSessionDescriptionHandler();\n      var sdhOptions = options.sessionDescriptionHandlerOptions;\n      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n      try {\n        return sdh.getDescription(sdhOptions, sdhModifiers).then(function (bodyAndContentType) {\n          return fromBodyLegacy(bodyAndContentType);\n        }).catch(function (error) {\n          // don't trust SDH to reject with Error\n          _this7.logger.error(\"Session.getOffer: SDH getDescription rejected...\");\n\n          var e = error instanceof Error ? error : new Error(\"Session.getOffer unknown error.\");\n\n          _this7.logger.error(e.message);\n\n          throw e;\n        });\n      } catch (error) {\n        // don't trust SDH to throw an Error\n        this.logger.error(\"Session.getOffer: SDH getDescription threw...\");\n        var e = error instanceof Error ? error : new Error(error);\n        this.logger.error(e.message);\n        return Promise.reject(e);\n      }\n    }\n    /**\n     * Rollback local/remote offer.\n     * @internal\n     */\n\n  }, {\n    key: \"rollbackOffer\",\n    value: function rollbackOffer() {\n      var _this8 = this;\n\n      var sdh = this.setupSessionDescriptionHandler();\n\n      if (sdh.rollbackDescription === undefined) {\n        return Promise.resolve();\n      } // This is intentionally written very defensively. Don't trust SDH to behave.\n\n\n      try {\n        return sdh.rollbackDescription().catch(function (error) {\n          // don't trust SDH to reject with Error\n          _this8.logger.error(\"Session.rollbackOffer: SDH rollbackDescription rejected...\");\n\n          var e = error instanceof Error ? error : new Error(\"Session.rollbackOffer unknown error.\");\n\n          _this8.logger.error(e.message);\n\n          throw e;\n        });\n      } catch (error) {\n        // don't trust SDH to throw an Error\n        this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription threw...\");\n        var e = error instanceof Error ? error : new Error(error);\n        this.logger.error(e.message);\n        return Promise.reject(e);\n      }\n    }\n    /**\n     * Set remote answer.\n     * @internal\n     */\n\n  }, {\n    key: \"setAnswer\",\n    value: function setAnswer(answer, options) {\n      var _this9 = this;\n\n      var sdh = this.setupSessionDescriptionHandler();\n      var sdhOptions = options.sessionDescriptionHandlerOptions;\n      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n      try {\n        if (!sdh.hasDescription(answer.contentType)) {\n          return Promise.reject(new ContentTypeUnsupportedError());\n        }\n      } catch (error) {\n        this.logger.error(\"Session.setAnswer: SDH hasDescription threw...\");\n        var e = error instanceof Error ? error : new Error(error);\n        this.logger.error(e.message);\n        return Promise.reject(e);\n      }\n\n      try {\n        return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch(function (error) {\n          // don't trust SDH to reject with Error\n          _this9.logger.error(\"Session.setAnswer: SDH setDescription rejected...\");\n\n          var e = error instanceof Error ? error : new Error(\"Session.setAnswer unknown error.\");\n\n          _this9.logger.error(e.message);\n\n          throw e;\n        });\n      } catch (error) {\n        // don't trust SDH to throw an Error\n        this.logger.error(\"Session.setAnswer: SDH setDescription threw...\");\n\n        var _e = error instanceof Error ? error : new Error(error);\n\n        this.logger.error(_e.message);\n        return Promise.reject(_e);\n      }\n    }\n    /**\n     * Set remote offer and get local answer.\n     * @internal\n     */\n\n  }, {\n    key: \"setOfferAndGetAnswer\",\n    value: function setOfferAndGetAnswer(offer, options) {\n      var _this10 = this;\n\n      var sdh = this.setupSessionDescriptionHandler();\n      var sdhOptions = options.sessionDescriptionHandlerOptions;\n      var sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n      try {\n        if (!sdh.hasDescription(offer.contentType)) {\n          return Promise.reject(new ContentTypeUnsupportedError());\n        }\n      } catch (error) {\n        this.logger.error(\"Session.setOfferAndGetAnswer: SDH hasDescription threw...\");\n        var e = error instanceof Error ? error : new Error(error);\n        this.logger.error(e.message);\n        return Promise.reject(e);\n      }\n\n      try {\n        return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(function () {\n          return sdh.getDescription(sdhOptions, sdhModifiers);\n        }).then(function (bodyAndContentType) {\n          return fromBodyLegacy(bodyAndContentType);\n        }).catch(function (error) {\n          // don't trust SDH to reject with Error\n          _this10.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...\");\n\n          var e = error instanceof Error ? error : new Error(\"Session.setOfferAndGetAnswer unknown error.\");\n\n          _this10.logger.error(e.message);\n\n          throw e;\n        });\n      } catch (error) {\n        // don't trust SDH to throw an Error\n        this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...\");\n\n        var _e2 = error instanceof Error ? error : new Error(error);\n\n        this.logger.error(_e2.message);\n        return Promise.reject(_e2);\n      }\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n\n  }, {\n    key: \"setSessionDescriptionHandler\",\n    value: function setSessionDescriptionHandler(sdh) {\n      if (this._sessionDescriptionHandler) {\n        throw new Error(\"Session description handler defined.\");\n      }\n\n      this._sessionDescriptionHandler = sdh;\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n\n  }, {\n    key: \"setupSessionDescriptionHandler\",\n    value: function setupSessionDescriptionHandler() {\n      var _a;\n\n      if (this._sessionDescriptionHandler) {\n        return this._sessionDescriptionHandler;\n      }\n\n      this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);\n\n      if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n        this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);\n      }\n\n      return this._sessionDescriptionHandler;\n    }\n    /**\n     * Transition session state.\n     * @internal\n     */\n\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState) {\n      var _this11 = this;\n\n      var invalidTransition = function invalidTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this11._state, \" to \").concat(newState));\n      }; // Validate transition\n\n\n      switch (this._state) {\n        case SessionState.Initial:\n          if (newState !== SessionState.Establishing && newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case SessionState.Establishing:\n          if (newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case SessionState.Established:\n          if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case SessionState.Terminating:\n          if (newState !== SessionState.Terminated) {\n            invalidTransition();\n          }\n\n          break;\n\n        case SessionState.Terminated:\n          invalidTransition();\n          break;\n\n        default:\n          throw new Error(\"Unrecognized state.\");\n      } // Transition\n\n\n      this._state = newState;\n      this.logger.log(\"Session \".concat(this.id, \" transitioned to state \").concat(this._state));\n\n      this._stateEventEmitter.emit(this._state); // Dispose\n\n\n      if (newState === SessionState.Terminated) {\n        this.dispose();\n      }\n    }\n  }, {\n    key: \"copyRequestOptions\",\n    value: function copyRequestOptions() {\n      var requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;\n      var body = requestOptions.body ? {\n        contentDisposition: requestOptions.body.contentDisposition || \"render\",\n        contentType: requestOptions.body.contentType || \"text/plain\",\n        content: requestOptions.body.content || \"\"\n      } : undefined;\n      return {\n        extraHeaders: extraHeaders,\n        body: body\n      };\n    }\n  }, {\n    key: \"getReasonHeaderValue\",\n    value: function getReasonHeaderValue(code, reason) {\n      var cause = code;\n      var text = getReasonPhrase(code);\n\n      if (!text && reason) {\n        text = reason;\n      }\n\n      return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n    }\n  }, {\n    key: \"referExtraHeaders\",\n    value: function referExtraHeaders(referTo) {\n      var extraHeaders = [];\n      extraHeaders.push(\"Referred-By: <\" + this.userAgent.configuration.uri + \">\");\n      extraHeaders.push(\"Contact: \" + this._contact);\n      extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n      extraHeaders.push(\"Refer-To: \" + referTo);\n      return extraHeaders;\n    }\n  }, {\n    key: \"referToString\",\n    value: function referToString(target) {\n      var referTo;\n\n      if (target instanceof URI) {\n        // REFER without Replaces (Blind Transfer)\n        referTo = target.toString();\n      } else {\n        // REFER with Replaces (Attended Transfer)\n        if (!target.dialog) {\n          throw new Error(\"Dialog undefined.\");\n        }\n\n        var displayName = target.remoteIdentity.friendlyName;\n        var remoteTarget = target.dialog.remoteTarget.toString();\n        var callId = target.dialog.callId;\n        var remoteTag = target.dialog.remoteTag;\n        var localTag = target.dialog.localTag;\n        var replaces = encodeURIComponent(\"\".concat(callId, \";to-tag=\").concat(remoteTag, \";from-tag=\").concat(localTag));\n        referTo = \"\\\"\".concat(displayName, \"\\\" <\").concat(remoteTarget, \"?Replaces=\").concat(replaces, \">\");\n      }\n\n      return referTo;\n    }\n  }, {\n    key: \"assertedIdentity\",\n    get: function get() {\n      return this._assertedIdentity;\n    }\n    /**\n     * The confirmed session dialog.\n     */\n\n  }, {\n    key: \"dialog\",\n    get: function get() {\n      return this._dialog;\n    }\n    /**\n     * A unique identifier for this session.\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * The session being replace by this one.\n     */\n\n  }, {\n    key: \"replacee\",\n    get: function get() {\n      return this._replacee;\n    }\n    /**\n     * Session description handler.\n     * @remarks\n     * If `this` is an instance of `Invitation`,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"establishing\".\n     * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * Otherwise `undefined`.\n     */\n\n  }, {\n    key: \"sessionDescriptionHandler\",\n    get: function get() {\n      return this._sessionDescriptionHandler;\n    }\n    /**\n     * Session description handler factory.\n     */\n\n  }, {\n    key: \"sessionDescriptionHandlerFactory\",\n    get: function get() {\n      return this.userAgent.configuration.sessionDescriptionHandlerFactory;\n    }\n    /**\n     * SDH modifiers for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n\n  }, {\n    key: \"sessionDescriptionHandlerModifiers\",\n    get: function get() {\n      return this._sessionDescriptionHandlerModifiers || [];\n    },\n    set: function set(modifiers) {\n      this._sessionDescriptionHandlerModifiers = modifiers.slice();\n    }\n    /**\n     * SDH options for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n\n  }, {\n    key: \"sessionDescriptionHandlerOptions\",\n    get: function get() {\n      return this._sessionDescriptionHandlerOptions || {};\n    },\n    set: function set(options) {\n      this._sessionDescriptionHandlerOptions = Object.assign({}, options);\n    }\n    /**\n     * SDH modifiers for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n\n  }, {\n    key: \"sessionDescriptionHandlerModifiersReInvite\",\n    get: function get() {\n      return this._sessionDescriptionHandlerModifiersReInvite || [];\n    },\n    set: function set(modifiers) {\n      this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();\n    }\n    /**\n     * SDH options for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n\n  }, {\n    key: \"sessionDescriptionHandlerOptionsReInvite\",\n    get: function get() {\n      return this._sessionDescriptionHandlerOptionsReInvite || {};\n    },\n    set: function set(options) {\n      this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);\n    }\n    /**\n     * Session state.\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n    /**\n     * Session state change emitter.\n     */\n\n  }, {\n    key: \"stateChange\",\n    get: function get() {\n      return this._stateEventEmitter;\n    }\n    /**\n     * The user agent.\n     */\n\n  }, {\n    key: \"userAgent\",\n    get: function get() {\n      return this._userAgent;\n    }\n  }]);\n\n  return Session;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/session.js"],"names":["fromBodyLegacy","getBody","Grammar","SessionState","SessionDialogState","SignalingState","URI","getReasonPhrase","AllowedMethods","Bye","EmitterImpl","ContentTypeUnsupportedError","RequestPendingError","Info","Message","Notification","Referral","Session","userAgent","options","pendingReinvite","pendingReinviteAck","_state","Initial","delegate","_stateEventEmitter","_userAgent","logger","log","id","_sessions","_sessionDescriptionHandler","close","state","Establishing","Established","Promise","resolve","_bye","onAccept","onRedirect","onReject","Terminating","Terminated","Error","message","cancel","reject","requestDelegate","requestOptions","copyRequestOptions","error","_info","sessionDescriptionHandlerModifiers","sessionDescriptionHandlerModifiersReInvite","sessionDescriptionHandlerOptions","sessionDescriptionHandlerOptionsReInvite","response","body","ackAndBye","stateTransition","withoutSdp","answerOptions","setOfferAndGetAnswer","then","answerBody","ack","catch","setAnswer","onProgress","warn","rollbackOffer","dialog","extraHeaders","push","getReasonHeaderValue","bye","undefined","onTrying","slice","toString","_contact","invite","offerOptions","getOffer","offerBody","_message","referTo","concat","referExtraHeaders","referToString","_refer","onNotify","sessionState","Early","AckWait","onAck","request","onAckTimeout","Confirmed","info","refer","statusCode","reasonPhrase","session","_sessionDescriptionHandlerModifiersReInvite","_sessionDescriptionHandlerModifiers","signalingState","Stable","contentDisposition","_renderbody","content","_rendertype","contentType","HaveLocalOffer","HaveRemoteOffer","Closed","onBye","accept","onInfo","hasHeader","header","getHeader","_assertedIdentity","nameAddrHeaderParse","generateResponseOfferAnswerInDialog","outgoingResponse","onInvite","errorRollback","extraHeadersBye","onMessage","notification","referral","onRefer","makeInviter","_referralInviterOptions","offer","sdh","setupSessionDescriptionHandler","sdhOptions","sdhModifiers","getDescription","bodyAndContentType","e","rollbackDescription","answer","hasDescription","setDescription","_a","sessionDescriptionHandlerFactory","configuration","sessionDescriptionHandlerFactoryOptions","onSessionDescriptionHandler","newState","invalidTransition","emit","dispose","code","reason","cause","text","uri","target","displayName","remoteIdentity","friendlyName","remoteTarget","callId","remoteTag","localTag","replaces","encodeURIComponent","_dialog","_id","_replacee","modifiers","_sessionDescriptionHandlerOptions","Object","assign","_sessionDescriptionHandlerOptionsReInvite"],"mappings":";;AAAA,SAASA,cAAT,EAAyBC,OAAzB,EAAkCC,OAAlC,EAA2CC,YAAY,IAAIC,kBAA3D,EAA+EC,cAA/E,EAA+FC,GAA/F,QAA0G,SAA1G;AACA,SAASC,eAAT,QAAgC,wBAAhC;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,GAAT,QAAoB,OAApB;AACA,SAASC,WAAT,QAA4B,WAA5B;AACA,SAASC,2BAAT,EAAsCC,mBAAtC,QAAiE,cAAjE;AACA,SAASC,IAAT,QAAqB,QAArB;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA,SAASb,YAAT,QAA6B,iBAA7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAac,OAAb;AACI;AACJ;AACA;AACA;AACA;AACI,mBAAYC,SAAZ,EAAqC;AAAA,QAAdC,OAAc,uEAAJ,EAAI;;AAAA;;AACjC;AACA,SAAKC,eAAL,GAAuB,KAAvB;AACA;;AACA,SAAKC,kBAAL,GAA0B,KAA1B;AACA;;AACA,SAAKC,MAAL,GAAcnB,YAAY,CAACoB,OAA3B;AACA,SAAKC,QAAL,GAAgBL,OAAO,CAACK,QAAxB;AACA,SAAKC,kBAAL,GAA0B,IAAIf,WAAJ,EAA1B;AACA,SAAKgB,UAAL,GAAkBR,SAAlB;AACH;AACD;AACJ;AACA;;;AAnBA;AAAA;AAAA,8BAoBc;AAAA;;AACN,WAAKS,MAAL,CAAYC,GAAZ,mBAA2B,KAAKC,EAAhC,uBAA+C,KAAKP,MAApD,yBADM,CAEN;;AACA,aAAO,KAAKJ,SAAL,CAAeY,SAAf,CAAyB,KAAKD,EAA9B,CAAP,CAHM,CAIN;;AACA,UAAI,KAAKE,0BAAT,EAAqC;AACjC,aAAKA,0BAAL,CAAgCC,KAAhC,GADiC,CAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACH;;AACD,cAAQ,KAAKC,KAAb;AACI,aAAK9B,YAAY,CAACoB,OAAlB;AACI;AAAO;;AACX,aAAKpB,YAAY,CAAC+B,YAAlB;AACI;AAAO;;AACX,aAAK/B,YAAY,CAACgC,WAAlB;AACI,iBAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC5B,YAAA,KAAI,CAACC,IAAL,CAAU;AACN;AACAC,cAAAA,QAAQ,EAAE;AAAA,uBAAMF,OAAO,EAAb;AAAA,eAFJ;AAGNG,cAAAA,UAAU,EAAE;AAAA,uBAAMH,OAAO,EAAb;AAAA,eAHN;AAINI,cAAAA,QAAQ,EAAE;AAAA,uBAAMJ,OAAO,EAAb;AAAA;AAJJ,aAAV;AAMH,WAPM,CAAP;;AAQJ,aAAKlC,YAAY,CAACuC,WAAlB;AACI;AAAO;;AACX,aAAKvC,YAAY,CAACwC,UAAlB;AACI;AAAO;;AACX;AACI,gBAAM,IAAIC,KAAJ,CAAU,gBAAV,CAAN;AAnBR;;AAqBA,aAAOR,OAAO,CAACC,OAAR,EAAP;AACH;AACD;AACJ;AACA;;AAlEA;AAAA;;AAsLI;AACJ;AACA;AACA;AAzLA,0BA0LsB;AAAA,UAAdlB,OAAc,uEAAJ,EAAI;AACd,UAAI0B,OAAO,GAAG,0DAAd;;AACA,cAAQ,KAAKZ,KAAb;AACI,aAAK9B,YAAY,CAACoB,OAAlB;AACI;AACA,cAAI,OAAO,KAAKuB,MAAZ,KAAuB,UAA3B,EAAuC;AACnCD,YAAAA,OAAO,IAAI,oDAAX;AACAA,YAAAA,OAAO,IAAI,mDAAX,CAFmC,CAGnC;AACH,WAJD,MAKK,IAAI,OAAO,KAAKE,MAAZ,KAAuB,UAA3B,EAAuC;AACxCF,YAAAA,OAAO,IAAI,uDAAX;AACAA,YAAAA,OAAO,IAAI,sDAAX;AACH;;AACD;;AACJ,aAAK1C,YAAY,CAAC+B,YAAlB;AACI;AACA,cAAI,OAAO,KAAKY,MAAZ,KAAuB,UAA3B,EAAuC;AACnCD,YAAAA,OAAO,IAAI,uCAAX;AACAA,YAAAA,OAAO,IAAI,mDAAX,CAFmC,CAGnC;AACH,WAJD,MAKK,IAAI,OAAO,KAAKE,MAAZ,KAAuB,UAA3B,EAAuC;AACxCF,YAAAA,OAAO,IAAI,6EAAX;AACAA,YAAAA,OAAO,IAAI,sDAAX;AACH;;AACD;;AACJ,aAAK1C,YAAY,CAACgC,WAAlB;AAA+B;AAC3B,gBAAMa,eAAe,GAAG7B,OAAO,CAAC6B,eAAhC;AACA,gBAAMC,cAAc,GAAG,KAAKC,kBAAL,CAAwB/B,OAAO,CAAC8B,cAAhC,CAAvB;AACA,mBAAO,KAAKX,IAAL,CAAUU,eAAV,EAA2BC,cAA3B,CAAP;AACH;;AACD,aAAK9C,YAAY,CAACuC,WAAlB;AACIG,UAAAA,OAAO,IAAI,+CAAX,CADJ,CAEI;;AACA,cAAI,OAAO,KAAKC,MAAZ,KAAuB,UAA3B,EAAuC;AACnCD,YAAAA,OAAO,IAAI,oDAAX,CADmC,CAEnC;AACH,WAHD,MAIK,IAAI,OAAO,KAAKE,MAAZ,KAAuB,UAA3B,EAAuC;AACxCF,YAAAA,OAAO,IAAI,iDAAX;AACH;;AACD;;AACJ,aAAK1C,YAAY,CAACwC,UAAlB;AACIE,UAAAA,OAAO,IAAI,8CAAX;AACA;;AACJ;AACI,gBAAM,IAAID,KAAJ,CAAU,eAAV,CAAN;AA7CR;;AA+CA,WAAKjB,MAAL,CAAYwB,KAAZ,CAAkBN,OAAlB;AACA,aAAOT,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,iCAAmC,KAAKX,KAAxC,EAAf,CAAP;AACH;AACD;AACJ;AACA;AACA;;AAjPA;AAAA;AAAA,2BAkPuB;AAAA,UAAdd,OAAc,uEAAJ,EAAI;;AACf;AACA,UAAI,KAAKc,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,YAAMU,OAAO,GAAG,2DAAhB;AACA,aAAKlB,MAAL,CAAYwB,KAAZ,CAAkBN,OAAlB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,iCAAmC,KAAKX,KAAxC,EAAf,CAAP;AACH;;AACD,UAAMe,eAAe,GAAG7B,OAAO,CAAC6B,eAAhC;AACA,UAAMC,cAAc,GAAG,KAAKC,kBAAL,CAAwB/B,OAAO,CAAC8B,cAAhC,CAAvB;AACA,aAAO,KAAKG,KAAL,CAAWJ,eAAX,EAA4BC,cAA5B,CAAP;AACH;AACD;AACJ;AACA;AACA;;AAhQA;AAAA;AAAA,6BAiQyB;AAAA;;AAAA,UAAd9B,OAAc,uEAAJ,EAAI;AACjB,WAAKQ,MAAL,CAAYC,GAAZ,CAAgB,gBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,eAAOC,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,iCAAmC,KAAKX,KAAxC,EAAf,CAAP;AACH;;AACD,UAAI,KAAKb,eAAT,EAA0B;AACtB,eAAOgB,OAAO,CAACW,MAAR,CAAe,IAAInC,mBAAJ,CAAwB,mEAAxB,CAAf,CAAP;AACH;;AACD,WAAKQ,eAAL,GAAuB,IAAvB,CARiB,CASjB;;AACA,UAAID,OAAO,CAACkC,kCAAZ,EAAgD;AAC5C,aAAKC,0CAAL,GAAkDnC,OAAO,CAACkC,kCAA1D;AACH;;AACD,UAAIlC,OAAO,CAACoC,gCAAZ,EAA8C;AAC1C,aAAKC,wCAAL,GAAgDrC,OAAO,CAACoC,gCAAxD;AACH;;AACD,UAAM/B,QAAQ,GAAG;AACbe,QAAAA,QAAQ,EAAE,kBAACkB,QAAD,EAAc;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAMC,IAAI,GAAGzD,OAAO,CAACwD,QAAQ,CAACZ,OAAV,CAApB;;AACA,cAAI,CAACa,IAAL,EAAW;AACP;AACA,YAAA,MAAI,CAAC/B,MAAL,CAAYwB,KAAZ,CAAkB,kEAAlB;;AACA,YAAA,MAAI,CAACQ,SAAL,CAAeF,QAAf,EAAyB,GAAzB,EAA8B,6BAA9B;;AACA,YAAA,MAAI,CAACG,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;;AACA,YAAA,MAAI,CAACvB,eAAL,GAAuB,KAAvB;AACA;AACH;;AACD,cAAID,OAAO,CAAC0C,UAAZ,EAAwB;AACpB;AACA,gBAAMC,aAAa,GAAG;AAClBP,cAAAA,gCAAgC,EAAE,MAAI,CAACC,wCADrB;AAElBH,cAAAA,kCAAkC,EAAE,MAAI,CAACC;AAFvB,aAAtB;;AAIA,YAAA,MAAI,CAACS,oBAAL,CAA0BL,IAA1B,EAAgCI,aAAhC,EACKE,IADL,CACU,UAACC,UAAD,EAAgB;AACtBR,cAAAA,QAAQ,CAACS,GAAT,CAAa;AAAER,gBAAAA,IAAI,EAAEO;AAAR,eAAb;AACH,aAHD,EAIKE,KAJL,CAIW,UAAChB,KAAD,EAAW;AAClB;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,qDAAlB;;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB;;AACA,kBAAI,MAAI,CAACZ,KAAL,KAAe9B,YAAY,CAACwC,UAAhC,EAA4C;AACxC;AACA;AACAc,gBAAAA,QAAQ,CAACS,GAAT;AACH,eAJD,MAKK;AACD,gBAAA,MAAI,CAACP,SAAL,CAAeF,QAAf,EAAyB,GAAzB,EAA8B,uBAA9B;;AACA,gBAAA,MAAI,CAACG,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH;AACJ,aAjBD,EAkBKqB,IAlBL,CAkBU,YAAM;AACZ,cAAA,MAAI,CAAC5C,eAAL,GAAuB,KAAvB;;AACA,kBAAID,OAAO,CAAC6B,eAAR,IAA2B7B,OAAO,CAAC6B,eAAR,CAAwBT,QAAvD,EAAiE;AAC7DpB,gBAAAA,OAAO,CAAC6B,eAAR,CAAwBT,QAAxB,CAAiCkB,QAAjC;AACH;AACJ,aAvBD;AAwBH,WA9BD,MA+BK;AACD;AACA,gBAAMK,cAAa,GAAG;AAClBP,cAAAA,gCAAgC,EAAE,MAAI,CAACC,wCADrB;AAElBH,cAAAA,kCAAkC,EAAE,MAAI,CAACC;AAFvB,aAAtB;;AAIA,YAAA,MAAI,CAACc,SAAL,CAAeV,IAAf,EAAqBI,cAArB,EACKE,IADL,CACU,YAAM;AACZP,cAAAA,QAAQ,CAACS,GAAT;AACH,aAHD,EAIKC,KAJL,CAIW,UAAChB,KAAD,EAAW;AAClB;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,sDAAlB;;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB,EAHkB,CAIlB;AACA;AACA;;;AACA,kBAAI,MAAI,CAACZ,KAAL,KAAe9B,YAAY,CAACwC,UAAhC,EAA4C;AACxC,gBAAA,MAAI,CAACgB,SAAL,CAAeF,QAAf,EAAyB,GAAzB,EAA8B,uBAA9B;;AACA,gBAAA,MAAI,CAACG,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH,eAHD,MAIK;AACDc,gBAAAA,QAAQ,CAACS,GAAT;AACH;AACJ,aAlBD,EAmBKF,IAnBL,CAmBU,YAAM;AACZ,cAAA,MAAI,CAAC5C,eAAL,GAAuB,KAAvB;;AACA,kBAAID,OAAO,CAAC6B,eAAR,IAA2B7B,OAAO,CAAC6B,eAAR,CAAwBT,QAAvD,EAAiE;AAC7DpB,gBAAAA,OAAO,CAAC6B,eAAR,CAAwBT,QAAxB,CAAiCkB,QAAjC;AACH;AACJ,aAxBD;AAyBH;AACJ,SAnFY;AAoFb;AACAY,QAAAA,UAAU,EAAE,oBAACZ,QAAD,EAAc;AACtB;AACH,SAvFY;AAwFb;AACAjB,QAAAA,UAAU,EAAE,oBAACiB,QAAD,EAAc;AACtB;AACH,SA3FY;AA4FbhB,QAAAA,QAAQ,EAAE,kBAACgB,QAAD,EAAc;AACpB,UAAA,MAAI,CAAC9B,MAAL,CAAY2C,IAAZ,CAAiB,0CAAjB;;AACA,UAAA,MAAI,CAAClD,eAAL,GAAuB,KAAvB;;AACA,cAAID,OAAO,CAAC0C,UAAZ,EAAwB;AACpB,gBAAI1C,OAAO,CAAC6B,eAAR,IAA2B7B,OAAO,CAAC6B,eAAR,CAAwBP,QAAvD,EAAiE;AAC7DtB,cAAAA,OAAO,CAAC6B,eAAR,CAAwBP,QAAxB,CAAiCgB,QAAjC;AACH;AACJ,WAJD,MAKK;AACD,YAAA,MAAI,CAACc,aAAL,GACKJ,KADL,CACW,UAAChB,KAAD,EAAW;AAClB;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,2DAAlB;;AACA,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB,EAHkB,CAIlB;AACA;AACA;;;AACA,kBAAI,MAAI,CAACZ,KAAL,KAAe9B,YAAY,CAACwC,UAAhC,EAA4C;AACxC,oBAAI,CAAC,MAAI,CAAC6B,MAAV,EAAkB;AACd,wBAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,oBAAM6B,YAAY,GAAG,EAArB;AACAA,gBAAAA,YAAY,CAACC,IAAb,CAAkB,aAAa,MAAI,CAACC,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAA/B;;AACA,gBAAA,MAAI,CAACH,MAAL,CAAYI,GAAZ,CAAgBC,SAAhB,EAA2B;AAAEJ,kBAAAA,YAAY,EAAZA;AAAF,iBAA3B;;AACA,gBAAA,MAAI,CAACb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH;AACJ,aAjBD,EAkBKqB,IAlBL,CAkBU,YAAM;AACZ,kBAAI7C,OAAO,CAAC6B,eAAR,IAA2B7B,OAAO,CAAC6B,eAAR,CAAwBP,QAAvD,EAAiE;AAC7DtB,gBAAAA,OAAO,CAAC6B,eAAR,CAAwBP,QAAxB,CAAiCgB,QAAjC;AACH;AACJ,aAtBD;AAuBH;AACJ,SA7HY;AA8Hb;AACAqB,QAAAA,QAAQ,EAAE,kBAACrB,QAAD,EAAc;AACpB;AACH;AAjIY,OAAjB;AAmIA,UAAMR,cAAc,GAAG9B,OAAO,CAAC8B,cAAR,IAA0B,EAAjD;AACAA,MAAAA,cAAc,CAACwB,YAAf,GAA8B,CAACxB,cAAc,CAACwB,YAAf,IAA+B,EAAhC,EAAoCM,KAApC,EAA9B;AACA9B,MAAAA,cAAc,CAACwB,YAAf,CAA4BC,IAA5B,CAAiC,YAAYlE,cAAc,CAACwE,QAAf,EAA7C;AACA/B,MAAAA,cAAc,CAACwB,YAAf,CAA4BC,IAA5B,CAAiC,cAAc,KAAKO,QAApD,EAtJiB,CAuJjB;;AACA,UAAI9D,OAAO,CAAC0C,UAAZ,EAAwB;AACpB,YAAI,CAAC,KAAKW,MAAV,EAAkB;AACd,eAAKpD,eAAL,GAAuB,KAAvB;AACA,gBAAM,IAAIwB,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,eAAOR,OAAO,CAACC,OAAR,CAAgB,KAAKmC,MAAL,CAAYU,MAAZ,CAAmB1D,QAAnB,EAA6ByB,cAA7B,CAAhB,CAAP;AACH,OA9JgB,CA+JjB;;;AACA,UAAMkC,YAAY,GAAG;AACjB5B,QAAAA,gCAAgC,EAAE,KAAKC,wCADtB;AAEjBH,QAAAA,kCAAkC,EAAE,KAAKC;AAFxB,OAArB;AAIA,aAAO,KAAK8B,QAAL,CAAcD,YAAd,EACFnB,IADE,CACG,UAACqB,SAAD,EAAe;AACrB,YAAI,CAAC,MAAI,CAACb,MAAV,EAAkB;AACd,UAAA,MAAI,CAACpD,eAAL,GAAuB,KAAvB;AACA,gBAAM,IAAIwB,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACDK,QAAAA,cAAc,CAACS,IAAf,GAAsB2B,SAAtB;AACA,eAAO,MAAI,CAACb,MAAL,CAAYU,MAAZ,CAAmB1D,QAAnB,EAA6ByB,cAA7B,CAAP;AACH,OARM,EASFkB,KATE,CASI,UAAChB,KAAD,EAAW;AAClB,QAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB;;AACA,QAAA,MAAI,CAAClB,MAAL,CAAYwB,KAAZ,CAAkB,0BAAlB;;AACA,QAAA,MAAI,CAAC/B,eAAL,GAAuB,KAAvB;AACA,cAAM+B,KAAN;AACH,OAdM,CAAP;AAeH;AACD;AACJ;AACA;AACA;;AAxbA;AAAA;AAAA,8BAyb0B;AAAA,UAAdhC,OAAc,uEAAJ,EAAI;;AAClB;AACA,UAAI,KAAKc,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,YAAMU,OAAO,GAAG,8DAAhB;AACA,aAAKlB,MAAL,CAAYwB,KAAZ,CAAkBN,OAAlB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,iCAAmC,KAAKX,KAAxC,EAAf,CAAP;AACH;;AACD,UAAMe,eAAe,GAAG7B,OAAO,CAAC6B,eAAhC;AACA,UAAMC,cAAc,GAAG,KAAKC,kBAAL,CAAwB/B,OAAO,CAAC8B,cAAhC,CAAvB;AACA,aAAO,KAAKqC,QAAL,CAActC,eAAd,EAA+BC,cAA/B,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;AAxcA;AAAA;AAAA,0BAycUsC,OAzcV,EAyciC;AAAA,UAAdpE,OAAc,uEAAJ,EAAI;;AACzB;AACA,UAAI,KAAKc,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,YAAMU,OAAO,GAAG,4DAAhB;AACA,aAAKlB,MAAL,CAAYwB,KAAZ,CAAkBN,OAAlB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,iCAAmC,KAAKX,KAAxC,EAAf,CAAP;AACH;;AACD,UAAMe,eAAe,GAAG7B,OAAO,CAAC6B,eAAhC;AACA,UAAMC,cAAc,GAAG,KAAKC,kBAAL,CAAwB/B,OAAO,CAAC8B,cAAhC,CAAvB;AACAA,MAAAA,cAAc,CAACwB,YAAf,GAA8BxB,cAAc,CAACwB,YAAf,GACxBxB,cAAc,CAACwB,YAAf,CAA4Be,MAA5B,CAAmC,KAAKC,iBAAL,CAAuB,KAAKC,aAAL,CAAmBH,OAAnB,CAAvB,CAAnC,CADwB,GAExB,KAAKE,iBAAL,CAAuB,KAAKC,aAAL,CAAmBH,OAAnB,CAAvB,CAFN;AAGA,aAAO,KAAKI,MAAL,CAAYxE,OAAO,CAACyE,QAApB,EAA8B5C,eAA9B,EAA+CC,cAA/C,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;AA5dA;AAAA;AAAA,yBA6dSzB,QA7dT,EA6dmBL,OA7dnB,EA6d4B;AAAA;;AACpB;AACA,UAAI,CAAC,KAAKqD,MAAV,EAAkB;AACd,eAAOpC,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,CAAU,2BAAV,CAAf,CAAP;AACH;;AACD,UAAM4B,MAAM,GAAG,KAAKA,MAApB,CALoB,CAMpB;AACA;AACA;AACA;AACA;AACA;;AACA,cAAQA,MAAM,CAACqB,YAAf;AACI,aAAKzF,kBAAkB,CAACmB,OAAxB;AACI,gBAAM,IAAIqB,KAAJ,gCAAkC4B,MAAM,CAACqB,YAAzC,EAAN;;AACJ,aAAKzF,kBAAkB,CAAC0F,KAAxB;AAA+B;AAC3B,gBAAM,IAAIlD,KAAJ,gCAAkC4B,MAAM,CAACqB,YAAzC,EAAN;;AACJ,aAAKzF,kBAAkB,CAAC2F,OAAxB;AAAiC;AAC7B;AACA,iBAAKnC,eAAL,CAAqBzD,YAAY,CAACuC,WAAlC,EAF6B,CAEmB;;AAChD,mBAAO,IAAIN,OAAJ,CAAY,UAACC,OAAD,EAAa;AAC5BmC,cAAAA,MAAM,CAAChD,QAAP,GAAkB;AACd;AACAwE,gBAAAA,KAAK,EAAE,iBAAM;AACT,sBAAMC,OAAO,GAAGzB,MAAM,CAACI,GAAP,CAAWpD,QAAX,EAAqBL,OAArB,CAAhB;;AACA,kBAAA,MAAI,CAACyC,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;;AACAN,kBAAAA,OAAO,CAAC4D,OAAD,CAAP;AACA,yBAAO7D,OAAO,CAACC,OAAR,EAAP;AACH,iBAPa;AAQd;AACA6D,gBAAAA,YAAY,EAAE,wBAAM;AAChB,sBAAMD,OAAO,GAAGzB,MAAM,CAACI,GAAP,CAAWpD,QAAX,EAAqBL,OAArB,CAAhB;;AACA,kBAAA,MAAI,CAACyC,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;;AACAN,kBAAAA,OAAO,CAAC4D,OAAD,CAAP;AACH;AAba,eAAlB;AAeH,aAhBM,CAAP;AAiBH;;AACD,aAAK7F,kBAAkB,CAAC+F,SAAxB;AAAmC;AAC/B,gBAAMF,OAAO,GAAGzB,MAAM,CAACI,GAAP,CAAWpD,QAAX,EAAqBL,OAArB,CAAhB;AACA,iBAAKyC,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACA,mBAAOP,OAAO,CAACC,OAAR,CAAgB4D,OAAhB,CAAP;AACH;;AACD,aAAK7F,kBAAkB,CAACuC,UAAxB;AACI,gBAAM,IAAIC,KAAJ,gCAAkC4B,MAAM,CAACqB,YAAzC,EAAN;;AACJ;AACI,gBAAM,IAAIjD,KAAJ,CAAU,qBAAV,CAAN;AAlCR;AAoCH;AACD;AACJ;AACA;AACA;AACA;AACA;;AAnhBA;AAAA;AAAA,0BAohBUpB,QAphBV,EAohBoBL,OAphBpB,EAohB6B;AACrB;AACA,UAAI,CAAC,KAAKqD,MAAV,EAAkB;AACd,eAAOpC,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,CAAU,2BAAV,CAAf,CAAP;AACH;;AACD,aAAOR,OAAO,CAACC,OAAR,CAAgB,KAAKmC,MAAL,CAAY4B,IAAZ,CAAiB5E,QAAjB,EAA2BL,OAA3B,CAAhB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;AAhiBA;AAAA;AAAA,6BAiiBaK,QAjiBb,EAiiBuBL,OAjiBvB,EAiiBgC;AACxB;AACA,UAAI,CAAC,KAAKqD,MAAV,EAAkB;AACd,eAAOpC,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,CAAU,2BAAV,CAAf,CAAP;AACH;;AACD,aAAOR,OAAO,CAACC,OAAR,CAAgB,KAAKmC,MAAL,CAAY3B,OAAZ,CAAoBrB,QAApB,EAA8BL,OAA9B,CAAhB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AA9iBA;AAAA;AAAA,2BA+iBWyE,QA/iBX,EA+iBqBpE,QA/iBrB,EA+iB+BL,OA/iB/B,EA+iBwC;AAChC;AACA,UAAI,CAAC,KAAKqD,MAAV,EAAkB;AACd,eAAOpC,OAAO,CAACW,MAAR,CAAe,IAAIH,KAAJ,CAAU,2BAAV,CAAf,CAAP;AACH,OAJ+B,CAKhC;;;AACA,WAAKgD,QAAL,GAAgBA,QAAhB;AACA,aAAOxD,OAAO,CAACC,OAAR,CAAgB,KAAKmC,MAAL,CAAY6B,KAAZ,CAAkB7E,QAAlB,EAA4BL,OAA5B,CAAhB,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnkBA;AAAA;AAAA,8BAokBcsC,QApkBd,EAokBwB6C,UApkBxB,EAokBoCC,YApkBpC,EAokBkD;AAC1C9C,MAAAA,QAAQ,CAACS,GAAT;AACA,UAAMO,YAAY,GAAG,EAArB;;AACA,UAAI6B,UAAJ,EAAgB;AACZ7B,QAAAA,YAAY,CAACC,IAAb,CAAkB,aAAa,KAAKC,oBAAL,CAA0B2B,UAA1B,EAAsCC,YAAtC,CAA/B;AACH,OALyC,CAM1C;;;AACA9C,MAAAA,QAAQ,CAAC+C,OAAT,CAAiB5B,GAAjB,CAAqBC,SAArB,EAAgC;AAAEJ,QAAAA,YAAY,EAAZA;AAAF,OAAhC;AACH;AACD;AACJ;AACA;AACA;;AAhlBA;AAAA;AAAA,iCAilBiBwB,OAjlBjB,EAilB0B;AAAA;;AAClB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,sBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAA5B,IAA2C,KAAKF,KAAL,KAAe9B,YAAY,CAACuC,WAA3E,EAAwF;AACpF,aAAKf,MAAL,CAAYwB,KAAZ,uCAAiD,KAAKlB,KAAtD;AACA,eAAOG,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,UAAMmC,MAAM,GAAG,KAAKA,MAApB;;AACA,UAAI,CAACA,MAAL,EAAa;AACT,cAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH,OATiB,CAUlB;;;AACA,UAAMkB,aAAa,GAAG;AAClBP,QAAAA,gCAAgC,EAAE,KAAKlC,kBAAL,GAC5B,KAAKmC,wCADuB,GAE5B,KAAKD,gCAHO;AAIlBF,QAAAA,kCAAkC,EAAE,KAAKhC,kBAAL,GAC9B,KAAKoF,2CADyB,GAE9B,KAAKC;AANO,OAAtB,CAXkB,CAmBlB;;AACA,WAAKrF,kBAAL,GAA0B,KAA1B;;AACA,cAAQmD,MAAM,CAACmC,cAAf;AACI,aAAKtG,cAAc,CAACkB,OAApB;AAA6B;AACzB;AACA;AACA,iBAAKI,MAAL,CAAYwB,KAAZ,mCAA6CqB,MAAM,CAACmC,cAApD;AACA,gBAAMlC,YAAY,GAAG,CAAC,aAAa,KAAKE,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAAd,CAArB;AACAH,YAAAA,MAAM,CAACI,GAAP,CAAWC,SAAX,EAAsB;AAAEJ,cAAAA,YAAY,EAAZA;AAAF,aAAtB;AACA,iBAAKb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACA,mBAAOP,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,aAAKhC,cAAc,CAACuG,MAApB;AAA4B;AACxB;AACA;AACA,gBAAMlD,IAAI,GAAGzD,OAAO,CAACgG,OAAO,CAACpD,OAAT,CAApB,CAHwB,CAIxB;;AACA,gBAAI,CAACa,IAAL,EAAW;AACP,qBAAOtB,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,gBAAIqB,IAAI,CAACmD,kBAAL,KAA4B,QAAhC,EAA0C;AACtC,mBAAKC,WAAL,GAAmBpD,IAAI,CAACqD,OAAxB;AACA,mBAAKC,WAAL,GAAmBtD,IAAI,CAACuD,WAAxB;AACA,qBAAO7E,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,gBAAIqB,IAAI,CAACmD,kBAAL,KAA4B,SAAhC,EAA2C;AACvC,qBAAOzE,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,mBAAO,KAAK+B,SAAL,CAAeV,IAAf,EAAqBI,aAArB,EAAoCK,KAApC,CAA0C,UAAChB,KAAD,EAAW;AACxD,cAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB;;AACA,kBAAM4B,YAAY,GAAG,CAAC,aAAa,MAAI,CAACE,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAAd,CAArB;AACAH,cAAAA,MAAM,CAACI,GAAP,CAAWC,SAAX,EAAsB;AAAEJ,gBAAAA,YAAY,EAAZA;AAAF,eAAtB;;AACA,cAAA,MAAI,CAACb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH,aALM,CAAP;AAMH;;AACD,aAAKtC,cAAc,CAAC6G,cAApB;AAAoC;AAChC;AACA;AACA,iBAAKvF,MAAL,CAAYwB,KAAZ,mCAA6CqB,MAAM,CAACmC,cAApD;AACA,gBAAMlC,aAAY,GAAG,CAAC,aAAa,KAAKE,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAAd,CAArB;AACAH,YAAAA,MAAM,CAACI,GAAP,CAAWC,SAAX,EAAsB;AAAEJ,cAAAA,YAAY,EAAZA;AAAF,aAAtB;AACA,iBAAKb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACA,mBAAOP,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,aAAKhC,cAAc,CAAC8G,eAApB;AAAqC;AACjC;AACA;AACA,iBAAKxF,MAAL,CAAYwB,KAAZ,mCAA6CqB,MAAM,CAACmC,cAApD;AACA,gBAAMlC,cAAY,GAAG,CAAC,aAAa,KAAKE,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAAd,CAArB;AACAH,YAAAA,MAAM,CAACI,GAAP,CAAWC,SAAX,EAAsB;AAAEJ,cAAAA,YAAY,EAAZA;AAAF,aAAtB;AACA,iBAAKb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACA,mBAAOP,OAAO,CAACC,OAAR,EAAP;AACH;;AACD,aAAKhC,cAAc,CAAC+G,MAApB;AACI,gBAAM,IAAIxE,KAAJ,mCAAqC4B,MAAM,CAACmC,cAA5C,OAAN;;AACJ;AACI,gBAAM,IAAI/D,KAAJ,mCAAqC4B,MAAM,CAACmC,cAA5C,OAAN;AAtDR;AAwDH;AACD;AACJ;AACA;AACA;;AAlqBA;AAAA;AAAA,iCAmqBiBV,OAnqBjB,EAmqB0B;AAClB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,sBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,uCAAiD,KAAKlB,KAAtD;AACA;AACH;;AACD,UAAI,KAAKT,QAAL,IAAiB,KAAKA,QAAL,CAAc6F,KAAnC,EAA0C;AACtC,YAAMzC,GAAG,GAAG,IAAInE,GAAJ,CAAQwF,OAAR,CAAZ;AACA,aAAKzE,QAAL,CAAc6F,KAAd,CAAoBzC,GAApB;AACH,OAHD,MAIK;AACDqB,QAAAA,OAAO,CAACqB,MAAR;AACH;;AACD,WAAK1D,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH;AACD;AACJ;AACA;AACA;;AArrBA;AAAA;AAAA,kCAsrBkBsD,OAtrBlB,EAsrB2B;AACnB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,uBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,wCAAkD,KAAKlB,KAAvD;AACA;AACH;;AACD,UAAI,KAAKT,QAAL,IAAiB,KAAKA,QAAL,CAAc+F,MAAnC,EAA2C;AACvC,YAAMnB,IAAI,GAAG,IAAIvF,IAAJ,CAASoF,OAAT,CAAb;AACA,aAAKzE,QAAL,CAAc+F,MAAd,CAAqBnB,IAArB;AACH,OAHD,MAIK;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,QAAAA,OAAO,CAACqB,MAAR;AACH;AACJ;AACD;AACJ;AACA;AACA;;AA/sBA;AAAA;AAAA,oCAgtBoBrB,OAhtBpB,EAgtB6B;AAAA;;AACrB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,yBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,0CAAoD,KAAKlB,KAAzD;AACA;AACH,OALoB,CAMrB;;;AACA,WAAKZ,kBAAL,GAA0B,IAA1B,CAPqB,CAQrB;AACA;;AACA,UAAMoD,YAAY,GAAG,CAAC,cAAc,KAAKQ,QAApB,CAArB,CAVqB,CAWrB;;AACA,UAAIgB,OAAO,CAACpD,OAAR,CAAgB2E,SAAhB,CAA0B,qBAA1B,CAAJ,EAAsD;AAClD,YAAMC,MAAM,GAAGxB,OAAO,CAACpD,OAAR,CAAgB6E,SAAhB,CAA0B,qBAA1B,CAAf;;AACA,YAAI,CAACD,MAAL,EAAa;AACT,gBAAM,IAAI7E,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,aAAK+E,iBAAL,GAAyBzH,OAAO,CAAC0H,mBAAR,CAA4BH,MAA5B,CAAzB;AACH;;AACD,UAAMtG,OAAO,GAAG;AACZoC,QAAAA,gCAAgC,EAAE,KAAKC,wCAD3B;AAEZH,QAAAA,kCAAkC,EAAE,KAAKC;AAF7B,OAAhB;AAIA,WAAKuE,mCAAL,CAAyC1G,OAAzC,EACK6C,IADL,CACU,UAACN,IAAD,EAAU;AAChB,YAAMoE,gBAAgB,GAAG7B,OAAO,CAACqB,MAAR,CAAe;AAAEhB,UAAAA,UAAU,EAAE,GAAd;AAAmB7B,UAAAA,YAAY,EAAZA,YAAnB;AAAiCf,UAAAA,IAAI,EAAJA;AAAjC,SAAf,CAAzB;;AACA,YAAI,MAAI,CAAClC,QAAL,IAAiB,MAAI,CAACA,QAAL,CAAcuG,QAAnC,EAA6C;AACzC,UAAA,MAAI,CAACvG,QAAL,CAAcuG,QAAd,CAAuB9B,OAAO,CAACpD,OAA/B,EAAwCiF,gBAAgB,CAACjF,OAAzD,EAAkE,GAAlE;AACH;AACJ,OAND,EAOKsB,KAPL,CAOW,UAAChB,KAAD,EAAW;AAClB,QAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB;;AACA,QAAA,MAAI,CAAClB,MAAL,CAAYwB,KAAZ,CAAkB,uCAAlB;;AACA,YAAI,CAAC,MAAI,CAACqB,MAAV,EAAkB;AACd,gBAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,QAAA,MAAI,CAACjB,MAAL,CAAYwB,KAAZ,CAAkB,MAAI,CAACqB,MAAL,CAAYmC,cAA9B,EANkB,CAOlB;;;AACA,YAAI,MAAI,CAACnC,MAAL,CAAYmC,cAAZ,KAA+BtG,cAAc,CAACuG,MAAlD,EAA0D;AACtD,cAAMkB,gBAAgB,GAAG7B,OAAO,CAAClD,MAAR,CAAe;AAAEuD,YAAAA,UAAU,EAAE;AAAd,WAAf,CAAzB,CADsD,CACQ;;AAC9D,cAAI,MAAI,CAAC9E,QAAL,IAAiB,MAAI,CAACA,QAAL,CAAcuG,QAAnC,EAA6C;AACzC,YAAA,MAAI,CAACvG,QAAL,CAAcuG,QAAd,CAAuB9B,OAAO,CAACpD,OAA/B,EAAwCiF,gBAAgB,CAACjF,OAAzD,EAAkE,GAAlE;AACH;;AACD;AACH,SAdiB,CAelB;;;AACA,QAAA,MAAI,CAAC0B,aAAL,GACKP,IADL,CACU,YAAM;AACZ,cAAM8D,gBAAgB,GAAG7B,OAAO,CAAClD,MAAR,CAAe;AAAEuD,YAAAA,UAAU,EAAE;AAAd,WAAf,CAAzB,CADY,CACkD;;AAC9D,cAAI,MAAI,CAAC9E,QAAL,IAAiB,MAAI,CAACA,QAAL,CAAcuG,QAAnC,EAA6C;AACzC,YAAA,MAAI,CAACvG,QAAL,CAAcuG,QAAd,CAAuB9B,OAAO,CAACpD,OAA/B,EAAwCiF,gBAAgB,CAACjF,OAAzD,EAAkE,GAAlE;AACH;AACJ,SAND,EAOKsB,KAPL,CAOW,UAAC6D,aAAD,EAAmB;AAC1B;AACA,UAAA,MAAI,CAACrG,MAAL,CAAYwB,KAAZ,CAAkB6E,aAAa,CAACnF,OAAhC;;AACA,UAAA,MAAI,CAAClB,MAAL,CAAYwB,KAAZ,CAAkB,+CAAlB;;AACA,cAAM2E,gBAAgB,GAAG7B,OAAO,CAAClD,MAAR,CAAe;AAAEuD,YAAAA,UAAU,EAAE;AAAd,WAAf,CAAzB,CAJ0B,CAIoC;AAC9D;AACA;AACA;;AACA,cAAI,MAAI,CAACrE,KAAL,KAAe9B,YAAY,CAACwC,UAAhC,EAA4C;AACxC,gBAAI,CAAC,MAAI,CAAC6B,MAAV,EAAkB;AACd,oBAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,gBAAMqF,eAAe,GAAG,EAAxB;AACAA,YAAAA,eAAe,CAACvD,IAAhB,CAAqB,aAAa,MAAI,CAACC,oBAAL,CAA0B,GAA1B,EAA+B,uBAA/B,CAAlC;;AACA,YAAA,MAAI,CAACH,MAAL,CAAYI,GAAZ,CAAgBC,SAAhB,EAA2B;AAAEJ,cAAAA,YAAY,EAAZA;AAAF,aAA3B;;AACA,YAAA,MAAI,CAACb,eAAL,CAAqBzD,YAAY,CAACwC,UAAlC;AACH;;AACD,cAAI,MAAI,CAACnB,QAAL,IAAiB,MAAI,CAACA,QAAL,CAAcuG,QAAnC,EAA6C;AACzC,YAAA,MAAI,CAACvG,QAAL,CAAcuG,QAAd,CAAuB9B,OAAO,CAACpD,OAA/B,EAAwCiF,gBAAgB,CAACjF,OAAzD,EAAkE,GAAlE;AACH;AACJ,SA3BD;AA4BH,OAnDD;AAoDH;AACD;AACJ;AACA;AACA;;AA/xBA;AAAA;AAAA,qCAgyBqBoD,OAhyBrB,EAgyB8B;AACtB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,0BAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,2CAAqD,KAAKlB,KAA1D;AACA;AACH;;AACD,UAAI,KAAKT,QAAL,IAAiB,KAAKA,QAAL,CAAc0G,SAAnC,EAA8C;AAC1C,YAAMrF,OAAO,GAAG,IAAI/B,OAAJ,CAAYmF,OAAZ,CAAhB;AACA,aAAKzE,QAAL,CAAc0G,SAAd,CAAwBrF,OAAxB;AACH,OAHD,MAIK;AACDoD,QAAAA,OAAO,CAACqB,MAAR;AACH;AACJ;AACD;AACJ;AACA;AACA;;AAjzBA;AAAA;AAAA,oCAkzBoBrB,OAlzBpB,EAkzB6B;AACrB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,yBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,0CAAoD,KAAKlB,KAAzD;AACA;AACH,OALoB,CAMrB;AACA;;;AACA,UAAI,KAAK2D,QAAT,EAAmB;AACf,YAAMuC,YAAY,GAAG,IAAIpH,YAAJ,CAAiBkF,OAAjB,CAArB;AACA,aAAKL,QAAL,CAAcuC,YAAd;AACA;AACH,OAZoB,CAarB;;;AACA,UAAI,KAAK3G,QAAL,IAAiB,KAAKA,QAAL,CAAcoE,QAAnC,EAA6C;AACzC,YAAMuC,aAAY,GAAG,IAAIpH,YAAJ,CAAiBkF,OAAjB,CAArB;;AACA,aAAKzE,QAAL,CAAcoE,QAAd,CAAuBuC,aAAvB;AACH,OAHD,MAIK;AACDlC,QAAAA,OAAO,CAACqB,MAAR;AACH;AACJ;AACD;AACJ;AACA;AACA;AACI;;AA50BJ;AAAA;AAAA,mCA60BmBrB,OA70BnB,EA60B4B;AACpB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,wBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,yCAAmD,KAAKlB,KAAxD;AACA;AACH;;AACD,YAAM,IAAIW,KAAJ,CAAU,gBAAV,CAAN;AACH;AACD;AACJ;AACA;AACA;;AAx1BA;AAAA;AAAA,mCAy1BmBqD,OAz1BnB,EAy1B4B;AAAA;;AACpB,WAAKtE,MAAL,CAAYC,GAAZ,CAAgB,wBAAhB;;AACA,UAAI,KAAKK,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,aAAKR,MAAL,CAAYwB,KAAZ,yCAAmD,KAAKlB,KAAxD;AACA;AACH,OALmB,CAMpB;AACA;AACA;;;AACA,UAAI,CAACgE,OAAO,CAACpD,OAAR,CAAgB2E,SAAhB,CAA0B,UAA1B,CAAL,EAA4C;AACxC,aAAK7F,MAAL,CAAY2C,IAAZ,CAAiB,iEAAjB;AACA2B,QAAAA,OAAO,CAAClD,MAAR;AACA;AACH;;AACD,UAAMqF,QAAQ,GAAG,IAAIpH,QAAJ,CAAaiF,OAAb,EAAsB,IAAtB,CAAjB;;AACA,UAAI,KAAKzE,QAAL,IAAiB,KAAKA,QAAL,CAAc6G,OAAnC,EAA4C;AACxC,aAAK7G,QAAL,CAAc6G,OAAd,CAAsBD,QAAtB;AACH,OAFD,MAGK;AACD,aAAKzG,MAAL,CAAYC,GAAZ,CAAgB,+EAAhB;AACAwG,QAAAA,QAAQ,CACHd,MADL,GAEKtD,IAFL,CAEU;AAAA,iBAAMoE,QAAQ,CAACE,WAAT,CAAqB,MAAI,CAACC,uBAA1B,EAAmDrD,MAAnD,EAAN;AAAA,SAFV,EAGKf,KAHL,CAGW,UAAChB,KAAD,EAAW;AAClB;AACA,UAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkBA,KAAK,CAACN,OAAxB;AACH,SAND;AAOH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;AA53BA;AAAA;AAAA,gDA63BgCoD,OA73BhC,EA63ByC9E,OA73BzC,EA63BkD;AAC1C,UAAI,KAAKqD,MAAT,EAAiB;AACb,eAAO,KAAKqD,mCAAL,CAAyC1G,OAAzC,CAAP;AACH;;AACD,UAAMuC,IAAI,GAAGzD,OAAO,CAACgG,OAAO,CAACpD,OAAT,CAApB;;AACA,UAAI,CAACa,IAAD,IAASA,IAAI,CAACmD,kBAAL,KAA4B,SAAzC,EAAoD;AAChD,eAAO,KAAKzB,QAAL,CAAcjE,OAAd,CAAP;AACH,OAFD,MAGK;AACD,eAAO,KAAK4C,oBAAL,CAA0BL,IAA1B,EAAgCvC,OAAhC,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;AA94BA;AAAA;AAAA,wDA+4BwCA,OA/4BxC,EA+4BiD;AACzC,UAAI,CAAC,KAAKqD,MAAV,EAAkB;AACd,cAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,cAAQ,KAAK4B,MAAL,CAAYmC,cAApB;AACI,aAAKtG,cAAc,CAACkB,OAApB;AACI,iBAAO,KAAK6D,QAAL,CAAcjE,OAAd,CAAP;;AACJ,aAAKd,cAAc,CAAC6G,cAApB;AACI;AACA;AACA;AACA;AACA;AACA;AACA,iBAAO9E,OAAO,CAACC,OAAR,CAAgBwC,SAAhB,CAAP;;AACJ,aAAKxE,cAAc,CAAC8G,eAApB;AACI,cAAI,CAAC,KAAK3C,MAAL,CAAYgE,KAAjB,EAAwB;AACpB,kBAAM,IAAI5F,KAAJ,sDAAwD,KAAK4B,MAAL,CAAYmC,cAApE,OAAN;AACH;;AACD,iBAAO,KAAK5C,oBAAL,CAA0B,KAAKS,MAAL,CAAYgE,KAAtC,EAA6CrH,OAA7C,CAAP;;AACJ,aAAKd,cAAc,CAACuG,MAApB;AACI;AACA;AACA;AACA;AACA;AACA;AACA,cAAI,KAAK3E,KAAL,KAAe9B,YAAY,CAACgC,WAAhC,EAA6C;AACzC,mBAAOC,OAAO,CAACC,OAAR,CAAgBwC,SAAhB,CAAP;AACH,WATL,CAUI;;;AACA,iBAAO,KAAKO,QAAL,CAAcjE,OAAd,CAAP;;AACJ,aAAKd,cAAc,CAAC+G,MAApB;AACI,gBAAM,IAAIxE,KAAJ,mCAAqC,KAAK4B,MAAL,CAAYmC,cAAjD,OAAN;;AACJ;AACI,gBAAM,IAAI/D,KAAJ,mCAAqC,KAAK4B,MAAL,CAAYmC,cAAjD,OAAN;AA/BR;AAiCH;AACD;AACJ;AACA;AACA;;AAx7BA;AAAA;AAAA,6BAy7BaxF,OAz7Bb,EAy7BsB;AAAA;;AACd,UAAMsH,GAAG,GAAG,KAAKC,8BAAL,EAAZ;AACA,UAAMC,UAAU,GAAGxH,OAAO,CAACoC,gCAA3B;AACA,UAAMqF,YAAY,GAAGzH,OAAO,CAACkC,kCAA7B,CAHc,CAId;;AACA,UAAI;AACA,eAAOoF,GAAG,CACLI,cADE,CACaF,UADb,EACyBC,YADzB,EAEF5E,IAFE,CAEG,UAAC8E,kBAAD;AAAA,iBAAwB9I,cAAc,CAAC8I,kBAAD,CAAtC;AAAA,SAFH,EAGF3E,KAHE,CAGI,UAAChB,KAAD,EAAW;AAClB;AACA,UAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,kDAAlB;;AACA,cAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAU,iCAAV,CAA3C;;AACA,UAAA,MAAI,CAACjB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;;AACA,gBAAMkG,CAAN;AACH,SATM,CAAP;AAUH,OAXD,CAYA,OAAO5F,KAAP,EAAc;AACV;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,+CAAlB;AACA,YAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,CAAf,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;AAr9BA;AAAA;AAAA,oCAs9BoB;AAAA;;AACZ,UAAMN,GAAG,GAAG,KAAKC,8BAAL,EAAZ;;AACA,UAAID,GAAG,CAACO,mBAAJ,KAA4BnE,SAAhC,EAA2C;AACvC,eAAOzC,OAAO,CAACC,OAAR,EAAP;AACH,OAJW,CAKZ;;;AACA,UAAI;AACA,eAAOoG,GAAG,CAACO,mBAAJ,GAA0B7E,KAA1B,CAAgC,UAAChB,KAAD,EAAW;AAC9C;AACA,UAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,4DAAlB;;AACA,cAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAU,sCAAV,CAA3C;;AACA,UAAA,MAAI,CAACjB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;;AACA,gBAAMkG,CAAN;AACH,SANM,CAAP;AAOH,OARD,CASA,OAAO5F,KAAP,EAAc;AACV;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,yDAAlB;AACA,YAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,CAAf,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;AAh/BA;AAAA;AAAA,8BAi/BcE,MAj/Bd,EAi/BsB9H,OAj/BtB,EAi/B+B;AAAA;;AACvB,UAAMsH,GAAG,GAAG,KAAKC,8BAAL,EAAZ;AACA,UAAMC,UAAU,GAAGxH,OAAO,CAACoC,gCAA3B;AACA,UAAMqF,YAAY,GAAGzH,OAAO,CAACkC,kCAA7B,CAHuB,CAIvB;;AACA,UAAI;AACA,YAAI,CAACoF,GAAG,CAACS,cAAJ,CAAmBD,MAAM,CAAChC,WAA1B,CAAL,EAA6C;AACzC,iBAAO7E,OAAO,CAACW,MAAR,CAAe,IAAIpC,2BAAJ,EAAf,CAAP;AACH;AACJ,OAJD,CAKA,OAAOwC,KAAP,EAAc;AACV,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,gDAAlB;AACA,YAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,CAAf,CAAP;AACH;;AACD,UAAI;AACA,eAAON,GAAG,CAACU,cAAJ,CAAmBF,MAAM,CAAClC,OAA1B,EAAmC4B,UAAnC,EAA+CC,YAA/C,EAA6DzE,KAA7D,CAAmE,UAAChB,KAAD,EAAW;AACjF;AACA,UAAA,MAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,mDAAlB;;AACA,cAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAU,kCAAV,CAA3C;;AACA,UAAA,MAAI,CAACjB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;;AACA,gBAAMkG,CAAN;AACH,SANM,CAAP;AAOH,OARD,CASA,OAAO5F,KAAP,EAAc;AACV;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,gDAAlB;;AACA,YAAM4F,EAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,EAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,EAAf,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;AArhCA;AAAA;AAAA,yCAshCyBP,KAthCzB,EAshCgCrH,OAthChC,EAshCyC;AAAA;;AACjC,UAAMsH,GAAG,GAAG,KAAKC,8BAAL,EAAZ;AACA,UAAMC,UAAU,GAAGxH,OAAO,CAACoC,gCAA3B;AACA,UAAMqF,YAAY,GAAGzH,OAAO,CAACkC,kCAA7B,CAHiC,CAIjC;;AACA,UAAI;AACA,YAAI,CAACoF,GAAG,CAACS,cAAJ,CAAmBV,KAAK,CAACvB,WAAzB,CAAL,EAA4C;AACxC,iBAAO7E,OAAO,CAACW,MAAR,CAAe,IAAIpC,2BAAJ,EAAf,CAAP;AACH;AACJ,OAJD,CAKA,OAAOwC,KAAP,EAAc;AACV,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,2DAAlB;AACA,YAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,CAAf,CAAP;AACH;;AACD,UAAI;AACA,eAAON,GAAG,CACLU,cADE,CACaX,KAAK,CAACzB,OADnB,EAC4B4B,UAD5B,EACwCC,YADxC,EAEF5E,IAFE,CAEG;AAAA,iBAAMyE,GAAG,CAACI,cAAJ,CAAmBF,UAAnB,EAA+BC,YAA/B,CAAN;AAAA,SAFH,EAGF5E,IAHE,CAGG,UAAC8E,kBAAD;AAAA,iBAAwB9I,cAAc,CAAC8I,kBAAD,CAAtC;AAAA,SAHH,EAIF3E,KAJE,CAII,UAAChB,KAAD,EAAW;AAClB;AACA,UAAA,OAAI,CAACxB,MAAL,CAAYwB,KAAZ,CAAkB,gFAAlB;;AACA,cAAM4F,CAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAU,6CAAV,CAA3C;;AACA,UAAA,OAAI,CAACjB,MAAL,CAAYwB,KAAZ,CAAkB4F,CAAC,CAAClG,OAApB;;AACA,gBAAMkG,CAAN;AACH,SAVM,CAAP;AAWH,OAZD,CAaA,OAAO5F,KAAP,EAAc;AACV;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB,6EAAlB;;AACA,YAAM4F,GAAC,GAAG5F,KAAK,YAAYP,KAAjB,GAAyBO,KAAzB,GAAiC,IAAIP,KAAJ,CAAUO,KAAV,CAA3C;;AACA,aAAKxB,MAAL,CAAYwB,KAAZ,CAAkB4F,GAAC,CAAClG,OAApB;AACA,eAAOT,OAAO,CAACW,MAAR,CAAegG,GAAf,CAAP;AACH;AACJ;AACD;AACJ;AACA;AACA;;AA9jCA;AAAA;AAAA,iDA+jCiCN,GA/jCjC,EA+jCsC;AAC9B,UAAI,KAAK1G,0BAAT,EAAqC;AACjC,cAAM,IAAIa,KAAJ,CAAU,sCAAV,CAAN;AACH;;AACD,WAAKb,0BAAL,GAAkC0G,GAAlC;AACH;AACD;AACJ;AACA;AACA;;AAxkCA;AAAA;AAAA,qDAykCqC;AAC7B,UAAIW,EAAJ;;AACA,UAAI,KAAKrH,0BAAT,EAAqC;AACjC,eAAO,KAAKA,0BAAZ;AACH;;AACD,WAAKA,0BAAL,GAAkC,KAAKsH,gCAAL,CAAsC,IAAtC,EAA4C,KAAKnI,SAAL,CAAeoI,aAAf,CAA6BC,uCAAzE,CAAlC;;AACA,UAAI,CAACH,EAAE,GAAG,KAAK5H,QAAX,MAAyB,IAAzB,IAAiC4H,EAAE,KAAK,KAAK,CAA7C,GAAiD,KAAK,CAAtD,GAA0DA,EAAE,CAACI,2BAAjE,EAA8F;AAC1F,aAAKhI,QAAL,CAAcgI,2BAAd,CAA0C,KAAKzH,0BAA/C,EAA2E,KAA3E;AACH;;AACD,aAAO,KAAKA,0BAAZ;AACH;AACD;AACJ;AACA;AACA;;AAvlCA;AAAA;AAAA,oCAwlCoB0H,QAxlCpB,EAwlC8B;AAAA;;AACtB,UAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,GAAM;AAC5B,cAAM,IAAI9G,KAAJ,yCAA2C,OAAI,CAACtB,MAAhD,iBAA6DmI,QAA7D,EAAN;AACH,OAFD,CADsB,CAItB;;;AACA,cAAQ,KAAKnI,MAAb;AACI,aAAKnB,YAAY,CAACoB,OAAlB;AACI,cAAIkI,QAAQ,KAAKtJ,YAAY,CAAC+B,YAA1B,IACAuH,QAAQ,KAAKtJ,YAAY,CAACgC,WAD1B,IAEAsH,QAAQ,KAAKtJ,YAAY,CAACuC,WAF1B,IAGA+G,QAAQ,KAAKtJ,YAAY,CAACwC,UAH9B,EAG0C;AACtC+G,YAAAA,iBAAiB;AACpB;;AACD;;AACJ,aAAKvJ,YAAY,CAAC+B,YAAlB;AACI,cAAIuH,QAAQ,KAAKtJ,YAAY,CAACgC,WAA1B,IACAsH,QAAQ,KAAKtJ,YAAY,CAACuC,WAD1B,IAEA+G,QAAQ,KAAKtJ,YAAY,CAACwC,UAF9B,EAE0C;AACtC+G,YAAAA,iBAAiB;AACpB;;AACD;;AACJ,aAAKvJ,YAAY,CAACgC,WAAlB;AACI,cAAIsH,QAAQ,KAAKtJ,YAAY,CAACuC,WAA1B,IAAyC+G,QAAQ,KAAKtJ,YAAY,CAACwC,UAAvE,EAAmF;AAC/E+G,YAAAA,iBAAiB;AACpB;;AACD;;AACJ,aAAKvJ,YAAY,CAACuC,WAAlB;AACI,cAAI+G,QAAQ,KAAKtJ,YAAY,CAACwC,UAA9B,EAA0C;AACtC+G,YAAAA,iBAAiB;AACpB;;AACD;;AACJ,aAAKvJ,YAAY,CAACwC,UAAlB;AACI+G,UAAAA,iBAAiB;AACjB;;AACJ;AACI,gBAAM,IAAI9G,KAAJ,CAAU,qBAAV,CAAN;AA9BR,OALsB,CAqCtB;;;AACA,WAAKtB,MAAL,GAAcmI,QAAd;AACA,WAAK9H,MAAL,CAAYC,GAAZ,mBAA2B,KAAKC,EAAhC,oCAA4D,KAAKP,MAAjE;;AACA,WAAKG,kBAAL,CAAwBkI,IAAxB,CAA6B,KAAKrI,MAAlC,EAxCsB,CAyCtB;;;AACA,UAAImI,QAAQ,KAAKtJ,YAAY,CAACwC,UAA9B,EAA0C;AACtC,aAAKiH,OAAL;AACH;AACJ;AAroCL;AAAA;AAAA,yCAsoC4C;AAAA,UAArB3G,cAAqB,uEAAJ,EAAI;AACpC,UAAMwB,YAAY,GAAGxB,cAAc,CAACwB,YAAf,GAA8BxB,cAAc,CAACwB,YAAf,CAA4BM,KAA5B,EAA9B,GAAoEF,SAAzF;AACA,UAAMnB,IAAI,GAAGT,cAAc,CAACS,IAAf,GACP;AACEmD,QAAAA,kBAAkB,EAAE5D,cAAc,CAACS,IAAf,CAAoBmD,kBAApB,IAA0C,QADhE;AAEEI,QAAAA,WAAW,EAAEhE,cAAc,CAACS,IAAf,CAAoBuD,WAApB,IAAmC,YAFlD;AAGEF,QAAAA,OAAO,EAAE9D,cAAc,CAACS,IAAf,CAAoBqD,OAApB,IAA+B;AAH1C,OADO,GAMPlC,SANN;AAOA,aAAO;AACHJ,QAAAA,YAAY,EAAZA,YADG;AAEHf,QAAAA,IAAI,EAAJA;AAFG,OAAP;AAIH;AAnpCL;AAAA;AAAA,yCAopCyBmG,IAppCzB,EAopC+BC,MAppC/B,EAopCuC;AAC/B,UAAMC,KAAK,GAAGF,IAAd;AACA,UAAIG,IAAI,GAAGzJ,eAAe,CAACsJ,IAAD,CAA1B;;AACA,UAAI,CAACG,IAAD,IAASF,MAAb,EAAqB;AACjBE,QAAAA,IAAI,GAAGF,MAAP;AACH;;AACD,aAAO,eAAeC,KAAf,GAAuB,SAAvB,GAAmCC,IAAnC,GAA0C,GAAjD;AACH;AA3pCL;AAAA;AAAA,sCA4pCsBzE,OA5pCtB,EA4pC+B;AACvB,UAAMd,YAAY,GAAG,EAArB;AACAA,MAAAA,YAAY,CAACC,IAAb,CAAkB,mBAAmB,KAAKxD,SAAL,CAAeoI,aAAf,CAA6BW,GAAhD,GAAsD,GAAxE;AACAxF,MAAAA,YAAY,CAACC,IAAb,CAAkB,cAAc,KAAKO,QAArC;AACAR,MAAAA,YAAY,CAACC,IAAb,CAAkB,YAAY,CAAC,KAAD,EAAQ,QAAR,EAAkB,QAAlB,EAA4B,SAA5B,EAAuC,KAAvC,EAA8C,SAA9C,EAAyD,MAAzD,EAAiE,QAAjE,EAA2E,OAA3E,EAAoFM,QAApF,EAA9B;AACAP,MAAAA,YAAY,CAACC,IAAb,CAAkB,eAAea,OAAjC;AACA,aAAOd,YAAP;AACH;AAnqCL;AAAA;AAAA,kCAoqCkByF,MApqClB,EAoqC0B;AAClB,UAAI3E,OAAJ;;AACA,UAAI2E,MAAM,YAAY5J,GAAtB,EAA2B;AACvB;AACAiF,QAAAA,OAAO,GAAG2E,MAAM,CAAClF,QAAP,EAAV;AACH,OAHD,MAIK;AACD;AACA,YAAI,CAACkF,MAAM,CAAC1F,MAAZ,EAAoB;AAChB,gBAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,YAAMuH,WAAW,GAAGD,MAAM,CAACE,cAAP,CAAsBC,YAA1C;AACA,YAAMC,YAAY,GAAGJ,MAAM,CAAC1F,MAAP,CAAc8F,YAAd,CAA2BtF,QAA3B,EAArB;AACA,YAAMuF,MAAM,GAAGL,MAAM,CAAC1F,MAAP,CAAc+F,MAA7B;AACA,YAAMC,SAAS,GAAGN,MAAM,CAAC1F,MAAP,CAAcgG,SAAhC;AACA,YAAMC,QAAQ,GAAGP,MAAM,CAAC1F,MAAP,CAAciG,QAA/B;AACA,YAAMC,QAAQ,GAAGC,kBAAkB,WAAIJ,MAAJ,qBAAqBC,SAArB,uBAA2CC,QAA3C,EAAnC;AACAlF,QAAAA,OAAO,eAAO4E,WAAP,iBAAwBG,YAAxB,uBAAiDI,QAAjD,MAAP;AACH;;AACD,aAAOnF,OAAP;AACH;AAxrCL;AAAA;AAAA,wBAmE2B;AACnB,aAAO,KAAKoC,iBAAZ;AACH;AACD;AACJ;AACA;;AAxEA;AAAA;AAAA,wBAyEiB;AACT,aAAO,KAAKiD,OAAZ;AACH;AACD;AACJ;AACA;;AA9EA;AAAA;AAAA,wBA+Ea;AACL,aAAO,KAAKC,GAAZ;AACH;AACD;AACJ;AACA;;AApFA;AAAA;AAAA,wBAqFmB;AACX,aAAO,KAAKC,SAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlGA;AAAA;AAAA,wBAmGoC;AAC5B,aAAO,KAAK/I,0BAAZ;AACH;AACD;AACJ;AACA;;AAxGA;AAAA;AAAA,wBAyG2C;AACnC,aAAO,KAAKb,SAAL,CAAeoI,aAAf,CAA6BD,gCAApC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAnHA;AAAA;AAAA,wBAoH6C;AACrC,aAAO,KAAK3C,mCAAL,IAA4C,EAAnD;AACH,KAtHL;AAAA,sBAuH2CqE,SAvH3C,EAuHsD;AAC9C,WAAKrE,mCAAL,GAA2CqE,SAAS,CAAChG,KAAV,EAA3C;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAjIA;AAAA;AAAA,wBAkI2C;AACnC,aAAO,KAAKiG,iCAAL,IAA0C,EAAjD;AACH,KApIL;AAAA,sBAqIyC7J,OArIzC,EAqIkD;AAC1C,WAAK6J,iCAAL,GAAyCC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/J,OAAlB,CAAzC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AA/IA;AAAA;AAAA,wBAgJqD;AAC7C,aAAO,KAAKsF,2CAAL,IAAoD,EAA3D;AACH,KAlJL;AAAA,sBAmJmDsE,SAnJnD,EAmJ8D;AACtD,WAAKtE,2CAAL,GAAmDsE,SAAS,CAAChG,KAAV,EAAnD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AA7JA;AAAA;AAAA,wBA8JmD;AAC3C,aAAO,KAAKoG,yCAAL,IAAkD,EAAzD;AACH,KAhKL;AAAA,sBAiKiDhK,OAjKjD,EAiK0D;AAClD,WAAKgK,yCAAL,GAAiDF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB/J,OAAlB,CAAjD;AACH;AACD;AACJ;AACA;;AAtKA;AAAA;AAAA,wBAuKgB;AACR,aAAO,KAAKG,MAAZ;AACH;AACD;AACJ;AACA;;AA5KA;AAAA;AAAA,wBA6KsB;AACd,aAAO,KAAKG,kBAAZ;AACH;AACD;AACJ;AACA;;AAlLA;AAAA;AAAA,wBAmLoB;AACZ,aAAO,KAAKC,UAAZ;AACH;AArLL;;AAAA;AAAA","sourcesContent":["import { fromBodyLegacy, getBody, Grammar, SessionState as SessionDialogState, SignalingState, URI } from \"../core\";\nimport { getReasonPhrase } from \"../core/messages/utils\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Bye } from \"./bye\";\nimport { EmitterImpl } from \"./emitter\";\nimport { ContentTypeUnsupportedError, RequestPendingError } from \"./exceptions\";\nimport { Info } from \"./info\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { Referral } from \"./referral\";\nimport { SessionState } from \"./session-state\";\n/**\n * A session provides real time communication between one or more participants.\n *\n * @remarks\n * The transport behaves in a deterministic manner according to the\n * the state defined in {@link SessionState}.\n * @public\n */\nexport class Session {\n    /**\n     * Constructor.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @internal\n     */\n    constructor(userAgent, options = {}) {\n        /** True if there is an outgoing re-INVITE request outstanding. */\n        this.pendingReinvite = false;\n        /** True if there is an incoming re-INVITE ACK request outstanding. */\n        this.pendingReinviteAck = false;\n        /** Session state. */\n        this._state = SessionState.Initial;\n        this.delegate = options.delegate;\n        this._stateEventEmitter = new EmitterImpl();\n        this._userAgent = userAgent;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`);\n        // Remove from the user agent's session collection\n        delete this.userAgent._sessions[this.id];\n        // Dispose of dialog media\n        if (this._sessionDescriptionHandler) {\n            this._sessionDescriptionHandler.close();\n            // TODO: The SDH needs to remain defined as it will be called after it is closed in cases\n            // where an answer/offer arrives while the session is being torn down. There are a variety\n            // of circumstances where this can happen - sending a BYE during a re-INVITE for example.\n            // The code is currently written such that it lazily makes a new SDH when it needs one\n            // and one is not yet defined. Thus if we undefined it here, it will currently make a\n            // new one which is out of sync and then never gets cleaned up.\n            //\n            // The downside of leaving it defined are that calls this closed SDH will continue to be\n            // made (think setDescription) and those should/will fail. These failures are handled, but\n            // it would be nice to have it all coded up in a way where having an undefined SDH where\n            // one is expected throws an error.\n            //\n            // this._sessionDescriptionHandler = undefined;\n        }\n        switch (this.state) {\n            case SessionState.Initial:\n                break; // the Inviter/Invitation sub class dispose method handles this case\n            case SessionState.Establishing:\n                break; // the Inviter/Invitation sub class dispose method handles this case\n            case SessionState.Established:\n                return new Promise((resolve) => {\n                    this._bye({\n                        // wait for the response to the BYE before resolving\n                        onAccept: () => resolve(),\n                        onRedirect: () => resolve(),\n                        onReject: () => resolve()\n                    });\n                });\n            case SessionState.Terminating:\n                break; // nothing to be done\n            case SessionState.Terminated:\n                break; // nothing to be done\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        return Promise.resolve();\n    }\n    /**\n     * The asserted identity of the remote user.\n     */\n    get assertedIdentity() {\n        return this._assertedIdentity;\n    }\n    /**\n     * The confirmed session dialog.\n     */\n    get dialog() {\n        return this._dialog;\n    }\n    /**\n     * A unique identifier for this session.\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * The session being replace by this one.\n     */\n    get replacee() {\n        return this._replacee;\n    }\n    /**\n     * Session description handler.\n     * @remarks\n     * If `this` is an instance of `Invitation`,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"establishing\".\n     * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,\n     * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n     * Otherwise `undefined`.\n     */\n    get sessionDescriptionHandler() {\n        return this._sessionDescriptionHandler;\n    }\n    /**\n     * Session description handler factory.\n     */\n    get sessionDescriptionHandlerFactory() {\n        return this.userAgent.configuration.sessionDescriptionHandlerFactory;\n    }\n    /**\n     * SDH modifiers for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n    get sessionDescriptionHandlerModifiers() {\n        return this._sessionDescriptionHandlerModifiers || [];\n    }\n    set sessionDescriptionHandlerModifiers(modifiers) {\n        this._sessionDescriptionHandlerModifiers = modifiers.slice();\n    }\n    /**\n     * SDH options for the initial INVITE transaction.\n     * @remarks\n     * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n     */\n    get sessionDescriptionHandlerOptions() {\n        return this._sessionDescriptionHandlerOptions || {};\n    }\n    set sessionDescriptionHandlerOptions(options) {\n        this._sessionDescriptionHandlerOptions = Object.assign({}, options);\n    }\n    /**\n     * SDH modifiers for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n    get sessionDescriptionHandlerModifiersReInvite() {\n        return this._sessionDescriptionHandlerModifiersReInvite || [];\n    }\n    set sessionDescriptionHandlerModifiersReInvite(modifiers) {\n        this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();\n    }\n    /**\n     * SDH options for re-INVITE transactions.\n     * @remarks\n     * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n     * May be set directly at anytime.\n     * May optionally be set via constructor option.\n     * May optionally be set via options passed to Session.invite().\n     */\n    get sessionDescriptionHandlerOptionsReInvite() {\n        return this._sessionDescriptionHandlerOptionsReInvite || {};\n    }\n    set sessionDescriptionHandlerOptionsReInvite(options) {\n        this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);\n    }\n    /**\n     * Session state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Session state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * The user agent.\n     */\n    get userAgent() {\n        return this._userAgent;\n    }\n    /**\n     * End the {@link Session}. Sends a BYE.\n     * @param options - Options bucket. See {@link SessionByeOptions} for details.\n     */\n    bye(options = {}) {\n        let message = \"Session.bye() may only be called if established session.\";\n        switch (this.state) {\n            case SessionState.Initial:\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" However Inviter.invite() has not yet been called.\";\n                    message += \" Perhaps you should have called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" However Invitation.accept() has not yet been called.\";\n                    message += \" Perhaps you should have called Invitation.reject()?\";\n                }\n                break;\n            case SessionState.Establishing:\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" However a dialog does not yet exist.\";\n                    message += \" Perhaps you should have called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" However Invitation.accept() has not yet been called (or not yet resolved).\";\n                    message += \" Perhaps you should have called Invitation.reject()?\";\n                }\n                break;\n            case SessionState.Established: {\n                const requestDelegate = options.requestDelegate;\n                const requestOptions = this.copyRequestOptions(options.requestOptions);\n                return this._bye(requestDelegate, requestOptions);\n            }\n            case SessionState.Terminating:\n                message += \" However this session is already terminating.\";\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                if (typeof this.cancel === \"function\") {\n                    message += \" Perhaps you have already called Inviter.cancel()?\";\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                }\n                else if (typeof this.reject === \"function\") {\n                    message += \" Perhaps you have already called Session.bye()?\";\n                }\n                break;\n            case SessionState.Terminated:\n                message += \" However this session is already terminated.\";\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        this.logger.error(message);\n        return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n    /**\n     * Share {@link Info} with peer. Sends an INFO.\n     * @param options - Options bucket. See {@link SessionInfoOptions} for details.\n     */\n    info(options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.info() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        return this._info(requestDelegate, requestOptions);\n    }\n    /**\n     * Renegotiate the session. Sends a re-INVITE.\n     * @param options - Options bucket. See {@link SessionInviteOptions} for details.\n     */\n    invite(options = {}) {\n        this.logger.log(\"Session.invite\");\n        if (this.state !== SessionState.Established) {\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        if (this.pendingReinvite) {\n            return Promise.reject(new RequestPendingError(\"Reinvite in progress. Please wait until complete, then try again.\"));\n        }\n        this.pendingReinvite = true;\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;\n        }\n        const delegate = {\n            onAccept: (response) => {\n                // A re-INVITE transaction has an offer/answer [RFC3264] exchange\n                // associated with it.  The UAC (User Agent Client) generating a given\n                // re-INVITE can act as the offerer or as the answerer.  A UAC willing\n                // to act as the offerer includes an offer in the re-INVITE.  The UAS\n                // (User Agent Server) then provides an answer in a response to the\n                // re-INVITE.  A UAC willing to act as answerer does not include an\n                // offer in the re-INVITE.  The UAS then provides an offer in a response\n                // to the re-INVITE becoming, thus, the offerer.\n                // https://tools.ietf.org/html/rfc6141#section-1\n                const body = getBody(response.message);\n                if (!body) {\n                    // No way to recover, so terminate session and mark as failed.\n                    this.logger.error(\"Received 2xx response to re-INVITE without a session description\");\n                    this.ackAndBye(response, 400, \"Missing session description\");\n                    this.stateTransition(SessionState.Terminated);\n                    this.pendingReinvite = false;\n                    return;\n                }\n                if (options.withoutSdp) {\n                    // INVITE without SDP - set remote offer and send an answer in the ACK\n                    const answerOptions = {\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n                    };\n                    this.setOfferAndGetAnswer(body, answerOptions)\n                        .then((answerBody) => {\n                        response.ack({ body: answerBody });\n                    })\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to handle offer in 2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        if (this.state === SessionState.Terminated) {\n                            // A BYE should not be sent if already terminated.\n                            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                            response.ack();\n                        }\n                        else {\n                            this.ackAndBye(response, 488, \"Bad Media Description\");\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                    })\n                        .then(() => {\n                        this.pendingReinvite = false;\n                        if (options.requestDelegate && options.requestDelegate.onAccept) {\n                            options.requestDelegate.onAccept(response);\n                        }\n                    });\n                }\n                else {\n                    // INVITE with SDP - set remote answer and send an ACK\n                    const answerOptions = {\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n                    };\n                    this.setAnswer(body, answerOptions)\n                        .then(() => {\n                        response.ack();\n                    })\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to handle answer in 2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        // A BYE should only be sent if session is not already terminated.\n                        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                        // The ACK needs to be sent regardless as it was not handled by the transaction.\n                        if (this.state !== SessionState.Terminated) {\n                            this.ackAndBye(response, 488, \"Bad Media Description\");\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                        else {\n                            response.ack();\n                        }\n                    })\n                        .then(() => {\n                        this.pendingReinvite = false;\n                        if (options.requestDelegate && options.requestDelegate.onAccept) {\n                            options.requestDelegate.onAccept(response);\n                        }\n                    });\n                }\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onProgress: (response) => {\n                return;\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onRedirect: (response) => {\n                return;\n            },\n            onReject: (response) => {\n                this.logger.warn(\"Received a non-2xx response to re-INVITE\");\n                this.pendingReinvite = false;\n                if (options.withoutSdp) {\n                    if (options.requestDelegate && options.requestDelegate.onReject) {\n                        options.requestDelegate.onReject(response);\n                    }\n                }\n                else {\n                    this.rollbackOffer()\n                        .catch((error) => {\n                        // No way to recover, so terminate session and mark as failed.\n                        this.logger.error(\"Failed to rollback offer on non-2xx response to re-INVITE\");\n                        this.logger.error(error.message);\n                        // A BYE should only be sent if session is not already terminated.\n                        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                        // Note that the ACK was already sent by the transaction, so just need to send BYE.\n                        if (this.state !== SessionState.Terminated) {\n                            if (!this.dialog) {\n                                throw new Error(\"Dialog undefined.\");\n                            }\n                            const extraHeaders = [];\n                            extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n                            this.dialog.bye(undefined, { extraHeaders });\n                            this.stateTransition(SessionState.Terminated);\n                        }\n                    })\n                        .then(() => {\n                        if (options.requestDelegate && options.requestDelegate.onReject) {\n                            options.requestDelegate.onReject(response);\n                        }\n                    });\n                }\n            },\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onTrying: (response) => {\n                return;\n            }\n        };\n        const requestOptions = options.requestOptions || {};\n        requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();\n        requestOptions.extraHeaders.push(\"Allow: \" + AllowedMethods.toString());\n        requestOptions.extraHeaders.push(\"Contact: \" + this._contact);\n        // Just send an INVITE with no sdp...\n        if (options.withoutSdp) {\n            if (!this.dialog) {\n                this.pendingReinvite = false;\n                throw new Error(\"Dialog undefined.\");\n            }\n            return Promise.resolve(this.dialog.invite(delegate, requestOptions));\n        }\n        // Get an offer and send it in an INVITE\n        const offerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n        };\n        return this.getOffer(offerOptions)\n            .then((offerBody) => {\n            if (!this.dialog) {\n                this.pendingReinvite = false;\n                throw new Error(\"Dialog undefined.\");\n            }\n            requestOptions.body = offerBody;\n            return this.dialog.invite(delegate, requestOptions);\n        })\n            .catch((error) => {\n            this.logger.error(error.message);\n            this.logger.error(\"Failed to send re-INVITE\");\n            this.pendingReinvite = false;\n            throw error;\n        });\n    }\n    /**\n     * Deliver a {@link Message}. Sends a MESSAGE.\n     * @param options - Options bucket. See {@link SessionMessageOptions} for details.\n     */\n    message(options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.message() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        return this._message(requestDelegate, requestOptions);\n    }\n    /**\n     * Proffer a {@link Referral}. Send a REFER.\n     * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.\n     * @param options - Options bucket. See {@link SessionReferOptions} for details.\n     */\n    refer(referTo, options = {}) {\n        // guard session state\n        if (this.state !== SessionState.Established) {\n            const message = \"Session.refer() may only be called if established session.\";\n            this.logger.error(message);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const requestDelegate = options.requestDelegate;\n        const requestOptions = this.copyRequestOptions(options.requestOptions);\n        requestOptions.extraHeaders = requestOptions.extraHeaders\n            ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo)))\n            : this.referExtraHeaders(this.referToString(referTo));\n        return this._refer(options.onNotify, requestDelegate, requestOptions);\n    }\n    /**\n     * Send BYE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _bye(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        const dialog = this.dialog;\n        // The caller's UA MAY send a BYE for either confirmed or early dialogs,\n        // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT\n        // send a BYE on early dialogs. However, the callee's UA MUST NOT send a\n        // BYE on a confirmed dialog until it has received an ACK for its 2xx\n        // response or until the server transaction times out.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        switch (dialog.sessionState) {\n            case SessionDialogState.Initial:\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            case SessionDialogState.Early: // Implementation choice - not sending BYE for early dialogs.\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            case SessionDialogState.AckWait: {\n                // This state only occurs if we are the callee.\n                this.stateTransition(SessionState.Terminating); // We're terminating\n                return new Promise((resolve) => {\n                    dialog.delegate = {\n                        // When ACK shows up, say BYE.\n                        onAck: () => {\n                            const request = dialog.bye(delegate, options);\n                            this.stateTransition(SessionState.Terminated);\n                            resolve(request);\n                            return Promise.resolve();\n                        },\n                        // Or the server transaction times out before the ACK arrives.\n                        onAckTimeout: () => {\n                            const request = dialog.bye(delegate, options);\n                            this.stateTransition(SessionState.Terminated);\n                            resolve(request);\n                        }\n                    };\n                });\n            }\n            case SessionDialogState.Confirmed: {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve(request);\n            }\n            case SessionDialogState.Terminated:\n                throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n    }\n    /**\n     * Send INFO.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _info(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        return Promise.resolve(this.dialog.info(delegate, options));\n    }\n    /**\n     * Send MESSAGE.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _message(delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        return Promise.resolve(this.dialog.message(delegate, options));\n    }\n    /**\n     * Send REFER.\n     * @param onNotify - Notification callback.\n     * @param delegate - Request delegate.\n     * @param options - Request options bucket.\n     * @internal\n     */\n    _refer(onNotify, delegate, options) {\n        // Using core session dialog\n        if (!this.dialog) {\n            return Promise.reject(new Error(\"Session dialog undefined.\"));\n        }\n        // If set, deliver any in-dialog NOTIFY requests here...\n        this.onNotify = onNotify;\n        return Promise.resolve(this.dialog.refer(delegate, options));\n    }\n    /**\n     * Send ACK and then BYE. There are unrecoverable errors which can occur\n     * while handling dialog forming and in-dialog INVITE responses and when\n     * they occur we ACK the response and send a BYE.\n     * Note that the BYE is sent in the dialog associated with the response\n     * which is not necessarily `this.dialog`. And, accordingly, the\n     * session state is not transitioned to terminated and session is not closed.\n     * @param inviteResponse - The response causing the error.\n     * @param statusCode - Status code for he reason phrase.\n     * @param reasonPhrase - Reason phrase for the BYE.\n     * @internal\n     */\n    ackAndBye(response, statusCode, reasonPhrase) {\n        response.ack();\n        const extraHeaders = [];\n        if (statusCode) {\n            extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(statusCode, reasonPhrase));\n        }\n        // Using the dialog session associate with the response (which might not be this.dialog)\n        response.session.bye(undefined, { extraHeaders });\n    }\n    /**\n     * Handle in dialog ACK request.\n     * @internal\n     */\n    onAckRequest(request) {\n        this.logger.log(\"Session.onAckRequest\");\n        if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {\n            this.logger.error(`ACK received while in state ${this.state}, dropping request`);\n            return Promise.resolve();\n        }\n        const dialog = this.dialog;\n        if (!dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        // if received answer in ACK.\n        const answerOptions = {\n            sessionDescriptionHandlerOptions: this.pendingReinviteAck\n                ? this.sessionDescriptionHandlerOptionsReInvite\n                : this.sessionDescriptionHandlerOptions,\n            sessionDescriptionHandlerModifiers: this.pendingReinviteAck\n                ? this._sessionDescriptionHandlerModifiersReInvite\n                : this._sessionDescriptionHandlerModifiers\n        };\n        // reset pending ACK flag\n        this.pendingReinviteAck = false;\n        switch (dialog.signalingState) {\n            case SignalingState.Initial: {\n                // State should never be reached as first reliable response must have answer/offer.\n                // So we must have never has sent an offer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.Stable: {\n                // State we should be in.\n                // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.\n                const body = getBody(request.message);\n                // If the ACK doesn't have an answer, nothing to be done.\n                if (!body) {\n                    return Promise.resolve();\n                }\n                if (body.contentDisposition === \"render\") {\n                    this._renderbody = body.content;\n                    this._rendertype = body.contentType;\n                    return Promise.resolve();\n                }\n                if (body.contentDisposition !== \"session\") {\n                    return Promise.resolve();\n                }\n                return this.setAnswer(body, answerOptions).catch((error) => {\n                    this.logger.error(error.message);\n                    const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                    dialog.bye(undefined, { extraHeaders });\n                    this.stateTransition(SessionState.Terminated);\n                });\n            }\n            case SignalingState.HaveLocalOffer: {\n                // State should never be reached as local offer would be answered by this ACK.\n                // So we must have received an ACK without an answer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.HaveRemoteOffer: {\n                // State should never be reached as remote offer would be answered in first reliable response.\n                // So we must have never has sent an answer.\n                this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n                const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n                dialog.bye(undefined, { extraHeaders });\n                this.stateTransition(SessionState.Terminated);\n                return Promise.resolve();\n            }\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n        }\n    }\n    /**\n     * Handle in dialog BYE request.\n     * @internal\n     */\n    onByeRequest(request) {\n        this.logger.log(\"Session.onByeRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`BYE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onBye) {\n            const bye = new Bye(request);\n            this.delegate.onBye(bye);\n        }\n        else {\n            request.accept();\n        }\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle in dialog INFO request.\n     * @internal\n     */\n    onInfoRequest(request) {\n        this.logger.log(\"Session.onInfoRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`INFO received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onInfo) {\n            const info = new Info(request);\n            this.delegate.onInfo(info);\n        }\n        else {\n            // FIXME: TODO: We should reject request...\n            //\n            // If a UA receives an INFO request associated with an Info Package that\n            // the UA has not indicated willingness to receive, the UA MUST send a\n            // 469 (Bad Info Package) response (see Section 11.6), which contains a\n            // Recv-Info header field with Info Packages for which the UA is willing\n            // to receive INFO requests.\n            // https://tools.ietf.org/html/rfc6086#section-4.2.2\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog INVITE request.\n     * @internal\n     */\n    onInviteRequest(request) {\n        this.logger.log(\"Session.onInviteRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`INVITE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // set pending ACK flag\n        this.pendingReinviteAck = true;\n        // TODO: would be nice to have core track and set the Contact header,\n        // but currently the session which is setting it is holding onto it.\n        const extraHeaders = [\"Contact: \" + this._contact];\n        // Handle P-Asserted-Identity\n        if (request.message.hasHeader(\"P-Asserted-Identity\")) {\n            const header = request.message.getHeader(\"P-Asserted-Identity\");\n            if (!header) {\n                throw new Error(\"Header undefined.\");\n            }\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(header);\n        }\n        const options = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n        };\n        this.generateResponseOfferAnswerInDialog(options)\n            .then((body) => {\n            const outgoingResponse = request.accept({ statusCode: 200, extraHeaders, body });\n            if (this.delegate && this.delegate.onInvite) {\n                this.delegate.onInvite(request.message, outgoingResponse.message, 200);\n            }\n        })\n            .catch((error) => {\n            this.logger.error(error.message);\n            this.logger.error(\"Failed to handle to re-INVITE request\");\n            if (!this.dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            this.logger.error(this.dialog.signalingState);\n            // If we don't have a local/remote offer...\n            if (this.dialog.signalingState === SignalingState.Stable) {\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n                return;\n            }\n            // Otherwise rollback\n            this.rollbackOffer()\n                .then(() => {\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n            })\n                .catch((errorRollback) => {\n                // No way to recover, so terminate session and mark as failed.\n                this.logger.error(errorRollback.message);\n                this.logger.error(\"Failed to rollback offer on re-INVITE request\");\n                const outgoingResponse = request.reject({ statusCode: 488 }); // Not Acceptable Here\n                // A BYE should only be sent if session is not already terminated.\n                // For example, a BYE may be sent/received while re-INVITE is outstanding.\n                // Note that the ACK was already sent by the transaction, so just need to send BYE.\n                if (this.state !== SessionState.Terminated) {\n                    if (!this.dialog) {\n                        throw new Error(\"Dialog undefined.\");\n                    }\n                    const extraHeadersBye = [];\n                    extraHeadersBye.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n                    this.dialog.bye(undefined, { extraHeaders });\n                    this.stateTransition(SessionState.Terminated);\n                }\n                if (this.delegate && this.delegate.onInvite) {\n                    this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n                }\n            });\n        });\n    }\n    /**\n     * Handle in dialog MESSAGE request.\n     * @internal\n     */\n    onMessageRequest(request) {\n        this.logger.log(\"Session.onMessageRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);\n            return;\n        }\n        if (this.delegate && this.delegate.onMessage) {\n            const message = new Message(request);\n            this.delegate.onMessage(message);\n        }\n        else {\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog NOTIFY request.\n     * @internal\n     */\n    onNotifyRequest(request) {\n        this.logger.log(\"Session.onNotifyRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // If this a NOTIFY associated with the progress of a REFER,\n        // look to delegate handling to the associated callback.\n        if (this.onNotify) {\n            const notification = new Notification(request);\n            this.onNotify(notification);\n            return;\n        }\n        // Otherwise accept the NOTIFY.\n        if (this.delegate && this.delegate.onNotify) {\n            const notification = new Notification(request);\n            this.delegate.onNotify(notification);\n        }\n        else {\n            request.accept();\n        }\n    }\n    /**\n     * Handle in dialog PRACK request.\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onPrackRequest(request) {\n        this.logger.log(\"Session.onPrackRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`PRACK received while in state ${this.state}, dropping request`);\n            return;\n        }\n        throw new Error(\"Unimplemented.\");\n    }\n    /**\n     * Handle in dialog REFER request.\n     * @internal\n     */\n    onReferRequest(request) {\n        this.logger.log(\"Session.onReferRequest\");\n        if (this.state !== SessionState.Established) {\n            this.logger.error(`REFER received while in state ${this.state}, dropping request`);\n            return;\n        }\n        // REFER is a SIP request and is constructed as defined in [1].  A REFER\n        // request MUST contain exactly one Refer-To header field value.\n        // https://tools.ietf.org/html/rfc3515#section-2.4.1\n        if (!request.message.hasHeader(\"refer-to\")) {\n            this.logger.warn(\"Invalid REFER packet. A refer-to header is required. Rejecting.\");\n            request.reject();\n            return;\n        }\n        const referral = new Referral(request, this);\n        if (this.delegate && this.delegate.onRefer) {\n            this.delegate.onRefer(referral);\n        }\n        else {\n            this.logger.log(\"No delegate available to handle REFER, automatically accepting and following.\");\n            referral\n                .accept()\n                .then(() => referral.makeInviter(this._referralInviterOptions).invite())\n                .catch((error) => {\n                // FIXME: logging and eating error...\n                this.logger.error(error.message);\n            });\n        }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request.\n     * If a remote offer was provided in the request, set the remote\n     * description and get a local answer. If a remote offer was not\n     * provided, generates a local offer.\n     * @internal\n     */\n    generateResponseOfferAnswer(request, options) {\n        if (this.dialog) {\n            return this.generateResponseOfferAnswerInDialog(options);\n        }\n        const body = getBody(request.message);\n        if (!body || body.contentDisposition !== \"session\") {\n            return this.getOffer(options);\n        }\n        else {\n            return this.setOfferAndGetAnswer(body, options);\n        }\n    }\n    /**\n     * Generate an offer or answer for a response to an INVITE request\n     * when a dialog (early or otherwise) has already been established.\n     * This method may NOT be called if a dialog has yet to be established.\n     * @internal\n     */\n    generateResponseOfferAnswerInDialog(options) {\n        if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n        }\n        switch (this.dialog.signalingState) {\n            case SignalingState.Initial:\n                return this.getOffer(options);\n            case SignalingState.HaveLocalOffer:\n                // o  Once the UAS has sent or received an answer to the initial\n                // offer, it MUST NOT generate subsequent offers in any responses\n                // to the initial INVITE.  This means that a UAS based on this\n                // specification alone can never generate subsequent offers until\n                // completion of the initial transaction.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                return Promise.resolve(undefined);\n            case SignalingState.HaveRemoteOffer:\n                if (!this.dialog.offer) {\n                    throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);\n                }\n                return this.setOfferAndGetAnswer(this.dialog.offer, options);\n            case SignalingState.Stable:\n                // o  Once the UAS has sent or received an answer to the initial\n                // offer, it MUST NOT generate subsequent offers in any responses\n                // to the initial INVITE.  This means that a UAS based on this\n                // specification alone can never generate subsequent offers until\n                // completion of the initial transaction.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                if (this.state !== SessionState.Established) {\n                    return Promise.resolve(undefined);\n                }\n                // In dialog INVITE without offer, get an offer for the response.\n                return this.getOffer(options);\n            case SignalingState.Closed:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n            default:\n                throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n        }\n    }\n    /**\n     * Get local offer.\n     * @internal\n     */\n    getOffer(options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            return sdh\n                .getDescription(sdhOptions, sdhModifiers)\n                .then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType))\n                .catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.getOffer: SDH getDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.getOffer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.getOffer: SDH getDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Rollback local/remote offer.\n     * @internal\n     */\n    rollbackOffer() {\n        const sdh = this.setupSessionDescriptionHandler();\n        if (sdh.rollbackDescription === undefined) {\n            return Promise.resolve();\n        }\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            return sdh.rollbackDescription().catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.rollbackOffer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Set remote answer.\n     * @internal\n     */\n    setAnswer(answer, options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            if (!sdh.hasDescription(answer.contentType)) {\n                return Promise.reject(new ContentTypeUnsupportedError());\n            }\n        }\n        catch (error) {\n            this.logger.error(\"Session.setAnswer: SDH hasDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n        try {\n            return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.setAnswer: SDH setDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.setAnswer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.setAnswer: SDH setDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * Set remote offer and get local answer.\n     * @internal\n     */\n    setOfferAndGetAnswer(offer, options) {\n        const sdh = this.setupSessionDescriptionHandler();\n        const sdhOptions = options.sessionDescriptionHandlerOptions;\n        const sdhModifiers = options.sessionDescriptionHandlerModifiers;\n        // This is intentionally written very defensively. Don't trust SDH to behave.\n        try {\n            if (!sdh.hasDescription(offer.contentType)) {\n                return Promise.reject(new ContentTypeUnsupportedError());\n            }\n        }\n        catch (error) {\n            this.logger.error(\"Session.setOfferAndGetAnswer: SDH hasDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n        try {\n            return sdh\n                .setDescription(offer.content, sdhOptions, sdhModifiers)\n                .then(() => sdh.getDescription(sdhOptions, sdhModifiers))\n                .then((bodyAndContentType) => fromBodyLegacy(bodyAndContentType))\n                .catch((error) => {\n                // don't trust SDH to reject with Error\n                this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...\");\n                const e = error instanceof Error ? error : new Error(\"Session.setOfferAndGetAnswer unknown error.\");\n                this.logger.error(e.message);\n                throw e;\n            });\n        }\n        catch (error) {\n            // don't trust SDH to throw an Error\n            this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...\");\n            const e = error instanceof Error ? error : new Error(error);\n            this.logger.error(e.message);\n            return Promise.reject(e);\n        }\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n    setSessionDescriptionHandler(sdh) {\n        if (this._sessionDescriptionHandler) {\n            throw new Error(\"Session description handler defined.\");\n        }\n        this._sessionDescriptionHandler = sdh;\n    }\n    /**\n     * SDH for confirmed dialog.\n     * @internal\n     */\n    setupSessionDescriptionHandler() {\n        var _a;\n        if (this._sessionDescriptionHandler) {\n            return this._sessionDescriptionHandler;\n        }\n        this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);\n        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n            this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);\n        }\n        return this._sessionDescriptionHandler;\n    }\n    /**\n     * Transition session state.\n     * @internal\n     */\n    stateTransition(newState) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate transition\n        switch (this._state) {\n            case SessionState.Initial:\n                if (newState !== SessionState.Establishing &&\n                    newState !== SessionState.Established &&\n                    newState !== SessionState.Terminating &&\n                    newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Establishing:\n                if (newState !== SessionState.Established &&\n                    newState !== SessionState.Terminating &&\n                    newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Established:\n                if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Terminating:\n                if (newState !== SessionState.Terminated) {\n                    invalidTransition();\n                }\n                break;\n            case SessionState.Terminated:\n                invalidTransition();\n                break;\n            default:\n                throw new Error(\"Unrecognized state.\");\n        }\n        // Transition\n        this._state = newState;\n        this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        // Dispose\n        if (newState === SessionState.Terminated) {\n            this.dispose();\n        }\n    }\n    copyRequestOptions(requestOptions = {}) {\n        const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;\n        const body = requestOptions.body\n            ? {\n                contentDisposition: requestOptions.body.contentDisposition || \"render\",\n                contentType: requestOptions.body.contentType || \"text/plain\",\n                content: requestOptions.body.content || \"\"\n            }\n            : undefined;\n        return {\n            extraHeaders,\n            body\n        };\n    }\n    getReasonHeaderValue(code, reason) {\n        const cause = code;\n        let text = getReasonPhrase(code);\n        if (!text && reason) {\n            text = reason;\n        }\n        return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n    }\n    referExtraHeaders(referTo) {\n        const extraHeaders = [];\n        extraHeaders.push(\"Referred-By: <\" + this.userAgent.configuration.uri + \">\");\n        extraHeaders.push(\"Contact: \" + this._contact);\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        extraHeaders.push(\"Refer-To: \" + referTo);\n        return extraHeaders;\n    }\n    referToString(target) {\n        let referTo;\n        if (target instanceof URI) {\n            // REFER without Replaces (Blind Transfer)\n            referTo = target.toString();\n        }\n        else {\n            // REFER with Replaces (Attended Transfer)\n            if (!target.dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            const displayName = target.remoteIdentity.friendlyName;\n            const remoteTarget = target.dialog.remoteTarget.toString();\n            const callId = target.dialog.callId;\n            const remoteTag = target.dialog.remoteTag;\n            const localTag = target.dialog.localTag;\n            const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);\n            referTo = `\"${displayName}\" <${remoteTarget}?Replaces=${replaces}>`;\n        }\n        return referTo;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}