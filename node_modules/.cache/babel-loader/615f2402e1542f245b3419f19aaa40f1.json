{"ast":null,"code":"import { Dialog, SessionDialog } from \"../dialogs\";\nimport { TransactionStateError } from \"../exceptions\";\nimport { SignalingState } from \"../session\";\nimport { InviteServerTransaction } from \"../transactions\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { UserAgentServer } from \"./user-agent-server\";\n/**\n * INVITE UAS.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.3 UAS Processing\n * https://tools.ietf.org/html/rfc3261#section-13.3\n * @public\n */\n\nexport class InviteUserAgentServer extends UserAgentServer {\n  constructor(core, message, delegate) {\n    super(InviteServerTransaction, core, message, delegate);\n    this.core = core;\n  }\n\n  dispose() {\n    if (this.earlyDialog) {\n      this.earlyDialog.dispose();\n    }\n\n    super.dispose();\n  }\n  /**\n   * 13.3.1.4 The INVITE is Accepted\n   * The UAS core generates a 2xx response.  This response establishes a\n   * dialog, and therefore follows the procedures of Section 12.1.1 in\n   * addition to those of Section 8.2.6.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n   * @param options - Accept options bucket.\n   */\n\n\n  accept(options = {\n    statusCode: 200\n  }) {\n    if (!this.acceptable) {\n      throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n    } // This response establishes a dialog...\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n    if (!this.confirmedDialog) {\n      if (this.earlyDialog) {\n        this.earlyDialog.confirm();\n        this.confirmedDialog = this.earlyDialog;\n        this.earlyDialog = undefined;\n      } else {\n        const transaction = this.transaction;\n\n        if (!(transaction instanceof InviteServerTransaction)) {\n          throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n        }\n\n        const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);\n        this.confirmedDialog = new SessionDialog(transaction, this.core, state);\n      }\n    } // When a UAS responds to a request with a response that establishes a\n    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n    // header field values from the request into the response (including the\n    // URIs, URI parameters, and any Record-Route header field parameters,\n    // whether they are known or unknown to the UAS) and MUST maintain the\n    // order of those values.  The UAS MUST add a Contact header field to\n    // the response.  The Contact header field contains an address where the\n    // UAS would like to be contacted for subsequent requests in the dialog\n    // (which includes the ACK for a 2xx response in the case of an INVITE).\n    // Generally, the host portion of this URI is the IP address or FQDN of\n    // the host.  The URI provided in the Contact header field MUST be a SIP\n    // or SIPS URI.  If the request that initiated the dialog contained a\n    // SIPS URI in the Request-URI or in the top Record-Route header field\n    // value, if there was any, or the Contact header field if there was no\n    // Record-Route header field, the Contact header field in the response\n    // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n    // same URI can be used in messages outside this dialog).  The same way,\n    // the scope of the URI in the Contact header field of the INVITE is not\n    // limited to this dialog either.  It can therefore be used in messages\n    // to the UAC even outside this dialog.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n    const recordRouteHeader = this.message.getHeaders(\"record-route\").map(header => `Record-Route: ${header}`);\n    const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`; // A 2xx response to an INVITE SHOULD contain the Allow header field and\n    // the Supported header field, and MAY contain the Accept header field.\n    // Including these header fields allows the UAC to determine the\n    // features and extensions supported by the UAS for the duration of the\n    // call, without probing.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n    // FIXME: TODO: This should not be hard coded.\n\n    const allowHeader = \"Allow: \" + AllowedMethods.toString(); // FIXME: TODO: Supported header (see reply())\n    // FIXME: TODO: Accept header\n    // If the INVITE request contained an offer, and the UAS had not yet\n    // sent an answer, the 2xx MUST contain an answer.  If the INVITE did\n    // not contain an offer, the 2xx MUST contain an offer if the UAS had\n    // not yet sent an offer.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n    if (!options.body) {\n      if (this.confirmedDialog.signalingState === SignalingState.Stable) {\n        options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response\n      } else if (this.confirmedDialog.signalingState === SignalingState.Initial || this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {\n        throw new Error(\"Response must have a body.\");\n      }\n    }\n\n    options.statusCode = options.statusCode || 200;\n    options.extraHeaders = options.extraHeaders || [];\n    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(contactHeader);\n    const response = super.accept(options);\n    const session = this.confirmedDialog;\n    const result = Object.assign(Object.assign({}, response), {\n      session\n    }); // Update dialog signaling state\n\n    if (options.body) {\n      // Once the UAS has sent or received an answer to the initial\n      // offer, it MUST NOT generate subsequent offers in any responses\n      // to the initial INVITE.  This means that a UAS based on this\n      // specification alone can never generate subsequent offers until\n      // completion of the initial transaction.\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      if (this.confirmedDialog.signalingState !== SignalingState.Stable) {\n        this.confirmedDialog.signalingStateTransition(options.body);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * 13.3.1.1 Progress\n   * If the UAS is not able to answer the invitation immediately, it can\n   * choose to indicate some kind of progress to the UAC (for example, an\n   * indication that a phone is ringing).  This is accomplished with a\n   * provisional response between 101 and 199.  These provisional\n   * responses establish early dialogs and therefore follow the procedures\n   * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY\n   * send as many provisional responses as it likes.  Each of these MUST\n   * indicate the same dialog ID.  However, these will not be delivered\n   * reliably.\n   *\n   * If the UAS desires an extended period of time to answer the INVITE,\n   * it will need to ask for an \"extension\" in order to prevent proxies\n   * from canceling the transaction.  A proxy has the option of canceling\n   * a transaction when there is a gap of 3 minutes between responses in a\n   * transaction.  To prevent cancellation, the UAS MUST send a non-100\n   * provisional response at every minute, to handle the possibility of\n   * lost provisional responses.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.1\n   * @param options - Progress options bucket.\n   */\n\n\n  progress(options = {\n    statusCode: 180\n  }) {\n    if (!this.progressable) {\n      throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n    } // This response establishes a dialog...\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n    if (!this.earlyDialog) {\n      const transaction = this.transaction;\n\n      if (!(transaction instanceof InviteServerTransaction)) {\n        throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n      }\n\n      const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);\n      this.earlyDialog = new SessionDialog(transaction, this.core, state);\n    } // When a UAS responds to a request with a response that establishes a\n    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n    // header field values from the request into the response (including the\n    // URIs, URI parameters, and any Record-Route header field parameters,\n    // whether they are known or unknown to the UAS) and MUST maintain the\n    // order of those values.  The UAS MUST add a Contact header field to\n    // the response.  The Contact header field contains an address where the\n    // UAS would like to be contacted for subsequent requests in the dialog\n    // (which includes the ACK for a 2xx response in the case of an INVITE).\n    // Generally, the host portion of this URI is the IP address or FQDN of\n    // the host.  The URI provided in the Contact header field MUST be a SIP\n    // or SIPS URI.  If the request that initiated the dialog contained a\n    // SIPS URI in the Request-URI or in the top Record-Route header field\n    // value, if there was any, or the Contact header field if there was no\n    // Record-Route header field, the Contact header field in the response\n    // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n    // same URI can be used in messages outside this dialog).  The same way,\n    // the scope of the URI in the Contact header field of the INVITE is not\n    // limited to this dialog either.  It can therefore be used in messages\n    // to the UAC even outside this dialog.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n    const recordRouteHeader = this.message.getHeaders(\"record-route\").map(header => `Record-Route: ${header}`);\n    const contactHeader = `Contact: ${this.core.configuration.contact}`;\n    options.extraHeaders = options.extraHeaders || [];\n    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n    options.extraHeaders.push(contactHeader);\n    const response = super.progress(options);\n    const session = this.earlyDialog;\n    const result = Object.assign(Object.assign({}, response), {\n      session\n    }); // Update dialog signaling state\n\n    if (options.body) {\n      // Once the UAS has sent or received an answer to the initial\n      // offer, it MUST NOT generate subsequent offers in any responses\n      // to the initial INVITE.  This means that a UAS based on this\n      // specification alone can never generate subsequent offers until\n      // completion of the initial transaction.\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      if (this.earlyDialog.signalingState !== SignalingState.Stable) {\n        this.earlyDialog.signalingStateTransition(options.body);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * 13.3.1.2 The INVITE is Redirected\n   * If the UAS decides to redirect the call, a 3xx response is sent.  A\n   * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved\n   * Temporarily) response SHOULD contain a Contact header field\n   * containing one or more URIs of new addresses to be tried.  The\n   * response is passed to the INVITE server transaction, which will deal\n   * with its retransmissions.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.2\n   * @param contacts - Contacts to redirect to.\n   * @param options - Redirect options bucket.\n   */\n\n\n  redirect(contacts, options = {\n    statusCode: 302\n  }) {\n    return super.redirect(contacts, options);\n  }\n  /**\n   * 13.3.1.3 The INVITE is Rejected\n   * A common scenario occurs when the callee is currently not willing or\n   * able to take additional calls at this end system.  A 486 (Busy Here)\n   * SHOULD be returned in such a scenario.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n   * @param options - Reject options bucket.\n   */\n\n\n  reject(options = {\n    statusCode: 486\n  }) {\n    return super.reject(options);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js"],"names":["Dialog","SessionDialog","TransactionStateError","SignalingState","InviteServerTransaction","AllowedMethods","UserAgentServer","InviteUserAgentServer","constructor","core","message","delegate","dispose","earlyDialog","accept","options","statusCode","acceptable","method","transaction","state","confirmedDialog","confirm","undefined","Error","initialDialogStateForUserAgentServer","toTag","recordRouteHeader","getHeaders","map","header","contactHeader","configuration","contact","toString","allowHeader","body","signalingState","Stable","answer","Initial","HaveRemoteOffer","extraHeaders","concat","push","response","session","result","Object","assign","signalingStateTransition","progress","progressable","redirect","contacts","reject"],"mappings":"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","sourcesContent":["import { Dialog, SessionDialog } from \"../dialogs\";\nimport { TransactionStateError } from \"../exceptions\";\nimport { SignalingState } from \"../session\";\nimport { InviteServerTransaction } from \"../transactions\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { UserAgentServer } from \"./user-agent-server\";\n/**\n * INVITE UAS.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.3 UAS Processing\n * https://tools.ietf.org/html/rfc3261#section-13.3\n * @public\n */\nexport class InviteUserAgentServer extends UserAgentServer {\n    constructor(core, message, delegate) {\n        super(InviteServerTransaction, core, message, delegate);\n        this.core = core;\n    }\n    dispose() {\n        if (this.earlyDialog) {\n            this.earlyDialog.dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * 13.3.1.4 The INVITE is Accepted\n     * The UAS core generates a 2xx response.  This response establishes a\n     * dialog, and therefore follows the procedures of Section 12.1.1 in\n     * addition to those of Section 8.2.6.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n     * @param options - Accept options bucket.\n     */\n    accept(options = { statusCode: 200 }) {\n        if (!this.acceptable) {\n            throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n        }\n        // This response establishes a dialog...\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!this.confirmedDialog) {\n            if (this.earlyDialog) {\n                this.earlyDialog.confirm();\n                this.confirmedDialog = this.earlyDialog;\n                this.earlyDialog = undefined;\n            }\n            else {\n                const transaction = this.transaction;\n                if (!(transaction instanceof InviteServerTransaction)) {\n                    throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                }\n                const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);\n                this.confirmedDialog = new SessionDialog(transaction, this.core, state);\n            }\n        }\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.  The Contact header field contains an address where the\n        // UAS would like to be contacted for subsequent requests in the dialog\n        // (which includes the ACK for a 2xx response in the case of an INVITE).\n        // Generally, the host portion of this URI is the IP address or FQDN of\n        // the host.  The URI provided in the Contact header field MUST be a SIP\n        // or SIPS URI.  If the request that initiated the dialog contained a\n        // SIPS URI in the Request-URI or in the top Record-Route header field\n        // value, if there was any, or the Contact header field if there was no\n        // Record-Route header field, the Contact header field in the response\n        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n        // same URI can be used in messages outside this dialog).  The same way,\n        // the scope of the URI in the Contact header field of the INVITE is not\n        // limited to this dialog either.  It can therefore be used in messages\n        // to the UAC even outside this dialog.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const recordRouteHeader = this.message.getHeaders(\"record-route\").map((header) => `Record-Route: ${header}`);\n        const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`;\n        // A 2xx response to an INVITE SHOULD contain the Allow header field and\n        // the Supported header field, and MAY contain the Accept header field.\n        // Including these header fields allows the UAC to determine the\n        // features and extensions supported by the UAS for the duration of the\n        // call, without probing.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        // FIXME: TODO: This should not be hard coded.\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        // FIXME: TODO: Supported header (see reply())\n        // FIXME: TODO: Accept header\n        // If the INVITE request contained an offer, and the UAS had not yet\n        // sent an answer, the 2xx MUST contain an answer.  If the INVITE did\n        // not contain an offer, the 2xx MUST contain an offer if the UAS had\n        // not yet sent an offer.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!options.body) {\n            if (this.confirmedDialog.signalingState === SignalingState.Stable) {\n                options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response\n            }\n            else if (this.confirmedDialog.signalingState === SignalingState.Initial ||\n                this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {\n                throw new Error(\"Response must have a body.\");\n            }\n        }\n        options.statusCode = options.statusCode || 200;\n        options.extraHeaders = options.extraHeaders || [];\n        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(contactHeader);\n        const response = super.accept(options);\n        const session = this.confirmedDialog;\n        const result = Object.assign(Object.assign({}, response), { session });\n        // Update dialog signaling state\n        if (options.body) {\n            // Once the UAS has sent or received an answer to the initial\n            // offer, it MUST NOT generate subsequent offers in any responses\n            // to the initial INVITE.  This means that a UAS based on this\n            // specification alone can never generate subsequent offers until\n            // completion of the initial transaction.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            if (this.confirmedDialog.signalingState !== SignalingState.Stable) {\n                this.confirmedDialog.signalingStateTransition(options.body);\n            }\n        }\n        return result;\n    }\n    /**\n     * 13.3.1.1 Progress\n     * If the UAS is not able to answer the invitation immediately, it can\n     * choose to indicate some kind of progress to the UAC (for example, an\n     * indication that a phone is ringing).  This is accomplished with a\n     * provisional response between 101 and 199.  These provisional\n     * responses establish early dialogs and therefore follow the procedures\n     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY\n     * send as many provisional responses as it likes.  Each of these MUST\n     * indicate the same dialog ID.  However, these will not be delivered\n     * reliably.\n     *\n     * If the UAS desires an extended period of time to answer the INVITE,\n     * it will need to ask for an \"extension\" in order to prevent proxies\n     * from canceling the transaction.  A proxy has the option of canceling\n     * a transaction when there is a gap of 3 minutes between responses in a\n     * transaction.  To prevent cancellation, the UAS MUST send a non-100\n     * provisional response at every minute, to handle the possibility of\n     * lost provisional responses.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1\n     * @param options - Progress options bucket.\n     */\n    progress(options = { statusCode: 180 }) {\n        if (!this.progressable) {\n            throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n        }\n        // This response establishes a dialog...\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!this.earlyDialog) {\n            const transaction = this.transaction;\n            if (!(transaction instanceof InviteServerTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n            const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);\n            this.earlyDialog = new SessionDialog(transaction, this.core, state);\n        }\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.  The Contact header field contains an address where the\n        // UAS would like to be contacted for subsequent requests in the dialog\n        // (which includes the ACK for a 2xx response in the case of an INVITE).\n        // Generally, the host portion of this URI is the IP address or FQDN of\n        // the host.  The URI provided in the Contact header field MUST be a SIP\n        // or SIPS URI.  If the request that initiated the dialog contained a\n        // SIPS URI in the Request-URI or in the top Record-Route header field\n        // value, if there was any, or the Contact header field if there was no\n        // Record-Route header field, the Contact header field in the response\n        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n        // same URI can be used in messages outside this dialog).  The same way,\n        // the scope of the URI in the Contact header field of the INVITE is not\n        // limited to this dialog either.  It can therefore be used in messages\n        // to the UAC even outside this dialog.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const recordRouteHeader = this.message.getHeaders(\"record-route\").map((header) => `Record-Route: ${header}`);\n        const contactHeader = `Contact: ${this.core.configuration.contact}`;\n        options.extraHeaders = options.extraHeaders || [];\n        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n        options.extraHeaders.push(contactHeader);\n        const response = super.progress(options);\n        const session = this.earlyDialog;\n        const result = Object.assign(Object.assign({}, response), { session });\n        // Update dialog signaling state\n        if (options.body) {\n            // Once the UAS has sent or received an answer to the initial\n            // offer, it MUST NOT generate subsequent offers in any responses\n            // to the initial INVITE.  This means that a UAS based on this\n            // specification alone can never generate subsequent offers until\n            // completion of the initial transaction.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            if (this.earlyDialog.signalingState !== SignalingState.Stable) {\n                this.earlyDialog.signalingStateTransition(options.body);\n            }\n        }\n        return result;\n    }\n    /**\n     * 13.3.1.2 The INVITE is Redirected\n     * If the UAS decides to redirect the call, a 3xx response is sent.  A\n     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved\n     * Temporarily) response SHOULD contain a Contact header field\n     * containing one or more URIs of new addresses to be tried.  The\n     * response is passed to the INVITE server transaction, which will deal\n     * with its retransmissions.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2\n     * @param contacts - Contacts to redirect to.\n     * @param options - Redirect options bucket.\n     */\n    redirect(contacts, options = { statusCode: 302 }) {\n        return super.redirect(contacts, options);\n    }\n    /**\n     * 13.3.1.3 The INVITE is Rejected\n     * A common scenario occurs when the callee is currently not willing or\n     * able to take additional calls at this end system.  A 486 (Busy Here)\n     * SHOULD be returned in such a scenario.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n     * @param options - Reject options bucket.\n     */\n    reject(options = { statusCode: 486 }) {\n        return super.reject(options);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}