{"ast":null,"code":"import { Dialog, SessionDialog } from \"../dialogs\";\nimport { SignalingState } from \"../session\";\nimport { InviteClientTransaction, TransactionState } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * INVITE UAC.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.2 UAC Processing\n * https://tools.ietf.org/html/rfc3261#section-13.2\n * @public\n */\n\nexport class InviteUserAgentClient extends UserAgentClient {\n  constructor(core, message, delegate) {\n    super(InviteClientTransaction, core, message, delegate);\n    this.confirmedDialogAcks = new Map();\n    this.confirmedDialogs = new Map();\n    this.earlyDialogs = new Map();\n    this.delegate = delegate;\n  }\n\n  dispose() {\n    // The UAC core considers the INVITE transaction completed 64*T1 seconds\n    // after the reception of the first 2xx response.  At this point all the\n    // early dialogs that have not transitioned to established dialogs are\n    // terminated.  Once the INVITE transaction is considered completed by\n    // the UAC core, no more new 2xx responses are expected to arrive.\n    //\n    // If, after acknowledging any 2xx response to an INVITE, the UAC does\n    // not want to continue with that dialog, then the UAC MUST terminate\n    // the dialog by sending a BYE request as described in Section 15.\n    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n    this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n    this.earlyDialogs.clear();\n    super.dispose();\n  }\n  /**\n   * Special case for transport error while sending ACK.\n   * @param error - Transport error\n   */\n\n\n  onTransportError(error) {\n    if (this.transaction.state === TransactionState.Calling) {\n      return super.onTransportError(error);\n    } // If not in 'calling' state, the transport error occurred while sending an ACK.\n\n\n    this.logger.error(error.message);\n    this.logger.error(\"User agent client request transport error while sending ACK.\");\n  }\n  /**\n   * Once the INVITE has been passed to the INVITE client transaction, the\n   * UAC waits for responses for the INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.2\n   * @param incomingResponse - Incoming response to INVITE request.\n   */\n\n\n  receiveResponse(message) {\n    if (!this.authenticationGuard(message)) {\n      return;\n    }\n\n    const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    }\n\n    switch (true) {\n      case /^100$/.test(statusCode):\n        if (this.delegate && this.delegate.onTrying) {\n          this.delegate.onTrying({\n            message\n          });\n        }\n\n        return;\n\n      case /^1[0-9]{2}$/.test(statusCode):\n        // Zero, one or multiple provisional responses may arrive before one or\n        // more final responses are received.  Provisional responses for an\n        // INVITE request can create \"early dialogs\".  If a provisional response\n        // has a tag in the To field, and if the dialog ID of the response does\n        // not match an existing dialog, one is constructed using the procedures\n        // defined in Section 12.1.2.\n        //\n        // The early dialog will only be needed if the UAC needs to send a\n        // request to its peer within the dialog before the initial INVITE\n        // transaction completes.  Header fields present in a provisional\n        // response are applicable as long as the dialog is in the early state\n        // (for example, an Allow header field in a provisional response\n        // contains the methods that can be used in the dialog while this is in\n        // the early state).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.1\n        {\n          // Dialogs are created through the generation of non-failure responses\n          // to requests with specific methods.  Within this specification, only\n          // 2xx and 101-199 responses with a To tag, where the request was\n          // INVITE, will establish a dialog.  A dialog established by a non-final\n          // response to a request is in the \"early\" state and it is called an\n          // early dialog.\n          // https://tools.ietf.org/html/rfc3261#section-12.1\n          // Provisional without to tag, no dialog to create.\n          if (!message.toTag) {\n            this.logger.warn(\"Non-100 1xx INVITE response received without a to tag, dropping.\");\n            return;\n          } // When a UAS responds to a request with a response that establishes a\n          // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n          // header field values from the request into the response (including the\n          // URIs, URI parameters, and any Record-Route header field parameters,\n          // whether they are known or unknown to the UAS) and MUST maintain the\n          // order of those values.  The UAS MUST add a Contact header field to\n          // the response.\n          // https://tools.ietf.org/html/rfc3261#section-12.1.1\n          // Provisional without Contact header field, malformed response.\n\n\n          const contact = message.parseHeader(\"contact\");\n\n          if (!contact) {\n            this.logger.error(\"Non-100 1xx INVITE response received without a Contact header field, dropping.\");\n            return;\n          } // Compute dialog state.\n\n\n          const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // Have existing early dialog or create a new one.\n\n          let earlyDialog = this.earlyDialogs.get(dialogState.id);\n\n          if (!earlyDialog) {\n            const transaction = this.transaction;\n\n            if (!(transaction instanceof InviteClientTransaction)) {\n              throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n\n            earlyDialog = new SessionDialog(transaction, this.core, dialogState);\n            this.earlyDialogs.set(earlyDialog.id, earlyDialog);\n          } // Guard against out of order reliable provisional responses.\n          // Note that this is where the rseq tracking is done.\n\n\n          if (!earlyDialog.reliableSequenceGuard(message)) {\n            this.logger.warn(\"1xx INVITE reliable response received out of order or is a retransmission, dropping.\");\n            return;\n          } // If the initial offer is in an INVITE, the answer MUST be in a\n          // reliable non-failure message from UAS back to UAC which is\n          // correlated to that INVITE.  For this specification, that is\n          // only the final 2xx response to that INVITE.  That same exact\n          // answer MAY also be placed in any provisional responses sent\n          // prior to the answer.  The UAC MUST treat the first session\n          // description it receives as the answer, and MUST ignore any\n          // session descriptions in subsequent responses to the initial\n          // INVITE.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n          if (earlyDialog.signalingState === SignalingState.Initial || earlyDialog.signalingState === SignalingState.HaveLocalOffer) {\n            earlyDialog.signalingStateTransition(message);\n          } // Pass response to delegate.\n\n\n          const session = earlyDialog;\n\n          if (this.delegate && this.delegate.onProgress) {\n            this.delegate.onProgress({\n              message,\n              session,\n              prack: options => {\n                const outgoingPrackRequest = session.prack(undefined, options);\n                return outgoingPrackRequest;\n              }\n            });\n          }\n        }\n        return;\n\n      case /^2[0-9]{2}$/.test(statusCode):\n        // Multiple 2xx responses may arrive at the UAC for a single INVITE\n        // request due to a forking proxy.  Each response is distinguished by\n        // the tag parameter in the To header field, and each represents a\n        // distinct dialog, with a distinct dialog identifier.\n        //\n        // If the dialog identifier in the 2xx response matches the dialog\n        // identifier of an existing dialog, the dialog MUST be transitioned to\n        // the \"confirmed\" state, and the route set for the dialog MUST be\n        // recomputed based on the 2xx response using the procedures of Section\n        // 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n        // constructed using the procedures of Section 12.1.2.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n        {\n          // Dialogs are created through the generation of non-failure responses\n          // to requests with specific methods.  Within this specification, only\n          // 2xx and 101-199 responses with a To tag, where the request was\n          // INVITE, will establish a dialog.  A dialog established by a non-final\n          // response to a request is in the \"early\" state and it is called an\n          // early dialog.\n          // https://tools.ietf.org/html/rfc3261#section-12.1\n          // Final without to tag, malformed response.\n          if (!message.toTag) {\n            this.logger.error(\"2xx INVITE response received without a to tag, dropping.\");\n            return;\n          } // When a UAS responds to a request with a response that establishes a\n          // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n          // header field values from the request into the response (including the\n          // URIs, URI parameters, and any Record-Route header field parameters,\n          // whether they are known or unknown to the UAS) and MUST maintain the\n          // order of those values.  The UAS MUST add a Contact header field to\n          // the response.\n          // https://tools.ietf.org/html/rfc3261#section-12.1.1\n          // Final without Contact header field, malformed response.\n\n\n          const contact = message.parseHeader(\"contact\");\n\n          if (!contact) {\n            this.logger.error(\"2xx INVITE response received without a Contact header field, dropping.\");\n            return;\n          } // Compute dialog state.\n\n\n          const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // NOTE: Currently our transaction layer is caching the 2xx ACKs and\n          // handling retransmissions of the ACK which is an approach which is\n          // not to spec. In any event, this block is intended to provide a to\n          // spec implementation of ACK retransmissions, but it should not be\n          // hit currently.\n\n          let dialog = this.confirmedDialogs.get(dialogState.id);\n\n          if (dialog) {\n            // Once the ACK has been constructed, the procedures of [4] are used to\n            // determine the destination address, port and transport.  However, the\n            // request is passed to the transport layer directly for transmission,\n            // rather than a client transaction.  This is because the UAC core\n            // handles retransmissions of the ACK, not the transaction layer.  The\n            // ACK MUST be passed to the client transport every time a\n            // retransmission of the 2xx final response that triggered the ACK\n            // arrives.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n            const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);\n\n            if (outgoingAckRequest) {\n              const transaction = this.transaction;\n\n              if (!(transaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Client transaction not instance of InviteClientTransaction.\");\n              }\n\n              transaction.ackResponse(outgoingAckRequest.message);\n            } else {// If still waiting for an ACK, drop the retransmission of the 2xx final response.\n            }\n\n            return;\n          } // If the dialog identifier in the 2xx response matches the dialog\n          // identifier of an existing dialog, the dialog MUST be transitioned to\n          // the \"confirmed\" state, and the route set for the dialog MUST be\n          // recomputed based on the 2xx response using the procedures of Section\n          // 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be\n          // constructed using the procedures of Section 12.1.2.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n\n          dialog = this.earlyDialogs.get(dialogState.id);\n\n          if (dialog) {\n            dialog.confirm();\n            dialog.recomputeRouteSet(message);\n            this.earlyDialogs.delete(dialog.id);\n            this.confirmedDialogs.set(dialog.id, dialog);\n          } else {\n            const transaction = this.transaction;\n\n            if (!(transaction instanceof InviteClientTransaction)) {\n              throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n\n            dialog = new SessionDialog(transaction, this.core, dialogState);\n            this.confirmedDialogs.set(dialog.id, dialog);\n          } // If the initial offer is in an INVITE, the answer MUST be in a\n          // reliable non-failure message from UAS back to UAC which is\n          // correlated to that INVITE.  For this specification, that is\n          // only the final 2xx response to that INVITE.  That same exact\n          // answer MAY also be placed in any provisional responses sent\n          // prior to the answer.  The UAC MUST treat the first session\n          // description it receives as the answer, and MUST ignore any\n          // session descriptions in subsequent responses to the initial\n          // INVITE.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n          if (dialog.signalingState === SignalingState.Initial || dialog.signalingState === SignalingState.HaveLocalOffer) {\n            dialog.signalingStateTransition(message);\n          } // Session Initiated! :)\n\n\n          const session = dialog; // The UAC core MUST generate an ACK request for each 2xx received from\n          // the transaction layer.  The header fields of the ACK are constructed\n          // in the same way as for any request sent within a dialog (see Section\n          // 12) with the exception of the CSeq and the header fields related to\n          // authentication.  The sequence number of the CSeq header field MUST be\n          // the same as the INVITE being acknowledged, but the CSeq method MUST\n          // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n          // the 2xx contains an offer (based on the rules above), the ACK MUST\n          // carry an answer in its body.  If the offer in the 2xx response is not\n          // acceptable, the UAC core MUST generate a valid answer in the ACK and\n          // then send a BYE immediately.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n          if (this.delegate && this.delegate.onAccept) {\n            this.delegate.onAccept({\n              message,\n              session,\n              ack: options => {\n                const outgoingAckRequest = session.ack(options);\n                this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                return outgoingAckRequest;\n              }\n            });\n          } else {\n            const outgoingAckRequest = session.ack();\n            this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n          }\n        }\n        return;\n\n      case /^3[0-9]{2}$/.test(statusCode):\n        // 12.3 Termination of a Dialog\n        //\n        // Independent of the method, if a request outside of a dialog generates\n        // a non-2xx final response, any early dialogs created through\n        // provisional responses to that request are terminated.  The mechanism\n        // for terminating confirmed dialogs is method specific.  In this\n        // specification, the BYE method terminates a session and the dialog\n        // associated with it.  See Section 15 for details.\n        // https://tools.ietf.org/html/rfc3261#section-12.3\n        // All early dialogs are considered terminated upon reception of the\n        // non-2xx final response.\n        //\n        // After having received the non-2xx final response the UAC core\n        // considers the INVITE transaction completed.  The INVITE client\n        // transaction handles the generation of ACKs for the response (see\n        // Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n        this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n        this.earlyDialogs.clear(); // A 3xx response may contain one or more Contact header field values\n        // providing new addresses where the callee might be reachable.\n        // Depending on the status code of the 3xx response (see Section 21.3),\n        // the UAC MAY choose to try those new addresses.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.2\n\n        if (this.delegate && this.delegate.onRedirect) {\n          this.delegate.onRedirect({\n            message\n          });\n        }\n\n        return;\n\n      case /^[4-6][0-9]{2}$/.test(statusCode):\n        // 12.3 Termination of a Dialog\n        //\n        // Independent of the method, if a request outside of a dialog generates\n        // a non-2xx final response, any early dialogs created through\n        // provisional responses to that request are terminated.  The mechanism\n        // for terminating confirmed dialogs is method specific.  In this\n        // specification, the BYE method terminates a session and the dialog\n        // associated with it.  See Section 15 for details.\n        // https://tools.ietf.org/html/rfc3261#section-12.3\n        // All early dialogs are considered terminated upon reception of the\n        // non-2xx final response.\n        //\n        // After having received the non-2xx final response the UAC core\n        // considers the INVITE transaction completed.  The INVITE client\n        // transaction handles the generation of ACKs for the response (see\n        // Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n        this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n        this.earlyDialogs.clear(); // A single non-2xx final response may be received for the INVITE.  4xx,\n        // 5xx and 6xx responses may contain a Contact header field value\n        // indicating the location where additional information about the error\n        // can be found.  Subsequent final responses (which would only arrive\n        // under error conditions) MUST be ignored.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n\n        if (this.delegate && this.delegate.onReject) {\n          this.delegate.onReject({\n            message\n          });\n        }\n\n        return;\n\n      default:\n        throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    throw new Error(`Executing what should be an unreachable code path receiving ${statusCode} response.`);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js"],"names":["Dialog","SessionDialog","SignalingState","InviteClientTransaction","TransactionState","UserAgentClient","InviteUserAgentClient","constructor","core","message","delegate","confirmedDialogAcks","Map","confirmedDialogs","earlyDialogs","dispose","forEach","earlyDialog","clear","onTransportError","error","transaction","state","Calling","logger","receiveResponse","authenticationGuard","statusCode","toString","Error","test","onTrying","toTag","warn","contact","parseHeader","dialogState","initialDialogStateForUserAgentClient","get","id","set","reliableSequenceGuard","signalingState","Initial","HaveLocalOffer","signalingStateTransition","session","onProgress","prack","options","outgoingPrackRequest","undefined","dialog","outgoingAckRequest","ackResponse","confirm","recomputeRouteSet","delete","onAccept","ack","onRedirect","onReject"],"mappings":"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","sourcesContent":["import { Dialog, SessionDialog } from \"../dialogs\";\nimport { SignalingState } from \"../session\";\nimport { InviteClientTransaction, TransactionState } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * INVITE UAC.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.2 UAC Processing\n * https://tools.ietf.org/html/rfc3261#section-13.2\n * @public\n */\nexport class InviteUserAgentClient extends UserAgentClient {\n    constructor(core, message, delegate) {\n        super(InviteClientTransaction, core, message, delegate);\n        this.confirmedDialogAcks = new Map();\n        this.confirmedDialogs = new Map();\n        this.earlyDialogs = new Map();\n        this.delegate = delegate;\n    }\n    dispose() {\n        // The UAC core considers the INVITE transaction completed 64*T1 seconds\n        // after the reception of the first 2xx response.  At this point all the\n        // early dialogs that have not transitioned to established dialogs are\n        // terminated.  Once the INVITE transaction is considered completed by\n        // the UAC core, no more new 2xx responses are expected to arrive.\n        //\n        // If, after acknowledging any 2xx response to an INVITE, the UAC does\n        // not want to continue with that dialog, then the UAC MUST terminate\n        // the dialog by sending a BYE request as described in Section 15.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n        this.earlyDialogs.clear();\n        super.dispose();\n    }\n    /**\n     * Special case for transport error while sending ACK.\n     * @param error - Transport error\n     */\n    onTransportError(error) {\n        if (this.transaction.state === TransactionState.Calling) {\n            return super.onTransportError(error);\n        }\n        // If not in 'calling' state, the transport error occurred while sending an ACK.\n        this.logger.error(error.message);\n        this.logger.error(\"User agent client request transport error while sending ACK.\");\n    }\n    /**\n     * Once the INVITE has been passed to the INVITE client transaction, the\n     * UAC waits for responses for the INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2\n     * @param incomingResponse - Incoming response to INVITE request.\n     */\n    receiveResponse(message) {\n        if (!this.authenticationGuard(message)) {\n            return;\n        }\n        const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        switch (true) {\n            case /^100$/.test(statusCode):\n                if (this.delegate && this.delegate.onTrying) {\n                    this.delegate.onTrying({ message });\n                }\n                return;\n            case /^1[0-9]{2}$/.test(statusCode):\n                // Zero, one or multiple provisional responses may arrive before one or\n                // more final responses are received.  Provisional responses for an\n                // INVITE request can create \"early dialogs\".  If a provisional response\n                // has a tag in the To field, and if the dialog ID of the response does\n                // not match an existing dialog, one is constructed using the procedures\n                // defined in Section 12.1.2.\n                //\n                // The early dialog will only be needed if the UAC needs to send a\n                // request to its peer within the dialog before the initial INVITE\n                // transaction completes.  Header fields present in a provisional\n                // response are applicable as long as the dialog is in the early state\n                // (for example, an Allow header field in a provisional response\n                // contains the methods that can be used in the dialog while this is in\n                // the early state).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.1\n                {\n                    // Dialogs are created through the generation of non-failure responses\n                    // to requests with specific methods.  Within this specification, only\n                    // 2xx and 101-199 responses with a To tag, where the request was\n                    // INVITE, will establish a dialog.  A dialog established by a non-final\n                    // response to a request is in the \"early\" state and it is called an\n                    // early dialog.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1\n                    // Provisional without to tag, no dialog to create.\n                    if (!message.toTag) {\n                        this.logger.warn(\"Non-100 1xx INVITE response received without a to tag, dropping.\");\n                        return;\n                    }\n                    // When a UAS responds to a request with a response that establishes a\n                    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n                    // header field values from the request into the response (including the\n                    // URIs, URI parameters, and any Record-Route header field parameters,\n                    // whether they are known or unknown to the UAS) and MUST maintain the\n                    // order of those values.  The UAS MUST add a Contact header field to\n                    // the response.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n                    // Provisional without Contact header field, malformed response.\n                    const contact = message.parseHeader(\"contact\");\n                    if (!contact) {\n                        this.logger.error(\"Non-100 1xx INVITE response received without a Contact header field, dropping.\");\n                        return;\n                    }\n                    // Compute dialog state.\n                    const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message);\n                    // Have existing early dialog or create a new one.\n                    let earlyDialog = this.earlyDialogs.get(dialogState.id);\n                    if (!earlyDialog) {\n                        const transaction = this.transaction;\n                        if (!(transaction instanceof InviteClientTransaction)) {\n                            throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                        }\n                        earlyDialog = new SessionDialog(transaction, this.core, dialogState);\n                        this.earlyDialogs.set(earlyDialog.id, earlyDialog);\n                    }\n                    // Guard against out of order reliable provisional responses.\n                    // Note that this is where the rseq tracking is done.\n                    if (!earlyDialog.reliableSequenceGuard(message)) {\n                        this.logger.warn(\"1xx INVITE reliable response received out of order or is a retransmission, dropping.\");\n                        return;\n                    }\n                    // If the initial offer is in an INVITE, the answer MUST be in a\n                    // reliable non-failure message from UAS back to UAC which is\n                    // correlated to that INVITE.  For this specification, that is\n                    // only the final 2xx response to that INVITE.  That same exact\n                    // answer MAY also be placed in any provisional responses sent\n                    // prior to the answer.  The UAC MUST treat the first session\n                    // description it receives as the answer, and MUST ignore any\n                    // session descriptions in subsequent responses to the initial\n                    // INVITE.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    if (earlyDialog.signalingState === SignalingState.Initial ||\n                        earlyDialog.signalingState === SignalingState.HaveLocalOffer) {\n                        earlyDialog.signalingStateTransition(message);\n                    }\n                    // Pass response to delegate.\n                    const session = earlyDialog;\n                    if (this.delegate && this.delegate.onProgress) {\n                        this.delegate.onProgress({\n                            message,\n                            session,\n                            prack: (options) => {\n                                const outgoingPrackRequest = session.prack(undefined, options);\n                                return outgoingPrackRequest;\n                            }\n                        });\n                    }\n                }\n                return;\n            case /^2[0-9]{2}$/.test(statusCode):\n                // Multiple 2xx responses may arrive at the UAC for a single INVITE\n                // request due to a forking proxy.  Each response is distinguished by\n                // the tag parameter in the To header field, and each represents a\n                // distinct dialog, with a distinct dialog identifier.\n                //\n                // If the dialog identifier in the 2xx response matches the dialog\n                // identifier of an existing dialog, the dialog MUST be transitioned to\n                // the \"confirmed\" state, and the route set for the dialog MUST be\n                // recomputed based on the 2xx response using the procedures of Section\n                // 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n                // constructed using the procedures of Section 12.1.2.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                {\n                    // Dialogs are created through the generation of non-failure responses\n                    // to requests with specific methods.  Within this specification, only\n                    // 2xx and 101-199 responses with a To tag, where the request was\n                    // INVITE, will establish a dialog.  A dialog established by a non-final\n                    // response to a request is in the \"early\" state and it is called an\n                    // early dialog.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1\n                    // Final without to tag, malformed response.\n                    if (!message.toTag) {\n                        this.logger.error(\"2xx INVITE response received without a to tag, dropping.\");\n                        return;\n                    }\n                    // When a UAS responds to a request with a response that establishes a\n                    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n                    // header field values from the request into the response (including the\n                    // URIs, URI parameters, and any Record-Route header field parameters,\n                    // whether they are known or unknown to the UAS) and MUST maintain the\n                    // order of those values.  The UAS MUST add a Contact header field to\n                    // the response.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n                    // Final without Contact header field, malformed response.\n                    const contact = message.parseHeader(\"contact\");\n                    if (!contact) {\n                        this.logger.error(\"2xx INVITE response received without a Contact header field, dropping.\");\n                        return;\n                    }\n                    // Compute dialog state.\n                    const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message);\n                    // NOTE: Currently our transaction layer is caching the 2xx ACKs and\n                    // handling retransmissions of the ACK which is an approach which is\n                    // not to spec. In any event, this block is intended to provide a to\n                    // spec implementation of ACK retransmissions, but it should not be\n                    // hit currently.\n                    let dialog = this.confirmedDialogs.get(dialogState.id);\n                    if (dialog) {\n                        // Once the ACK has been constructed, the procedures of [4] are used to\n                        // determine the destination address, port and transport.  However, the\n                        // request is passed to the transport layer directly for transmission,\n                        // rather than a client transaction.  This is because the UAC core\n                        // handles retransmissions of the ACK, not the transaction layer.  The\n                        // ACK MUST be passed to the client transport every time a\n                        // retransmission of the 2xx final response that triggered the ACK\n                        // arrives.\n                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                        const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);\n                        if (outgoingAckRequest) {\n                            const transaction = this.transaction;\n                            if (!(transaction instanceof InviteClientTransaction)) {\n                                throw new Error(\"Client transaction not instance of InviteClientTransaction.\");\n                            }\n                            transaction.ackResponse(outgoingAckRequest.message);\n                        }\n                        else {\n                            // If still waiting for an ACK, drop the retransmission of the 2xx final response.\n                        }\n                        return;\n                    }\n                    // If the dialog identifier in the 2xx response matches the dialog\n                    // identifier of an existing dialog, the dialog MUST be transitioned to\n                    // the \"confirmed\" state, and the route set for the dialog MUST be\n                    // recomputed based on the 2xx response using the procedures of Section\n                    // 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be\n                    // constructed using the procedures of Section 12.1.2.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                    dialog = this.earlyDialogs.get(dialogState.id);\n                    if (dialog) {\n                        dialog.confirm();\n                        dialog.recomputeRouteSet(message);\n                        this.earlyDialogs.delete(dialog.id);\n                        this.confirmedDialogs.set(dialog.id, dialog);\n                    }\n                    else {\n                        const transaction = this.transaction;\n                        if (!(transaction instanceof InviteClientTransaction)) {\n                            throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                        }\n                        dialog = new SessionDialog(transaction, this.core, dialogState);\n                        this.confirmedDialogs.set(dialog.id, dialog);\n                    }\n                    // If the initial offer is in an INVITE, the answer MUST be in a\n                    // reliable non-failure message from UAS back to UAC which is\n                    // correlated to that INVITE.  For this specification, that is\n                    // only the final 2xx response to that INVITE.  That same exact\n                    // answer MAY also be placed in any provisional responses sent\n                    // prior to the answer.  The UAC MUST treat the first session\n                    // description it receives as the answer, and MUST ignore any\n                    // session descriptions in subsequent responses to the initial\n                    // INVITE.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    if (dialog.signalingState === SignalingState.Initial ||\n                        dialog.signalingState === SignalingState.HaveLocalOffer) {\n                        dialog.signalingStateTransition(message);\n                    }\n                    // Session Initiated! :)\n                    const session = dialog;\n                    // The UAC core MUST generate an ACK request for each 2xx received from\n                    // the transaction layer.  The header fields of the ACK are constructed\n                    // in the same way as for any request sent within a dialog (see Section\n                    // 12) with the exception of the CSeq and the header fields related to\n                    // authentication.  The sequence number of the CSeq header field MUST be\n                    // the same as the INVITE being acknowledged, but the CSeq method MUST\n                    // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n                    // the 2xx contains an offer (based on the rules above), the ACK MUST\n                    // carry an answer in its body.  If the offer in the 2xx response is not\n                    // acceptable, the UAC core MUST generate a valid answer in the ACK and\n                    // then send a BYE immediately.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                    if (this.delegate && this.delegate.onAccept) {\n                        this.delegate.onAccept({\n                            message,\n                            session,\n                            ack: (options) => {\n                                const outgoingAckRequest = session.ack(options);\n                                this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                                return outgoingAckRequest;\n                            }\n                        });\n                    }\n                    else {\n                        const outgoingAckRequest = session.ack();\n                        this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                    }\n                }\n                return;\n            case /^3[0-9]{2}$/.test(statusCode):\n                // 12.3 Termination of a Dialog\n                //\n                // Independent of the method, if a request outside of a dialog generates\n                // a non-2xx final response, any early dialogs created through\n                // provisional responses to that request are terminated.  The mechanism\n                // for terminating confirmed dialogs is method specific.  In this\n                // specification, the BYE method terminates a session and the dialog\n                // associated with it.  See Section 15 for details.\n                // https://tools.ietf.org/html/rfc3261#section-12.3\n                // All early dialogs are considered terminated upon reception of the\n                // non-2xx final response.\n                //\n                // After having received the non-2xx final response the UAC core\n                // considers the INVITE transaction completed.  The INVITE client\n                // transaction handles the generation of ACKs for the response (see\n                // Section 17).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n                this.earlyDialogs.clear();\n                // A 3xx response may contain one or more Contact header field values\n                // providing new addresses where the callee might be reachable.\n                // Depending on the status code of the 3xx response (see Section 21.3),\n                // the UAC MAY choose to try those new addresses.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.2\n                if (this.delegate && this.delegate.onRedirect) {\n                    this.delegate.onRedirect({ message });\n                }\n                return;\n            case /^[4-6][0-9]{2}$/.test(statusCode):\n                // 12.3 Termination of a Dialog\n                //\n                // Independent of the method, if a request outside of a dialog generates\n                // a non-2xx final response, any early dialogs created through\n                // provisional responses to that request are terminated.  The mechanism\n                // for terminating confirmed dialogs is method specific.  In this\n                // specification, the BYE method terminates a session and the dialog\n                // associated with it.  See Section 15 for details.\n                // https://tools.ietf.org/html/rfc3261#section-12.3\n                // All early dialogs are considered terminated upon reception of the\n                // non-2xx final response.\n                //\n                // After having received the non-2xx final response the UAC core\n                // considers the INVITE transaction completed.  The INVITE client\n                // transaction handles the generation of ACKs for the response (see\n                // Section 17).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n                this.earlyDialogs.clear();\n                // A single non-2xx final response may be received for the INVITE.  4xx,\n                // 5xx and 6xx responses may contain a Contact header field value\n                // indicating the location where additional information about the error\n                // can be found.  Subsequent final responses (which would only arrive\n                // under error conditions) MUST be ignored.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                if (this.delegate && this.delegate.onReject) {\n                    this.delegate.onReject({ message });\n                }\n                return;\n            default:\n                throw new Error(`Invalid status code ${statusCode}`);\n        }\n        throw new Error(`Executing what should be an unreachable code path receiving ${statusCode} response.`);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}