{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Client Transaction.\n * @remarks\n * The INVITE transaction consists of a three-way handshake.  The client\n * transaction sends an INVITE, the server transaction sends responses,\n * and the client transaction sends an ACK.\n * https://tools.ietf.org/html/rfc3261#section-17.1.1\n * @public\n */\n\nexport var InviteClientTransaction = /*#__PURE__*/function (_ClientTransaction) {\n  _inherits(InviteClientTransaction, _ClientTransaction);\n\n  var _super = _createSuper(InviteClientTransaction);\n\n  /**\n   * Constructor.\n   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n   * Then `toString` is called on the outgoing request and the message is sent via the transport.\n   * After construction the transaction will be in the \"calling\" state and the transaction id\n   * will equal the branch parameter set in the Via header of the outgoing request.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1\n   * @param request - The outgoing INVITE request.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  function InviteClientTransaction(request, transport, user) {\n    var _this;\n\n    _classCallCheck(this, InviteClientTransaction);\n\n    _this = _super.call(this, request, transport, user, TransactionState.Calling, \"sip.transaction.ict\");\n    /**\n     * Map of 2xx to-tag to ACK.\n     * If value is not undefined, value is the ACK which was sent.\n     * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.\n     * Otherwise, a 2xx was not (yet) received for this transaction.\n     */\n\n    _this.ackRetransmissionCache = new Map(); // FIXME: Timer A for unreliable transport not implemented\n    //\n    // If an unreliable transport is being used, the client transaction\n    // MUST start timer A with a value of T1. If a reliable transport is being used,\n    // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).\n    // For any transport, the client transaction MUST start timer B with a value\n    // of 64*T1 seconds (Timer B controls transaction timeouts).\n    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n    //\n    // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n    // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n    // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n    _this.B = setTimeout(function () {\n      return _this.timerB();\n    }, Timers.TIMER_B);\n\n    _this.send(request.toString()).catch(function (error) {\n      _this.logTransportError(error, \"Failed to send initial outgoing request.\");\n    });\n\n    return _this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(InviteClientTransaction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.B) {\n        clearTimeout(this.B);\n        this.B = undefined;\n      }\n\n      if (this.D) {\n        clearTimeout(this.D);\n        this.D = undefined;\n      }\n\n      if (this.M) {\n        clearTimeout(this.M);\n        this.M = undefined;\n      }\n\n      _get(_getPrototypeOf(InviteClientTransaction.prototype), \"dispose\", this).call(this);\n    }\n    /** Transaction kind. Deprecated. */\n\n  }, {\n    key: \"ackResponse\",\n\n    /**\n     * ACK a 2xx final response.\n     *\n     * The transaction includes the ACK only if the final response was not a 2xx response (the\n     * transaction will generate and send the ACK to the transport automagically). If the\n     * final response was a 2xx, the ACK is not considered part of the transaction (the\n     * transaction user needs to generate and send the ACK).\n     *\n     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final\n     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled\n     * by the transaction layer (instead of the UAC core). The \"standard\" approach is for\n     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to\n     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses\n     * and any retransmissions of those ACKs as needed.\n     *\n     * @param ack - The outgoing ACK request.\n     */\n    value: function ackResponse(ack) {\n      var _this2 = this;\n\n      var toTag = ack.toTag;\n\n      if (!toTag) {\n        throw new Error(\"To tag undefined.\");\n      }\n\n      var id = \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n      ack.setViaHeader(id, this.transport.protocol);\n      this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache\n\n      this.send(ack.toString()).catch(function (error) {\n        _this2.logTransportError(error, \"Failed to send ACK to 2xx response.\");\n      });\n    }\n    /**\n     * Handler for incoming responses from the transport which match this transaction.\n     * @param response - The incoming response.\n     */\n\n  }, {\n    key: \"receiveResponse\",\n    value: function receiveResponse(response) {\n      var _this3 = this;\n\n      var statusCode = response.statusCode;\n\n      if (!statusCode || statusCode < 100 || statusCode > 699) {\n        throw new Error(\"Invalid status code \".concat(statusCode));\n      }\n\n      switch (this.state) {\n        case TransactionState.Calling:\n          // If the client transaction receives a provisional response while in\n          // the \"Calling\" state, it transitions to the \"Proceeding\" state. In the\n          // \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n          // request any longer. Furthermore, the provisional response MUST be\n          // passed to the TU.  Any further provisional responses MUST be passed\n          // up to the TU while in the \"Proceeding\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n          if (statusCode >= 100 && statusCode <= 199) {\n            this.stateTransition(TransactionState.Proceeding);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // When a 2xx response is received while in either the \"Calling\" or\n          // \"Proceeding\" states, the client transaction MUST transition to\n          // the \"Accepted\" state... The 2xx response MUST be passed up to the TU.\n          // The client transaction MUST NOT generate an ACK to the 2xx response -- its\n          // handling is delegated to the TU. A UAC core will send an ACK to\n          // the 2xx response using a new transaction.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n          if (statusCode >= 200 && statusCode <= 299) {\n            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n            this.stateTransition(TransactionState.Accepted);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n          // a response with status code from 300-699 MUST cause the client\n          // transaction to transition to \"Completed\". The client transaction\n          // MUST pass the received response up to the TU, and the client\n          // transaction MUST generate an ACK request, even if the transport is\n          // reliable (guidelines for constructing the ACK from the response\n          // are given in Section 17.1.1.3), and then pass the ACK to the\n          // transport layer for transmission. The ACK MUST be sent to the\n          // same address, port, and transport to which the original request was sent.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n          if (statusCode >= 300 && statusCode <= 699) {\n            this.stateTransition(TransactionState.Completed);\n            this.ack(response);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Proceeding:\n          // In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n          // request any longer. Furthermore, the provisional response MUST be\n          // passed to the TU.  Any further provisional responses MUST be passed\n          // up to the TU while in the \"Proceeding\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n          if (statusCode >= 100 && statusCode <= 199) {\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // When a 2xx response is received while in either the \"Calling\" or \"Proceeding\" states,\n          // the client transaction MUST transition to the \"Accepted\" state...\n          // The 2xx response MUST be passed up to the TU. The client\n          // transaction MUST NOT generate an ACK to the 2xx response -- its\n          // handling is delegated to the TU. A UAC core will send an ACK to\n          // the 2xx response using a new transaction.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n          if (statusCode >= 200 && statusCode <= 299) {\n            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n            this.stateTransition(TransactionState.Accepted);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n          // a response with status code from 300-699 MUST cause the client\n          // transaction to transition to \"Completed\". The client transaction\n          // MUST pass the received response up to the TU, and the client\n          // transaction MUST generate an ACK request, even if the transport is\n          // reliable (guidelines for constructing the ACK from the response\n          // are given in Section 17.1.1.3), and then pass the ACK to the\n          // transport layer for transmission. The ACK MUST be sent to the\n          // same address, port, and transport to which the original request was sent.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n          if (statusCode >= 300 && statusCode <= 699) {\n            this.stateTransition(TransactionState.Completed);\n            this.ack(response);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Accepted:\n          // The purpose of the \"Accepted\" state is to allow the client\n          // transaction to continue to exist to receive, and pass to the TU,\n          // any retransmissions of the 2xx response and any additional 2xx\n          // responses from other branches of the INVITE if it forked\n          // downstream. Timer M reflects the amount of time that the\n          // transaction user will wait for such messages.\n          //\n          // Any 2xx responses that match this client transaction and that are\n          // received while in the \"Accepted\" state MUST be passed up to the\n          // TU. The client transaction MUST NOT generate an ACK to the 2xx\n          // response. The client transaction takes no further action.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n          if (statusCode >= 200 && statusCode <= 299) {\n            // NOTE: This implementation herein is intentionally not RFC compliant.\n            // While the first 2xx response for a given branch is passed up to the TU,\n            // retransmissions of 2xx responses are absorbed and the ACK associated\n            // with the original response is resent. This approach is taken because\n            // our current transaction users are not currently in a good position to\n            // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)\n            //\n            // If we don't have a cache hit, pass the response to the TU.\n            if (!this.ackRetransmissionCache.has(response.toTag)) {\n              this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n              if (this.user.receiveResponse) {\n                this.user.receiveResponse(response);\n              }\n\n              return;\n            } // If we have a cache hit, try pulling the ACK from cache and retransmitting it.\n\n\n            var ack = this.ackRetransmissionCache.get(response.toTag);\n\n            if (ack) {\n              this.send(ack.toString()).catch(function (error) {\n                _this3.logTransportError(error, \"Failed to send retransmission of ACK to 2xx response.\");\n              });\n              return;\n            } // If an ACK was not found in cache then we have received a retransmitted 2xx\n            // response before the TU responded to the original response (we don't have an ACK yet).\n            // So discard this response under the assumption that the TU will eventually\n            // get us a ACK for the original response.\n\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Completed:\n          // Any retransmissions of a response with status code 300-699 that\n          // are received while in the \"Completed\" state MUST cause the ACK to\n          // be re-passed to the transport layer for retransmission, but the\n          // newly received response MUST NOT be passed up to the TU.\n          // https://tools.ietf.org/html/rfc6026#section-8.4\n          if (statusCode >= 300 && statusCode <= 699) {\n            this.ack(response);\n            return;\n          }\n\n          break;\n\n        case TransactionState.Terminated:\n          break;\n\n        default:\n          throw new Error(\"Invalid state \".concat(this.state));\n      } // Any response received that does not match an existing client\n      // transaction state machine is simply dropped. (Implementations are,\n      // of course, free to log or do other implementation-specific things\n      // with such responses, but the implementer should be sure to consider\n      // the impact of large numbers of malicious stray responses.)\n      // https://tools.ietf.org/html/rfc6026#section-7.2\n\n\n      var message = \"Received unexpected \".concat(statusCode, \" response while in state \").concat(this.state, \".\");\n      this.logger.warn(message);\n      return;\n    }\n    /**\n     * The client transaction SHOULD inform the TU that a transport failure\n     * has occurred, and the client transaction SHOULD transition directly\n     * to the \"Terminated\" state.  The TU will handle the failover\n     * mechanisms described in [4].\n     * https://tools.ietf.org/html/rfc3261#section-17.1.4\n     * @param error - The error.\n     */\n\n  }, {\n    key: \"onTransportError\",\n    value: function onTransportError(error) {\n      if (this.user.onTransportError) {\n        this.user.onTransportError(error);\n      }\n\n      this.stateTransition(TransactionState.Terminated, true);\n    }\n    /** For logging. */\n\n  }, {\n    key: \"typeToString\",\n    value: function typeToString() {\n      return \"INVITE client transaction\";\n    }\n  }, {\n    key: \"ack\",\n    value: function ack(response) {\n      var _this4 = this;\n\n      // The ACK request constructed by the client transaction MUST contain\n      // values for the Call-ID, From, and Request-URI that are equal to the\n      // values of those header fields in the request passed to the transport\n      // by the client transaction (call this the \"original request\"). The To\n      // header field in the ACK MUST equal the To header field in the\n      // response being acknowledged, and therefore will usually differ from\n      // the To header field in the original request by the addition of the\n      // tag parameter. The ACK MUST contain a single Via header field, and\n      // this MUST be equal to the top Via header field of the original\n      // request. The CSeq header field in the ACK MUST contain the same\n      // value for the sequence number as was present in the original request,\n      // but the method parameter MUST be equal to \"ACK\".\n      //\n      // If the INVITE request whose response is being acknowledged had Route\n      // header fields, those header fields MUST appear in the ACK. This is\n      // to ensure that the ACK can be routed properly through any downstream\n      // stateless proxies.\n      // https://tools.ietf.org/html/rfc3261#section-17.1.1.3\n      var ruri = this.request.ruri;\n      var callId = this.request.callId;\n      var cseq = this.request.cseq;\n      var from = this.request.getHeader(\"from\");\n      var to = response.getHeader(\"to\");\n      var via = this.request.getHeader(\"via\");\n      var route = this.request.getHeader(\"route\");\n\n      if (!from) {\n        throw new Error(\"From undefined.\");\n      }\n\n      if (!to) {\n        throw new Error(\"To undefined.\");\n      }\n\n      if (!via) {\n        throw new Error(\"Via undefined.\");\n      }\n\n      var ack = \"ACK \".concat(ruri, \" SIP/2.0\\r\\n\");\n\n      if (route) {\n        ack += \"Route: \".concat(route, \"\\r\\n\");\n      }\n\n      ack += \"Via: \".concat(via, \"\\r\\n\");\n      ack += \"To: \".concat(to, \"\\r\\n\");\n      ack += \"From: \".concat(from, \"\\r\\n\");\n      ack += \"Call-ID: \".concat(callId, \"\\r\\n\");\n      ack += \"CSeq: \".concat(cseq, \" ACK\\r\\n\");\n      ack += \"Max-Forwards: 70\\r\\n\";\n      ack += \"Content-Length: 0\\r\\n\\r\\n\"; // TOOO: \"User-Agent\" header\n\n      this.send(ack).catch(function (error) {\n        _this4.logTransportError(error, \"Failed to send ACK to non-2xx response.\");\n      });\n      return;\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState) {\n      var _this5 = this;\n\n      var dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Assert valid state transitions.\n      var invalidStateTransition = function invalidStateTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this5.state, \" to \").concat(newState));\n      };\n\n      switch (newState) {\n        case TransactionState.Calling:\n          invalidStateTransition();\n          break;\n\n        case TransactionState.Proceeding:\n          if (this.state !== TransactionState.Calling) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Accepted:\n        case TransactionState.Completed:\n          if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Terminated:\n          if (this.state !== TransactionState.Calling && this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed) {\n            if (!dueToTransportError) {\n              invalidStateTransition();\n            }\n          }\n\n          break;\n\n        default:\n          invalidStateTransition();\n      } // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n      // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n      // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n\n      if (this.B) {\n        clearTimeout(this.B);\n        this.B = undefined;\n      }\n\n      if (newState === TransactionState.Proceeding) {// Timers have no effect on \"Proceeding\" state.\n        // In the \"Proceeding\" state, the client transaction\n        // SHOULD NOT retransmit the request any longer.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n      } // The client transaction MUST start Timer D when it enters the \"Completed\" state\n      // for any reason, with a value of at least 32 seconds for unreliable transports,\n      // and a value of zero seconds for reliable transports.\n      // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n      if (newState === TransactionState.Completed) {\n        this.D = setTimeout(function () {\n          return _this5.timerD();\n        }, Timers.TIMER_D);\n      } // The client transaction MUST transition to the \"Accepted\" state,\n      // and Timer M MUST be started with a value of 64*T1.\n      // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n      if (newState === TransactionState.Accepted) {\n        this.M = setTimeout(function () {\n          return _this5.timerM();\n        }, Timers.TIMER_M);\n      } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n      // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n      if (newState === TransactionState.Terminated) {\n        this.dispose();\n      } // Update state.\n\n\n      this.setState(newState);\n    }\n    /**\n     * When timer A fires, the client transaction MUST retransmit the\n     * request by passing it to the transport layer, and MUST reset the\n     * timer with a value of 2*T1.\n     * When timer A fires 2*T1 seconds later, the request MUST be\n     * retransmitted again (assuming the client transaction is still in this\n     * state). This process MUST continue so that the request is\n     * retransmitted with intervals that double after each transmission.\n     * These retransmissions SHOULD only be done while the client\n     * transaction is in the \"Calling\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n\n  }, {\n    key: \"timerA\",\n    value: function timerA() {// TODO\n    }\n    /**\n     * If the client transaction is still in the \"Calling\" state when timer\n     * B fires, the client transaction SHOULD inform the TU that a timeout\n     * has occurred.  The client transaction MUST NOT generate an ACK.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n\n  }, {\n    key: \"timerB\",\n    value: function timerB() {\n      this.logger.debug(\"Timer B expired for INVITE client transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Calling) {\n        this.onRequestTimeout();\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n    /**\n     * If Timer D fires while the client transaction is in the \"Completed\" state,\n     * the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n\n  }, {\n    key: \"timerD\",\n    value: function timerD() {\n      this.logger.debug(\"Timer D expired for INVITE client transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Completed) {\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n    /**\n     * If Timer M fires while the client transaction is in the \"Accepted\"\n     * state, the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n\n  }, {\n    key: \"timerM\",\n    value: function timerM() {\n      this.logger.debug(\"Timer M expired for INVITE client transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Accepted) {\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n  }, {\n    key: \"kind\",\n    get: function get() {\n      return \"ict\";\n    }\n  }]);\n\n  return InviteClientTransaction;\n}(ClientTransaction);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/invite-client-transaction.js"],"names":["Timers","ClientTransaction","TransactionState","InviteClientTransaction","request","transport","user","Calling","ackRetransmissionCache","Map","B","setTimeout","timerB","TIMER_B","send","toString","catch","error","logTransportError","clearTimeout","undefined","D","M","ack","toTag","Error","id","Math","floor","random","setViaHeader","protocol","set","response","statusCode","state","stateTransition","Proceeding","receiveResponse","Accepted","Completed","has","get","Terminated","message","logger","warn","onTransportError","ruri","callId","cseq","from","getHeader","to","via","route","newState","dueToTransportError","invalidStateTransition","timerD","TIMER_D","timerM","TIMER_M","dispose","setState","debug","onRequestTimeout"],"mappings":"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","sourcesContent":["import { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * INVITE Client Transaction.\n * @remarks\n * The INVITE transaction consists of a three-way handshake.  The client\n * transaction sends an INVITE, the server transaction sends responses,\n * and the client transaction sends an ACK.\n * https://tools.ietf.org/html/rfc3261#section-17.1.1\n * @public\n */\nexport class InviteClientTransaction extends ClientTransaction {\n    /**\n     * Constructor.\n     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n     * Then `toString` is called on the outgoing request and the message is sent via the transport.\n     * After construction the transaction will be in the \"calling\" state and the transaction id\n     * will equal the branch parameter set in the Via header of the outgoing request.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1\n     * @param request - The outgoing INVITE request.\n     * @param transport - The transport.\n     * @param user - The transaction user.\n     */\n    constructor(request, transport, user) {\n        super(request, transport, user, TransactionState.Calling, \"sip.transaction.ict\");\n        /**\n         * Map of 2xx to-tag to ACK.\n         * If value is not undefined, value is the ACK which was sent.\n         * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.\n         * Otherwise, a 2xx was not (yet) received for this transaction.\n         */\n        this.ackRetransmissionCache = new Map();\n        // FIXME: Timer A for unreliable transport not implemented\n        //\n        // If an unreliable transport is being used, the client transaction\n        // MUST start timer A with a value of T1. If a reliable transport is being used,\n        // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).\n        // For any transport, the client transaction MUST start timer B with a value\n        // of 64*T1 seconds (Timer B controls transaction timeouts).\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        //\n        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n        // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n        // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n        this.B = setTimeout(() => this.timerB(), Timers.TIMER_B);\n        this.send(request.toString()).catch((error) => {\n            this.logTransportError(error, \"Failed to send initial outgoing request.\");\n        });\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        if (this.B) {\n            clearTimeout(this.B);\n            this.B = undefined;\n        }\n        if (this.D) {\n            clearTimeout(this.D);\n            this.D = undefined;\n        }\n        if (this.M) {\n            clearTimeout(this.M);\n            this.M = undefined;\n        }\n        super.dispose();\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        return \"ict\";\n    }\n    /**\n     * ACK a 2xx final response.\n     *\n     * The transaction includes the ACK only if the final response was not a 2xx response (the\n     * transaction will generate and send the ACK to the transport automagically). If the\n     * final response was a 2xx, the ACK is not considered part of the transaction (the\n     * transaction user needs to generate and send the ACK).\n     *\n     * This library is not strictly RFC compliant with regard to ACK handling for 2xx final\n     * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled\n     * by the transaction layer (instead of the UAC core). The \"standard\" approach is for\n     * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to\n     * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses\n     * and any retransmissions of those ACKs as needed.\n     *\n     * @param ack - The outgoing ACK request.\n     */\n    ackResponse(ack) {\n        const toTag = ack.toTag;\n        if (!toTag) {\n            throw new Error(\"To tag undefined.\");\n        }\n        const id = \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n        ack.setViaHeader(id, this.transport.protocol);\n        this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache\n        this.send(ack.toString()).catch((error) => {\n            this.logTransportError(error, \"Failed to send ACK to 2xx response.\");\n        });\n    }\n    /**\n     * Handler for incoming responses from the transport which match this transaction.\n     * @param response - The incoming response.\n     */\n    receiveResponse(response) {\n        const statusCode = response.statusCode;\n        if (!statusCode || statusCode < 100 || statusCode > 699) {\n            throw new Error(`Invalid status code ${statusCode}`);\n        }\n        switch (this.state) {\n            case TransactionState.Calling:\n                // If the client transaction receives a provisional response while in\n                // the \"Calling\" state, it transitions to the \"Proceeding\" state. In the\n                // \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n                // request any longer. Furthermore, the provisional response MUST be\n                // passed to the TU.  Any further provisional responses MUST be passed\n                // up to the TU while in the \"Proceeding\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    this.stateTransition(TransactionState.Proceeding);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When a 2xx response is received while in either the \"Calling\" or\n                // \"Proceeding\" states, the client transaction MUST transition to\n                // the \"Accepted\" state... The 2xx response MUST be passed up to the TU.\n                // The client transaction MUST NOT generate an ACK to the 2xx response -- its\n                // handling is delegated to the TU. A UAC core will send an ACK to\n                // the 2xx response using a new transaction.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                    this.stateTransition(TransactionState.Accepted);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When in either the \"Calling\" or \"Proceeding\" states, reception of\n                // a response with status code from 300-699 MUST cause the client\n                // transaction to transition to \"Completed\". The client transaction\n                // MUST pass the received response up to the TU, and the client\n                // transaction MUST generate an ACK request, even if the transport is\n                // reliable (guidelines for constructing the ACK from the response\n                // are given in Section 17.1.1.3), and then pass the ACK to the\n                // transport layer for transmission. The ACK MUST be sent to the\n                // same address, port, and transport to which the original request was sent.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    this.ack(response);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Proceeding:\n                // In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n                // request any longer. Furthermore, the provisional response MUST be\n                // passed to the TU.  Any further provisional responses MUST be passed\n                // up to the TU while in the \"Proceeding\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When a 2xx response is received while in either the \"Calling\" or \"Proceeding\" states,\n                // the client transaction MUST transition to the \"Accepted\" state...\n                // The 2xx response MUST be passed up to the TU. The client\n                // transaction MUST NOT generate an ACK to the 2xx response -- its\n                // handling is delegated to the TU. A UAC core will send an ACK to\n                // the 2xx response using a new transaction.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                    this.stateTransition(TransactionState.Accepted);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // When in either the \"Calling\" or \"Proceeding\" states, reception of\n                // a response with status code from 300-699 MUST cause the client\n                // transaction to transition to \"Completed\". The client transaction\n                // MUST pass the received response up to the TU, and the client\n                // transaction MUST generate an ACK request, even if the transport is\n                // reliable (guidelines for constructing the ACK from the response\n                // are given in Section 17.1.1.3), and then pass the ACK to the\n                // transport layer for transmission. The ACK MUST be sent to the\n                // same address, port, and transport to which the original request was sent.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    this.ack(response);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Accepted:\n                // The purpose of the \"Accepted\" state is to allow the client\n                // transaction to continue to exist to receive, and pass to the TU,\n                // any retransmissions of the 2xx response and any additional 2xx\n                // responses from other branches of the INVITE if it forked\n                // downstream. Timer M reflects the amount of time that the\n                // transaction user will wait for such messages.\n                //\n                // Any 2xx responses that match this client transaction and that are\n                // received while in the \"Accepted\" state MUST be passed up to the\n                // TU. The client transaction MUST NOT generate an ACK to the 2xx\n                // response. The client transaction takes no further action.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 200 && statusCode <= 299) {\n                    // NOTE: This implementation herein is intentionally not RFC compliant.\n                    // While the first 2xx response for a given branch is passed up to the TU,\n                    // retransmissions of 2xx responses are absorbed and the ACK associated\n                    // with the original response is resent. This approach is taken because\n                    // our current transaction users are not currently in a good position to\n                    // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)\n                    //\n                    // If we don't have a cache hit, pass the response to the TU.\n                    if (!this.ackRetransmissionCache.has(response.toTag)) {\n                        this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n                        if (this.user.receiveResponse) {\n                            this.user.receiveResponse(response);\n                        }\n                        return;\n                    }\n                    // If we have a cache hit, try pulling the ACK from cache and retransmitting it.\n                    const ack = this.ackRetransmissionCache.get(response.toTag);\n                    if (ack) {\n                        this.send(ack.toString()).catch((error) => {\n                            this.logTransportError(error, \"Failed to send retransmission of ACK to 2xx response.\");\n                        });\n                        return;\n                    }\n                    // If an ACK was not found in cache then we have received a retransmitted 2xx\n                    // response before the TU responded to the original response (we don't have an ACK yet).\n                    // So discard this response under the assumption that the TU will eventually\n                    // get us a ACK for the original response.\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                // Any retransmissions of a response with status code 300-699 that\n                // are received while in the \"Completed\" state MUST cause the ACK to\n                // be re-passed to the transport layer for retransmission, but the\n                // newly received response MUST NOT be passed up to the TU.\n                // https://tools.ietf.org/html/rfc6026#section-8.4\n                if (statusCode >= 300 && statusCode <= 699) {\n                    this.ack(response);\n                    return;\n                }\n                break;\n            case TransactionState.Terminated:\n                break;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        // Any response received that does not match an existing client\n        // transaction state machine is simply dropped. (Implementations are,\n        // of course, free to log or do other implementation-specific things\n        // with such responses, but the implementer should be sure to consider\n        // the impact of large numbers of malicious stray responses.)\n        // https://tools.ietf.org/html/rfc6026#section-7.2\n        const message = `Received unexpected ${statusCode} response while in state ${this.state}.`;\n        this.logger.warn(message);\n        return;\n    }\n    /**\n     * The client transaction SHOULD inform the TU that a transport failure\n     * has occurred, and the client transaction SHOULD transition directly\n     * to the \"Terminated\" state.  The TU will handle the failover\n     * mechanisms described in [4].\n     * https://tools.ietf.org/html/rfc3261#section-17.1.4\n     * @param error - The error.\n     */\n    onTransportError(error) {\n        if (this.user.onTransportError) {\n            this.user.onTransportError(error);\n        }\n        this.stateTransition(TransactionState.Terminated, true);\n    }\n    /** For logging. */\n    typeToString() {\n        return \"INVITE client transaction\";\n    }\n    ack(response) {\n        // The ACK request constructed by the client transaction MUST contain\n        // values for the Call-ID, From, and Request-URI that are equal to the\n        // values of those header fields in the request passed to the transport\n        // by the client transaction (call this the \"original request\"). The To\n        // header field in the ACK MUST equal the To header field in the\n        // response being acknowledged, and therefore will usually differ from\n        // the To header field in the original request by the addition of the\n        // tag parameter. The ACK MUST contain a single Via header field, and\n        // this MUST be equal to the top Via header field of the original\n        // request. The CSeq header field in the ACK MUST contain the same\n        // value for the sequence number as was present in the original request,\n        // but the method parameter MUST be equal to \"ACK\".\n        //\n        // If the INVITE request whose response is being acknowledged had Route\n        // header fields, those header fields MUST appear in the ACK. This is\n        // to ensure that the ACK can be routed properly through any downstream\n        // stateless proxies.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.3\n        const ruri = this.request.ruri;\n        const callId = this.request.callId;\n        const cseq = this.request.cseq;\n        const from = this.request.getHeader(\"from\");\n        const to = response.getHeader(\"to\");\n        const via = this.request.getHeader(\"via\");\n        const route = this.request.getHeader(\"route\");\n        if (!from) {\n            throw new Error(\"From undefined.\");\n        }\n        if (!to) {\n            throw new Error(\"To undefined.\");\n        }\n        if (!via) {\n            throw new Error(\"Via undefined.\");\n        }\n        let ack = `ACK ${ruri} SIP/2.0\\r\\n`;\n        if (route) {\n            ack += `Route: ${route}\\r\\n`;\n        }\n        ack += `Via: ${via}\\r\\n`;\n        ack += `To: ${to}\\r\\n`;\n        ack += `From: ${from}\\r\\n`;\n        ack += `Call-ID: ${callId}\\r\\n`;\n        ack += `CSeq: ${cseq} ACK\\r\\n`;\n        ack += `Max-Forwards: 70\\r\\n`;\n        ack += `Content-Length: 0\\r\\n\\r\\n`;\n        // TOOO: \"User-Agent\" header\n        this.send(ack).catch((error) => {\n            this.logTransportError(error, \"Failed to send ACK to non-2xx response.\");\n        });\n        return;\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n    stateTransition(newState, dueToTransportError = false) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n        };\n        switch (newState) {\n            case TransactionState.Calling:\n                invalidStateTransition();\n                break;\n            case TransactionState.Proceeding:\n                if (this.state !== TransactionState.Calling) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Accepted:\n            case TransactionState.Completed:\n                if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Terminated:\n                if (this.state !== TransactionState.Calling &&\n                    this.state !== TransactionState.Accepted &&\n                    this.state !== TransactionState.Completed) {\n                    if (!dueToTransportError) {\n                        invalidStateTransition();\n                    }\n                }\n                break;\n            default:\n                invalidStateTransition();\n        }\n        // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n        // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n        // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n        if (this.B) {\n            clearTimeout(this.B);\n            this.B = undefined;\n        }\n        if (newState === TransactionState.Proceeding) {\n            // Timers have no effect on \"Proceeding\" state.\n            // In the \"Proceeding\" state, the client transaction\n            // SHOULD NOT retransmit the request any longer.\n            // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        }\n        // The client transaction MUST start Timer D when it enters the \"Completed\" state\n        // for any reason, with a value of at least 32 seconds for unreliable transports,\n        // and a value of zero seconds for reliable transports.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (newState === TransactionState.Completed) {\n            this.D = setTimeout(() => this.timerD(), Timers.TIMER_D);\n        }\n        // The client transaction MUST transition to the \"Accepted\" state,\n        // and Timer M MUST be started with a value of 64*T1.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (newState === TransactionState.Accepted) {\n            this.M = setTimeout(() => this.timerM(), Timers.TIMER_M);\n        }\n        // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (newState === TransactionState.Terminated) {\n            this.dispose();\n        }\n        // Update state.\n        this.setState(newState);\n    }\n    /**\n     * When timer A fires, the client transaction MUST retransmit the\n     * request by passing it to the transport layer, and MUST reset the\n     * timer with a value of 2*T1.\n     * When timer A fires 2*T1 seconds later, the request MUST be\n     * retransmitted again (assuming the client transaction is still in this\n     * state). This process MUST continue so that the request is\n     * retransmitted with intervals that double after each transmission.\n     * These retransmissions SHOULD only be done while the client\n     * transaction is in the \"Calling\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n    timerA() {\n        // TODO\n    }\n    /**\n     * If the client transaction is still in the \"Calling\" state when timer\n     * B fires, the client transaction SHOULD inform the TU that a timeout\n     * has occurred.  The client transaction MUST NOT generate an ACK.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n     */\n    timerB() {\n        this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Calling) {\n            this.onRequestTimeout();\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * If Timer D fires while the client transaction is in the \"Completed\" state,\n     * the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n    timerD() {\n        this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Completed) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * If Timer M fires while the client transaction is in the \"Accepted\"\n     * state, the client transaction MUST move to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc6026#section-8.4\n     */\n    timerM() {\n        this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Accepted) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}