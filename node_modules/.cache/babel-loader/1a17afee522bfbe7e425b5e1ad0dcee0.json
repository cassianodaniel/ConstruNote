{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { TransportError } from \"../exceptions\";\n/**\n * Transaction.\n * @remarks\n * SIP is a transactional protocol: interactions between components take\n * place in a series of independent message exchanges.  Specifically, a\n * SIP transaction consists of a single request and any responses to\n * that request, which include zero or more provisional responses and\n * one or more final responses.  In the case of a transaction where the\n * request was an INVITE (known as an INVITE transaction), the\n * transaction also includes the ACK only if the final response was not\n * a 2xx response.  If the response was a 2xx, the ACK is not considered\n * part of the transaction.\n * https://tools.ietf.org/html/rfc3261#section-17\n * @public\n */\n\nexport var Transaction = /*#__PURE__*/function () {\n  function Transaction(_transport, _user, _id, _state, loggerCategory) {\n    _classCallCheck(this, Transaction);\n\n    this._transport = _transport;\n    this._user = _user;\n    this._id = _id;\n    this._state = _state;\n    this.listeners = new Array();\n    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);\n    this.logger.debug(\"Constructing \".concat(this.typeToString(), \" with id \").concat(this.id, \".\"));\n  }\n  /**\n   * Destructor.\n   * Once the transaction is in the \"terminated\" state, it is destroyed\n   * immediately and there is no need to call `dispose`. However, if a\n   * transaction needs to be ended prematurely, the transaction user may\n   * do so by calling this method (for example, perhaps the UA is shutting down).\n   * No state transition will occur upon calling this method, all outstanding\n   * transmission timers will be cancelled, and use of the transaction after\n   * calling `dispose` is undefined.\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.logger.debug(\"Destroyed \".concat(this.typeToString(), \" with id \").concat(this.id, \".\"));\n    }\n    /** Transaction id. */\n\n  }, {\n    key: \"addStateChangeListener\",\n\n    /**\n     * Sets up a function that will be called whenever the transaction state changes.\n     * @param listener - Callback function.\n     * @param options - An options object that specifies characteristics about the listener.\n     *                  If once true, indicates that the listener should be invoked at most once after being added.\n     *                  If once true, the listener would be automatically removed when invoked.\n     */\n    value: function addStateChangeListener(listener, options) {\n      var _this = this;\n\n      var onceWrapper = function onceWrapper() {\n        _this.removeStateChangeListener(onceWrapper);\n\n        listener();\n      };\n\n      (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);\n    }\n    /**\n     * This is currently public so tests may spy on it.\n     * @internal\n     */\n\n  }, {\n    key: \"notifyStateChangeListeners\",\n    value: function notifyStateChangeListeners() {\n      this.listeners.slice().forEach(function (listener) {\n        return listener();\n      });\n    }\n    /**\n     * Removes a listener previously registered with addStateListener.\n     * @param listener - Callback function.\n     */\n\n  }, {\n    key: \"removeStateChangeListener\",\n    value: function removeStateChangeListener(listener) {\n      this.listeners = this.listeners.filter(function (l) {\n        return l !== listener;\n      });\n    }\n  }, {\n    key: \"logTransportError\",\n    value: function logTransportError(error, message) {\n      this.logger.error(error.message);\n      this.logger.error(\"Transport error occurred in \".concat(this.typeToString(), \" with id \").concat(this.id, \".\"));\n      this.logger.error(message);\n    }\n    /**\n     * Pass message to transport for transmission. If transport fails,\n     * the transaction user is notified by callback to onTransportError().\n     * @returns\n     * Rejects with `TransportError` if transport fails.\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(message) {\n      var _this2 = this;\n\n      return this.transport.send(message).catch(function (error) {\n        // If the transport rejects, it SHOULD reject with a TransportError.\n        // But the transport may be external code, so we are careful\n        // make sure we convert it to a TransportError if need be.\n        if (error instanceof TransportError) {\n          _this2.onTransportError(error);\n\n          throw error;\n        }\n\n        var transportError;\n\n        if (error && typeof error.message === \"string\") {\n          transportError = new TransportError(error.message);\n        } else {\n          transportError = new TransportError();\n        }\n\n        _this2.onTransportError(transportError);\n\n        throw transportError;\n      });\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      this.logger.debug(\"State change to \\\"\".concat(state, \"\\\" on \").concat(this.typeToString(), \" with id \").concat(this.id, \".\"));\n      this._state = state;\n\n      if (this._user.onStateChange) {\n        this._user.onStateChange(state);\n      }\n\n      this.notifyStateChangeListeners();\n    }\n  }, {\n    key: \"typeToString\",\n    value: function typeToString() {\n      return \"UnknownType\";\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /** Transaction kind. Deprecated. */\n\n  }, {\n    key: \"kind\",\n    get: function get() {\n      throw new Error(\"Invalid kind.\");\n    }\n    /** Transaction state. */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n    /** Transaction transport. */\n\n  }, {\n    key: \"transport\",\n    get: function get() {\n      return this._transport;\n    }\n  }]);\n\n  return Transaction;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/transaction.js"],"names":["TransportError","Transaction","_transport","_user","_id","_state","loggerCategory","listeners","Array","logger","loggerFactory","getLogger","debug","typeToString","id","listener","options","onceWrapper","removeStateChangeListener","once","push","slice","forEach","filter","l","error","message","transport","send","catch","onTransportError","transportError","state","onStateChange","notifyStateChangeListeners","Error"],"mappings":"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","sourcesContent":["import { TransportError } from \"../exceptions\";\n/**\n * Transaction.\n * @remarks\n * SIP is a transactional protocol: interactions between components take\n * place in a series of independent message exchanges.  Specifically, a\n * SIP transaction consists of a single request and any responses to\n * that request, which include zero or more provisional responses and\n * one or more final responses.  In the case of a transaction where the\n * request was an INVITE (known as an INVITE transaction), the\n * transaction also includes the ACK only if the final response was not\n * a 2xx response.  If the response was a 2xx, the ACK is not considered\n * part of the transaction.\n * https://tools.ietf.org/html/rfc3261#section-17\n * @public\n */\nexport class Transaction {\n    constructor(_transport, _user, _id, _state, loggerCategory) {\n        this._transport = _transport;\n        this._user = _user;\n        this._id = _id;\n        this._state = _state;\n        this.listeners = new Array();\n        this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);\n        this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);\n    }\n    /**\n     * Destructor.\n     * Once the transaction is in the \"terminated\" state, it is destroyed\n     * immediately and there is no need to call `dispose`. However, if a\n     * transaction needs to be ended prematurely, the transaction user may\n     * do so by calling this method (for example, perhaps the UA is shutting down).\n     * No state transition will occur upon calling this method, all outstanding\n     * transmission timers will be cancelled, and use of the transaction after\n     * calling `dispose` is undefined.\n     */\n    dispose() {\n        this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);\n    }\n    /** Transaction id. */\n    get id() {\n        return this._id;\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        throw new Error(\"Invalid kind.\");\n    }\n    /** Transaction state. */\n    get state() {\n        return this._state;\n    }\n    /** Transaction transport. */\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * Sets up a function that will be called whenever the transaction state changes.\n     * @param listener - Callback function.\n     * @param options - An options object that specifies characteristics about the listener.\n     *                  If once true, indicates that the listener should be invoked at most once after being added.\n     *                  If once true, the listener would be automatically removed when invoked.\n     */\n    addStateChangeListener(listener, options) {\n        const onceWrapper = () => {\n            this.removeStateChangeListener(onceWrapper);\n            listener();\n        };\n        (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);\n    }\n    /**\n     * This is currently public so tests may spy on it.\n     * @internal\n     */\n    notifyStateChangeListeners() {\n        this.listeners.slice().forEach((listener) => listener());\n    }\n    /**\n     * Removes a listener previously registered with addStateListener.\n     * @param listener - Callback function.\n     */\n    removeStateChangeListener(listener) {\n        this.listeners = this.listeners.filter((l) => l !== listener);\n    }\n    logTransportError(error, message) {\n        this.logger.error(error.message);\n        this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);\n        this.logger.error(message);\n    }\n    /**\n     * Pass message to transport for transmission. If transport fails,\n     * the transaction user is notified by callback to onTransportError().\n     * @returns\n     * Rejects with `TransportError` if transport fails.\n     */\n    send(message) {\n        return this.transport.send(message).catch((error) => {\n            // If the transport rejects, it SHOULD reject with a TransportError.\n            // But the transport may be external code, so we are careful\n            // make sure we convert it to a TransportError if need be.\n            if (error instanceof TransportError) {\n                this.onTransportError(error);\n                throw error;\n            }\n            let transportError;\n            if (error && typeof error.message === \"string\") {\n                transportError = new TransportError(error.message);\n            }\n            else {\n                transportError = new TransportError();\n            }\n            this.onTransportError(transportError);\n            throw transportError;\n        });\n    }\n    setState(state) {\n        this.logger.debug(`State change to \"${state}\" on ${this.typeToString()} with id ${this.id}.`);\n        this._state = state;\n        if (this._user.onStateChange) {\n            this._user.onStateChange(state);\n        }\n        this.notifyStateChangeListeners();\n    }\n    typeToString() {\n        return \"UnknownType\";\n    }\n}\n"]},"metadata":{},"sourceType":"module"}