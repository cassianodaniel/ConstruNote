{"ast":null,"code":"/* eslint-disable no-inner-declarations */\n\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { Grammar } from \"../../grammar\";\nimport { IncomingRequestMessage } from \"./incoming-request-message\";\nimport { IncomingResponseMessage } from \"./incoming-response-message\";\n/**\n * Extract and parse every header of a SIP message.\n * @internal\n */\n\nexport var Parser;\n\n(function (Parser) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function getHeader(data, headerStart) {\n    // 'start' position of the header.\n    let start = headerStart; // 'end' position of the header.\n\n    let end = 0; // 'partial end' position of the header.\n\n    let partialEnd = 0; // End of message.\n\n    if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n      return -2;\n    }\n\n    while (end === 0) {\n      // Partial End of Header.\n      partialEnd = data.indexOf(\"\\r\\n\", start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n      if (partialEnd === -1) {\n        return partialEnd;\n      }\n\n      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n        // Not the end of the message. Continue from the next position.\n        start = partialEnd + 2;\n      } else {\n        end = partialEnd;\n      }\n    }\n\n    return end;\n  }\n\n  Parser.getHeader = getHeader;\n\n  function parseHeader(message, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data, headerStart, headerEnd) {\n    const hcolonIndex = data.indexOf(\":\", headerStart);\n    const headerName = data.substring(headerStart, hcolonIndex).trim();\n    const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let parsed; // If header-field is well-known, parse it.\n\n    switch (headerName.toLowerCase()) {\n      case \"via\":\n      case \"v\":\n        message.addHeader(\"via\", headerValue);\n\n        if (message.getHeaders(\"via\").length === 1) {\n          parsed = message.parseHeader(\"Via\");\n\n          if (parsed) {\n            message.via = parsed;\n            message.viaBranch = parsed.branch;\n          }\n        } else {\n          parsed = 0;\n        }\n\n        break;\n\n      case \"from\":\n      case \"f\":\n        message.setHeader(\"from\", headerValue);\n        parsed = message.parseHeader(\"from\");\n\n        if (parsed) {\n          message.from = parsed;\n          message.fromTag = parsed.getParam(\"tag\");\n        }\n\n        break;\n\n      case \"to\":\n      case \"t\":\n        message.setHeader(\"to\", headerValue);\n        parsed = message.parseHeader(\"to\");\n\n        if (parsed) {\n          message.to = parsed;\n          message.toTag = parsed.getParam(\"tag\");\n        }\n\n        break;\n\n      case \"record-route\":\n        parsed = Grammar.parse(headerValue, \"Record_Route\");\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        if (!(parsed instanceof Array)) {\n          parsed = undefined;\n          break;\n        }\n\n        parsed.forEach(header => {\n          message.addHeader(\"record-route\", headerValue.substring(header.position, header.offset));\n          message.headers[\"Record-Route\"][message.getHeaders(\"record-route\").length - 1].parsed = header.parsed;\n        });\n        break;\n\n      case \"call-id\":\n      case \"i\":\n        message.setHeader(\"call-id\", headerValue);\n        parsed = message.parseHeader(\"call-id\");\n\n        if (parsed) {\n          message.callId = headerValue;\n        }\n\n        break;\n\n      case \"contact\":\n      case \"m\":\n        parsed = Grammar.parse(headerValue, \"Contact\");\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        if (!(parsed instanceof Array)) {\n          parsed = undefined;\n          break;\n        }\n\n        parsed.forEach(header => {\n          message.addHeader(\"contact\", headerValue.substring(header.position, header.offset));\n          message.headers.Contact[message.getHeaders(\"contact\").length - 1].parsed = header.parsed;\n        });\n        break;\n\n      case \"content-length\":\n      case \"l\":\n        message.setHeader(\"content-length\", headerValue);\n        parsed = message.parseHeader(\"content-length\");\n        break;\n\n      case \"content-type\":\n      case \"c\":\n        message.setHeader(\"content-type\", headerValue);\n        parsed = message.parseHeader(\"content-type\");\n        break;\n\n      case \"cseq\":\n        message.setHeader(\"cseq\", headerValue);\n        parsed = message.parseHeader(\"cseq\");\n\n        if (parsed) {\n          message.cseq = parsed.value;\n        }\n\n        if (message instanceof IncomingResponseMessage) {\n          message.method = parsed.method;\n        }\n\n        break;\n\n      case \"max-forwards\":\n        message.setHeader(\"max-forwards\", headerValue);\n        parsed = message.parseHeader(\"max-forwards\");\n        break;\n\n      case \"www-authenticate\":\n        message.setHeader(\"www-authenticate\", headerValue);\n        parsed = message.parseHeader(\"www-authenticate\");\n        break;\n\n      case \"proxy-authenticate\":\n        message.setHeader(\"proxy-authenticate\", headerValue);\n        parsed = message.parseHeader(\"proxy-authenticate\");\n        break;\n\n      case \"refer-to\":\n      case \"r\":\n        message.setHeader(\"refer-to\", headerValue);\n        parsed = message.parseHeader(\"refer-to\");\n\n        if (parsed) {\n          message.referTo = parsed;\n        }\n\n        break;\n\n      default:\n        // Do not parse this header.\n        message.addHeader(headerName.toLowerCase(), headerValue);\n        parsed = 0;\n    }\n\n    if (parsed === undefined) {\n      return {\n        error: \"error parsing header '\" + headerName + \"'\"\n      };\n    } else {\n      return true;\n    }\n  }\n\n  Parser.parseHeader = parseHeader;\n\n  function parseMessage(data, logger) {\n    let headerStart = 0;\n    let headerEnd = data.indexOf(\"\\r\\n\");\n\n    if (headerEnd === -1) {\n      logger.warn(\"no CRLF found, not a SIP message, discarded\");\n      return;\n    } // Parse first line. Check if it is a Request or a Reply.\n\n\n    const firstLine = data.substring(0, headerEnd);\n    const parsed = Grammar.parse(firstLine, \"Request_Response\");\n    let message;\n\n    if (parsed === -1) {\n      logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n      return;\n    } else if (!parsed.status_code) {\n      message = new IncomingRequestMessage();\n      message.method = parsed.method;\n      message.ruri = parsed.uri;\n    } else {\n      message = new IncomingResponseMessage();\n      message.statusCode = parsed.status_code;\n      message.reasonPhrase = parsed.reason_phrase;\n    }\n\n    message.data = data;\n    headerStart = headerEnd + 2; // Loop over every line in data. Detect the end of each header and parse\n    // it or simply add to the headers collection.\n\n    let bodyStart; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n      if (headerEnd === -2) {\n        bodyStart = headerStart + 2;\n        break;\n      } else if (headerEnd === -1) {\n        // data.indexOf returned -1 due to a malformed message.\n        logger.error(\"malformed message\");\n        return;\n      }\n\n      const parsedHeader = parseHeader(message, data, headerStart, headerEnd);\n\n      if (parsedHeader !== true) {\n        logger.error(parsed.error);\n        return;\n      }\n\n      headerStart = headerEnd + 2;\n    } // RFC3261 18.3.\n    // If there are additional bytes in the transport packet\n    // beyond the end of the body, they MUST be discarded.\n\n\n    if (message.hasHeader(\"content-length\")) {\n      message.body = data.substr(bodyStart, Number(message.getHeader(\"content-length\")));\n    } else {\n      message.body = data.substring(bodyStart);\n    }\n\n    return message;\n  }\n\n  Parser.parseMessage = parseMessage;\n})(Parser || (Parser = {}));","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/parser.js"],"names":["Grammar","IncomingRequestMessage","IncomingResponseMessage","Parser","getHeader","data","headerStart","start","end","partialEnd","substring","match","indexOf","charAt","parseHeader","message","headerEnd","hcolonIndex","headerName","trim","headerValue","parsed","toLowerCase","addHeader","getHeaders","length","via","viaBranch","branch","setHeader","from","fromTag","getParam","to","toTag","parse","undefined","Array","forEach","header","position","offset","headers","callId","Contact","cseq","value","method","referTo","error","parseMessage","logger","warn","firstLine","status_code","ruri","uri","statusCode","reasonPhrase","reason_phrase","bodyStart","parsedHeader","hasHeader","body","substr","Number"],"mappings":"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","sourcesContent":["/* eslint-disable no-inner-declarations */\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { Grammar } from \"../../grammar\";\nimport { IncomingRequestMessage } from \"./incoming-request-message\";\nimport { IncomingResponseMessage } from \"./incoming-response-message\";\n/**\n * Extract and parse every header of a SIP message.\n * @internal\n */\nexport var Parser;\n(function (Parser) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function getHeader(data, headerStart) {\n        // 'start' position of the header.\n        let start = headerStart;\n        // 'end' position of the header.\n        let end = 0;\n        // 'partial end' position of the header.\n        let partialEnd = 0;\n        // End of message.\n        if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n            return -2;\n        }\n        while (end === 0) {\n            // Partial End of Header.\n            partialEnd = data.indexOf(\"\\r\\n\", start);\n            // 'indexOf' returns -1 if the value to be found never occurs.\n            if (partialEnd === -1) {\n                return partialEnd;\n            }\n            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) &&\n                data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n                // Not the end of the message. Continue from the next position.\n                start = partialEnd + 2;\n            }\n            else {\n                end = partialEnd;\n            }\n        }\n        return end;\n    }\n    Parser.getHeader = getHeader;\n    function parseHeader(message, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, headerStart, headerEnd) {\n        const hcolonIndex = data.indexOf(\":\", headerStart);\n        const headerName = data.substring(headerStart, hcolonIndex).trim();\n        const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let parsed;\n        // If header-field is well-known, parse it.\n        switch (headerName.toLowerCase()) {\n            case \"via\":\n            case \"v\":\n                message.addHeader(\"via\", headerValue);\n                if (message.getHeaders(\"via\").length === 1) {\n                    parsed = message.parseHeader(\"Via\");\n                    if (parsed) {\n                        message.via = parsed;\n                        message.viaBranch = parsed.branch;\n                    }\n                }\n                else {\n                    parsed = 0;\n                }\n                break;\n            case \"from\":\n            case \"f\":\n                message.setHeader(\"from\", headerValue);\n                parsed = message.parseHeader(\"from\");\n                if (parsed) {\n                    message.from = parsed;\n                    message.fromTag = parsed.getParam(\"tag\");\n                }\n                break;\n            case \"to\":\n            case \"t\":\n                message.setHeader(\"to\", headerValue);\n                parsed = message.parseHeader(\"to\");\n                if (parsed) {\n                    message.to = parsed;\n                    message.toTag = parsed.getParam(\"tag\");\n                }\n                break;\n            case \"record-route\":\n                parsed = Grammar.parse(headerValue, \"Record_Route\");\n                if (parsed === -1) {\n                    parsed = undefined;\n                    break;\n                }\n                if (!(parsed instanceof Array)) {\n                    parsed = undefined;\n                    break;\n                }\n                parsed.forEach((header) => {\n                    message.addHeader(\"record-route\", headerValue.substring(header.position, header.offset));\n                    message.headers[\"Record-Route\"][message.getHeaders(\"record-route\").length - 1].parsed = header.parsed;\n                });\n                break;\n            case \"call-id\":\n            case \"i\":\n                message.setHeader(\"call-id\", headerValue);\n                parsed = message.parseHeader(\"call-id\");\n                if (parsed) {\n                    message.callId = headerValue;\n                }\n                break;\n            case \"contact\":\n            case \"m\":\n                parsed = Grammar.parse(headerValue, \"Contact\");\n                if (parsed === -1) {\n                    parsed = undefined;\n                    break;\n                }\n                if (!(parsed instanceof Array)) {\n                    parsed = undefined;\n                    break;\n                }\n                parsed.forEach((header) => {\n                    message.addHeader(\"contact\", headerValue.substring(header.position, header.offset));\n                    message.headers.Contact[message.getHeaders(\"contact\").length - 1].parsed = header.parsed;\n                });\n                break;\n            case \"content-length\":\n            case \"l\":\n                message.setHeader(\"content-length\", headerValue);\n                parsed = message.parseHeader(\"content-length\");\n                break;\n            case \"content-type\":\n            case \"c\":\n                message.setHeader(\"content-type\", headerValue);\n                parsed = message.parseHeader(\"content-type\");\n                break;\n            case \"cseq\":\n                message.setHeader(\"cseq\", headerValue);\n                parsed = message.parseHeader(\"cseq\");\n                if (parsed) {\n                    message.cseq = parsed.value;\n                }\n                if (message instanceof IncomingResponseMessage) {\n                    message.method = parsed.method;\n                }\n                break;\n            case \"max-forwards\":\n                message.setHeader(\"max-forwards\", headerValue);\n                parsed = message.parseHeader(\"max-forwards\");\n                break;\n            case \"www-authenticate\":\n                message.setHeader(\"www-authenticate\", headerValue);\n                parsed = message.parseHeader(\"www-authenticate\");\n                break;\n            case \"proxy-authenticate\":\n                message.setHeader(\"proxy-authenticate\", headerValue);\n                parsed = message.parseHeader(\"proxy-authenticate\");\n                break;\n            case \"refer-to\":\n            case \"r\":\n                message.setHeader(\"refer-to\", headerValue);\n                parsed = message.parseHeader(\"refer-to\");\n                if (parsed) {\n                    message.referTo = parsed;\n                }\n                break;\n            default:\n                // Do not parse this header.\n                message.addHeader(headerName.toLowerCase(), headerValue);\n                parsed = 0;\n        }\n        if (parsed === undefined) {\n            return {\n                error: \"error parsing header '\" + headerName + \"'\"\n            };\n        }\n        else {\n            return true;\n        }\n    }\n    Parser.parseHeader = parseHeader;\n    function parseMessage(data, logger) {\n        let headerStart = 0;\n        let headerEnd = data.indexOf(\"\\r\\n\");\n        if (headerEnd === -1) {\n            logger.warn(\"no CRLF found, not a SIP message, discarded\");\n            return;\n        }\n        // Parse first line. Check if it is a Request or a Reply.\n        const firstLine = data.substring(0, headerEnd);\n        const parsed = Grammar.parse(firstLine, \"Request_Response\");\n        let message;\n        if (parsed === -1) {\n            logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n            return;\n        }\n        else if (!parsed.status_code) {\n            message = new IncomingRequestMessage();\n            message.method = parsed.method;\n            message.ruri = parsed.uri;\n        }\n        else {\n            message = new IncomingResponseMessage();\n            message.statusCode = parsed.status_code;\n            message.reasonPhrase = parsed.reason_phrase;\n        }\n        message.data = data;\n        headerStart = headerEnd + 2;\n        // Loop over every line in data. Detect the end of each header and parse\n        // it or simply add to the headers collection.\n        let bodyStart;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            headerEnd = getHeader(data, headerStart);\n            // The SIP message has normally finished.\n            if (headerEnd === -2) {\n                bodyStart = headerStart + 2;\n                break;\n            }\n            else if (headerEnd === -1) {\n                // data.indexOf returned -1 due to a malformed message.\n                logger.error(\"malformed message\");\n                return;\n            }\n            const parsedHeader = parseHeader(message, data, headerStart, headerEnd);\n            if (parsedHeader !== true) {\n                logger.error(parsed.error);\n                return;\n            }\n            headerStart = headerEnd + 2;\n        }\n        // RFC3261 18.3.\n        // If there are additional bytes in the transport packet\n        // beyond the end of the body, they MUST be discarded.\n        if (message.hasHeader(\"content-length\")) {\n            message.body = data.substr(bodyStart, Number(message.getHeader(\"content-length\")));\n        }\n        else {\n            message.body = data.substring(bodyStart);\n        }\n        return message;\n    }\n    Parser.parseMessage = parseMessage;\n})(Parser || (Parser = {}));\n"]},"metadata":{},"sourceType":"module"}