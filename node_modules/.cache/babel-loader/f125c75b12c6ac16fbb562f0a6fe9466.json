{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Dialog, SessionDialog } from \"../dialogs\";\nimport { SignalingState } from \"../session\";\nimport { InviteClientTransaction, TransactionState } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * INVITE UAC.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.2 UAC Processing\n * https://tools.ietf.org/html/rfc3261#section-13.2\n * @public\n */\n\nexport var InviteUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {\n  _inherits(InviteUserAgentClient, _UserAgentClient);\n\n  var _super = _createSuper(InviteUserAgentClient);\n\n  function InviteUserAgentClient(core, message, delegate) {\n    var _this;\n\n    _classCallCheck(this, InviteUserAgentClient);\n\n    _this = _super.call(this, InviteClientTransaction, core, message, delegate);\n    _this.confirmedDialogAcks = new Map();\n    _this.confirmedDialogs = new Map();\n    _this.earlyDialogs = new Map();\n    _this.delegate = delegate;\n    return _this;\n  }\n\n  _createClass(InviteUserAgentClient, [{\n    key: \"dispose\",\n    value: function dispose() {\n      // The UAC core considers the INVITE transaction completed 64*T1 seconds\n      // after the reception of the first 2xx response.  At this point all the\n      // early dialogs that have not transitioned to established dialogs are\n      // terminated.  Once the INVITE transaction is considered completed by\n      // the UAC core, no more new 2xx responses are expected to arrive.\n      //\n      // If, after acknowledging any 2xx response to an INVITE, the UAC does\n      // not want to continue with that dialog, then the UAC MUST terminate\n      // the dialog by sending a BYE request as described in Section 15.\n      // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n      this.earlyDialogs.forEach(function (earlyDialog) {\n        return earlyDialog.dispose();\n      });\n      this.earlyDialogs.clear();\n\n      _get(_getPrototypeOf(InviteUserAgentClient.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * Special case for transport error while sending ACK.\n     * @param error - Transport error\n     */\n\n  }, {\n    key: \"onTransportError\",\n    value: function onTransportError(error) {\n      if (this.transaction.state === TransactionState.Calling) {\n        return _get(_getPrototypeOf(InviteUserAgentClient.prototype), \"onTransportError\", this).call(this, error);\n      } // If not in 'calling' state, the transport error occurred while sending an ACK.\n\n\n      this.logger.error(error.message);\n      this.logger.error(\"User agent client request transport error while sending ACK.\");\n    }\n    /**\n     * Once the INVITE has been passed to the INVITE client transaction, the\n     * UAC waits for responses for the INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2\n     * @param incomingResponse - Incoming response to INVITE request.\n     */\n\n  }, {\n    key: \"receiveResponse\",\n    value: function receiveResponse(message) {\n      var _this2 = this;\n\n      if (!this.authenticationGuard(message)) {\n        return;\n      }\n\n      var statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n      if (!statusCode) {\n        throw new Error(\"Response status code undefined.\");\n      }\n\n      switch (true) {\n        case /^100$/.test(statusCode):\n          if (this.delegate && this.delegate.onTrying) {\n            this.delegate.onTrying({\n              message: message\n            });\n          }\n\n          return;\n\n        case /^1[0-9]{2}$/.test(statusCode):\n          // Zero, one or multiple provisional responses may arrive before one or\n          // more final responses are received.  Provisional responses for an\n          // INVITE request can create \"early dialogs\".  If a provisional response\n          // has a tag in the To field, and if the dialog ID of the response does\n          // not match an existing dialog, one is constructed using the procedures\n          // defined in Section 12.1.2.\n          //\n          // The early dialog will only be needed if the UAC needs to send a\n          // request to its peer within the dialog before the initial INVITE\n          // transaction completes.  Header fields present in a provisional\n          // response are applicable as long as the dialog is in the early state\n          // (for example, an Allow header field in a provisional response\n          // contains the methods that can be used in the dialog while this is in\n          // the early state).\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.1\n          {\n            // Dialogs are created through the generation of non-failure responses\n            // to requests with specific methods.  Within this specification, only\n            // 2xx and 101-199 responses with a To tag, where the request was\n            // INVITE, will establish a dialog.  A dialog established by a non-final\n            // response to a request is in the \"early\" state and it is called an\n            // early dialog.\n            // https://tools.ietf.org/html/rfc3261#section-12.1\n            // Provisional without to tag, no dialog to create.\n            if (!message.toTag) {\n              this.logger.warn(\"Non-100 1xx INVITE response received without a to tag, dropping.\");\n              return;\n            } // When a UAS responds to a request with a response that establishes a\n            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n            // header field values from the request into the response (including the\n            // URIs, URI parameters, and any Record-Route header field parameters,\n            // whether they are known or unknown to the UAS) and MUST maintain the\n            // order of those values.  The UAS MUST add a Contact header field to\n            // the response.\n            // https://tools.ietf.org/html/rfc3261#section-12.1.1\n            // Provisional without Contact header field, malformed response.\n\n\n            var contact = message.parseHeader(\"contact\");\n\n            if (!contact) {\n              this.logger.error(\"Non-100 1xx INVITE response received without a Contact header field, dropping.\");\n              return;\n            } // Compute dialog state.\n\n\n            var dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // Have existing early dialog or create a new one.\n\n            var earlyDialog = this.earlyDialogs.get(dialogState.id);\n\n            if (!earlyDialog) {\n              var transaction = this.transaction;\n\n              if (!(transaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n              }\n\n              earlyDialog = new SessionDialog(transaction, this.core, dialogState);\n              this.earlyDialogs.set(earlyDialog.id, earlyDialog);\n            } // Guard against out of order reliable provisional responses.\n            // Note that this is where the rseq tracking is done.\n\n\n            if (!earlyDialog.reliableSequenceGuard(message)) {\n              this.logger.warn(\"1xx INVITE reliable response received out of order or is a retransmission, dropping.\");\n              return;\n            } // If the initial offer is in an INVITE, the answer MUST be in a\n            // reliable non-failure message from UAS back to UAC which is\n            // correlated to that INVITE.  For this specification, that is\n            // only the final 2xx response to that INVITE.  That same exact\n            // answer MAY also be placed in any provisional responses sent\n            // prior to the answer.  The UAC MUST treat the first session\n            // description it receives as the answer, and MUST ignore any\n            // session descriptions in subsequent responses to the initial\n            // INVITE.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n            if (earlyDialog.signalingState === SignalingState.Initial || earlyDialog.signalingState === SignalingState.HaveLocalOffer) {\n              earlyDialog.signalingStateTransition(message);\n            } // Pass response to delegate.\n\n\n            var session = earlyDialog;\n\n            if (this.delegate && this.delegate.onProgress) {\n              this.delegate.onProgress({\n                message: message,\n                session: session,\n                prack: function prack(options) {\n                  var outgoingPrackRequest = session.prack(undefined, options);\n                  return outgoingPrackRequest;\n                }\n              });\n            }\n          }\n          return;\n\n        case /^2[0-9]{2}$/.test(statusCode):\n          // Multiple 2xx responses may arrive at the UAC for a single INVITE\n          // request due to a forking proxy.  Each response is distinguished by\n          // the tag parameter in the To header field, and each represents a\n          // distinct dialog, with a distinct dialog identifier.\n          //\n          // If the dialog identifier in the 2xx response matches the dialog\n          // identifier of an existing dialog, the dialog MUST be transitioned to\n          // the \"confirmed\" state, and the route set for the dialog MUST be\n          // recomputed based on the 2xx response using the procedures of Section\n          // 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n          // constructed using the procedures of Section 12.1.2.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n          {\n            // Dialogs are created through the generation of non-failure responses\n            // to requests with specific methods.  Within this specification, only\n            // 2xx and 101-199 responses with a To tag, where the request was\n            // INVITE, will establish a dialog.  A dialog established by a non-final\n            // response to a request is in the \"early\" state and it is called an\n            // early dialog.\n            // https://tools.ietf.org/html/rfc3261#section-12.1\n            // Final without to tag, malformed response.\n            if (!message.toTag) {\n              this.logger.error(\"2xx INVITE response received without a to tag, dropping.\");\n              return;\n            } // When a UAS responds to a request with a response that establishes a\n            // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n            // header field values from the request into the response (including the\n            // URIs, URI parameters, and any Record-Route header field parameters,\n            // whether they are known or unknown to the UAS) and MUST maintain the\n            // order of those values.  The UAS MUST add a Contact header field to\n            // the response.\n            // https://tools.ietf.org/html/rfc3261#section-12.1.1\n            // Final without Contact header field, malformed response.\n\n\n            var _contact = message.parseHeader(\"contact\");\n\n            if (!_contact) {\n              this.logger.error(\"2xx INVITE response received without a Contact header field, dropping.\");\n              return;\n            } // Compute dialog state.\n\n\n            var _dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // NOTE: Currently our transaction layer is caching the 2xx ACKs and\n            // handling retransmissions of the ACK which is an approach which is\n            // not to spec. In any event, this block is intended to provide a to\n            // spec implementation of ACK retransmissions, but it should not be\n            // hit currently.\n\n\n            var dialog = this.confirmedDialogs.get(_dialogState.id);\n\n            if (dialog) {\n              // Once the ACK has been constructed, the procedures of [4] are used to\n              // determine the destination address, port and transport.  However, the\n              // request is passed to the transport layer directly for transmission,\n              // rather than a client transaction.  This is because the UAC core\n              // handles retransmissions of the ACK, not the transaction layer.  The\n              // ACK MUST be passed to the client transport every time a\n              // retransmission of the 2xx final response that triggered the ACK\n              // arrives.\n              // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n              var outgoingAckRequest = this.confirmedDialogAcks.get(_dialogState.id);\n\n              if (outgoingAckRequest) {\n                var _transaction = this.transaction;\n\n                if (!(_transaction instanceof InviteClientTransaction)) {\n                  throw new Error(\"Client transaction not instance of InviteClientTransaction.\");\n                }\n\n                _transaction.ackResponse(outgoingAckRequest.message);\n              } else {// If still waiting for an ACK, drop the retransmission of the 2xx final response.\n              }\n\n              return;\n            } // If the dialog identifier in the 2xx response matches the dialog\n            // identifier of an existing dialog, the dialog MUST be transitioned to\n            // the \"confirmed\" state, and the route set for the dialog MUST be\n            // recomputed based on the 2xx response using the procedures of Section\n            // 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be\n            // constructed using the procedures of Section 12.1.2.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n\n            dialog = this.earlyDialogs.get(_dialogState.id);\n\n            if (dialog) {\n              dialog.confirm();\n              dialog.recomputeRouteSet(message);\n              this.earlyDialogs.delete(dialog.id);\n              this.confirmedDialogs.set(dialog.id, dialog);\n            } else {\n              var _transaction2 = this.transaction;\n\n              if (!(_transaction2 instanceof InviteClientTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n              }\n\n              dialog = new SessionDialog(_transaction2, this.core, _dialogState);\n              this.confirmedDialogs.set(dialog.id, dialog);\n            } // If the initial offer is in an INVITE, the answer MUST be in a\n            // reliable non-failure message from UAS back to UAC which is\n            // correlated to that INVITE.  For this specification, that is\n            // only the final 2xx response to that INVITE.  That same exact\n            // answer MAY also be placed in any provisional responses sent\n            // prior to the answer.  The UAC MUST treat the first session\n            // description it receives as the answer, and MUST ignore any\n            // session descriptions in subsequent responses to the initial\n            // INVITE.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n            if (dialog.signalingState === SignalingState.Initial || dialog.signalingState === SignalingState.HaveLocalOffer) {\n              dialog.signalingStateTransition(message);\n            } // Session Initiated! :)\n\n\n            var _session = dialog; // The UAC core MUST generate an ACK request for each 2xx received from\n            // the transaction layer.  The header fields of the ACK are constructed\n            // in the same way as for any request sent within a dialog (see Section\n            // 12) with the exception of the CSeq and the header fields related to\n            // authentication.  The sequence number of the CSeq header field MUST be\n            // the same as the INVITE being acknowledged, but the CSeq method MUST\n            // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n            // the 2xx contains an offer (based on the rules above), the ACK MUST\n            // carry an answer in its body.  If the offer in the 2xx response is not\n            // acceptable, the UAC core MUST generate a valid answer in the ACK and\n            // then send a BYE immediately.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n            if (this.delegate && this.delegate.onAccept) {\n              this.delegate.onAccept({\n                message: message,\n                session: _session,\n                ack: function ack(options) {\n                  var outgoingAckRequest = _session.ack(options);\n\n                  _this2.confirmedDialogAcks.set(_session.id, outgoingAckRequest);\n\n                  return outgoingAckRequest;\n                }\n              });\n            } else {\n              var _outgoingAckRequest = _session.ack();\n\n              this.confirmedDialogAcks.set(_session.id, _outgoingAckRequest);\n            }\n          }\n          return;\n\n        case /^3[0-9]{2}$/.test(statusCode):\n          // 12.3 Termination of a Dialog\n          //\n          // Independent of the method, if a request outside of a dialog generates\n          // a non-2xx final response, any early dialogs created through\n          // provisional responses to that request are terminated.  The mechanism\n          // for terminating confirmed dialogs is method specific.  In this\n          // specification, the BYE method terminates a session and the dialog\n          // associated with it.  See Section 15 for details.\n          // https://tools.ietf.org/html/rfc3261#section-12.3\n          // All early dialogs are considered terminated upon reception of the\n          // non-2xx final response.\n          //\n          // After having received the non-2xx final response the UAC core\n          // considers the INVITE transaction completed.  The INVITE client\n          // transaction handles the generation of ACKs for the response (see\n          // Section 17).\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n          this.earlyDialogs.forEach(function (earlyDialog) {\n            return earlyDialog.dispose();\n          });\n          this.earlyDialogs.clear(); // A 3xx response may contain one or more Contact header field values\n          // providing new addresses where the callee might be reachable.\n          // Depending on the status code of the 3xx response (see Section 21.3),\n          // the UAC MAY choose to try those new addresses.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.2\n\n          if (this.delegate && this.delegate.onRedirect) {\n            this.delegate.onRedirect({\n              message: message\n            });\n          }\n\n          return;\n\n        case /^[4-6][0-9]{2}$/.test(statusCode):\n          // 12.3 Termination of a Dialog\n          //\n          // Independent of the method, if a request outside of a dialog generates\n          // a non-2xx final response, any early dialogs created through\n          // provisional responses to that request are terminated.  The mechanism\n          // for terminating confirmed dialogs is method specific.  In this\n          // specification, the BYE method terminates a session and the dialog\n          // associated with it.  See Section 15 for details.\n          // https://tools.ietf.org/html/rfc3261#section-12.3\n          // All early dialogs are considered terminated upon reception of the\n          // non-2xx final response.\n          //\n          // After having received the non-2xx final response the UAC core\n          // considers the INVITE transaction completed.  The INVITE client\n          // transaction handles the generation of ACKs for the response (see\n          // Section 17).\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n          this.earlyDialogs.forEach(function (earlyDialog) {\n            return earlyDialog.dispose();\n          });\n          this.earlyDialogs.clear(); // A single non-2xx final response may be received for the INVITE.  4xx,\n          // 5xx and 6xx responses may contain a Contact header field value\n          // indicating the location where additional information about the error\n          // can be found.  Subsequent final responses (which would only arrive\n          // under error conditions) MUST be ignored.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n\n          if (this.delegate && this.delegate.onReject) {\n            this.delegate.onReject({\n              message: message\n            });\n          }\n\n          return;\n\n        default:\n          throw new Error(\"Invalid status code \".concat(statusCode));\n      }\n\n      throw new Error(\"Executing what should be an unreachable code path receiving \".concat(statusCode, \" response.\"));\n    }\n  }]);\n\n  return InviteUserAgentClient;\n}(UserAgentClient);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/invite-user-agent-client.js"],"names":["Dialog","SessionDialog","SignalingState","InviteClientTransaction","TransactionState","UserAgentClient","InviteUserAgentClient","core","message","delegate","confirmedDialogAcks","Map","confirmedDialogs","earlyDialogs","forEach","earlyDialog","dispose","clear","error","transaction","state","Calling","logger","authenticationGuard","statusCode","toString","Error","test","onTrying","toTag","warn","contact","parseHeader","dialogState","initialDialogStateForUserAgentClient","get","id","set","reliableSequenceGuard","signalingState","Initial","HaveLocalOffer","signalingStateTransition","session","onProgress","prack","options","outgoingPrackRequest","undefined","dialog","outgoingAckRequest","ackResponse","confirm","recomputeRouteSet","delete","onAccept","ack","onRedirect","onReject"],"mappings":"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","sourcesContent":["import { Dialog, SessionDialog } from \"../dialogs\";\nimport { SignalingState } from \"../session\";\nimport { InviteClientTransaction, TransactionState } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * INVITE UAC.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.2 UAC Processing\n * https://tools.ietf.org/html/rfc3261#section-13.2\n * @public\n */\nexport class InviteUserAgentClient extends UserAgentClient {\n    constructor(core, message, delegate) {\n        super(InviteClientTransaction, core, message, delegate);\n        this.confirmedDialogAcks = new Map();\n        this.confirmedDialogs = new Map();\n        this.earlyDialogs = new Map();\n        this.delegate = delegate;\n    }\n    dispose() {\n        // The UAC core considers the INVITE transaction completed 64*T1 seconds\n        // after the reception of the first 2xx response.  At this point all the\n        // early dialogs that have not transitioned to established dialogs are\n        // terminated.  Once the INVITE transaction is considered completed by\n        // the UAC core, no more new 2xx responses are expected to arrive.\n        //\n        // If, after acknowledging any 2xx response to an INVITE, the UAC does\n        // not want to continue with that dialog, then the UAC MUST terminate\n        // the dialog by sending a BYE request as described in Section 15.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n        this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n        this.earlyDialogs.clear();\n        super.dispose();\n    }\n    /**\n     * Special case for transport error while sending ACK.\n     * @param error - Transport error\n     */\n    onTransportError(error) {\n        if (this.transaction.state === TransactionState.Calling) {\n            return super.onTransportError(error);\n        }\n        // If not in 'calling' state, the transport error occurred while sending an ACK.\n        this.logger.error(error.message);\n        this.logger.error(\"User agent client request transport error while sending ACK.\");\n    }\n    /**\n     * Once the INVITE has been passed to the INVITE client transaction, the\n     * UAC waits for responses for the INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2\n     * @param incomingResponse - Incoming response to INVITE request.\n     */\n    receiveResponse(message) {\n        if (!this.authenticationGuard(message)) {\n            return;\n        }\n        const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        switch (true) {\n            case /^100$/.test(statusCode):\n                if (this.delegate && this.delegate.onTrying) {\n                    this.delegate.onTrying({ message });\n                }\n                return;\n            case /^1[0-9]{2}$/.test(statusCode):\n                // Zero, one or multiple provisional responses may arrive before one or\n                // more final responses are received.  Provisional responses for an\n                // INVITE request can create \"early dialogs\".  If a provisional response\n                // has a tag in the To field, and if the dialog ID of the response does\n                // not match an existing dialog, one is constructed using the procedures\n                // defined in Section 12.1.2.\n                //\n                // The early dialog will only be needed if the UAC needs to send a\n                // request to its peer within the dialog before the initial INVITE\n                // transaction completes.  Header fields present in a provisional\n                // response are applicable as long as the dialog is in the early state\n                // (for example, an Allow header field in a provisional response\n                // contains the methods that can be used in the dialog while this is in\n                // the early state).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.1\n                {\n                    // Dialogs are created through the generation of non-failure responses\n                    // to requests with specific methods.  Within this specification, only\n                    // 2xx and 101-199 responses with a To tag, where the request was\n                    // INVITE, will establish a dialog.  A dialog established by a non-final\n                    // response to a request is in the \"early\" state and it is called an\n                    // early dialog.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1\n                    // Provisional without to tag, no dialog to create.\n                    if (!message.toTag) {\n                        this.logger.warn(\"Non-100 1xx INVITE response received without a to tag, dropping.\");\n                        return;\n                    }\n                    // When a UAS responds to a request with a response that establishes a\n                    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n                    // header field values from the request into the response (including the\n                    // URIs, URI parameters, and any Record-Route header field parameters,\n                    // whether they are known or unknown to the UAS) and MUST maintain the\n                    // order of those values.  The UAS MUST add a Contact header field to\n                    // the response.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n                    // Provisional without Contact header field, malformed response.\n                    const contact = message.parseHeader(\"contact\");\n                    if (!contact) {\n                        this.logger.error(\"Non-100 1xx INVITE response received without a Contact header field, dropping.\");\n                        return;\n                    }\n                    // Compute dialog state.\n                    const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message);\n                    // Have existing early dialog or create a new one.\n                    let earlyDialog = this.earlyDialogs.get(dialogState.id);\n                    if (!earlyDialog) {\n                        const transaction = this.transaction;\n                        if (!(transaction instanceof InviteClientTransaction)) {\n                            throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                        }\n                        earlyDialog = new SessionDialog(transaction, this.core, dialogState);\n                        this.earlyDialogs.set(earlyDialog.id, earlyDialog);\n                    }\n                    // Guard against out of order reliable provisional responses.\n                    // Note that this is where the rseq tracking is done.\n                    if (!earlyDialog.reliableSequenceGuard(message)) {\n                        this.logger.warn(\"1xx INVITE reliable response received out of order or is a retransmission, dropping.\");\n                        return;\n                    }\n                    // If the initial offer is in an INVITE, the answer MUST be in a\n                    // reliable non-failure message from UAS back to UAC which is\n                    // correlated to that INVITE.  For this specification, that is\n                    // only the final 2xx response to that INVITE.  That same exact\n                    // answer MAY also be placed in any provisional responses sent\n                    // prior to the answer.  The UAC MUST treat the first session\n                    // description it receives as the answer, and MUST ignore any\n                    // session descriptions in subsequent responses to the initial\n                    // INVITE.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    if (earlyDialog.signalingState === SignalingState.Initial ||\n                        earlyDialog.signalingState === SignalingState.HaveLocalOffer) {\n                        earlyDialog.signalingStateTransition(message);\n                    }\n                    // Pass response to delegate.\n                    const session = earlyDialog;\n                    if (this.delegate && this.delegate.onProgress) {\n                        this.delegate.onProgress({\n                            message,\n                            session,\n                            prack: (options) => {\n                                const outgoingPrackRequest = session.prack(undefined, options);\n                                return outgoingPrackRequest;\n                            }\n                        });\n                    }\n                }\n                return;\n            case /^2[0-9]{2}$/.test(statusCode):\n                // Multiple 2xx responses may arrive at the UAC for a single INVITE\n                // request due to a forking proxy.  Each response is distinguished by\n                // the tag parameter in the To header field, and each represents a\n                // distinct dialog, with a distinct dialog identifier.\n                //\n                // If the dialog identifier in the 2xx response matches the dialog\n                // identifier of an existing dialog, the dialog MUST be transitioned to\n                // the \"confirmed\" state, and the route set for the dialog MUST be\n                // recomputed based on the 2xx response using the procedures of Section\n                // 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n                // constructed using the procedures of Section 12.1.2.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                {\n                    // Dialogs are created through the generation of non-failure responses\n                    // to requests with specific methods.  Within this specification, only\n                    // 2xx and 101-199 responses with a To tag, where the request was\n                    // INVITE, will establish a dialog.  A dialog established by a non-final\n                    // response to a request is in the \"early\" state and it is called an\n                    // early dialog.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1\n                    // Final without to tag, malformed response.\n                    if (!message.toTag) {\n                        this.logger.error(\"2xx INVITE response received without a to tag, dropping.\");\n                        return;\n                    }\n                    // When a UAS responds to a request with a response that establishes a\n                    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n                    // header field values from the request into the response (including the\n                    // URIs, URI parameters, and any Record-Route header field parameters,\n                    // whether they are known or unknown to the UAS) and MUST maintain the\n                    // order of those values.  The UAS MUST add a Contact header field to\n                    // the response.\n                    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n                    // Final without Contact header field, malformed response.\n                    const contact = message.parseHeader(\"contact\");\n                    if (!contact) {\n                        this.logger.error(\"2xx INVITE response received without a Contact header field, dropping.\");\n                        return;\n                    }\n                    // Compute dialog state.\n                    const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message);\n                    // NOTE: Currently our transaction layer is caching the 2xx ACKs and\n                    // handling retransmissions of the ACK which is an approach which is\n                    // not to spec. In any event, this block is intended to provide a to\n                    // spec implementation of ACK retransmissions, but it should not be\n                    // hit currently.\n                    let dialog = this.confirmedDialogs.get(dialogState.id);\n                    if (dialog) {\n                        // Once the ACK has been constructed, the procedures of [4] are used to\n                        // determine the destination address, port and transport.  However, the\n                        // request is passed to the transport layer directly for transmission,\n                        // rather than a client transaction.  This is because the UAC core\n                        // handles retransmissions of the ACK, not the transaction layer.  The\n                        // ACK MUST be passed to the client transport every time a\n                        // retransmission of the 2xx final response that triggered the ACK\n                        // arrives.\n                        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                        const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);\n                        if (outgoingAckRequest) {\n                            const transaction = this.transaction;\n                            if (!(transaction instanceof InviteClientTransaction)) {\n                                throw new Error(\"Client transaction not instance of InviteClientTransaction.\");\n                            }\n                            transaction.ackResponse(outgoingAckRequest.message);\n                        }\n                        else {\n                            // If still waiting for an ACK, drop the retransmission of the 2xx final response.\n                        }\n                        return;\n                    }\n                    // If the dialog identifier in the 2xx response matches the dialog\n                    // identifier of an existing dialog, the dialog MUST be transitioned to\n                    // the \"confirmed\" state, and the route set for the dialog MUST be\n                    // recomputed based on the 2xx response using the procedures of Section\n                    // 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be\n                    // constructed using the procedures of Section 12.1.2.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                    dialog = this.earlyDialogs.get(dialogState.id);\n                    if (dialog) {\n                        dialog.confirm();\n                        dialog.recomputeRouteSet(message);\n                        this.earlyDialogs.delete(dialog.id);\n                        this.confirmedDialogs.set(dialog.id, dialog);\n                    }\n                    else {\n                        const transaction = this.transaction;\n                        if (!(transaction instanceof InviteClientTransaction)) {\n                            throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                        }\n                        dialog = new SessionDialog(transaction, this.core, dialogState);\n                        this.confirmedDialogs.set(dialog.id, dialog);\n                    }\n                    // If the initial offer is in an INVITE, the answer MUST be in a\n                    // reliable non-failure message from UAS back to UAC which is\n                    // correlated to that INVITE.  For this specification, that is\n                    // only the final 2xx response to that INVITE.  That same exact\n                    // answer MAY also be placed in any provisional responses sent\n                    // prior to the answer.  The UAC MUST treat the first session\n                    // description it receives as the answer, and MUST ignore any\n                    // session descriptions in subsequent responses to the initial\n                    // INVITE.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    if (dialog.signalingState === SignalingState.Initial ||\n                        dialog.signalingState === SignalingState.HaveLocalOffer) {\n                        dialog.signalingStateTransition(message);\n                    }\n                    // Session Initiated! :)\n                    const session = dialog;\n                    // The UAC core MUST generate an ACK request for each 2xx received from\n                    // the transaction layer.  The header fields of the ACK are constructed\n                    // in the same way as for any request sent within a dialog (see Section\n                    // 12) with the exception of the CSeq and the header fields related to\n                    // authentication.  The sequence number of the CSeq header field MUST be\n                    // the same as the INVITE being acknowledged, but the CSeq method MUST\n                    // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n                    // the 2xx contains an offer (based on the rules above), the ACK MUST\n                    // carry an answer in its body.  If the offer in the 2xx response is not\n                    // acceptable, the UAC core MUST generate a valid answer in the ACK and\n                    // then send a BYE immediately.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n                    if (this.delegate && this.delegate.onAccept) {\n                        this.delegate.onAccept({\n                            message,\n                            session,\n                            ack: (options) => {\n                                const outgoingAckRequest = session.ack(options);\n                                this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                                return outgoingAckRequest;\n                            }\n                        });\n                    }\n                    else {\n                        const outgoingAckRequest = session.ack();\n                        this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                    }\n                }\n                return;\n            case /^3[0-9]{2}$/.test(statusCode):\n                // 12.3 Termination of a Dialog\n                //\n                // Independent of the method, if a request outside of a dialog generates\n                // a non-2xx final response, any early dialogs created through\n                // provisional responses to that request are terminated.  The mechanism\n                // for terminating confirmed dialogs is method specific.  In this\n                // specification, the BYE method terminates a session and the dialog\n                // associated with it.  See Section 15 for details.\n                // https://tools.ietf.org/html/rfc3261#section-12.3\n                // All early dialogs are considered terminated upon reception of the\n                // non-2xx final response.\n                //\n                // After having received the non-2xx final response the UAC core\n                // considers the INVITE transaction completed.  The INVITE client\n                // transaction handles the generation of ACKs for the response (see\n                // Section 17).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n                this.earlyDialogs.clear();\n                // A 3xx response may contain one or more Contact header field values\n                // providing new addresses where the callee might be reachable.\n                // Depending on the status code of the 3xx response (see Section 21.3),\n                // the UAC MAY choose to try those new addresses.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.2\n                if (this.delegate && this.delegate.onRedirect) {\n                    this.delegate.onRedirect({ message });\n                }\n                return;\n            case /^[4-6][0-9]{2}$/.test(statusCode):\n                // 12.3 Termination of a Dialog\n                //\n                // Independent of the method, if a request outside of a dialog generates\n                // a non-2xx final response, any early dialogs created through\n                // provisional responses to that request are terminated.  The mechanism\n                // for terminating confirmed dialogs is method specific.  In this\n                // specification, the BYE method terminates a session and the dialog\n                // associated with it.  See Section 15 for details.\n                // https://tools.ietf.org/html/rfc3261#section-12.3\n                // All early dialogs are considered terminated upon reception of the\n                // non-2xx final response.\n                //\n                // After having received the non-2xx final response the UAC core\n                // considers the INVITE transaction completed.  The INVITE client\n                // transaction handles the generation of ACKs for the response (see\n                // Section 17).\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                this.earlyDialogs.forEach((earlyDialog) => earlyDialog.dispose());\n                this.earlyDialogs.clear();\n                // A single non-2xx final response may be received for the INVITE.  4xx,\n                // 5xx and 6xx responses may contain a Contact header field value\n                // indicating the location where additional information about the error\n                // can be found.  Subsequent final responses (which would only arrive\n                // under error conditions) MUST be ignored.\n                // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n                if (this.delegate && this.delegate.onReject) {\n                    this.delegate.onReject({ message });\n                }\n                return;\n            default:\n                throw new Error(`Invalid status code ${statusCode}`);\n        }\n        throw new Error(`Executing what should be an unreachable code path receiving ${statusCode} response.`);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}