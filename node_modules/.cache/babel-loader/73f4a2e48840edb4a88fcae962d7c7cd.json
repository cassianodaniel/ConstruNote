{"ast":null,"code":"import { TransportError } from \"../exceptions\";\n/**\n * Transaction.\n * @remarks\n * SIP is a transactional protocol: interactions between components take\n * place in a series of independent message exchanges.  Specifically, a\n * SIP transaction consists of a single request and any responses to\n * that request, which include zero or more provisional responses and\n * one or more final responses.  In the case of a transaction where the\n * request was an INVITE (known as an INVITE transaction), the\n * transaction also includes the ACK only if the final response was not\n * a 2xx response.  If the response was a 2xx, the ACK is not considered\n * part of the transaction.\n * https://tools.ietf.org/html/rfc3261#section-17\n * @public\n */\n\nexport class Transaction {\n  constructor(_transport, _user, _id, _state, loggerCategory) {\n    this._transport = _transport;\n    this._user = _user;\n    this._id = _id;\n    this._state = _state;\n    this.listeners = new Array();\n    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);\n    this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);\n  }\n  /**\n   * Destructor.\n   * Once the transaction is in the \"terminated\" state, it is destroyed\n   * immediately and there is no need to call `dispose`. However, if a\n   * transaction needs to be ended prematurely, the transaction user may\n   * do so by calling this method (for example, perhaps the UA is shutting down).\n   * No state transition will occur upon calling this method, all outstanding\n   * transmission timers will be cancelled, and use of the transaction after\n   * calling `dispose` is undefined.\n   */\n\n\n  dispose() {\n    this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);\n  }\n  /** Transaction id. */\n\n\n  get id() {\n    return this._id;\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    throw new Error(\"Invalid kind.\");\n  }\n  /** Transaction state. */\n\n\n  get state() {\n    return this._state;\n  }\n  /** Transaction transport. */\n\n\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * Sets up a function that will be called whenever the transaction state changes.\n   * @param listener - Callback function.\n   * @param options - An options object that specifies characteristics about the listener.\n   *                  If once true, indicates that the listener should be invoked at most once after being added.\n   *                  If once true, the listener would be automatically removed when invoked.\n   */\n\n\n  addStateChangeListener(listener, options) {\n    const onceWrapper = () => {\n      this.removeStateChangeListener(onceWrapper);\n      listener();\n    };\n\n    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);\n  }\n  /**\n   * This is currently public so tests may spy on it.\n   * @internal\n   */\n\n\n  notifyStateChangeListeners() {\n    this.listeners.slice().forEach(listener => listener());\n  }\n  /**\n   * Removes a listener previously registered with addStateListener.\n   * @param listener - Callback function.\n   */\n\n\n  removeStateChangeListener(listener) {\n    this.listeners = this.listeners.filter(l => l !== listener);\n  }\n\n  logTransportError(error, message) {\n    this.logger.error(error.message);\n    this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);\n    this.logger.error(message);\n  }\n  /**\n   * Pass message to transport for transmission. If transport fails,\n   * the transaction user is notified by callback to onTransportError().\n   * @returns\n   * Rejects with `TransportError` if transport fails.\n   */\n\n\n  send(message) {\n    return this.transport.send(message).catch(error => {\n      // If the transport rejects, it SHOULD reject with a TransportError.\n      // But the transport may be external code, so we are careful\n      // make sure we convert it to a TransportError if need be.\n      if (error instanceof TransportError) {\n        this.onTransportError(error);\n        throw error;\n      }\n\n      let transportError;\n\n      if (error && typeof error.message === \"string\") {\n        transportError = new TransportError(error.message);\n      } else {\n        transportError = new TransportError();\n      }\n\n      this.onTransportError(transportError);\n      throw transportError;\n    });\n  }\n\n  setState(state) {\n    this.logger.debug(`State change to \"${state}\" on ${this.typeToString()} with id ${this.id}.`);\n    this._state = state;\n\n    if (this._user.onStateChange) {\n      this._user.onStateChange(state);\n    }\n\n    this.notifyStateChangeListeners();\n  }\n\n  typeToString() {\n    return \"UnknownType\";\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/transaction.js"],"names":["TransportError","Transaction","constructor","_transport","_user","_id","_state","loggerCategory","listeners","Array","logger","loggerFactory","getLogger","debug","typeToString","id","dispose","kind","Error","state","transport","addStateChangeListener","listener","options","onceWrapper","removeStateChangeListener","once","push","notifyStateChangeListeners","slice","forEach","filter","l","logTransportError","error","message","send","catch","onTransportError","transportError","setState","onStateChange"],"mappings":"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","sourcesContent":["import { TransportError } from \"../exceptions\";\n/**\n * Transaction.\n * @remarks\n * SIP is a transactional protocol: interactions between components take\n * place in a series of independent message exchanges.  Specifically, a\n * SIP transaction consists of a single request and any responses to\n * that request, which include zero or more provisional responses and\n * one or more final responses.  In the case of a transaction where the\n * request was an INVITE (known as an INVITE transaction), the\n * transaction also includes the ACK only if the final response was not\n * a 2xx response.  If the response was a 2xx, the ACK is not considered\n * part of the transaction.\n * https://tools.ietf.org/html/rfc3261#section-17\n * @public\n */\nexport class Transaction {\n    constructor(_transport, _user, _id, _state, loggerCategory) {\n        this._transport = _transport;\n        this._user = _user;\n        this._id = _id;\n        this._state = _state;\n        this.listeners = new Array();\n        this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);\n        this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);\n    }\n    /**\n     * Destructor.\n     * Once the transaction is in the \"terminated\" state, it is destroyed\n     * immediately and there is no need to call `dispose`. However, if a\n     * transaction needs to be ended prematurely, the transaction user may\n     * do so by calling this method (for example, perhaps the UA is shutting down).\n     * No state transition will occur upon calling this method, all outstanding\n     * transmission timers will be cancelled, and use of the transaction after\n     * calling `dispose` is undefined.\n     */\n    dispose() {\n        this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);\n    }\n    /** Transaction id. */\n    get id() {\n        return this._id;\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        throw new Error(\"Invalid kind.\");\n    }\n    /** Transaction state. */\n    get state() {\n        return this._state;\n    }\n    /** Transaction transport. */\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * Sets up a function that will be called whenever the transaction state changes.\n     * @param listener - Callback function.\n     * @param options - An options object that specifies characteristics about the listener.\n     *                  If once true, indicates that the listener should be invoked at most once after being added.\n     *                  If once true, the listener would be automatically removed when invoked.\n     */\n    addStateChangeListener(listener, options) {\n        const onceWrapper = () => {\n            this.removeStateChangeListener(onceWrapper);\n            listener();\n        };\n        (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);\n    }\n    /**\n     * This is currently public so tests may spy on it.\n     * @internal\n     */\n    notifyStateChangeListeners() {\n        this.listeners.slice().forEach((listener) => listener());\n    }\n    /**\n     * Removes a listener previously registered with addStateListener.\n     * @param listener - Callback function.\n     */\n    removeStateChangeListener(listener) {\n        this.listeners = this.listeners.filter((l) => l !== listener);\n    }\n    logTransportError(error, message) {\n        this.logger.error(error.message);\n        this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);\n        this.logger.error(message);\n    }\n    /**\n     * Pass message to transport for transmission. If transport fails,\n     * the transaction user is notified by callback to onTransportError().\n     * @returns\n     * Rejects with `TransportError` if transport fails.\n     */\n    send(message) {\n        return this.transport.send(message).catch((error) => {\n            // If the transport rejects, it SHOULD reject with a TransportError.\n            // But the transport may be external code, so we are careful\n            // make sure we convert it to a TransportError if need be.\n            if (error instanceof TransportError) {\n                this.onTransportError(error);\n                throw error;\n            }\n            let transportError;\n            if (error && typeof error.message === \"string\") {\n                transportError = new TransportError(error.message);\n            }\n            else {\n                transportError = new TransportError();\n            }\n            this.onTransportError(transportError);\n            throw transportError;\n        });\n    }\n    setState(state) {\n        this.logger.debug(`State change to \"${state}\" on ${this.typeToString()} with id ${this.id}.`);\n        this._state = state;\n        if (this._user.onStateChange) {\n            this._user.onStateChange(state);\n        }\n        this.notifyStateChangeListeners();\n    }\n    typeToString() {\n        return \"UnknownType\";\n    }\n}\n"]},"metadata":{},"sourceType":"module"}