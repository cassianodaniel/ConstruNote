{"ast":null,"code":"import { C, Grammar, SignalingState } from \"../core\";\nimport { getReasonPhrase, newTag } from \"../core/messages/utils\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An inviter offers to establish a {@link Session} (outgoing INVITE).\n * @public\n */\n\nexport class Inviter extends Session {\n  /**\n   * Constructs a new instance of the `Inviter` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - Request URI identifying the target of the message.\n   * @param options - Options bucket. See {@link InviterOptions} for details.\n   */\n  constructor(userAgent, targetURI, options = {}) {\n    super(userAgent, options);\n    /** True if dispose() has been called. */\n\n    this.disposed = false;\n    /** True if early media use is enabled. */\n\n    this.earlyMedia = false;\n    /** The early media session description handlers. */\n\n    this.earlyMediaSessionDescriptionHandlers = new Map();\n    /** True if cancel() was called. */\n\n    this.isCanceled = false;\n    /** True if initial INVITE without SDP. */\n\n    this.inviteWithoutSdp = false;\n    this.logger = userAgent.getLogger(\"sip.Inviter\"); // Early media\n\n    this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : this.earlyMedia; // From tag\n\n    this.fromTag = newTag(); // Invite without SDP\n\n    this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : this.inviteWithoutSdp; // Inviter options (could do better copying these options)\n\n    const inviterOptions = Object.assign({}, options);\n    inviterOptions.params = Object.assign({}, options.params); // Anonymous call\n\n    const anonymous = options.anonymous || false; // Contact\n\n    const contact = userAgent.contact.toString({\n      anonymous,\n      // Do not add ;ob in initial forming dialog requests if the\n      // registration over the current connection got a GRUU URI.\n      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu\n    }); // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception\n    // which is not something we want our constructor to do. URIs should be passed in as params.\n    // URIs\n\n    if (anonymous && userAgent.configuration.uri) {\n      inviterOptions.params.fromDisplayName = \"Anonymous\";\n      inviterOptions.params.fromUri = \"sip:anonymous@anonymous.invalid\";\n    }\n\n    let fromURI = userAgent.userAgentCore.configuration.aor;\n\n    if (inviterOptions.params.fromUri) {\n      fromURI = typeof inviterOptions.params.fromUri === \"string\" ? Grammar.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;\n    }\n\n    if (!fromURI) {\n      throw new TypeError(\"Invalid from URI: \" + inviterOptions.params.fromUri);\n    }\n\n    let toURI = targetURI;\n\n    if (inviterOptions.params.toUri) {\n      toURI = typeof inviterOptions.params.toUri === \"string\" ? Grammar.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;\n    }\n\n    if (!toURI) {\n      throw new TypeError(\"Invalid to URI: \" + inviterOptions.params.toUri);\n    } // Params\n\n\n    const messageOptions = Object.assign({}, inviterOptions.params);\n    messageOptions.fromTag = this.fromTag; // Extra headers\n\n    const extraHeaders = (inviterOptions.extraHeaders || []).slice();\n\n    if (anonymous && userAgent.configuration.uri) {\n      extraHeaders.push(\"P-Preferred-Identity: \" + userAgent.configuration.uri.toString());\n      extraHeaders.push(\"Privacy: id\");\n    }\n\n    extraHeaders.push(\"Contact: \" + contact);\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n\n    if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {\n      extraHeaders.push(\"Require: 100rel\");\n    }\n\n    if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {\n      extraHeaders.push(\"Require: replaces\");\n    }\n\n    inviterOptions.extraHeaders = extraHeaders; // Body\n\n    const body = undefined; // Make initial outgoing request message\n\n    this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body); // Session parent properties\n\n    this._contact = contact;\n    this._referralInviterOptions = inviterOptions;\n    this._renderbody = options.renderbody;\n    this._rendertype = options.rendertype; // Modifiers and options for initial INVITE transaction\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // Modifiers and options for re-INVITE transactions\n\n\n    if (options.sessionDescriptionHandlerModifiersReInvite) {\n      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;\n    }\n\n    if (options.sessionDescriptionHandlerOptionsReInvite) {\n      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;\n    } // Identifier\n\n\n    this._id = this.outgoingRequestMessage.callId + this.fromTag; // Add to the user agent's session collection.\n\n    this.userAgent._sessions[this._id] = this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    // Only run through this once. It can and does get called multiple times\n    // depending on the what the sessions state is when first called.\n    // For example, if called when \"establishing\" it will be called again\n    // at least once when the session transitions to \"terminated\".\n    // Regardless, running through this more than once is pointless.\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true; // Dispose of early dialog media\n\n    this.disposeEarlyMedia(); // If the final response for the initial INVITE not yet been received, cancel it\n\n    switch (this.state) {\n      case SessionState.Initial:\n        return this.cancel().then(() => super.dispose());\n\n      case SessionState.Establishing:\n        return this.cancel().then(() => super.dispose());\n\n      case SessionState.Established:\n        return super.dispose();\n\n      case SessionState.Terminating:\n        return super.dispose();\n\n      case SessionState.Terminated:\n        return super.dispose();\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n  }\n  /**\n   * Initial outgoing INVITE request message body.\n   */\n\n\n  get body() {\n    return this.outgoingRequestMessage.body;\n  }\n  /**\n   * The identity of the local user.\n   */\n\n\n  get localIdentity() {\n    return this.outgoingRequestMessage.from;\n  }\n  /**\n   * The identity of the remote user.\n   */\n\n\n  get remoteIdentity() {\n    return this.outgoingRequestMessage.to;\n  }\n  /**\n   * Initial outgoing INVITE request message.\n   */\n\n\n  get request() {\n    return this.outgoingRequestMessage;\n  }\n  /**\n   * Cancels the INVITE request.\n   *\n   * @remarks\n   * Sends a CANCEL request.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * After sending a CANCEL request the expectation is that a 487 final response\n   * will be received for the INVITE. However a 200 final response to the INVITE\n   * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before\n   * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect\n   * is that this method will terminate the session regardless of the race.\n   * @param options - Options bucket.\n   */\n\n\n  cancel(options = {}) {\n    this.logger.log(\"Inviter.cancel\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // flag canceled\n\n\n    this.isCanceled = true; // transition state\n\n    this.stateTransition(SessionState.Terminating); // helper function\n\n    function getCancelReason(code, reason) {\n      if (code && code < 200 || code > 699) {\n        throw new TypeError(\"Invalid statusCode: \" + code);\n      } else if (code) {\n        const cause = code;\n        const text = getReasonPhrase(code) || reason;\n        return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n      }\n    }\n\n    if (this.outgoingInviteRequest) {\n      // the CANCEL may not be respected by peer(s), so don't transition to terminated\n      let cancelReason;\n\n      if (options.statusCode && options.reasonPhrase) {\n        cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);\n      }\n\n      this.outgoingInviteRequest.cancel(cancelReason, options);\n    } else {\n      this.logger.warn(\"Canceled session before INVITE was sent\");\n      this.stateTransition(SessionState.Terminated);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Sends the INVITE request.\n   *\n   * @remarks\n   * TLDR...\n   *  1) Only one offer/answer exchange permitted during initial INVITE.\n   *  2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n   *  3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n   *\n   * 1) Only one offer/answer exchange permitted during initial INVITE.\n   *\n   * Our implementation replaces the following bullet point...\n   *\n   * o  After having sent or received an answer to the first offer, the\n   *    UAC MAY generate subsequent offers in requests based on rules\n   *    specified for that method, but only if it has received answers\n   *    to any previous offers, and has not sent any offers to which it\n   *    hasn't gotten an answer.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * ...with...\n   *\n   * o  After having sent or received an answer to the first offer, the\n   *    UAC MUST NOT generate subsequent offers in requests based on rules\n   *    specified for that method.\n   *\n   * ...which in combination with this bullet point...\n   *\n   * o  Once the UAS has sent or received an answer to the initial\n   *    offer, it MUST NOT generate subsequent offers in any responses\n   *    to the initial INVITE.  This means that a UAS based on this\n   *    specification alone can never generate subsequent offers until\n   *    completion of the initial transaction.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * ...ensures that EXACTLY ONE offer/answer exchange will occur\n   * during an initial out of dialog INVITE request made by our UAC.\n   *\n   *\n   * 2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n   *\n   * While our implementation adheres to the following bullet point...\n   *\n   * o  If the initial offer is in an INVITE, the answer MUST be in a\n   *    reliable non-failure message from UAS back to UAC which is\n   *    correlated to that INVITE.  For this specification, that is\n   *    only the final 2xx response to that INVITE.  That same exact\n   *    answer MAY also be placed in any provisional responses sent\n   *    prior to the answer.  The UAC MUST treat the first session\n   *    description it receives as the answer, and MUST ignore any\n   *    session descriptions in subsequent responses to the initial\n   *    INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * We have made the following implementation decision with regard to early media...\n   *\n   * o  If the initial offer is in the INVITE, the answer from the\n   *    UAS back to the UAC will establish a media session only\n   *    only after the final 2xx response to that INVITE is received.\n   *\n   * The reason for this decision is rooted in a restriction currently\n   * inherent in WebRTC. Specifically, while a SIP INVITE request with an\n   * initial offer may fork resulting in more than one provisional answer,\n   * there is currently no easy/good way to to \"fork\" an offer generated\n   * by a peer connection. In particular, a WebRTC offer currently may only\n   * be matched with one answer and we have no good way to know which\n   * \"provisional answer\" is going to be the \"final answer\". So we have\n   * decided to punt and not create any \"early media\" sessions in this case.\n   *\n   * The upshot is that if you want \"early media\", you must not put the\n   * initial offer in the INVITE. Instead, force the UAS to provide the\n   * initial offer by sending an INVITE without an offer. In the WebRTC\n   * case this allows us to create a unique peer connection with a unique\n   * answer for every provisional offer with \"early media\" on all of them.\n   *\n   *\n   * 3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n   *\n   * The default behavior may be altered and \"early media\" utilized if the\n   * initial offer is in the an INVITE by setting the `earlyMedia` options.\n   * However in that case the INVITE request MUST NOT fork. This allows for\n   * \"early media\" in environments where the forking behavior of the SIP\n   * servers being utilized is configured to disallow forking.\n   */\n\n\n  invite(options = {}) {\n    this.logger.log(\"Inviter.invite\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      // re-invite\n      return super.invite(options);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // just send an INVITE with no sdp...\n\n\n    if (options.withoutSdp || this.inviteWithoutSdp) {\n      if (this._renderbody && this._rendertype) {\n        this.outgoingRequestMessage.body = {\n          contentType: this._rendertype,\n          body: this._renderbody\n        };\n      } // transition state\n\n\n      this.stateTransition(SessionState.Establishing);\n      return Promise.resolve(this.sendInvite(options));\n    } // get an offer and send it in an INVITE\n\n\n    const offerOptions = {\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n    };\n    return this.getOffer(offerOptions).then(body => {\n      this.outgoingRequestMessage.body = {\n        body: body.content,\n        contentType: body.contentType\n      }; // transition state\n\n      this.stateTransition(SessionState.Establishing);\n      return this.sendInvite(options);\n    }).catch(error => {\n      this.logger.log(error.message);\n      this.stateTransition(SessionState.Terminated);\n      throw error;\n    });\n  }\n  /**\n   * 13.2.1 Creating the Initial INVITE\n   *\n   * Since the initial INVITE represents a request outside of a dialog,\n   * its construction follows the procedures of Section 8.1.1.  Additional\n   * processing is required for the specific case of INVITE.\n   *\n   * An Allow header field (Section 20.5) SHOULD be present in the INVITE.\n   * It indicates what methods can be invoked within a dialog, on the UA\n   * sending the INVITE, for the duration of the dialog.  For example, a\n   * UA capable of receiving INFO requests within a dialog [34] SHOULD\n   * include an Allow header field listing the INFO method.\n   *\n   * A Supported header field (Section 20.37) SHOULD be present in the\n   * INVITE.  It enumerates all the extensions understood by the UAC.\n   *\n   * An Accept (Section 20.1) header field MAY be present in the INVITE.\n   * It indicates which Content-Types are acceptable to the UA, in both\n   * the response received by it, and in any subsequent requests sent to\n   * it within dialogs established by the INVITE.  The Accept header field\n   * is especially useful for indicating support of various session\n   * description formats.\n   *\n   * The UAC MAY add an Expires header field (Section 20.19) to limit the\n   * validity of the invitation.  If the time indicated in the Expires\n   * header field is reached and no final answer for the INVITE has been\n   * received, the UAC core SHOULD generate a CANCEL request for the\n   * INVITE, as per Section 9.\n   *\n   * A UAC MAY also find it useful to add, among others, Subject (Section\n   * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)\n   * header fields.  They all contain information related to the INVITE.\n   *\n   * The UAC MAY choose to add a message body to the INVITE.  Section\n   * 8.1.1.10 deals with how to construct the header fields -- Content-\n   * Type among others -- needed to describe the message body.\n   *\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   */\n\n\n  sendInvite(options = {}) {\n    //    There are special rules for message bodies that contain a session\n    //    description - their corresponding Content-Disposition is \"session\".\n    //    SIP uses an offer/answer model where one UA sends a session\n    //    description, called the offer, which contains a proposed description\n    //    of the session.  The offer indicates the desired communications means\n    //    (audio, video, games), parameters of those means (such as codec\n    //    types) and addresses for receiving media from the answerer.  The\n    //    other UA responds with another session description, called the\n    //    answer, which indicates which communications means are accepted, the\n    //    parameters that apply to those means, and addresses for receiving\n    //    media from the offerer. An offer/answer exchange is within the\n    //    context of a dialog, so that if a SIP INVITE results in multiple\n    //    dialogs, each is a separate offer/answer exchange.  The offer/answer\n    //    model defines restrictions on when offers and answers can be made\n    //    (for example, you cannot make a new offer while one is in progress).\n    //    This results in restrictions on where the offers and answers can\n    //    appear in SIP messages.  In this specification, offers and answers\n    //    can only appear in INVITE requests and responses, and ACK.  The usage\n    //    of offers and answers is further restricted.  For the initial INVITE\n    //    transaction, the rules are:\n    //\n    //       o  The initial offer MUST be in either an INVITE or, if not there,\n    //          in the first reliable non-failure message from the UAS back to\n    //          the UAC.  In this specification, that is the final 2xx\n    //          response.\n    //\n    //       o  If the initial offer is in an INVITE, the answer MUST be in a\n    //          reliable non-failure message from UAS back to UAC which is\n    //          correlated to that INVITE.  For this specification, that is\n    //          only the final 2xx response to that INVITE.  That same exact\n    //          answer MAY also be placed in any provisional responses sent\n    //          prior to the answer.  The UAC MUST treat the first session\n    //          description it receives as the answer, and MUST ignore any\n    //          session descriptions in subsequent responses to the initial\n    //          INVITE.\n    //\n    //       o  If the initial offer is in the first reliable non-failure\n    //          message from the UAS back to UAC, the answer MUST be in the\n    //          acknowledgement for that message (in this specification, ACK\n    //          for a 2xx response).\n    //\n    //       o  After having sent or received an answer to the first offer, the\n    //          UAC MAY generate subsequent offers in requests based on rules\n    //          specified for that method, but only if it has received answers\n    //          to any previous offers, and has not sent any offers to which it\n    //          hasn't gotten an answer.\n    //\n    //       o  Once the UAS has sent or received an answer to the initial\n    //          offer, it MUST NOT generate subsequent offers in any responses\n    //          to the initial INVITE.  This means that a UAS based on this\n    //          specification alone can never generate subsequent offers until\n    //          completion of the initial transaction.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n    // 5 The Offer/Answer Model and PRACK\n    //\n    //    RFC 3261 describes guidelines for the sets of messages in which\n    //    offers and answers [3] can appear.  Based on those guidelines, this\n    //    extension provides additional opportunities for offer/answer\n    //    exchanges.\n    //    If the INVITE contained an offer, the UAS MAY generate an answer in a\n    //    reliable provisional response (assuming these are supported by the\n    //    UAC).  That results in the establishment of the session before\n    //    completion of the call.  Similarly, if a reliable provisional\n    //    response is the first reliable message sent back to the UAC, and the\n    //    INVITE did not contain an offer, one MUST appear in that reliable\n    //    provisional response.\n    //    If the UAC receives a reliable provisional response with an offer\n    //    (this would occur if the UAC sent an INVITE without an offer, in\n    //    which case the first reliable provisional response will contain the\n    //    offer), it MUST generate an answer in the PRACK.  If the UAC receives\n    //    a reliable provisional response with an answer, it MAY generate an\n    //    additional offer in the PRACK.  If the UAS receives a PRACK with an\n    //    offer, it MUST place the answer in the 2xx to the PRACK.\n    //    Once an answer has been sent or received, the UA SHOULD establish the\n    //    session based on the parameters of the offer and answer, even if the\n    //    original INVITE itself has not been responded to.\n    //    If the UAS had placed a session description in any reliable\n    //    provisional response that is unacknowledged when the INVITE is\n    //    accepted, the UAS MUST delay sending the 2xx until the provisional\n    //    response is acknowledged.  Otherwise, the reliability of the 1xx\n    //    cannot be guaranteed, and reliability is needed for proper operation\n    //    of the offer/answer exchange.\n    //    All user agents that support this extension MUST support all\n    //    offer/answer exchanges that are possible based on the rules in\n    //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK\n    //    as requests, and 2xx and reliable 1xx as non-failure reliable\n    //    responses.\n    //\n    // https://tools.ietf.org/html/rfc3262#section-5\n    ////\n    // The Offer/Answer Model Implementation\n    //\n    // The offer/answer model is straight forward, but one MUST READ the specifications...\n    //\n    // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)\n    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n    //\n    // 5 The Offer/Answer Model and PRACK\n    // https://tools.ietf.org/html/rfc3262#section-5\n    //\n    // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model\n    // https://tools.ietf.org/html/rfc6337\n    ////\n    ////\n    // TODO: The Offer/Answer Model Implementation\n    //\n    // Currently if `earlyMedia` is enabled and the INVITE request forks,\n    // the session is terminated if the early dialog does not match the\n    // confirmed dialog. This restriction make sense in a WebRTC environment,\n    // but there are other environments where this restriction does not hold.\n    //\n    // So while we currently cannot make the offer in INVITE+forking+webrtc\n    // case work, we propose doing the following...\n    //\n    // OPTION 1\n    // - add a `earlyMediaForking` option and\n    // - require SDH.setDescription() to be callable multiple times.\n    //\n    // OPTION 2\n    // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...\n    // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...\n    // 3) ask SDH Factory if it supports \"earlyRemoteAnswer\"\n    //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)\n    //   b) if false, defer getting a SDH until 2xx response is received\n    //\n    // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)\n    // early media if initial offer is in the INVITE). We will, however, provide an \"inviteWillNotFork\"\n    // option which if set to \"true\" will have our supplied WebRTC SDH behave in the 3a manner.\n    // That will result in\n    //  - early media working with initial offer in the INVITE, and...\n    //  - if the INVITE forks, the session terminating with an ERROR that reads like\n    //    \"You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too.\"\n    //  - furthermore, we accept that users will report that error to us as \"bug\" regardless\n    //\n    // So, SDH Factory is going to end up with a new interface along the lines of...\n    //\n    // interface SessionDescriptionHandlerFactory {\n    //   makeLocalOffer(): Promise<ContentTypeAndBody>;\n    //   makeSessionDescriptionHandler(\n    //     initialOffer: ContentTypeAndBody, offerType: \"local\" | \"remote\"\n    //   ): Promise<SessionDescriptionHandler>;\n    //   supportsEarlyRemoteAnswer: boolean;\n    //   supportsContentType(contentType: string): boolean;\n    //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>\n    //   setDescription(description: ContentTypeAndBody): Promise<void>\n    // }\n    ////\n    // Send the INVITE request.\n    this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {\n      onAccept: inviteResponse => {\n        // Our transaction layer is \"non-standard\" in that it will only\n        // pass us a 2xx response once per branch, so there is no need to\n        // worry about dealing with 2xx retransmissions. However, we can\n        // and do still get 2xx responses for multiple branches (when an\n        // INVITE is forked) which may create multiple confirmed dialogs.\n        // Herein we are acking and sending a bye to any confirmed dialogs\n        // which arrive beyond the first one. This is the desired behavior\n        // for most applications (but certainly not all).\n        // If we already received a confirmed dialog, ack & bye this additional confirmed session.\n        if (this.dialog) {\n          this.logger.log(\"Additional confirmed dialog, sending ACK and BYE\");\n          this.ackAndBye(inviteResponse); // We do NOT transition state in this case (this is an \"extra\" dialog)\n\n          return;\n        } // If the user requested cancellation, ack & bye this session.\n\n\n        if (this.isCanceled) {\n          this.logger.log(\"Canceled session accepted, sending ACK and BYE\");\n          this.ackAndBye(inviteResponse);\n          this.stateTransition(SessionState.Terminated);\n          return;\n        }\n\n        this.notifyReferer(inviteResponse);\n        this.onAccept(inviteResponse).then(() => {\n          this.disposeEarlyMedia();\n        }).catch(() => {\n          this.disposeEarlyMedia();\n        }).then(() => {\n          if (options.requestDelegate && options.requestDelegate.onAccept) {\n            options.requestDelegate.onAccept(inviteResponse);\n          }\n        });\n      },\n      onProgress: inviteResponse => {\n        // If the user requested cancellation, ignore response.\n        if (this.isCanceled) {\n          return;\n        }\n\n        this.notifyReferer(inviteResponse);\n        this.onProgress(inviteResponse).catch(() => {\n          this.disposeEarlyMedia();\n        }).then(() => {\n          if (options.requestDelegate && options.requestDelegate.onProgress) {\n            options.requestDelegate.onProgress(inviteResponse);\n          }\n        });\n      },\n      onRedirect: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onRedirect(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(inviteResponse);\n        }\n      },\n      onReject: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onReject(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(inviteResponse);\n        }\n      },\n      onTrying: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onTrying(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(inviteResponse);\n        }\n      }\n    });\n    return this.outgoingInviteRequest;\n  }\n\n  disposeEarlyMedia() {\n    this.earlyMediaSessionDescriptionHandlers.forEach(sessionDescriptionHandler => {\n      sessionDescriptionHandler.close();\n    });\n    this.earlyMediaSessionDescriptionHandlers.clear();\n  }\n\n  notifyReferer(response) {\n    if (!this._referred) {\n      return;\n    }\n\n    if (!(this._referred instanceof Session)) {\n      throw new Error(\"Referred session not instance of session\");\n    }\n\n    if (!this._referred.dialog) {\n      return;\n    }\n\n    if (!response.message.statusCode) {\n      throw new Error(\"Status code undefined.\");\n    }\n\n    if (!response.message.reasonPhrase) {\n      throw new Error(\"Reason phrase undefined.\");\n    }\n\n    const statusCode = response.message.statusCode;\n    const reasonPhrase = response.message.reasonPhrase;\n    const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();\n\n    const outgoingNotifyRequest = this._referred.dialog.notify(undefined, {\n      extraHeaders: [\"Event: refer\", \"Subscription-State: terminated\"],\n      body: {\n        contentDisposition: \"render\",\n        contentType: \"message/sipfrag\",\n        content: body\n      }\n    }); // The implicit subscription created by a REFER is the same as a\n    // subscription created with a SUBSCRIBE request.  The agent issuing the\n    // REFER can terminate this subscription prematurely by unsubscribing\n    // using the mechanisms described in [2].  Terminating a subscription,\n    // either by explicitly unsubscribing or rejecting NOTIFY, is not an\n    // indication that the referenced request should be withdrawn or\n    // abandoned.\n    // https://tools.ietf.org/html/rfc3515#section-2.4.4\n    // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.\n    // If the notify is rejected, stop sending NOTIFY requests.\n\n\n    outgoingNotifyRequest.delegate = {\n      onReject: () => {\n        this._referred = undefined;\n      }\n    };\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 2xx response.\n   */\n\n\n  onAccept(inviteResponse) {\n    this.logger.log(\"Inviter.onAccept\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Accept received while in state ${this.state}, dropping response`);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const response = inviteResponse.message;\n    const session = inviteResponse.session; // Ported behavior.\n\n    if (response.hasHeader(\"P-Asserted-Identity\")) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n    } // We have a confirmed dialog.\n\n\n    session.delegate = {\n      onAck: ackRequest => this.onAckRequest(ackRequest),\n      onBye: byeRequest => this.onByeRequest(byeRequest),\n      onInfo: infoRequest => this.onInfoRequest(infoRequest),\n      onInvite: inviteRequest => this.onInviteRequest(inviteRequest),\n      onMessage: messageRequest => this.onMessageRequest(messageRequest),\n      onNotify: notifyRequest => this.onNotifyRequest(notifyRequest),\n      onPrack: prackRequest => this.onPrackRequest(prackRequest),\n      onRefer: referRequest => this.onReferRequest(referRequest)\n    };\n    this._dialog = session;\n\n    switch (session.signalingState) {\n      case SignalingState.Initial:\n        // INVITE without offer, so MUST have offer at this point, so invalid state.\n        this.logger.error(\"Received 2xx response to INVITE without a session description\");\n        this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n        this.stateTransition(SessionState.Terminated);\n        return Promise.reject(new Error(\"Bad Media Description\"));\n\n      case SignalingState.HaveLocalOffer:\n        // INVITE with offer, so MUST have answer at this point, so invalid state.\n        this.logger.error(\"Received 2xx response to INVITE without a session description\");\n        this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n        this.stateTransition(SessionState.Terminated);\n        return Promise.reject(new Error(\"Bad Media Description\"));\n\n      case SignalingState.HaveRemoteOffer:\n        {\n          // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.\n          if (!this._dialog.offer) {\n            throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setOfferAndGetAnswer(this._dialog.offer, options).then(body => {\n            inviteResponse.ack({\n              body\n            });\n            this.stateTransition(SessionState.Established);\n          }).catch(error => {\n            this.ackAndBye(inviteResponse, 488, \"Invalid session description\");\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Stable:\n        {\n          // If INVITE without offer and we have already completed the initial exchange.\n          if (this.earlyMediaSessionDescriptionHandlers.size > 0) {\n            const sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);\n\n            if (!sdh) {\n              throw new Error(\"Session description handler undefined.\");\n            }\n\n            this.setSessionDescriptionHandler(sdh);\n            this.earlyMediaSessionDescriptionHandlers.delete(session.id);\n            inviteResponse.ack();\n            this.stateTransition(SessionState.Established);\n            return Promise.resolve();\n          } // If INVITE with offer and we used an \"early\" answer in a provisional response for media\n\n\n          if (this.earlyMediaDialog) {\n            // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.\n            // This limitation stems from how WebRTC currently implements its offer/answer model.\n            // There are details elsewhere, but in short a WebRTC offer cannot be forked.\n            if (this.earlyMediaDialog !== session) {\n              if (this.earlyMedia) {\n                const message = \"You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests \" + \"do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly \" + \"the end point which accepted the INVITE (confirmed dialog) does not match the end point with \" + \"which early media has been setup (early dialog) and thus this session is unable to proceed. \" + \"In accordance with the SIP specifications, the SIP servers your end point is connected to \" + \"determine if an INVITE forks and the forking behavior of those servers cannot be controlled \" + \"by this library. If you wish to use early media with this library you must configure those \" + \"servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow \" + \"this library to function with any INVITE requests which do fork.\";\n                this.logger.error(message);\n              }\n\n              const error = new Error(\"Early media dialog does not equal confirmed dialog, terminating session\");\n              this.logger.error(error.message);\n              this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n              this.stateTransition(SessionState.Terminated);\n              return Promise.reject(error);\n            } // Otherwise we are good to go.\n\n\n            inviteResponse.ack();\n            this.stateTransition(SessionState.Established);\n            return Promise.resolve();\n          } // If INVITE with offer and we have been waiting till now to apply the answer.\n\n\n          const answer = session.answer;\n\n          if (!answer) {\n            throw new Error(\"Answer is undefined.\");\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setAnswer(answer, options).then(() => {\n            // This session has completed an initial offer/answer exchange...\n            let ackOptions;\n\n            if (this._renderbody && this._rendertype) {\n              ackOptions = {\n                body: {\n                  contentDisposition: \"render\",\n                  contentType: this._rendertype,\n                  content: this._renderbody\n                }\n              };\n            }\n\n            inviteResponse.ack(ackOptions);\n            this.stateTransition(SessionState.Established);\n          }).catch(error => {\n            this.logger.error(error.message);\n            this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Closed:\n        // Dialog has terminated.\n        return Promise.reject(new Error(\"Terminated.\"));\n\n      default:\n        throw new Error(\"Unknown session signaling state.\");\n    }\n  }\n  /**\n   * Handle provisional response to initial INVITE.\n   * @param inviteResponse - 1xx response.\n   */\n\n\n  onProgress(inviteResponse) {\n    var _a;\n\n    this.logger.log(\"Inviter.onProgress\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Progress received while in state ${this.state}, dropping response`);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    if (!this.outgoingInviteRequest) {\n      throw new Error(\"Outgoing INVITE request undefined.\");\n    }\n\n    const response = inviteResponse.message;\n    const session = inviteResponse.session; // Ported - Set assertedIdentity.\n\n    if (response.hasHeader(\"P-Asserted-Identity\")) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n    } // If a provisional response is received for an initial request, and\n    // that response contains a Require header field containing the option\n    // tag 100rel, the response is to be sent reliably.  If the response is\n    // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n    // ignored, and the procedures below MUST NOT be used.\n    // https://tools.ietf.org/html/rfc3262#section-4\n\n\n    const requireHeader = response.getHeader(\"require\");\n    const rseqHeader = response.getHeader(\"rseq\");\n    const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n    const responseReliable = !!rseq;\n    const extraHeaders = [];\n\n    if (responseReliable) {\n      extraHeaders.push(\"RAck: \" + response.getHeader(\"rseq\") + \" \" + response.getHeader(\"cseq\"));\n    }\n\n    switch (session.signalingState) {\n      case SignalingState.Initial:\n        // INVITE without offer and session still has no offer (and no answer).\n        if (responseReliable) {\n          // Similarly, if a reliable provisional\n          // response is the first reliable message sent back to the UAC, and the\n          // INVITE did not contain an offer, one MUST appear in that reliable\n          // provisional response.\n          // https://tools.ietf.org/html/rfc3262#section-5\n          this.logger.warn(\"First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.\"); // FIXME: Known popular UA's currently end up here...\n\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.HaveLocalOffer:\n        // INVITE with offer and session only has that initial local offer.\n        if (responseReliable) {\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.HaveRemoteOffer:\n        if (!responseReliable) {\n          // The initial offer MUST be in either an INVITE or, if not there,\n          // in the first reliable non-failure message from the UAS back to\n          // the UAC.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // According to Section 13.2.1 of [RFC3261], 'The first reliable\n          // non-failure message' must have an offer if there is no offer in the\n          // INVITE request.  This means that the User Agent (UA) that receives\n          // the INVITE request without an offer must include an offer in the\n          // first reliable response with 100rel extension.  If no reliable\n          // provisional response has been sent, the User Agent Server (UAS) must\n          // include an offer when sending 2xx response.\n          // https://tools.ietf.org/html/rfc6337#section-2.2\n          this.logger.warn(\"Non-reliable provisional response MUST NOT contain an initial offer, discarding response.\");\n          return Promise.resolve();\n        }\n\n        {\n          // If the initial offer is in the first reliable non-failure\n          // message from the UAS back to UAC, the answer MUST be in the\n          // acknowledgement for that message\n          const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});\n\n          if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n            this.delegate.onSessionDescriptionHandler(sdh, true);\n          }\n\n          this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);\n          return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)).then(description => {\n            const body = {\n              contentDisposition: \"session\",\n              contentType: description.contentType,\n              content: description.body\n            };\n            inviteResponse.prack({\n              extraHeaders,\n              body\n            });\n          }).catch(error => {\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Stable:\n        // This session has completed an initial offer/answer exchange, so...\n        // - INVITE with SDP and this provisional response MAY be reliable\n        // - INVITE without SDP and this provisional response MAY be reliable\n        if (responseReliable) {\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        if (this.earlyMedia && !this.earlyMediaDialog) {\n          this.earlyMediaDialog = session;\n          const answer = session.answer;\n\n          if (!answer) {\n            throw new Error(\"Answer is undefined.\");\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setAnswer(answer, options).catch(error => {\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.Closed:\n        // Dialog has terminated.\n        return Promise.reject(new Error(\"Terminated.\"));\n\n      default:\n        throw new Error(\"Unknown session signaling state.\");\n    }\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 3xx response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onRedirect(inviteResponse) {\n    this.logger.log(\"Inviter.onRedirect\"); // validate state\n\n    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n      this.logger.error(`Redirect received while in state ${this.state}, dropping response`);\n      return;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 4xx, 5xx, or 6xx response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onReject(inviteResponse) {\n    this.logger.log(\"Inviter.onReject\"); // validate state\n\n    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n      this.logger.error(`Reject received while in state ${this.state}, dropping response`);\n      return;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 100 response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onTrying(inviteResponse) {\n    this.logger.log(\"Inviter.onTrying\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Trying received while in state ${this.state}, dropping response`);\n      return;\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/inviter.js"],"names":["C","Grammar","SignalingState","getReasonPhrase","newTag","Session","SessionState","SIPExtension","Inviter","constructor","userAgent","targetURI","options","disposed","earlyMedia","earlyMediaSessionDescriptionHandlers","Map","isCanceled","inviteWithoutSdp","logger","getLogger","undefined","fromTag","inviterOptions","Object","assign","params","anonymous","contact","toString","outbound","tempGruu","pubGruu","configuration","uri","fromDisplayName","fromUri","fromURI","userAgentCore","aor","URIParse","TypeError","toURI","toUri","messageOptions","extraHeaders","slice","push","sipExtension100rel","Required","sipExtensionReplaces","body","outgoingRequestMessage","makeOutgoingRequestMessage","INVITE","_contact","_referralInviterOptions","_renderbody","renderbody","_rendertype","rendertype","sessionDescriptionHandlerModifiers","sessionDescriptionHandlerOptions","sessionDescriptionHandlerModifiersReInvite","sessionDescriptionHandlerOptionsReInvite","_id","callId","_sessions","dispose","Promise","resolve","disposeEarlyMedia","state","Initial","cancel","then","Establishing","Established","Terminating","Terminated","Error","localIdentity","from","remoteIdentity","to","request","log","error","message","reject","stateTransition","getCancelReason","code","reason","cause","text","outgoingInviteRequest","cancelReason","statusCode","reasonPhrase","warn","invite","withoutSdp","contentType","sendInvite","offerOptions","getOffer","content","catch","onAccept","inviteResponse","dialog","ackAndBye","notifyReferer","requestDelegate","onProgress","onRedirect","onReject","onTrying","forEach","sessionDescriptionHandler","close","clear","response","_referred","trim","outgoingNotifyRequest","notify","contentDisposition","delegate","session","hasHeader","_assertedIdentity","nameAddrHeaderParse","getHeader","onAck","ackRequest","onAckRequest","onBye","byeRequest","onByeRequest","onInfo","infoRequest","onInfoRequest","onInvite","inviteRequest","onInviteRequest","onMessage","messageRequest","onMessageRequest","onNotify","notifyRequest","onNotifyRequest","onPrack","prackRequest","onPrackRequest","onRefer","referRequest","onReferRequest","_dialog","signalingState","HaveLocalOffer","HaveRemoteOffer","offer","setOfferAndGetAnswer","ack","Stable","size","sdh","get","id","setSessionDescriptionHandler","delete","earlyMediaDialog","answer","setAnswer","ackOptions","Closed","_a","requireHeader","rseqHeader","rseq","includes","Number","responseReliable","prack","sessionDescriptionHandlerFactory","sessionDescriptionHandlerFactoryOptions","onSessionDescriptionHandler","set","setDescription","getDescription","description"],"mappings":"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D,QAAI,KAAKC,qBAAT,EAAgC;AAC5B;AACA,UAAIC,YAAJ;;AACA,UAAIrF,OAAO,CAACsF,UAAR,IAAsBtF,OAAO,CAACuF,YAAlC,EAAgD;AAC5CF,QAAAA,YAAY,GAAGN,eAAe,CAAC/E,OAAO,CAACsF,UAAT,EAAqBtF,OAAO,CAACuF,YAA7B,CAA9B;AACH;;AACD,WAAKH,qBAAL,CAA2BtB,MAA3B,CAAkCuB,YAAlC,EAAgDrF,OAAhD;AACH,KAPD,MAQK;AACD,WAAKO,MAAL,CAAYiF,IAAZ,CAAiB,yCAAjB;AACA,WAAKV,eAAL,CAAqBpF,YAAY,CAACyE,UAAlC;AACH;;AACD,WAAOV,OAAO,CAACC,OAAR,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI+B,EAAAA,MAAM,CAACzF,OAAO,GAAG,EAAX,EAAe;AACjB,SAAKO,MAAL,CAAYmE,GAAZ,CAAgB,gBAAhB,EADiB,CAEjB;;AACA,QAAI,KAAKd,KAAL,KAAelE,YAAY,CAACmE,OAAhC,EAAyC;AACrC;AACA,aAAO,MAAM4B,MAAN,CAAazF,OAAb,CAAP;AACH,KANgB,CAOjB;;;AACA,QAAIA,OAAO,CAACiD,kCAAZ,EAAgD;AAC5C,WAAKA,kCAAL,GAA0CjD,OAAO,CAACiD,kCAAlD;AACH;;AACD,QAAIjD,OAAO,CAACkD,gCAAZ,EAA8C;AAC1C,WAAKA,gCAAL,GAAwClD,OAAO,CAACkD,gCAAhD;AACH,KAbgB,CAcjB;;;AACA,QAAIlD,OAAO,CAAC0F,UAAR,IAAsB,KAAKpF,gBAA/B,EAAiD;AAC7C,UAAI,KAAKuC,WAAL,IAAoB,KAAKE,WAA7B,EAA0C;AACtC,aAAKP,sBAAL,CAA4BD,IAA5B,GAAmC;AAAEoD,UAAAA,WAAW,EAAE,KAAK5C,WAApB;AAAiCR,UAAAA,IAAI,EAAE,KAAKM;AAA5C,SAAnC;AACH,OAH4C,CAI7C;;;AACA,WAAKiC,eAAL,CAAqBpF,YAAY,CAACsE,YAAlC;AACA,aAAOP,OAAO,CAACC,OAAR,CAAgB,KAAKkC,UAAL,CAAgB5F,OAAhB,CAAhB,CAAP;AACH,KAtBgB,CAuBjB;;;AACA,UAAM6F,YAAY,GAAG;AACjB5C,MAAAA,kCAAkC,EAAE,KAAKA,kCADxB;AAEjBC,MAAAA,gCAAgC,EAAE,KAAKA;AAFtB,KAArB;AAIA,WAAO,KAAK4C,QAAL,CAAcD,YAAd,EACF9B,IADE,CACIxB,IAAD,IAAU;AAChB,WAAKC,sBAAL,CAA4BD,IAA5B,GAAmC;AAAEA,QAAAA,IAAI,EAAEA,IAAI,CAACwD,OAAb;AAAsBJ,QAAAA,WAAW,EAAEpD,IAAI,CAACoD;AAAxC,OAAnC,CADgB,CAEhB;;AACA,WAAKb,eAAL,CAAqBpF,YAAY,CAACsE,YAAlC;AACA,aAAO,KAAK4B,UAAL,CAAgB5F,OAAhB,CAAP;AACH,KANM,EAOFgG,KAPE,CAOKrB,KAAD,IAAW;AAClB,WAAKpE,MAAL,CAAYmE,GAAZ,CAAgBC,KAAK,CAACC,OAAtB;AACA,WAAKE,eAAL,CAAqBpF,YAAY,CAACyE,UAAlC;AACA,YAAMQ,KAAN;AACH,KAXM,CAAP;AAYH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIiB,EAAAA,UAAU,CAAC5F,OAAO,GAAG,EAAX,EAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAKoF,qBAAL,GAA6B,KAAKtF,SAAL,CAAe4B,aAAf,CAA6B+D,MAA7B,CAAoC,KAAKjD,sBAAzC,EAAiE;AAC1FyD,MAAAA,QAAQ,EAAGC,cAAD,IAAoB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,KAAKC,MAAT,EAAiB;AACb,eAAK5F,MAAL,CAAYmE,GAAZ,CAAgB,kDAAhB;AACA,eAAK0B,SAAL,CAAeF,cAAf,EAFa,CAGb;;AACA;AACH,SAfyB,CAgB1B;;;AACA,YAAI,KAAK7F,UAAT,EAAqB;AACjB,eAAKE,MAAL,CAAYmE,GAAZ,CAAgB,gDAAhB;AACA,eAAK0B,SAAL,CAAeF,cAAf;AACA,eAAKpB,eAAL,CAAqBpF,YAAY,CAACyE,UAAlC;AACA;AACH;;AACD,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","sourcesContent":["import { C, Grammar, SignalingState } from \"../core\";\nimport { getReasonPhrase, newTag } from \"../core/messages/utils\";\nimport { Session } from \"./session\";\nimport { SessionState } from \"./session-state\";\nimport { SIPExtension } from \"./user-agent-options\";\n/**\n * An inviter offers to establish a {@link Session} (outgoing INVITE).\n * @public\n */\nexport class Inviter extends Session {\n    /**\n     * Constructs a new instance of the `Inviter` class.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param targetURI - Request URI identifying the target of the message.\n     * @param options - Options bucket. See {@link InviterOptions} for details.\n     */\n    constructor(userAgent, targetURI, options = {}) {\n        super(userAgent, options);\n        /** True if dispose() has been called. */\n        this.disposed = false;\n        /** True if early media use is enabled. */\n        this.earlyMedia = false;\n        /** The early media session description handlers. */\n        this.earlyMediaSessionDescriptionHandlers = new Map();\n        /** True if cancel() was called. */\n        this.isCanceled = false;\n        /** True if initial INVITE without SDP. */\n        this.inviteWithoutSdp = false;\n        this.logger = userAgent.getLogger(\"sip.Inviter\");\n        // Early media\n        this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : this.earlyMedia;\n        // From tag\n        this.fromTag = newTag();\n        // Invite without SDP\n        this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : this.inviteWithoutSdp;\n        // Inviter options (could do better copying these options)\n        const inviterOptions = Object.assign({}, options);\n        inviterOptions.params = Object.assign({}, options.params);\n        // Anonymous call\n        const anonymous = options.anonymous || false;\n        // Contact\n        const contact = userAgent.contact.toString({\n            anonymous,\n            // Do not add ;ob in initial forming dialog requests if the\n            // registration over the current connection got a GRUU URI.\n            outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu\n        });\n        // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception\n        // which is not something we want our constructor to do. URIs should be passed in as params.\n        // URIs\n        if (anonymous && userAgent.configuration.uri) {\n            inviterOptions.params.fromDisplayName = \"Anonymous\";\n            inviterOptions.params.fromUri = \"sip:anonymous@anonymous.invalid\";\n        }\n        let fromURI = userAgent.userAgentCore.configuration.aor;\n        if (inviterOptions.params.fromUri) {\n            fromURI =\n                typeof inviterOptions.params.fromUri === \"string\"\n                    ? Grammar.URIParse(inviterOptions.params.fromUri)\n                    : inviterOptions.params.fromUri;\n        }\n        if (!fromURI) {\n            throw new TypeError(\"Invalid from URI: \" + inviterOptions.params.fromUri);\n        }\n        let toURI = targetURI;\n        if (inviterOptions.params.toUri) {\n            toURI =\n                typeof inviterOptions.params.toUri === \"string\"\n                    ? Grammar.URIParse(inviterOptions.params.toUri)\n                    : inviterOptions.params.toUri;\n        }\n        if (!toURI) {\n            throw new TypeError(\"Invalid to URI: \" + inviterOptions.params.toUri);\n        }\n        // Params\n        const messageOptions = Object.assign({}, inviterOptions.params);\n        messageOptions.fromTag = this.fromTag;\n        // Extra headers\n        const extraHeaders = (inviterOptions.extraHeaders || []).slice();\n        if (anonymous && userAgent.configuration.uri) {\n            extraHeaders.push(\"P-Preferred-Identity: \" + userAgent.configuration.uri.toString());\n            extraHeaders.push(\"Privacy: id\");\n        }\n        extraHeaders.push(\"Contact: \" + contact);\n        extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n        if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {\n            extraHeaders.push(\"Require: 100rel\");\n        }\n        if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {\n            extraHeaders.push(\"Require: replaces\");\n        }\n        inviterOptions.extraHeaders = extraHeaders;\n        // Body\n        const body = undefined;\n        // Make initial outgoing request message\n        this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body);\n        // Session parent properties\n        this._contact = contact;\n        this._referralInviterOptions = inviterOptions;\n        this._renderbody = options.renderbody;\n        this._rendertype = options.rendertype;\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // Modifiers and options for re-INVITE transactions\n        if (options.sessionDescriptionHandlerModifiersReInvite) {\n            this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;\n        }\n        if (options.sessionDescriptionHandlerOptionsReInvite) {\n            this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;\n        }\n        // Identifier\n        this._id = this.outgoingRequestMessage.callId + this.fromTag;\n        // Add to the user agent's session collection.\n        this.userAgent._sessions[this._id] = this;\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        // Only run through this once. It can and does get called multiple times\n        // depending on the what the sessions state is when first called.\n        // For example, if called when \"establishing\" it will be called again\n        // at least once when the session transitions to \"terminated\".\n        // Regardless, running through this more than once is pointless.\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.disposed = true;\n        // Dispose of early dialog media\n        this.disposeEarlyMedia();\n        // If the final response for the initial INVITE not yet been received, cancel it\n        switch (this.state) {\n            case SessionState.Initial:\n                return this.cancel().then(() => super.dispose());\n            case SessionState.Establishing:\n                return this.cancel().then(() => super.dispose());\n            case SessionState.Established:\n                return super.dispose();\n            case SessionState.Terminating:\n                return super.dispose();\n            case SessionState.Terminated:\n                return super.dispose();\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n    }\n    /**\n     * Initial outgoing INVITE request message body.\n     */\n    get body() {\n        return this.outgoingRequestMessage.body;\n    }\n    /**\n     * The identity of the local user.\n     */\n    get localIdentity() {\n        return this.outgoingRequestMessage.from;\n    }\n    /**\n     * The identity of the remote user.\n     */\n    get remoteIdentity() {\n        return this.outgoingRequestMessage.to;\n    }\n    /**\n     * Initial outgoing INVITE request message.\n     */\n    get request() {\n        return this.outgoingRequestMessage;\n    }\n    /**\n     * Cancels the INVITE request.\n     *\n     * @remarks\n     * Sends a CANCEL request.\n     * Resolves once the response sent, otherwise rejects.\n     *\n     * After sending a CANCEL request the expectation is that a 487 final response\n     * will be received for the INVITE. However a 200 final response to the INVITE\n     * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before\n     * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect\n     * is that this method will terminate the session regardless of the race.\n     * @param options - Options bucket.\n     */\n    cancel(options = {}) {\n        this.logger.log(\"Inviter.cancel\");\n        // validate state\n        if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n            const error = new Error(`Invalid session state ${this.state}`);\n            this.logger.error(error.message);\n            return Promise.reject(error);\n        }\n        // flag canceled\n        this.isCanceled = true;\n        // transition state\n        this.stateTransition(SessionState.Terminating);\n        // helper function\n        function getCancelReason(code, reason) {\n            if ((code && code < 200) || code > 699) {\n                throw new TypeError(\"Invalid statusCode: \" + code);\n            }\n            else if (code) {\n                const cause = code;\n                const text = getReasonPhrase(code) || reason;\n                return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n            }\n        }\n        if (this.outgoingInviteRequest) {\n            // the CANCEL may not be respected by peer(s), so don't transition to terminated\n            let cancelReason;\n            if (options.statusCode && options.reasonPhrase) {\n                cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);\n            }\n            this.outgoingInviteRequest.cancel(cancelReason, options);\n        }\n        else {\n            this.logger.warn(\"Canceled session before INVITE was sent\");\n            this.stateTransition(SessionState.Terminated);\n        }\n        return Promise.resolve();\n    }\n    /**\n     * Sends the INVITE request.\n     *\n     * @remarks\n     * TLDR...\n     *  1) Only one offer/answer exchange permitted during initial INVITE.\n     *  2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *  3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * 1) Only one offer/answer exchange permitted during initial INVITE.\n     *\n     * Our implementation replaces the following bullet point...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MAY generate subsequent offers in requests based on rules\n     *    specified for that method, but only if it has received answers\n     *    to any previous offers, and has not sent any offers to which it\n     *    hasn't gotten an answer.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...with...\n     *\n     * o  After having sent or received an answer to the first offer, the\n     *    UAC MUST NOT generate subsequent offers in requests based on rules\n     *    specified for that method.\n     *\n     * ...which in combination with this bullet point...\n     *\n     * o  Once the UAS has sent or received an answer to the initial\n     *    offer, it MUST NOT generate subsequent offers in any responses\n     *    to the initial INVITE.  This means that a UAS based on this\n     *    specification alone can never generate subsequent offers until\n     *    completion of the initial transaction.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * ...ensures that EXACTLY ONE offer/answer exchange will occur\n     * during an initial out of dialog INVITE request made by our UAC.\n     *\n     *\n     * 2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n     *\n     * While our implementation adheres to the following bullet point...\n     *\n     * o  If the initial offer is in an INVITE, the answer MUST be in a\n     *    reliable non-failure message from UAS back to UAC which is\n     *    correlated to that INVITE.  For this specification, that is\n     *    only the final 2xx response to that INVITE.  That same exact\n     *    answer MAY also be placed in any provisional responses sent\n     *    prior to the answer.  The UAC MUST treat the first session\n     *    description it receives as the answer, and MUST ignore any\n     *    session descriptions in subsequent responses to the initial\n     *    INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     *\n     * We have made the following implementation decision with regard to early media...\n     *\n     * o  If the initial offer is in the INVITE, the answer from the\n     *    UAS back to the UAC will establish a media session only\n     *    only after the final 2xx response to that INVITE is received.\n     *\n     * The reason for this decision is rooted in a restriction currently\n     * inherent in WebRTC. Specifically, while a SIP INVITE request with an\n     * initial offer may fork resulting in more than one provisional answer,\n     * there is currently no easy/good way to to \"fork\" an offer generated\n     * by a peer connection. In particular, a WebRTC offer currently may only\n     * be matched with one answer and we have no good way to know which\n     * \"provisional answer\" is going to be the \"final answer\". So we have\n     * decided to punt and not create any \"early media\" sessions in this case.\n     *\n     * The upshot is that if you want \"early media\", you must not put the\n     * initial offer in the INVITE. Instead, force the UAS to provide the\n     * initial offer by sending an INVITE without an offer. In the WebRTC\n     * case this allows us to create a unique peer connection with a unique\n     * answer for every provisional offer with \"early media\" on all of them.\n     *\n     *\n     * 3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n     *\n     * The default behavior may be altered and \"early media\" utilized if the\n     * initial offer is in the an INVITE by setting the `earlyMedia` options.\n     * However in that case the INVITE request MUST NOT fork. This allows for\n     * \"early media\" in environments where the forking behavior of the SIP\n     * servers being utilized is configured to disallow forking.\n     */\n    invite(options = {}) {\n        this.logger.log(\"Inviter.invite\");\n        // validate state\n        if (this.state !== SessionState.Initial) {\n            // re-invite\n            return super.invite(options);\n        }\n        // Modifiers and options for initial INVITE transaction\n        if (options.sessionDescriptionHandlerModifiers) {\n            this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n        }\n        if (options.sessionDescriptionHandlerOptions) {\n            this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n        }\n        // just send an INVITE with no sdp...\n        if (options.withoutSdp || this.inviteWithoutSdp) {\n            if (this._renderbody && this._rendertype) {\n                this.outgoingRequestMessage.body = { contentType: this._rendertype, body: this._renderbody };\n            }\n            // transition state\n            this.stateTransition(SessionState.Establishing);\n            return Promise.resolve(this.sendInvite(options));\n        }\n        // get an offer and send it in an INVITE\n        const offerOptions = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n        };\n        return this.getOffer(offerOptions)\n            .then((body) => {\n            this.outgoingRequestMessage.body = { body: body.content, contentType: body.contentType };\n            // transition state\n            this.stateTransition(SessionState.Establishing);\n            return this.sendInvite(options);\n        })\n            .catch((error) => {\n            this.logger.log(error.message);\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n        });\n    }\n    /**\n     * 13.2.1 Creating the Initial INVITE\n     *\n     * Since the initial INVITE represents a request outside of a dialog,\n     * its construction follows the procedures of Section 8.1.1.  Additional\n     * processing is required for the specific case of INVITE.\n     *\n     * An Allow header field (Section 20.5) SHOULD be present in the INVITE.\n     * It indicates what methods can be invoked within a dialog, on the UA\n     * sending the INVITE, for the duration of the dialog.  For example, a\n     * UA capable of receiving INFO requests within a dialog [34] SHOULD\n     * include an Allow header field listing the INFO method.\n     *\n     * A Supported header field (Section 20.37) SHOULD be present in the\n     * INVITE.  It enumerates all the extensions understood by the UAC.\n     *\n     * An Accept (Section 20.1) header field MAY be present in the INVITE.\n     * It indicates which Content-Types are acceptable to the UA, in both\n     * the response received by it, and in any subsequent requests sent to\n     * it within dialogs established by the INVITE.  The Accept header field\n     * is especially useful for indicating support of various session\n     * description formats.\n     *\n     * The UAC MAY add an Expires header field (Section 20.19) to limit the\n     * validity of the invitation.  If the time indicated in the Expires\n     * header field is reached and no final answer for the INVITE has been\n     * received, the UAC core SHOULD generate a CANCEL request for the\n     * INVITE, as per Section 9.\n     *\n     * A UAC MAY also find it useful to add, among others, Subject (Section\n     * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)\n     * header fields.  They all contain information related to the INVITE.\n     *\n     * The UAC MAY choose to add a message body to the INVITE.  Section\n     * 8.1.1.10 deals with how to construct the header fields -- Content-\n     * Type among others -- needed to describe the message body.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-13.2.1\n     */\n    sendInvite(options = {}) {\n        //    There are special rules for message bodies that contain a session\n        //    description - their corresponding Content-Disposition is \"session\".\n        //    SIP uses an offer/answer model where one UA sends a session\n        //    description, called the offer, which contains a proposed description\n        //    of the session.  The offer indicates the desired communications means\n        //    (audio, video, games), parameters of those means (such as codec\n        //    types) and addresses for receiving media from the answerer.  The\n        //    other UA responds with another session description, called the\n        //    answer, which indicates which communications means are accepted, the\n        //    parameters that apply to those means, and addresses for receiving\n        //    media from the offerer. An offer/answer exchange is within the\n        //    context of a dialog, so that if a SIP INVITE results in multiple\n        //    dialogs, each is a separate offer/answer exchange.  The offer/answer\n        //    model defines restrictions on when offers and answers can be made\n        //    (for example, you cannot make a new offer while one is in progress).\n        //    This results in restrictions on where the offers and answers can\n        //    appear in SIP messages.  In this specification, offers and answers\n        //    can only appear in INVITE requests and responses, and ACK.  The usage\n        //    of offers and answers is further restricted.  For the initial INVITE\n        //    transaction, the rules are:\n        //\n        //       o  The initial offer MUST be in either an INVITE or, if not there,\n        //          in the first reliable non-failure message from the UAS back to\n        //          the UAC.  In this specification, that is the final 2xx\n        //          response.\n        //\n        //       o  If the initial offer is in an INVITE, the answer MUST be in a\n        //          reliable non-failure message from UAS back to UAC which is\n        //          correlated to that INVITE.  For this specification, that is\n        //          only the final 2xx response to that INVITE.  That same exact\n        //          answer MAY also be placed in any provisional responses sent\n        //          prior to the answer.  The UAC MUST treat the first session\n        //          description it receives as the answer, and MUST ignore any\n        //          session descriptions in subsequent responses to the initial\n        //          INVITE.\n        //\n        //       o  If the initial offer is in the first reliable non-failure\n        //          message from the UAS back to UAC, the answer MUST be in the\n        //          acknowledgement for that message (in this specification, ACK\n        //          for a 2xx response).\n        //\n        //       o  After having sent or received an answer to the first offer, the\n        //          UAC MAY generate subsequent offers in requests based on rules\n        //          specified for that method, but only if it has received answers\n        //          to any previous offers, and has not sent any offers to which it\n        //          hasn't gotten an answer.\n        //\n        //       o  Once the UAS has sent or received an answer to the initial\n        //          offer, it MUST NOT generate subsequent offers in any responses\n        //          to the initial INVITE.  This means that a UAS based on this\n        //          specification alone can never generate subsequent offers until\n        //          completion of the initial transaction.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        // 5 The Offer/Answer Model and PRACK\n        //\n        //    RFC 3261 describes guidelines for the sets of messages in which\n        //    offers and answers [3] can appear.  Based on those guidelines, this\n        //    extension provides additional opportunities for offer/answer\n        //    exchanges.\n        //    If the INVITE contained an offer, the UAS MAY generate an answer in a\n        //    reliable provisional response (assuming these are supported by the\n        //    UAC).  That results in the establishment of the session before\n        //    completion of the call.  Similarly, if a reliable provisional\n        //    response is the first reliable message sent back to the UAC, and the\n        //    INVITE did not contain an offer, one MUST appear in that reliable\n        //    provisional response.\n        //    If the UAC receives a reliable provisional response with an offer\n        //    (this would occur if the UAC sent an INVITE without an offer, in\n        //    which case the first reliable provisional response will contain the\n        //    offer), it MUST generate an answer in the PRACK.  If the UAC receives\n        //    a reliable provisional response with an answer, it MAY generate an\n        //    additional offer in the PRACK.  If the UAS receives a PRACK with an\n        //    offer, it MUST place the answer in the 2xx to the PRACK.\n        //    Once an answer has been sent or received, the UA SHOULD establish the\n        //    session based on the parameters of the offer and answer, even if the\n        //    original INVITE itself has not been responded to.\n        //    If the UAS had placed a session description in any reliable\n        //    provisional response that is unacknowledged when the INVITE is\n        //    accepted, the UAS MUST delay sending the 2xx until the provisional\n        //    response is acknowledged.  Otherwise, the reliability of the 1xx\n        //    cannot be guaranteed, and reliability is needed for proper operation\n        //    of the offer/answer exchange.\n        //    All user agents that support this extension MUST support all\n        //    offer/answer exchanges that are possible based on the rules in\n        //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK\n        //    as requests, and 2xx and reliable 1xx as non-failure reliable\n        //    responses.\n        //\n        // https://tools.ietf.org/html/rfc3262#section-5\n        ////\n        // The Offer/Answer Model Implementation\n        //\n        // The offer/answer model is straight forward, but one MUST READ the specifications...\n        //\n        // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        //\n        // 5 The Offer/Answer Model and PRACK\n        // https://tools.ietf.org/html/rfc3262#section-5\n        //\n        // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model\n        // https://tools.ietf.org/html/rfc6337\n        ////\n        ////\n        // TODO: The Offer/Answer Model Implementation\n        //\n        // Currently if `earlyMedia` is enabled and the INVITE request forks,\n        // the session is terminated if the early dialog does not match the\n        // confirmed dialog. This restriction make sense in a WebRTC environment,\n        // but there are other environments where this restriction does not hold.\n        //\n        // So while we currently cannot make the offer in INVITE+forking+webrtc\n        // case work, we propose doing the following...\n        //\n        // OPTION 1\n        // - add a `earlyMediaForking` option and\n        // - require SDH.setDescription() to be callable multiple times.\n        //\n        // OPTION 2\n        // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...\n        // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...\n        // 3) ask SDH Factory if it supports \"earlyRemoteAnswer\"\n        //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)\n        //   b) if false, defer getting a SDH until 2xx response is received\n        //\n        // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)\n        // early media if initial offer is in the INVITE). We will, however, provide an \"inviteWillNotFork\"\n        // option which if set to \"true\" will have our supplied WebRTC SDH behave in the 3a manner.\n        // That will result in\n        //  - early media working with initial offer in the INVITE, and...\n        //  - if the INVITE forks, the session terminating with an ERROR that reads like\n        //    \"You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too.\"\n        //  - furthermore, we accept that users will report that error to us as \"bug\" regardless\n        //\n        // So, SDH Factory is going to end up with a new interface along the lines of...\n        //\n        // interface SessionDescriptionHandlerFactory {\n        //   makeLocalOffer(): Promise<ContentTypeAndBody>;\n        //   makeSessionDescriptionHandler(\n        //     initialOffer: ContentTypeAndBody, offerType: \"local\" | \"remote\"\n        //   ): Promise<SessionDescriptionHandler>;\n        //   supportsEarlyRemoteAnswer: boolean;\n        //   supportsContentType(contentType: string): boolean;\n        //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>\n        //   setDescription(description: ContentTypeAndBody): Promise<void>\n        // }\n        ////\n        // Send the INVITE request.\n        this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {\n            onAccept: (inviteResponse) => {\n                // Our transaction layer is \"non-standard\" in that it will only\n                // pass us a 2xx response once per branch, so there is no need to\n                // worry about dealing with 2xx retransmissions. However, we can\n                // and do still get 2xx responses for multiple branches (when an\n                // INVITE is forked) which may create multiple confirmed dialogs.\n                // Herein we are acking and sending a bye to any confirmed dialogs\n                // which arrive beyond the first one. This is the desired behavior\n                // for most applications (but certainly not all).\n                // If we already received a confirmed dialog, ack & bye this additional confirmed session.\n                if (this.dialog) {\n                    this.logger.log(\"Additional confirmed dialog, sending ACK and BYE\");\n                    this.ackAndBye(inviteResponse);\n                    // We do NOT transition state in this case (this is an \"extra\" dialog)\n                    return;\n                }\n                // If the user requested cancellation, ack & bye this session.\n                if (this.isCanceled) {\n                    this.logger.log(\"Canceled session accepted, sending ACK and BYE\");\n                    this.ackAndBye(inviteResponse);\n                    this.stateTransition(SessionState.Terminated);\n                    return;\n                }\n                this.notifyReferer(inviteResponse);\n                this.onAccept(inviteResponse)\n                    .then(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .catch(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .then(() => {\n                    if (options.requestDelegate && options.requestDelegate.onAccept) {\n                        options.requestDelegate.onAccept(inviteResponse);\n                    }\n                });\n            },\n            onProgress: (inviteResponse) => {\n                // If the user requested cancellation, ignore response.\n                if (this.isCanceled) {\n                    return;\n                }\n                this.notifyReferer(inviteResponse);\n                this.onProgress(inviteResponse)\n                    .catch(() => {\n                    this.disposeEarlyMedia();\n                })\n                    .then(() => {\n                    if (options.requestDelegate && options.requestDelegate.onProgress) {\n                        options.requestDelegate.onProgress(inviteResponse);\n                    }\n                });\n            },\n            onRedirect: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onRedirect(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onRedirect) {\n                    options.requestDelegate.onRedirect(inviteResponse);\n                }\n            },\n            onReject: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onReject(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onReject) {\n                    options.requestDelegate.onReject(inviteResponse);\n                }\n            },\n            onTrying: (inviteResponse) => {\n                this.notifyReferer(inviteResponse);\n                this.onTrying(inviteResponse);\n                if (options.requestDelegate && options.requestDelegate.onTrying) {\n                    options.requestDelegate.onTrying(inviteResponse);\n                }\n            }\n        });\n        return this.outgoingInviteRequest;\n    }\n    disposeEarlyMedia() {\n        this.earlyMediaSessionDescriptionHandlers.forEach((sessionDescriptionHandler) => {\n            sessionDescriptionHandler.close();\n        });\n        this.earlyMediaSessionDescriptionHandlers.clear();\n    }\n    notifyReferer(response) {\n        if (!this._referred) {\n            return;\n        }\n        if (!(this._referred instanceof Session)) {\n            throw new Error(\"Referred session not instance of session\");\n        }\n        if (!this._referred.dialog) {\n            return;\n        }\n        if (!response.message.statusCode) {\n            throw new Error(\"Status code undefined.\");\n        }\n        if (!response.message.reasonPhrase) {\n            throw new Error(\"Reason phrase undefined.\");\n        }\n        const statusCode = response.message.statusCode;\n        const reasonPhrase = response.message.reasonPhrase;\n        const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();\n        const outgoingNotifyRequest = this._referred.dialog.notify(undefined, {\n            extraHeaders: [\"Event: refer\", \"Subscription-State: terminated\"],\n            body: {\n                contentDisposition: \"render\",\n                contentType: \"message/sipfrag\",\n                content: body\n            }\n        });\n        // The implicit subscription created by a REFER is the same as a\n        // subscription created with a SUBSCRIBE request.  The agent issuing the\n        // REFER can terminate this subscription prematurely by unsubscribing\n        // using the mechanisms described in [2].  Terminating a subscription,\n        // either by explicitly unsubscribing or rejecting NOTIFY, is not an\n        // indication that the referenced request should be withdrawn or\n        // abandoned.\n        // https://tools.ietf.org/html/rfc3515#section-2.4.4\n        // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.\n        // If the notify is rejected, stop sending NOTIFY requests.\n        outgoingNotifyRequest.delegate = {\n            onReject: () => {\n                this._referred = undefined;\n            }\n        };\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 2xx response.\n     */\n    onAccept(inviteResponse) {\n        this.logger.log(\"Inviter.onAccept\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Accept received while in state ${this.state}, dropping response`);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        const response = inviteResponse.message;\n        const session = inviteResponse.session;\n        // Ported behavior.\n        if (response.hasHeader(\"P-Asserted-Identity\")) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n        }\n        // We have a confirmed dialog.\n        session.delegate = {\n            onAck: (ackRequest) => this.onAckRequest(ackRequest),\n            onBye: (byeRequest) => this.onByeRequest(byeRequest),\n            onInfo: (infoRequest) => this.onInfoRequest(infoRequest),\n            onInvite: (inviteRequest) => this.onInviteRequest(inviteRequest),\n            onMessage: (messageRequest) => this.onMessageRequest(messageRequest),\n            onNotify: (notifyRequest) => this.onNotifyRequest(notifyRequest),\n            onPrack: (prackRequest) => this.onPrackRequest(prackRequest),\n            onRefer: (referRequest) => this.onReferRequest(referRequest)\n        };\n        this._dialog = session;\n        switch (session.signalingState) {\n            case SignalingState.Initial:\n                // INVITE without offer, so MUST have offer at this point, so invalid state.\n                this.logger.error(\"Received 2xx response to INVITE without a session description\");\n                this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n                this.stateTransition(SessionState.Terminated);\n                return Promise.reject(new Error(\"Bad Media Description\"));\n            case SignalingState.HaveLocalOffer:\n                // INVITE with offer, so MUST have answer at this point, so invalid state.\n                this.logger.error(\"Received 2xx response to INVITE without a session description\");\n                this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n                this.stateTransition(SessionState.Terminated);\n                return Promise.reject(new Error(\"Bad Media Description\"));\n            case SignalingState.HaveRemoteOffer: {\n                // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.\n                if (!this._dialog.offer) {\n                    throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);\n                }\n                const options = {\n                    sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                    sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                };\n                return this.setOfferAndGetAnswer(this._dialog.offer, options)\n                    .then((body) => {\n                    inviteResponse.ack({ body });\n                    this.stateTransition(SessionState.Established);\n                })\n                    .catch((error) => {\n                    this.ackAndBye(inviteResponse, 488, \"Invalid session description\");\n                    this.stateTransition(SessionState.Terminated);\n                    throw error;\n                });\n            }\n            case SignalingState.Stable: {\n                // If INVITE without offer and we have already completed the initial exchange.\n                if (this.earlyMediaSessionDescriptionHandlers.size > 0) {\n                    const sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);\n                    if (!sdh) {\n                        throw new Error(\"Session description handler undefined.\");\n                    }\n                    this.setSessionDescriptionHandler(sdh);\n                    this.earlyMediaSessionDescriptionHandlers.delete(session.id);\n                    inviteResponse.ack();\n                    this.stateTransition(SessionState.Established);\n                    return Promise.resolve();\n                }\n                // If INVITE with offer and we used an \"early\" answer in a provisional response for media\n                if (this.earlyMediaDialog) {\n                    // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.\n                    // This limitation stems from how WebRTC currently implements its offer/answer model.\n                    // There are details elsewhere, but in short a WebRTC offer cannot be forked.\n                    if (this.earlyMediaDialog !== session) {\n                        if (this.earlyMedia) {\n                            const message = \"You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests \" +\n                                \"do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly \" +\n                                \"the end point which accepted the INVITE (confirmed dialog) does not match the end point with \" +\n                                \"which early media has been setup (early dialog) and thus this session is unable to proceed. \" +\n                                \"In accordance with the SIP specifications, the SIP servers your end point is connected to \" +\n                                \"determine if an INVITE forks and the forking behavior of those servers cannot be controlled \" +\n                                \"by this library. If you wish to use early media with this library you must configure those \" +\n                                \"servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow \" +\n                                \"this library to function with any INVITE requests which do fork.\";\n                            this.logger.error(message);\n                        }\n                        const error = new Error(\"Early media dialog does not equal confirmed dialog, terminating session\");\n                        this.logger.error(error.message);\n                        this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n                        this.stateTransition(SessionState.Terminated);\n                        return Promise.reject(error);\n                    }\n                    // Otherwise we are good to go.\n                    inviteResponse.ack();\n                    this.stateTransition(SessionState.Established);\n                    return Promise.resolve();\n                }\n                // If INVITE with offer and we have been waiting till now to apply the answer.\n                const answer = session.answer;\n                if (!answer) {\n                    throw new Error(\"Answer is undefined.\");\n                }\n                const options = {\n                    sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                    sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                };\n                return this.setAnswer(answer, options)\n                    .then(() => {\n                    // This session has completed an initial offer/answer exchange...\n                    let ackOptions;\n                    if (this._renderbody && this._rendertype) {\n                        ackOptions = {\n                            body: { contentDisposition: \"render\", contentType: this._rendertype, content: this._renderbody }\n                        };\n                    }\n                    inviteResponse.ack(ackOptions);\n                    this.stateTransition(SessionState.Established);\n                })\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                    this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n                    this.stateTransition(SessionState.Terminated);\n                    throw error;\n                });\n            }\n            case SignalingState.Closed:\n                // Dialog has terminated.\n                return Promise.reject(new Error(\"Terminated.\"));\n            default:\n                throw new Error(\"Unknown session signaling state.\");\n        }\n    }\n    /**\n     * Handle provisional response to initial INVITE.\n     * @param inviteResponse - 1xx response.\n     */\n    onProgress(inviteResponse) {\n        var _a;\n        this.logger.log(\"Inviter.onProgress\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Progress received while in state ${this.state}, dropping response`);\n            return Promise.reject(new Error(`Invalid session state ${this.state}`));\n        }\n        if (!this.outgoingInviteRequest) {\n            throw new Error(\"Outgoing INVITE request undefined.\");\n        }\n        const response = inviteResponse.message;\n        const session = inviteResponse.session;\n        // Ported - Set assertedIdentity.\n        if (response.hasHeader(\"P-Asserted-Identity\")) {\n            this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n        }\n        // If a provisional response is received for an initial request, and\n        // that response contains a Require header field containing the option\n        // tag 100rel, the response is to be sent reliably.  If the response is\n        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n        // ignored, and the procedures below MUST NOT be used.\n        // https://tools.ietf.org/html/rfc3262#section-4\n        const requireHeader = response.getHeader(\"require\");\n        const rseqHeader = response.getHeader(\"rseq\");\n        const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n        const responseReliable = !!rseq;\n        const extraHeaders = [];\n        if (responseReliable) {\n            extraHeaders.push(\"RAck: \" + response.getHeader(\"rseq\") + \" \" + response.getHeader(\"cseq\"));\n        }\n        switch (session.signalingState) {\n            case SignalingState.Initial:\n                // INVITE without offer and session still has no offer (and no answer).\n                if (responseReliable) {\n                    // Similarly, if a reliable provisional\n                    // response is the first reliable message sent back to the UAC, and the\n                    // INVITE did not contain an offer, one MUST appear in that reliable\n                    // provisional response.\n                    // https://tools.ietf.org/html/rfc3262#section-5\n                    this.logger.warn(\"First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.\");\n                    // FIXME: Known popular UA's currently end up here...\n                    inviteResponse.prack({ extraHeaders });\n                }\n                return Promise.resolve();\n            case SignalingState.HaveLocalOffer:\n                // INVITE with offer and session only has that initial local offer.\n                if (responseReliable) {\n                    inviteResponse.prack({ extraHeaders });\n                }\n                return Promise.resolve();\n            case SignalingState.HaveRemoteOffer:\n                if (!responseReliable) {\n                    // The initial offer MUST be in either an INVITE or, if not there,\n                    // in the first reliable non-failure message from the UAS back to\n                    // the UAC.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // According to Section 13.2.1 of [RFC3261], 'The first reliable\n                    // non-failure message' must have an offer if there is no offer in the\n                    // INVITE request.  This means that the User Agent (UA) that receives\n                    // the INVITE request without an offer must include an offer in the\n                    // first reliable response with 100rel extension.  If no reliable\n                    // provisional response has been sent, the User Agent Server (UAS) must\n                    // include an offer when sending 2xx response.\n                    // https://tools.ietf.org/html/rfc6337#section-2.2\n                    this.logger.warn(\"Non-reliable provisional response MUST NOT contain an initial offer, discarding response.\");\n                    return Promise.resolve();\n                }\n                {\n                    // If the initial offer is in the first reliable non-failure\n                    // message from the UAS back to UAC, the answer MUST be in the\n                    // acknowledgement for that message\n                    const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});\n                    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n                        this.delegate.onSessionDescriptionHandler(sdh, true);\n                    }\n                    this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);\n                    return sdh\n                        .setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)\n                        .then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers))\n                        .then((description) => {\n                        const body = {\n                            contentDisposition: \"session\",\n                            contentType: description.contentType,\n                            content: description.body\n                        };\n                        inviteResponse.prack({ extraHeaders, body });\n                    })\n                        .catch((error) => {\n                        this.stateTransition(SessionState.Terminated);\n                        throw error;\n                    });\n                }\n            case SignalingState.Stable:\n                // This session has completed an initial offer/answer exchange, so...\n                // - INVITE with SDP and this provisional response MAY be reliable\n                // - INVITE without SDP and this provisional response MAY be reliable\n                if (responseReliable) {\n                    inviteResponse.prack({ extraHeaders });\n                }\n                if (this.earlyMedia && !this.earlyMediaDialog) {\n                    this.earlyMediaDialog = session;\n                    const answer = session.answer;\n                    if (!answer) {\n                        throw new Error(\"Answer is undefined.\");\n                    }\n                    const options = {\n                        sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n                        sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n                    };\n                    return this.setAnswer(answer, options).catch((error) => {\n                        this.stateTransition(SessionState.Terminated);\n                        throw error;\n                    });\n                }\n                return Promise.resolve();\n            case SignalingState.Closed:\n                // Dialog has terminated.\n                return Promise.reject(new Error(\"Terminated.\"));\n            default:\n                throw new Error(\"Unknown session signaling state.\");\n        }\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 3xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onRedirect(inviteResponse) {\n        this.logger.log(\"Inviter.onRedirect\");\n        // validate state\n        if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n            this.logger.error(`Redirect received while in state ${this.state}, dropping response`);\n            return;\n        }\n        // transition state\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 4xx, 5xx, or 6xx response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onReject(inviteResponse) {\n        this.logger.log(\"Inviter.onReject\");\n        // validate state\n        if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n            this.logger.error(`Reject received while in state ${this.state}, dropping response`);\n            return;\n        }\n        // transition state\n        this.stateTransition(SessionState.Terminated);\n    }\n    /**\n     * Handle final response to initial INVITE.\n     * @param inviteResponse - 100 response.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrying(inviteResponse) {\n        this.logger.log(\"Inviter.onTrying\");\n        // validate state\n        if (this.state !== SessionState.Establishing) {\n            this.logger.error(`Trying received while in state ${this.state}, dropping response`);\n            return;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}