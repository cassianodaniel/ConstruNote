{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { SubscriptionDialog } from \"../dialogs/subscription-dialog\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { NonInviteClientTransaction } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * SUBSCRIBE UAC.\n * @remarks\n * 4.1.  Subscriber Behavior\n * https://tools.ietf.org/html/rfc6665#section-4.1\n *\n * User agent client for installation of a single subscription per SUBSCRIBE request.\n * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.\n * @public\n */\n\nexport var SubscribeUserAgentClient = /*#__PURE__*/function (_UserAgentClient) {\n  _inherits(SubscribeUserAgentClient, _UserAgentClient);\n\n  var _super = _createSuper(SubscribeUserAgentClient);\n\n  function SubscribeUserAgentClient(core, message, delegate) {\n    var _this;\n\n    _classCallCheck(this, SubscribeUserAgentClient);\n\n    // Get event from request message.\n    var event = message.getHeader(\"Event\");\n\n    if (!event) {\n      throw new Error(\"Event undefined\");\n    } // Get expires from request message.\n\n\n    var expires = message.getHeader(\"Expires\");\n\n    if (!expires) {\n      throw new Error(\"Expires undefined\");\n    }\n\n    _this = _super.call(this, NonInviteClientTransaction, core, message, delegate);\n    _this.delegate = delegate; // FIXME: Subscriber id should also be matching on event id.\n\n    _this.subscriberId = message.callId + message.fromTag + event;\n    _this.subscriptionExpiresRequested = _this.subscriptionExpires = Number(expires);\n    _this.subscriptionEvent = event;\n    _this.subscriptionState = SubscriptionState.NotifyWait; // Start waiting for a NOTIFY we can use to create a subscription.\n\n    _this.waitNotifyStart();\n\n    return _this;\n  }\n  /**\n   * Destructor.\n   * Note that Timer N may live on waiting for an initial NOTIFY and\n   * the delegate may still receive that NOTIFY. If you don't want\n   * that behavior then either clear the delegate so the delegate\n   * doesn't get called (a 200 will be sent in response to the NOTIFY)\n   * or call `waitNotifyStop` which will clear Timer N and remove this\n   * UAC from the core (a 481 will be sent in response to the NOTIFY).\n   */\n\n\n  _createClass(SubscribeUserAgentClient, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(SubscribeUserAgentClient.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * Handle out of dialog NOTIFY associated with SUBSCRIBE request.\n     * This is the first NOTIFY received after the SUBSCRIBE request.\n     * @param uas - User agent server handling the subscription creating NOTIFY.\n     */\n\n  }, {\n    key: \"onNotify\",\n    value: function onNotify(uas) {\n      // NOTIFY requests are matched to such SUBSCRIBE requests if they\n      // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n      // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n      // request, and the same \"Event\" header field.  Rules for comparisons of\n      // the \"Event\" header fields are described in Section 8.2.1.\n      // https://tools.ietf.org/html/rfc6665#section-4.4.1\n      var event = uas.message.parseHeader(\"Event\").event;\n\n      if (!event || event !== this.subscriptionEvent) {\n        this.logger.warn(\"Failed to parse event.\");\n        uas.reject({\n          statusCode: 489\n        });\n        return;\n      } // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n      // indicate the status of the subscription.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n      var subscriptionState = uas.message.parseHeader(\"Subscription-State\");\n\n      if (!subscriptionState || !subscriptionState.state) {\n        this.logger.warn(\"Failed to parse subscription state.\");\n        uas.reject({\n          statusCode: 489\n        });\n        return;\n      } // Validate subscription state.\n\n\n      var state = subscriptionState.state;\n\n      switch (state) {\n        case \"pending\":\n          break;\n\n        case \"active\":\n          break;\n\n        case \"terminated\":\n          break;\n\n        default:\n          this.logger.warn(\"Invalid subscription state \".concat(state));\n          uas.reject({\n            statusCode: 489\n          });\n          return;\n      } // Dialogs usages are created upon completion of a NOTIFY transaction\n      // for a new subscription, unless the NOTIFY request contains a\n      // \"Subscription-State\" of \"terminated.\"\n      // https://tools.ietf.org/html/rfc6665#section-4.4.1\n\n\n      if (state !== \"terminated\") {\n        // The Contact header field MUST be present and contain exactly one SIP\n        // or SIPS URI in any request that can result in the establishment of a\n        // dialog.\n        // https://tools.ietf.org/html/rfc3261#section-8.1.1.8\n        var contact = uas.message.parseHeader(\"contact\");\n\n        if (!contact) {\n          this.logger.warn(\"Failed to parse contact.\");\n          uas.reject({\n            statusCode: 489\n          });\n          return;\n        }\n      } // In accordance with the rules for proxying non-INVITE requests as\n      // defined in [RFC3261], successful SUBSCRIBE requests will receive only\n      // one 200-class response; however, due to forking, the subscription may\n      // have been accepted by multiple nodes.  The subscriber MUST therefore\n      // be prepared to receive NOTIFY requests with \"From:\" tags that differ\n      // from the \"To:\" tag received in the SUBSCRIBE 200-class response.\n      //\n      // If multiple NOTIFY requests are received in different dialogs in\n      // response to a single SUBSCRIBE request, each dialog represents a\n      // different destination to which the SUBSCRIBE request was forked.\n      // Subscriber handling in such situations varies by event package; see\n      // Section 5.4.9 for details.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.4\n      // Each event package MUST specify whether forked SUBSCRIBE requests are\n      // allowed to install multiple subscriptions.\n      //\n      // If such behavior is not allowed, the first potential dialog-\n      // establishing message will create a dialog.  All subsequent NOTIFY\n      // requests that correspond to the SUBSCRIBE request (i.e., have\n      // matching \"To\", \"From\", \"Call-ID\", and \"Event\" header fields, as well\n      // as \"From\" header field \"tag\" parameter and \"Event\" header field \"id\"\n      // parameter) but that do not match the dialog would be rejected with a\n      // 481 response.  Note that the 200-class response to the SUBSCRIBE\n      // request can arrive after a matching NOTIFY request has been received;\n      // such responses might not correlate to the same dialog established by\n      // the NOTIFY request.  Except as required to complete the SUBSCRIBE\n      // transaction, such non-matching 200-class responses are ignored.\n      //\n      // If installing of multiple subscriptions by way of a single forked\n      // SUBSCRIBE request is allowed, the subscriber establishes a new dialog\n      // towards each notifier by returning a 200-class response to each\n      // NOTIFY request.  Each dialog is then handled as its own entity and is\n      // refreshed independently of the other dialogs.\n      //\n      // In the case that multiple subscriptions are allowed, the event\n      // package MUST specify whether merging of the notifications to form a\n      // single state is required, and how such merging is to be performed.\n      // Note that it is possible that some event packages may be defined in\n      // such a way that each dialog is tied to a mutually exclusive state\n      // that is unaffected by the other dialogs; this MUST be clearly stated\n      // if it is the case.\n      // https://tools.ietf.org/html/rfc6665#section-5.4.9\n      // *** NOTE: This implementation is only for event packages which\n      // do not allow forked requests to install multiple subscriptions.\n      // As such and in accordance with the specification, we stop waiting\n      // and any future NOTIFY requests will be rejected with a 481.\n\n\n      if (this.dialog) {\n        throw new Error(\"Dialog already created. This implementation only supports install of single subscriptions.\");\n      }\n\n      this.waitNotifyStop(); // Update expires.\n\n      this.subscriptionExpires = subscriptionState.expires ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) : this.subscriptionExpires; // Update subscription state.\n\n      switch (state) {\n        case \"pending\":\n          this.subscriptionState = SubscriptionState.Pending;\n          break;\n\n        case \"active\":\n          this.subscriptionState = SubscriptionState.Active;\n          break;\n\n        case \"terminated\":\n          this.subscriptionState = SubscriptionState.Terminated;\n          break;\n\n        default:\n          throw new Error(\"Unrecognized state \".concat(state, \".\"));\n      } // Dialogs usages are created upon completion of a NOTIFY transaction\n      // for a new subscription, unless the NOTIFY request contains a\n      // \"Subscription-State\" of \"terminated.\"\n      // https://tools.ietf.org/html/rfc6665#section-4.4.1\n\n\n      if (this.subscriptionState !== SubscriptionState.Terminated) {\n        // Because the dialog usage is established by the NOTIFY request, the\n        // route set at the subscriber is taken from the NOTIFY request itself,\n        // as opposed to the route set present in the 200-class response to the\n        // SUBSCRIBE request.\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        var dialogState = SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message); // Subscription Initiated! :)\n\n        this.dialog = new SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);\n      } // Delegate.\n\n\n      if (this.delegate && this.delegate.onNotify) {\n        var request = uas;\n        var subscription = this.dialog;\n        this.delegate.onNotify({\n          request: request,\n          subscription: subscription\n        });\n      } else {\n        uas.accept();\n      }\n    }\n  }, {\n    key: \"waitNotifyStart\",\n    value: function waitNotifyStart() {\n      var _this2 = this;\n\n      if (!this.N) {\n        // Add ourselves to the core's subscriber map.\n        // This allows the core to route out of dialog NOTIFY messages to us.\n        this.core.subscribers.set(this.subscriberId, this);\n        this.N = setTimeout(function () {\n          return _this2.timerN();\n        }, Timers.TIMER_N);\n      }\n    }\n  }, {\n    key: \"waitNotifyStop\",\n    value: function waitNotifyStop() {\n      if (this.N) {\n        // Remove ourselves to the core's subscriber map.\n        // Any future out of dialog NOTIFY messages will be rejected with a 481.\n        this.core.subscribers.delete(this.subscriberId);\n        clearTimeout(this.N);\n        this.N = undefined;\n      }\n    }\n    /**\n     * Receive a response from the transaction layer.\n     * @param message - Incoming response message.\n     */\n\n  }, {\n    key: \"receiveResponse\",\n    value: function receiveResponse(message) {\n      if (!this.authenticationGuard(message)) {\n        return;\n      }\n\n      if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {\n        //  The \"Expires\" header field in a 200-class response to SUBSCRIBE\n        //  request indicates the actual duration for which the subscription will\n        //  remain active (unless refreshed).  The received value might be\n        //  smaller than the value indicated in the SUBSCRIBE request but cannot\n        //  be larger; see Section 4.2.1 for details.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        // The \"Expires\" values present in SUBSCRIBE 200-class responses behave\n        // in the same way as they do in REGISTER responses: the server MAY\n        // shorten the interval but MUST NOT lengthen it.\n        //\n        //    If the duration specified in a SUBSCRIBE request is unacceptably\n        //    short, the notifier may be able to send a 423 response, as\n        //    described earlier in this section.\n        //\n        // 200-class responses to SUBSCRIBE requests will not generally contain\n        // any useful information beyond subscription duration; their primary\n        // purpose is to serve as a reliability mechanism.  State information\n        // will be communicated via a subsequent NOTIFY request from the\n        // notifier.\n        // https://tools.ietf.org/html/rfc6665#section-4.2.1.1\n        var expires = message.getHeader(\"Expires\");\n\n        if (!expires) {\n          this.logger.warn(\"Expires header missing in a 200-class response to SUBSCRIBE\");\n        } else {\n          var subscriptionExpiresReceived = Number(expires);\n\n          if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {\n            this.logger.warn(\"Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request\");\n          }\n\n          if (subscriptionExpiresReceived < this.subscriptionExpires) {\n            this.subscriptionExpires = subscriptionExpiresReceived;\n          }\n        } // If a NOTIFY arrived before 200-class response a dialog may have been created.\n        // Updated the dialogs expiration only if this indicates earlier expiration.\n\n\n        if (this.dialog) {\n          if (this.dialog.subscriptionExpires > this.subscriptionExpires) {\n            this.dialog.subscriptionExpires = this.subscriptionExpires;\n          }\n        }\n      }\n\n      if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {\n        this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.\n      }\n\n      _get(_getPrototypeOf(SubscribeUserAgentClient.prototype), \"receiveResponse\", this).call(this, message);\n    }\n    /**\n     * To ensure that subscribers do not wait indefinitely for a\n     * subscription to be established, a subscriber starts a Timer N, set to\n     * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires\n     * prior to the receipt of a NOTIFY request, the subscriber considers\n     * the subscription failed, and cleans up any state associated with the\n     * subscription attempt.\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n     */\n\n  }, {\n    key: \"timerN\",\n    value: function timerN() {\n      this.logger.warn(\"Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.\");\n      this.waitNotifyStop();\n\n      if (this.delegate && this.delegate.onNotifyTimeout) {\n        this.delegate.onNotifyTimeout();\n      }\n    }\n  }]);\n\n  return SubscribeUserAgentClient;\n}(UserAgentClient);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/subscribe-user-agent-client.js"],"names":["SubscriptionDialog","SubscriptionState","Timers","NonInviteClientTransaction","UserAgentClient","SubscribeUserAgentClient","core","message","delegate","event","getHeader","Error","expires","subscriberId","callId","fromTag","subscriptionExpiresRequested","subscriptionExpires","Number","subscriptionEvent","subscriptionState","NotifyWait","waitNotifyStart","uas","parseHeader","logger","warn","reject","statusCode","state","contact","dialog","waitNotifyStop","Math","min","max","Pending","Active","Terminated","dialogState","initialDialogStateForSubscription","onNotify","request","subscription","accept","N","subscribers","set","setTimeout","timerN","TIMER_N","delete","clearTimeout","undefined","authenticationGuard","subscriptionExpiresReceived","onNotifyTimeout"],"mappings":"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","sourcesContent":["import { SubscriptionDialog } from \"../dialogs/subscription-dialog\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { NonInviteClientTransaction } from \"../transactions\";\nimport { UserAgentClient } from \"./user-agent-client\";\n/**\n * SUBSCRIBE UAC.\n * @remarks\n * 4.1.  Subscriber Behavior\n * https://tools.ietf.org/html/rfc6665#section-4.1\n *\n * User agent client for installation of a single subscription per SUBSCRIBE request.\n * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.\n * @public\n */\nexport class SubscribeUserAgentClient extends UserAgentClient {\n    constructor(core, message, delegate) {\n        // Get event from request message.\n        const event = message.getHeader(\"Event\");\n        if (!event) {\n            throw new Error(\"Event undefined\");\n        }\n        // Get expires from request message.\n        const expires = message.getHeader(\"Expires\");\n        if (!expires) {\n            throw new Error(\"Expires undefined\");\n        }\n        super(NonInviteClientTransaction, core, message, delegate);\n        this.delegate = delegate;\n        // FIXME: Subscriber id should also be matching on event id.\n        this.subscriberId = message.callId + message.fromTag + event;\n        this.subscriptionExpiresRequested = this.subscriptionExpires = Number(expires);\n        this.subscriptionEvent = event;\n        this.subscriptionState = SubscriptionState.NotifyWait;\n        // Start waiting for a NOTIFY we can use to create a subscription.\n        this.waitNotifyStart();\n    }\n    /**\n     * Destructor.\n     * Note that Timer N may live on waiting for an initial NOTIFY and\n     * the delegate may still receive that NOTIFY. If you don't want\n     * that behavior then either clear the delegate so the delegate\n     * doesn't get called (a 200 will be sent in response to the NOTIFY)\n     * or call `waitNotifyStop` which will clear Timer N and remove this\n     * UAC from the core (a 481 will be sent in response to the NOTIFY).\n     */\n    dispose() {\n        super.dispose();\n    }\n    /**\n     * Handle out of dialog NOTIFY associated with SUBSCRIBE request.\n     * This is the first NOTIFY received after the SUBSCRIBE request.\n     * @param uas - User agent server handling the subscription creating NOTIFY.\n     */\n    onNotify(uas) {\n        // NOTIFY requests are matched to such SUBSCRIBE requests if they\n        // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n        // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n        // request, and the same \"Event\" header field.  Rules for comparisons of\n        // the \"Event\" header fields are described in Section 8.2.1.\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        const event = uas.message.parseHeader(\"Event\").event;\n        if (!event || event !== this.subscriptionEvent) {\n            this.logger.warn(`Failed to parse event.`);\n            uas.reject({ statusCode: 489 });\n            return;\n        }\n        // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n        // indicate the status of the subscription.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const subscriptionState = uas.message.parseHeader(\"Subscription-State\");\n        if (!subscriptionState || !subscriptionState.state) {\n            this.logger.warn(\"Failed to parse subscription state.\");\n            uas.reject({ statusCode: 489 });\n            return;\n        }\n        // Validate subscription state.\n        const state = subscriptionState.state;\n        switch (state) {\n            case \"pending\":\n                break;\n            case \"active\":\n                break;\n            case \"terminated\":\n                break;\n            default:\n                this.logger.warn(`Invalid subscription state ${state}`);\n                uas.reject({ statusCode: 489 });\n                return;\n        }\n        // Dialogs usages are created upon completion of a NOTIFY transaction\n        // for a new subscription, unless the NOTIFY request contains a\n        // \"Subscription-State\" of \"terminated.\"\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        if (state !== \"terminated\") {\n            // The Contact header field MUST be present and contain exactly one SIP\n            // or SIPS URI in any request that can result in the establishment of a\n            // dialog.\n            // https://tools.ietf.org/html/rfc3261#section-8.1.1.8\n            const contact = uas.message.parseHeader(\"contact\");\n            if (!contact) {\n                this.logger.warn(\"Failed to parse contact.\");\n                uas.reject({ statusCode: 489 });\n                return;\n            }\n        }\n        // In accordance with the rules for proxying non-INVITE requests as\n        // defined in [RFC3261], successful SUBSCRIBE requests will receive only\n        // one 200-class response; however, due to forking, the subscription may\n        // have been accepted by multiple nodes.  The subscriber MUST therefore\n        // be prepared to receive NOTIFY requests with \"From:\" tags that differ\n        // from the \"To:\" tag received in the SUBSCRIBE 200-class response.\n        //\n        // If multiple NOTIFY requests are received in different dialogs in\n        // response to a single SUBSCRIBE request, each dialog represents a\n        // different destination to which the SUBSCRIBE request was forked.\n        // Subscriber handling in such situations varies by event package; see\n        // Section 5.4.9 for details.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.4\n        // Each event package MUST specify whether forked SUBSCRIBE requests are\n        // allowed to install multiple subscriptions.\n        //\n        // If such behavior is not allowed, the first potential dialog-\n        // establishing message will create a dialog.  All subsequent NOTIFY\n        // requests that correspond to the SUBSCRIBE request (i.e., have\n        // matching \"To\", \"From\", \"Call-ID\", and \"Event\" header fields, as well\n        // as \"From\" header field \"tag\" parameter and \"Event\" header field \"id\"\n        // parameter) but that do not match the dialog would be rejected with a\n        // 481 response.  Note that the 200-class response to the SUBSCRIBE\n        // request can arrive after a matching NOTIFY request has been received;\n        // such responses might not correlate to the same dialog established by\n        // the NOTIFY request.  Except as required to complete the SUBSCRIBE\n        // transaction, such non-matching 200-class responses are ignored.\n        //\n        // If installing of multiple subscriptions by way of a single forked\n        // SUBSCRIBE request is allowed, the subscriber establishes a new dialog\n        // towards each notifier by returning a 200-class response to each\n        // NOTIFY request.  Each dialog is then handled as its own entity and is\n        // refreshed independently of the other dialogs.\n        //\n        // In the case that multiple subscriptions are allowed, the event\n        // package MUST specify whether merging of the notifications to form a\n        // single state is required, and how such merging is to be performed.\n        // Note that it is possible that some event packages may be defined in\n        // such a way that each dialog is tied to a mutually exclusive state\n        // that is unaffected by the other dialogs; this MUST be clearly stated\n        // if it is the case.\n        // https://tools.ietf.org/html/rfc6665#section-5.4.9\n        // *** NOTE: This implementation is only for event packages which\n        // do not allow forked requests to install multiple subscriptions.\n        // As such and in accordance with the specification, we stop waiting\n        // and any future NOTIFY requests will be rejected with a 481.\n        if (this.dialog) {\n            throw new Error(\"Dialog already created. This implementation only supports install of single subscriptions.\");\n        }\n        this.waitNotifyStop();\n        // Update expires.\n        this.subscriptionExpires = subscriptionState.expires\n            ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0))\n            : this.subscriptionExpires;\n        // Update subscription state.\n        switch (state) {\n            case \"pending\":\n                this.subscriptionState = SubscriptionState.Pending;\n                break;\n            case \"active\":\n                this.subscriptionState = SubscriptionState.Active;\n                break;\n            case \"terminated\":\n                this.subscriptionState = SubscriptionState.Terminated;\n                break;\n            default:\n                throw new Error(`Unrecognized state ${state}.`);\n        }\n        // Dialogs usages are created upon completion of a NOTIFY transaction\n        // for a new subscription, unless the NOTIFY request contains a\n        // \"Subscription-State\" of \"terminated.\"\n        // https://tools.ietf.org/html/rfc6665#section-4.4.1\n        if (this.subscriptionState !== SubscriptionState.Terminated) {\n            // Because the dialog usage is established by the NOTIFY request, the\n            // route set at the subscriber is taken from the NOTIFY request itself,\n            // as opposed to the route set present in the 200-class response to the\n            // SUBSCRIBE request.\n            // https://tools.ietf.org/html/rfc6665#section-4.4.1\n            const dialogState = SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message);\n            // Subscription Initiated! :)\n            this.dialog = new SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);\n        }\n        // Delegate.\n        if (this.delegate && this.delegate.onNotify) {\n            const request = uas;\n            const subscription = this.dialog;\n            this.delegate.onNotify({ request, subscription });\n        }\n        else {\n            uas.accept();\n        }\n    }\n    waitNotifyStart() {\n        if (!this.N) {\n            // Add ourselves to the core's subscriber map.\n            // This allows the core to route out of dialog NOTIFY messages to us.\n            this.core.subscribers.set(this.subscriberId, this);\n            this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n        }\n    }\n    waitNotifyStop() {\n        if (this.N) {\n            // Remove ourselves to the core's subscriber map.\n            // Any future out of dialog NOTIFY messages will be rejected with a 481.\n            this.core.subscribers.delete(this.subscriberId);\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n    }\n    /**\n     * Receive a response from the transaction layer.\n     * @param message - Incoming response message.\n     */\n    receiveResponse(message) {\n        if (!this.authenticationGuard(message)) {\n            return;\n        }\n        if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {\n            //  The \"Expires\" header field in a 200-class response to SUBSCRIBE\n            //  request indicates the actual duration for which the subscription will\n            //  remain active (unless refreshed).  The received value might be\n            //  smaller than the value indicated in the SUBSCRIBE request but cannot\n            //  be larger; see Section 4.2.1 for details.\n            // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n            // The \"Expires\" values present in SUBSCRIBE 200-class responses behave\n            // in the same way as they do in REGISTER responses: the server MAY\n            // shorten the interval but MUST NOT lengthen it.\n            //\n            //    If the duration specified in a SUBSCRIBE request is unacceptably\n            //    short, the notifier may be able to send a 423 response, as\n            //    described earlier in this section.\n            //\n            // 200-class responses to SUBSCRIBE requests will not generally contain\n            // any useful information beyond subscription duration; their primary\n            // purpose is to serve as a reliability mechanism.  State information\n            // will be communicated via a subsequent NOTIFY request from the\n            // notifier.\n            // https://tools.ietf.org/html/rfc6665#section-4.2.1.1\n            const expires = message.getHeader(\"Expires\");\n            if (!expires) {\n                this.logger.warn(\"Expires header missing in a 200-class response to SUBSCRIBE\");\n            }\n            else {\n                const subscriptionExpiresReceived = Number(expires);\n                if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {\n                    this.logger.warn(\"Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request\");\n                }\n                if (subscriptionExpiresReceived < this.subscriptionExpires) {\n                    this.subscriptionExpires = subscriptionExpiresReceived;\n                }\n            }\n            // If a NOTIFY arrived before 200-class response a dialog may have been created.\n            // Updated the dialogs expiration only if this indicates earlier expiration.\n            if (this.dialog) {\n                if (this.dialog.subscriptionExpires > this.subscriptionExpires) {\n                    this.dialog.subscriptionExpires = this.subscriptionExpires;\n                }\n            }\n        }\n        if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {\n            this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.\n        }\n        super.receiveResponse(message);\n    }\n    /**\n     * To ensure that subscribers do not wait indefinitely for a\n     * subscription to be established, a subscriber starts a Timer N, set to\n     * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires\n     * prior to the receipt of a NOTIFY request, the subscriber considers\n     * the subscription failed, and cleans up any state associated with the\n     * subscription attempt.\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n     */\n    timerN() {\n        this.logger.warn(`Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.`);\n        this.waitNotifyStop();\n        if (this.delegate && this.delegate.onNotifyTimeout) {\n            this.delegate.onNotifyTimeout();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}