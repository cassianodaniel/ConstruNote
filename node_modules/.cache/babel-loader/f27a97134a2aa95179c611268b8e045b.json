{"ast":null,"code":"import { Grammar } from \"../../grammar\";\nimport { headerize } from \"./utils\";\n/**\n * Incoming message.\n * @public\n */\n\nexport class IncomingMessage {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.headers = {};\n  }\n  /**\n   * Insert a header of the given name and value into the last position of the\n   * header array.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  addHeader(name, value) {\n    const header = {\n      raw: value\n    };\n    name = headerize(name);\n\n    if (this.headers[name]) {\n      this.headers[name].push(header);\n    } else {\n      this.headers[name] = [header];\n    }\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   * @param name - header name\n   * @returns Returns the specified header, undefined if header doesn't exist.\n   */\n\n\n  getHeader(name) {\n    const header = this.headers[headerize(name)];\n\n    if (header) {\n      if (header[0]) {\n        return header[0].raw;\n      }\n    } else {\n      return;\n    }\n  }\n  /**\n   * Get the header/s of the given name.\n   * @param name - header name\n   * @returns Array - with all the headers of the specified name.\n   */\n\n\n  getHeaders(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const header = this.headers[headerize(name)];\n    const result = [];\n\n    if (!header) {\n      return [];\n    }\n\n    for (const headerPart of header) {\n      result.push(headerPart.raw);\n    }\n\n    return result;\n  }\n  /**\n   * Verify the existence of the given header.\n   * @param name - header name\n   * @returns true if header with given name exists, false otherwise\n   */\n\n\n  hasHeader(name) {\n    return !!this.headers[headerize(name)];\n  }\n  /**\n   * Parse the given header on the given index.\n   * @param name - header name\n   * @param idx - header index\n   * @returns Parsed header object, undefined if the\n   *   header is not present or in case of a parsing error.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  parseHeader(name, idx = 0) {\n    name = headerize(name);\n\n    if (!this.headers[name]) {\n      // this.logger.log(\"header '\" + name + \"' not present\");\n      return;\n    } else if (idx >= this.headers[name].length) {\n      // this.logger.log(\"not so many '\" + name + \"' headers present\");\n      return;\n    }\n\n    const header = this.headers[name][idx];\n    const value = header.raw;\n\n    if (header.parsed) {\n      return header.parsed;\n    } // substitute '-' by '_' for grammar rule matching.\n\n\n    const parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n\n    if (parsed === -1) {\n      this.headers[name].splice(idx, 1); // delete from headers\n      // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\n      return;\n    } else {\n      header.parsed = parsed;\n      return parsed;\n    }\n  }\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * @param name - header name\n   * @param idx - header index\n   * @returns Parsed header object, undefined if the\n   *   header is not present or in case of a parsing error.\n   *\n   * @example\n   * message.s('via',3).port\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  s(name, idx = 0) {\n    return this.parseHeader(name, idx);\n  }\n  /**\n   * Replace the value of the given header by the value.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  setHeader(name, value) {\n    this.headers[headerize(name)] = [{\n      raw: value\n    }];\n  }\n\n  toString() {\n    return this.data;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/incoming-message.js"],"names":["Grammar","headerize","IncomingMessage","constructor","headers","addHeader","name","value","header","raw","push","getHeader","getHeaders","result","headerPart","hasHeader","parseHeader","idx","length","parsed","parse","replace","splice","s","setHeader","toString","data"],"mappings":"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","sourcesContent":["import { Grammar } from \"../../grammar\";\nimport { headerize } from \"./utils\";\n/**\n * Incoming message.\n * @public\n */\nexport class IncomingMessage {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.headers = {};\n    }\n    /**\n     * Insert a header of the given name and value into the last position of the\n     * header array.\n     * @param name - header name\n     * @param value - header value\n     */\n    addHeader(name, value) {\n        const header = { raw: value };\n        name = headerize(name);\n        if (this.headers[name]) {\n            this.headers[name].push(header);\n        }\n        else {\n            this.headers[name] = [header];\n        }\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0].raw;\n            }\n        }\n        else {\n            return;\n        }\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array - with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const header = this.headers[headerize(name)];\n        const result = [];\n        if (!header) {\n            return [];\n        }\n        for (const headerPart of header) {\n            result.push(headerPart.raw);\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        return !!this.headers[headerize(name)];\n    }\n    /**\n     * Parse the given header on the given index.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parseHeader(name, idx = 0) {\n        name = headerize(name);\n        if (!this.headers[name]) {\n            // this.logger.log(\"header '\" + name + \"' not present\");\n            return;\n        }\n        else if (idx >= this.headers[name].length) {\n            // this.logger.log(\"not so many '\" + name + \"' headers present\");\n            return;\n        }\n        const header = this.headers[name][idx];\n        const value = header.raw;\n        if (header.parsed) {\n            return header.parsed;\n        }\n        // substitute '-' by '_' for grammar rule matching.\n        const parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n        if (parsed === -1) {\n            this.headers[name].splice(idx, 1); // delete from headers\n            // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n            return;\n        }\n        else {\n            header.parsed = parsed;\n            return parsed;\n        }\n    }\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     *\n     * @example\n     * message.s('via',3).port\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    s(name, idx = 0) {\n        return this.parseHeader(name, idx);\n    }\n    /**\n     * Replace the value of the given header by the value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = [{ raw: value }];\n    }\n    toString() {\n        return this.data;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}