{"ast":null,"code":"import { C, IncomingResponseMessage } from \"../messages\";\nimport { NonInviteClientTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Client (UAC).\n * @remarks\n * A user agent client is a logical entity\n * that creates a new request, and then uses the client\n * transaction state machinery to send it.  The role of UAC lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software initiates a request, it acts as a UAC for\n * the duration of that transaction.  If it receives a request\n * later, it assumes the role of a user agent server for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport class UserAgentClient {\n  constructor(transactionConstructor, core, message, delegate) {\n    this.transactionConstructor = transactionConstructor;\n    this.core = core;\n    this.message = message;\n    this.delegate = delegate;\n    this.challenged = false;\n    this.stale = false;\n    this.logger = this.loggerFactory.getLogger(\"sip.user-agent-client\");\n    this.init();\n  }\n\n  dispose() {\n    this.transaction.dispose();\n  }\n\n  get loggerFactory() {\n    return this.core.loggerFactory;\n  }\n  /** The transaction associated with this request. */\n\n\n  get transaction() {\n    if (!this._transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    return this._transaction;\n  }\n  /**\n   * Since requests other than INVITE are responded to immediately, sending a\n   * CANCEL for a non-INVITE request would always create a race condition.\n   * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-9.1\n   * @param options - Cancel options bucket.\n   */\n\n\n  cancel(reason, options = {}) {\n    if (!this.transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    if (!this.message.to) {\n      throw new Error(\"To undefined.\");\n    }\n\n    if (!this.message.from) {\n      throw new Error(\"From undefined.\");\n    } // The following procedures are used to construct a CANCEL request.  The\n    // Request-URI, Call-ID, To, the numeric part of CSeq, and From header\n    // fields in the CANCEL request MUST be identical to those in the\n    // request being cancelled, including tags.  A CANCEL constructed by a\n    // client MUST have only a single Via header field value matching the\n    // top Via value in the request being cancelled.  Using the same values\n    // for these header fields allows the CANCEL to be matched with the\n    // request it cancels (Section 9.2 indicates how such matching occurs).\n    // However, the method part of the CSeq header field MUST have a value\n    // of CANCEL.  This allows it to be identified and processed as a\n    // transaction in its own right (See Section 17).\n    // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n    const message = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {\n      toTag: this.message.toTag,\n      fromTag: this.message.fromTag,\n      callId: this.message.callId,\n      cseq: this.message.cseq\n    }, options.extraHeaders); // TODO: Revisit this.\n    // The CANCEL needs to use the same branch parameter so that\n    // it matches the INVITE transaction, but this is a hacky way to do this.\n    // Or at the very least not well documented. If the the branch parameter\n    // is set on the outgoing request, the transaction will use it.\n    // Otherwise the transaction will make a new one.\n\n    message.branch = this.message.branch;\n\n    if (this.message.headers.Route) {\n      message.headers.Route = this.message.headers.Route;\n    }\n\n    if (reason) {\n      message.setHeader(\"Reason\", reason);\n    } // If no provisional response has been received, the CANCEL request MUST\n    // NOT be sent; rather, the client MUST wait for the arrival of a\n    // provisional response before sending the request. If the original\n    // request has generated a final response, the CANCEL SHOULD NOT be\n    // sent, as it is an effective no-op, since CANCEL has no effect on\n    // requests that have already generated a final response.\n    // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n    if (this.transaction.state === TransactionState.Proceeding) {\n      new UserAgentClient(NonInviteClientTransaction, this.core, message);\n    } else {\n      this.transaction.addStateChangeListener(() => {\n        if (this.transaction && this.transaction.state === TransactionState.Proceeding) {\n          new UserAgentClient(NonInviteClientTransaction, this.core, message);\n        }\n      }, {\n        once: true\n      });\n    }\n\n    return message;\n  }\n  /**\n   * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n   * response is received, the UAC SHOULD follow the authorization\n   * procedures of Section 22.2 and Section 22.3 to retry the request with\n   * credentials.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n   * 22 Usage of HTTP Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22\n   * 22.1 Framework\n   * https://tools.ietf.org/html/rfc3261#section-22.1\n   * 22.2 User-to-User Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22.2\n   * 22.3 Proxy-to-User Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22.3\n   *\n   * FIXME: This \"guard for and retry the request with credentials\"\n   * implementation is not complete and at best minimally passable.\n   * @param response - The incoming response to guard.\n   * @param dialog - If defined, the dialog within which the response was received.\n   * @returns True if the program execution is to continue in the branch in question.\n   *          Otherwise the request is retried with credentials and current request processing must stop.\n   */\n\n\n  authenticationGuard(message, dialog) {\n    const statusCode = message.statusCode;\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    } // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n    // response is received, the UAC SHOULD follow the authorization\n    // procedures of Section 22.2 and Section 22.3 to retry the request with\n    // credentials.\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n\n\n    if (statusCode !== 401 && statusCode !== 407) {\n      return true;\n    } // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    let challenge;\n    let authorizationHeaderName;\n\n    if (statusCode === 401) {\n      challenge = message.parseHeader(\"www-authenticate\");\n      authorizationHeaderName = \"authorization\";\n    } else {\n      challenge = message.parseHeader(\"proxy-authenticate\");\n      authorizationHeaderName = \"proxy-authorization\";\n    } // Verify it seems a valid challenge.\n\n\n    if (!challenge) {\n      this.logger.warn(statusCode + \" with wrong or missing challenge, cannot authenticate\");\n      return true;\n    } // Avoid infinite authentications.\n\n\n    if (this.challenged && (this.stale || challenge.stale !== true)) {\n      this.logger.warn(statusCode + \" apparently in authentication loop, cannot authenticate\");\n      return true;\n    } // Get credentials.\n\n\n    if (!this.credentials) {\n      this.credentials = this.core.configuration.authenticationFactory();\n\n      if (!this.credentials) {\n        this.logger.warn(\"Unable to obtain credentials, cannot authenticate\");\n        return true;\n      }\n    } // Verify that the challenge is really valid.\n\n\n    if (!this.credentials.authenticate(this.message, challenge)) {\n      return true;\n    }\n\n    this.challenged = true;\n\n    if (challenge.stale) {\n      this.stale = true;\n    } // If response to out of dialog request, assume incrementing the CSeq will suffice.\n\n\n    let cseq = this.message.cseq += 1; // If response to in dialog request, get a valid next CSeq number.\n\n    if (dialog && dialog.localSequenceNumber) {\n      dialog.incrementLocalSequenceNumber();\n      cseq = this.message.cseq = dialog.localSequenceNumber;\n    }\n\n    this.message.setHeader(\"cseq\", cseq + \" \" + this.message.method);\n    this.message.setHeader(authorizationHeaderName, this.credentials.toString()); // Calling init (again) will swap out our existing client transaction with a new one.\n    // FIXME: HACK: An assumption is being made here that there is nothing that needs to\n    // be cleaned up beyond the client transaction which is being replaced. For example,\n    // it is assumed that no early dialogs have been created.\n\n    this.init();\n    return false;\n  }\n  /**\n   * 8.1.3.1 Transaction Layer Errors\n   * In some cases, the response returned by the transaction layer will\n   * not be a SIP message, but rather a transaction layer error.  When a\n   * timeout error is received from the transaction layer, it MUST be\n   * treated as if a 408 (Request Timeout) status code has been received.\n   * If a fatal transport error is reported by the transport layer\n   * (generally, due to fatal ICMP errors in UDP or connection failures in\n   * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n   * status code.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n   */\n\n\n  onRequestTimeout() {\n    this.logger.warn(\"User agent client request timed out. Generating internal 408 Request Timeout.\");\n    const message = new IncomingResponseMessage();\n    message.statusCode = 408;\n    message.reasonPhrase = \"Request Timeout\";\n    this.receiveResponse(message);\n    return;\n  }\n  /**\n   * 8.1.3.1 Transaction Layer Errors\n   * In some cases, the response returned by the transaction layer will\n   * not be a SIP message, but rather a transaction layer error.  When a\n   * timeout error is received from the transaction layer, it MUST be\n   * treated as if a 408 (Request Timeout) status code has been received.\n   * If a fatal transport error is reported by the transport layer\n   * (generally, due to fatal ICMP errors in UDP or connection failures in\n   * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n   * status code.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n   * @param error - Transport error\n   */\n\n\n  onTransportError(error) {\n    this.logger.error(error.message);\n    this.logger.error(\"User agent client request transport error. Generating internal 503 Service Unavailable.\");\n    const message = new IncomingResponseMessage();\n    message.statusCode = 503;\n    message.reasonPhrase = \"Service Unavailable\";\n    this.receiveResponse(message);\n  }\n  /**\n   * Receive a response from the transaction layer.\n   * @param message - Incoming response message.\n   */\n\n\n  receiveResponse(message) {\n    if (!this.authenticationGuard(message)) {\n      return;\n    }\n\n    const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    }\n\n    switch (true) {\n      case /^100$/.test(statusCode):\n        if (this.delegate && this.delegate.onTrying) {\n          this.delegate.onTrying({\n            message\n          });\n        }\n\n        break;\n\n      case /^1[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onProgress) {\n          this.delegate.onProgress({\n            message\n          });\n        }\n\n        break;\n\n      case /^2[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onAccept) {\n          this.delegate.onAccept({\n            message\n          });\n        }\n\n        break;\n\n      case /^3[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onRedirect) {\n          this.delegate.onRedirect({\n            message\n          });\n        }\n\n        break;\n\n      case /^[4-6][0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onReject) {\n          this.delegate.onReject({\n            message\n          });\n        }\n\n        break;\n\n      default:\n        throw new Error(`Invalid status code ${statusCode}`);\n    }\n  }\n\n  init() {\n    // We are the transaction user.\n    const user = {\n      loggerFactory: this.loggerFactory,\n      onRequestTimeout: () => this.onRequestTimeout(),\n      onStateChange: newState => {\n        if (newState === TransactionState.Terminated) {\n          // Remove the terminated transaction from the core.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          this.core.userAgentClients.delete(userAgentClientId); // FIXME: HACK: Our transaction may have been swapped out with a new one\n          // post authentication (see above), so make sure to only to dispose of\n          // ourselves if this terminating transaction is our current transaction.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n          if (transaction === this._transaction) {\n            this.dispose();\n          }\n        }\n      },\n      onTransportError: error => this.onTransportError(error),\n      receiveResponse: message => this.receiveResponse(message)\n    }; // Create a new transaction with us as the user.\n\n    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n    this._transaction = transaction; // Add the new transaction to the core.\n\n    const userAgentClientId = transaction.id + transaction.request.method;\n    this.core.userAgentClients.set(userAgentClientId, this);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/user-agent-client.js"],"names":["C","IncomingResponseMessage","NonInviteClientTransaction","TransactionState","UserAgentClient","constructor","transactionConstructor","core","message","delegate","challenged","stale","logger","loggerFactory","getLogger","init","dispose","transaction","_transaction","Error","cancel","reason","options","to","from","makeOutgoingRequestMessage","CANCEL","ruri","uri","toTag","fromTag","callId","cseq","extraHeaders","branch","headers","Route","setHeader","state","Proceeding","addStateChangeListener","once","authenticationGuard","dialog","statusCode","challenge","authorizationHeaderName","parseHeader","warn","credentials","configuration","authenticationFactory","authenticate","localSequenceNumber","incrementLocalSequenceNumber","method","toString","onRequestTimeout","reasonPhrase","receiveResponse","onTransportError","error","test","onTrying","onProgress","onAccept","onRedirect","onReject","user","onStateChange","newState","Terminated","userAgentClients","delete","userAgentClientId","transport","id","request","set"],"mappings":"AAAA,SAASA,CAAT,EAAYC,uBAAZ,QAA2C,aAA3C;AACA,SAASC,0BAAT,EAAqCC,gBAArC,QAA6D,iBAA7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,eAAN,CAAsB;AACzBC,EAAAA,WAAW,CAACC,sBAAD,EAAyBC,IAAzB,EAA+BC,OAA/B,EAAwCC,QAAxC,EAAkD;AACzD,SAAKH,sBAAL,GAA8BA,sBAA9B;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,KAAL,GAAa,KAAb;AACA,SAAKC,MAAL,GAAc,KAAKC,aAAL,CAAmBC,SAAnB,CAA6B,uBAA7B,CAAd;AACA,SAAKC,IAAL;AACH;;AACDC,EAAAA,OAAO,GAAG;AACN,SAAKC,WAAL,CAAiBD,OAAjB;AACH;;AACD,MAAIH,aAAJ,GAAoB;AAChB,WAAO,KAAKN,IAAL,CAAUM,aAAjB;AACH;AACD;;;AACA,MAAII,WAAJ,GAAkB;AACd,QAAI,CAAC,KAAKC,YAAV,EAAwB;AACpB,YAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AACH;;AACD,WAAO,KAAKD,YAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIE,EAAAA,MAAM,CAACC,MAAD,EAASC,OAAO,GAAG,EAAnB,EAAuB;AACzB,QAAI,CAAC,KAAKL,WAAV,EAAuB;AACnB,YAAM,IAAIE,KAAJ,CAAU,wBAAV,CAAN;AACH;;AACD,QAAI,CAAC,KAAKX,OAAL,CAAae,EAAlB,EAAsB;AAClB,YAAM,IAAIJ,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,QAAI,CAAC,KAAKX,OAAL,CAAagB,IAAlB,EAAwB;AACpB,YAAM,IAAIL,KAAJ,CAAU,iBAAV,CAAN;AACH,KATwB,CAUzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMX,OAAO,GAAG,KAAKD,IAAL,CAAUkB,0BAAV,CAAqCzB,CAAC,CAAC0B,MAAvC,EAA+C,KAAKlB,OAAL,CAAamB,IAA5D,EAAkE,KAAKnB,OAAL,CAAagB,IAAb,CAAkBI,GAApF,EAAyF,KAAKpB,OAAL,CAAae,EAAb,CAAgBK,GAAzG,EAA8G;AAC1HC,MAAAA,KAAK,EAAE,KAAKrB,OAAL,CAAaqB,KADsG;AAE1HC,MAAAA,OAAO,EAAE,KAAKtB,OAAL,CAAasB,OAFoG;AAG1HC,MAAAA,MAAM,EAAE,KAAKvB,OAAL,CAAauB,MAHqG;AAI1HC,MAAAA,IAAI,EAAE,KAAKxB,OAAL,CAAawB;AAJuG,KAA9G,EAKbV,OAAO,CAACW,YALK,CAAhB,CAtByB,CA4BzB;AACA;AACA;AACA;AACA;AACA;;AACAzB,IAAAA,OAAO,CAAC0B,MAAR,GAAiB,KAAK1B,OAAL,CAAa0B,MAA9B;;AACA,QAAI,KAAK1B,OAAL,CAAa2B,OAAb,CAAqBC,KAAzB,EAAgC;AAC5B5B,MAAAA,OAAO,CAAC2B,OAAR,CAAgBC,KAAhB,GAAwB,KAAK5B,OAAL,CAAa2B,OAAb,CAAqBC,KAA7C;AACH;;AACD,QAAIf,MAAJ,EAAY;AACRb,MAAAA,OAAO,CAAC6B,SAAR,CAAkB,QAAlB,EAA4BhB,MAA5B;AACH,KAxCwB,CAyCzB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAI,KAAKJ,WAAL,CAAiBqB,KAAjB,KAA2BnC,gBAAgB,CAACoC,UAAhD,EAA4D;AACxD,UAAInC,eAAJ,CAAoBF,0BAApB,EAAgD,KAAKK,IAArD,EAA2DC,OAA3D;AACH,KAFD,MAGK;AACD,WAAKS,WAAL,CAAiBuB,sBAAjB,CAAwC,MAAM;AAC1C,YAAI,KAAKvB,WAAL,IAAoB,KAAKA,WAAL,CAAiBqB,KAAjB,KAA2BnC,gBAAgB,CAACoC,UAApE,EAAgF;AAC5E,cAAInC,eAAJ,CAAoBF,0BAApB,EAAgD,KAAKK,IAArD,EAA2DC,OAA3D;AACH;AACJ,OAJD,EAIG;AAAEiC,QAAAA,IAAI,EAAE;AAAR,OAJH;AAKH;;AACD,WAAOjC,OAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIkC,EAAAA,mBAAmB,CAAClC,OAAD,EAAUmC,MAAV,EAAkB;AACjC,UAAMC,UAAU,GAAGpC,OAAO,CAACoC,UAA3B;;AACA,QAAI,CAACA,UAAL,EAAiB;AACb,YAAM,IAAIzB,KAAJ,CAAU,iCAAV,CAAN;AACH,KAJgC,CAKjC;AACA;AACA;AACA;AACA;;;AACA,QAAIyB,UAAU,KAAK,GAAf,IAAsBA,UAAU,KAAK,GAAzC,EAA8C;AAC1C,aAAO,IAAP;AACH,KAZgC,CAajC;AACA;;;AACA,QAAIC,SAAJ;AACA,QAAIC,uBAAJ;;AACA,QAAIF,UAAU,KAAK,GAAnB,EAAwB;AACpBC,MAAAA,SAAS,GAAGrC,OAAO,CAACuC,WAAR,CAAoB,kBAApB,CAAZ;AACAD,MAAAA,uBAAuB,GAAG,eAA1B;AACH,KAHD,MAIK;AACDD,MAAAA,SAAS,GAAGrC,OAAO,CAACuC,WAAR,CAAoB,oBAApB,CAAZ;AACAD,MAAAA,uBAAuB,GAAG,qBAA1B;AACH,KAxBgC,CAyBjC;;;AACA,QAAI,CAACD,SAAL,EAAgB;AACZ,WAAKjC,MAAL,CAAYoC,IAAZ,CAAiBJ,UAAU,GAAG,uDAA9B;AACA,aAAO,IAAP;AACH,KA7BgC,CA8BjC;;;AACA,QAAI,KAAKlC,UAAL,KAAoB,KAAKC,KAAL,IAAckC,SAAS,CAAClC,KAAV,KAAoB,IAAtD,CAAJ,EAAiE;AAC7D,WAAKC,MAAL,CAAYoC,IAAZ,CAAiBJ,UAAU,GAAG,yDAA9B;AACA,aAAO,IAAP;AACH,KAlCgC,CAmCjC;;;AACA,QAAI,CAAC,KAAKK,WAAV,EAAuB;AACnB,WAAKA,WAAL,GAAmB,KAAK1C,IAAL,CAAU2C,aAAV,CAAwBC,qBAAxB,EAAnB;;AACA,UAAI,CAAC,KAAKF,WAAV,EAAuB;AACnB,aAAKrC,MAAL,CAAYoC,IAAZ,CAAiB,mDAAjB;AACA,eAAO,IAAP;AACH;AACJ,KA1CgC,CA2CjC;;;AACA,QAAI,CAAC,KAAKC,WAAL,CAAiBG,YAAjB,CAA8B,KAAK5C,OAAnC,EAA4CqC,SAA5C,CAAL,EAA6D;AACzD,aAAO,IAAP;AACH;;AACD,SAAKnC,UAAL,GAAkB,IAAlB;;AACA,QAAImC,SAAS,CAAClC,KAAd,EAAqB;AACjB,WAAKA,KAAL,GAAa,IAAb;AACH,KAlDgC,CAmDjC;;;AACA,QAAIqB,IAAI,GAAI,KAAKxB,OAAL,CAAawB,IAAb,IAAqB,CAAjC,CApDiC,CAqDjC;;AACA,QAAIW,MAAM,IAAIA,MAAM,CAACU,mBAArB,EAA0C;AACtCV,MAAAA,MAAM,CAACW,4BAAP;AACAtB,MAAAA,IAAI,GAAG,KAAKxB,OAAL,CAAawB,IAAb,GAAoBW,MAAM,CAACU,mBAAlC;AACH;;AACD,SAAK7C,OAAL,CAAa6B,SAAb,CAAuB,MAAvB,EAA+BL,IAAI,GAAG,GAAP,GAAa,KAAKxB,OAAL,CAAa+C,MAAzD;AACA,SAAK/C,OAAL,CAAa6B,SAAb,CAAuBS,uBAAvB,EAAgD,KAAKG,WAAL,CAAiBO,QAAjB,EAAhD,EA3DiC,CA4DjC;AACA;AACA;AACA;;AACA,SAAKzC,IAAL;AACA,WAAO,KAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI0C,EAAAA,gBAAgB,GAAG;AACf,SAAK7C,MAAL,CAAYoC,IAAZ,CAAiB,+EAAjB;AACA,UAAMxC,OAAO,GAAG,IAAIP,uBAAJ,EAAhB;AACAO,IAAAA,OAAO,CAACoC,UAAR,GAAqB,GAArB;AACApC,IAAAA,OAAO,CAACkD,YAAR,GAAuB,iBAAvB;AACA,SAAKC,eAAL,CAAqBnD,OAArB;AACA;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIoD,EAAAA,gBAAgB,CAACC,KAAD,EAAQ;AACpB,SAAKjD,MAAL,CAAYiD,KAAZ,CAAkBA,KAAK,CAACrD,OAAxB;AACA,SAAKI,MAAL,CAAYiD,KAAZ,CAAkB,yFAAlB;AACA,UAAMrD,OAAO,GAAG,IAAIP,uBAAJ,EAAhB;AACAO,IAAAA,OAAO,CAACoC,UAAR,GAAqB,GAArB;AACApC,IAAAA,OAAO,CAACkD,YAAR,GAAuB,qBAAvB;AACA,SAAKC,eAAL,CAAqBnD,OAArB;AACH;AACD;AACJ;AACA;AACA;;;AACImD,EAAAA,eAAe,CAACnD,OAAD,EAAU;AACrB,QAAI,CAAC,KAAKkC,mBAAL,CAAyBlC,OAAzB,CAAL,EAAwC;AACpC;AACH;;AACD,UAAMoC,UAAU,GAAGpC,OAAO,CAACoC,UAAR,GAAqBpC,OAAO,CAACoC,UAAR,CAAmBY,QAAnB,EAArB,GAAqD,EAAxE;;AACA,QAAI,CAACZ,UAAL,EAAiB;AACb,YAAM,IAAIzB,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,YAAQ,IAAR;AACI,WAAK,QAAQ2C,IAAR,CAAalB,UAAb,CAAL;AACI,YAAI,KAAKnC,QAAL,IAAiB,KAAKA,QAAL,CAAcsD,QAAnC,EAA6C;AACzC,eAAKtD,QAAL,CAAcsD,QAAd,CAAuB;AAAEvD,YAAAA;AAAF,WAAvB;AACH;;AACD;;AACJ,WAAK,cAAcsD,IAAd,CAAmBlB,UAAnB,CAAL;AACI,YAAI,KAAKnC,QAAL,IAAiB,KAAKA,QAAL,CAAcuD,UAAnC,EAA+C;AAC3C,eAAKvD,QAAL,CAAcuD,UAAd,CAAyB;AAAExD,YAAAA;AAAF,WAAzB;AACH;;AACD;;AACJ,WAAK,cAAcsD,IAAd,CAAmBlB,UAAnB,CAAL;AACI,YAAI,KAAKnC,QAAL,IAAiB,KAAKA,QAAL,CAAcwD,QAAnC,EAA6C;AACzC,eAAKxD,QAAL,CAAcwD,QAAd,CAAuB;AAAEzD,YAAAA;AAAF,WAAvB;AACH;;AACD;;AACJ,WAAK,cAAcsD,IAAd,CAAmBlB,UAAnB,CAAL;AACI,YAAI,KAAKnC,QAAL,IAAiB,KAAKA,QAAL,CAAcyD,UAAnC,EAA+C;AAC3C,eAAKzD,QAAL,CAAcyD,UAAd,CAAyB;AAAE1D,YAAAA;AAAF,WAAzB;AACH;;AACD;;AACJ,WAAK,kBAAkBsD,IAAlB,CAAuBlB,UAAvB,CAAL;AACI,YAAI,KAAKnC,QAAL,IAAiB,KAAKA,QAAL,CAAc0D,QAAnC,EAA6C;AACzC,eAAK1D,QAAL,CAAc0D,QAAd,CAAuB;AAAE3D,YAAAA;AAAF,WAAvB;AACH;;AACD;;AACJ;AACI,cAAM,IAAIW,KAAJ,CAAW,uBAAsByB,UAAW,EAA5C,CAAN;AA3BR;AA6BH;;AACD7B,EAAAA,IAAI,GAAG;AACH;AACA,UAAMqD,IAAI,GAAG;AACTvD,MAAAA,aAAa,EAAE,KAAKA,aADX;AAET4C,MAAAA,gBAAgB,EAAE,MAAM,KAAKA,gBAAL,EAFf;AAGTY,MAAAA,aAAa,EAAGC,QAAD,IAAc;AACzB,YAAIA,QAAQ,KAAKnE,gBAAgB,CAACoE,UAAlC,EAA8C;AAC1C;AACA;AACA,eAAKhE,IAAL,CAAUiE,gBAAV,CAA2BC,MAA3B,CAAkCC,iBAAlC,EAH0C,CAI1C;AACA;AACA;AACA;;AACA,cAAIzD,WAAW,KAAK,KAAKC,YAAzB,EAAuC;AACnC,iBAAKF,OAAL;AACH;AACJ;AACJ,OAhBQ;AAiBT4C,MAAAA,gBAAgB,EAAGC,KAAD,IAAW,KAAKD,gBAAL,CAAsBC,KAAtB,CAjBpB;AAkBTF,MAAAA,eAAe,EAAGnD,OAAD,IAAa,KAAKmD,eAAL,CAAqBnD,OAArB;AAlBrB,KAAb,CAFG,CAsBH;;AACA,UAAMS,WAAW,GAAG,IAAI,KAAKX,sBAAT,CAAgC,KAAKE,OAArC,EAA8C,KAAKD,IAAL,CAAUoE,SAAxD,EAAmEP,IAAnE,CAApB;AACA,SAAKlD,YAAL,GAAoBD,WAApB,CAxBG,CAyBH;;AACA,UAAMyD,iBAAiB,GAAGzD,WAAW,CAAC2D,EAAZ,GAAiB3D,WAAW,CAAC4D,OAAZ,CAAoBtB,MAA/D;AACA,SAAKhD,IAAL,CAAUiE,gBAAV,CAA2BM,GAA3B,CAA+BJ,iBAA/B,EAAkD,IAAlD;AACH;;AAnSwB","sourcesContent":["import { C, IncomingResponseMessage } from \"../messages\";\nimport { NonInviteClientTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Client (UAC).\n * @remarks\n * A user agent client is a logical entity\n * that creates a new request, and then uses the client\n * transaction state machinery to send it.  The role of UAC lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software initiates a request, it acts as a UAC for\n * the duration of that transaction.  If it receives a request\n * later, it assumes the role of a user agent server for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\nexport class UserAgentClient {\n    constructor(transactionConstructor, core, message, delegate) {\n        this.transactionConstructor = transactionConstructor;\n        this.core = core;\n        this.message = message;\n        this.delegate = delegate;\n        this.challenged = false;\n        this.stale = false;\n        this.logger = this.loggerFactory.getLogger(\"sip.user-agent-client\");\n        this.init();\n    }\n    dispose() {\n        this.transaction.dispose();\n    }\n    get loggerFactory() {\n        return this.core.loggerFactory;\n    }\n    /** The transaction associated with this request. */\n    get transaction() {\n        if (!this._transaction) {\n            throw new Error(\"Transaction undefined.\");\n        }\n        return this._transaction;\n    }\n    /**\n     * Since requests other than INVITE are responded to immediately, sending a\n     * CANCEL for a non-INVITE request would always create a race condition.\n     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-9.1\n     * @param options - Cancel options bucket.\n     */\n    cancel(reason, options = {}) {\n        if (!this.transaction) {\n            throw new Error(\"Transaction undefined.\");\n        }\n        if (!this.message.to) {\n            throw new Error(\"To undefined.\");\n        }\n        if (!this.message.from) {\n            throw new Error(\"From undefined.\");\n        }\n        // The following procedures are used to construct a CANCEL request.  The\n        // Request-URI, Call-ID, To, the numeric part of CSeq, and From header\n        // fields in the CANCEL request MUST be identical to those in the\n        // request being cancelled, including tags.  A CANCEL constructed by a\n        // client MUST have only a single Via header field value matching the\n        // top Via value in the request being cancelled.  Using the same values\n        // for these header fields allows the CANCEL to be matched with the\n        // request it cancels (Section 9.2 indicates how such matching occurs).\n        // However, the method part of the CSeq header field MUST have a value\n        // of CANCEL.  This allows it to be identified and processed as a\n        // transaction in its own right (See Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-9.1\n        const message = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {\n            toTag: this.message.toTag,\n            fromTag: this.message.fromTag,\n            callId: this.message.callId,\n            cseq: this.message.cseq\n        }, options.extraHeaders);\n        // TODO: Revisit this.\n        // The CANCEL needs to use the same branch parameter so that\n        // it matches the INVITE transaction, but this is a hacky way to do this.\n        // Or at the very least not well documented. If the the branch parameter\n        // is set on the outgoing request, the transaction will use it.\n        // Otherwise the transaction will make a new one.\n        message.branch = this.message.branch;\n        if (this.message.headers.Route) {\n            message.headers.Route = this.message.headers.Route;\n        }\n        if (reason) {\n            message.setHeader(\"Reason\", reason);\n        }\n        // If no provisional response has been received, the CANCEL request MUST\n        // NOT be sent; rather, the client MUST wait for the arrival of a\n        // provisional response before sending the request. If the original\n        // request has generated a final response, the CANCEL SHOULD NOT be\n        // sent, as it is an effective no-op, since CANCEL has no effect on\n        // requests that have already generated a final response.\n        // https://tools.ietf.org/html/rfc3261#section-9.1\n        if (this.transaction.state === TransactionState.Proceeding) {\n            new UserAgentClient(NonInviteClientTransaction, this.core, message);\n        }\n        else {\n            this.transaction.addStateChangeListener(() => {\n                if (this.transaction && this.transaction.state === TransactionState.Proceeding) {\n                    new UserAgentClient(NonInviteClientTransaction, this.core, message);\n                }\n            }, { once: true });\n        }\n        return message;\n    }\n    /**\n     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n     * response is received, the UAC SHOULD follow the authorization\n     * procedures of Section 22.2 and Section 22.3 to retry the request with\n     * credentials.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n     * 22 Usage of HTTP Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22\n     * 22.1 Framework\n     * https://tools.ietf.org/html/rfc3261#section-22.1\n     * 22.2 User-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.2\n     * 22.3 Proxy-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.3\n     *\n     * FIXME: This \"guard for and retry the request with credentials\"\n     * implementation is not complete and at best minimally passable.\n     * @param response - The incoming response to guard.\n     * @param dialog - If defined, the dialog within which the response was received.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise the request is retried with credentials and current request processing must stop.\n     */\n    authenticationGuard(message, dialog) {\n        const statusCode = message.statusCode;\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n        // response is received, the UAC SHOULD follow the authorization\n        // procedures of Section 22.2 and Section 22.3 to retry the request with\n        // credentials.\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n        if (statusCode !== 401 && statusCode !== 407) {\n            return true;\n        }\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let challenge;\n        let authorizationHeaderName;\n        if (statusCode === 401) {\n            challenge = message.parseHeader(\"www-authenticate\");\n            authorizationHeaderName = \"authorization\";\n        }\n        else {\n            challenge = message.parseHeader(\"proxy-authenticate\");\n            authorizationHeaderName = \"proxy-authorization\";\n        }\n        // Verify it seems a valid challenge.\n        if (!challenge) {\n            this.logger.warn(statusCode + \" with wrong or missing challenge, cannot authenticate\");\n            return true;\n        }\n        // Avoid infinite authentications.\n        if (this.challenged && (this.stale || challenge.stale !== true)) {\n            this.logger.warn(statusCode + \" apparently in authentication loop, cannot authenticate\");\n            return true;\n        }\n        // Get credentials.\n        if (!this.credentials) {\n            this.credentials = this.core.configuration.authenticationFactory();\n            if (!this.credentials) {\n                this.logger.warn(\"Unable to obtain credentials, cannot authenticate\");\n                return true;\n            }\n        }\n        // Verify that the challenge is really valid.\n        if (!this.credentials.authenticate(this.message, challenge)) {\n            return true;\n        }\n        this.challenged = true;\n        if (challenge.stale) {\n            this.stale = true;\n        }\n        // If response to out of dialog request, assume incrementing the CSeq will suffice.\n        let cseq = (this.message.cseq += 1);\n        // If response to in dialog request, get a valid next CSeq number.\n        if (dialog && dialog.localSequenceNumber) {\n            dialog.incrementLocalSequenceNumber();\n            cseq = this.message.cseq = dialog.localSequenceNumber;\n        }\n        this.message.setHeader(\"cseq\", cseq + \" \" + this.message.method);\n        this.message.setHeader(authorizationHeaderName, this.credentials.toString());\n        // Calling init (again) will swap out our existing client transaction with a new one.\n        // FIXME: HACK: An assumption is being made here that there is nothing that needs to\n        // be cleaned up beyond the client transaction which is being replaced. For example,\n        // it is assumed that no early dialogs have been created.\n        this.init();\n        return false;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     */\n    onRequestTimeout() {\n        this.logger.warn(\"User agent client request timed out. Generating internal 408 Request Timeout.\");\n        const message = new IncomingResponseMessage();\n        message.statusCode = 408;\n        message.reasonPhrase = \"Request Timeout\";\n        this.receiveResponse(message);\n        return;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     * @param error - Transport error\n     */\n    onTransportError(error) {\n        this.logger.error(error.message);\n        this.logger.error(\"User agent client request transport error. Generating internal 503 Service Unavailable.\");\n        const message = new IncomingResponseMessage();\n        message.statusCode = 503;\n        message.reasonPhrase = \"Service Unavailable\";\n        this.receiveResponse(message);\n    }\n    /**\n     * Receive a response from the transaction layer.\n     * @param message - Incoming response message.\n     */\n    receiveResponse(message) {\n        if (!this.authenticationGuard(message)) {\n            return;\n        }\n        const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        switch (true) {\n            case /^100$/.test(statusCode):\n                if (this.delegate && this.delegate.onTrying) {\n                    this.delegate.onTrying({ message });\n                }\n                break;\n            case /^1[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onProgress) {\n                    this.delegate.onProgress({ message });\n                }\n                break;\n            case /^2[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onAccept) {\n                    this.delegate.onAccept({ message });\n                }\n                break;\n            case /^3[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onRedirect) {\n                    this.delegate.onRedirect({ message });\n                }\n                break;\n            case /^[4-6][0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onReject) {\n                    this.delegate.onReject({ message });\n                }\n                break;\n            default:\n                throw new Error(`Invalid status code ${statusCode}`);\n        }\n    }\n    init() {\n        // We are the transaction user.\n        const user = {\n            loggerFactory: this.loggerFactory,\n            onRequestTimeout: () => this.onRequestTimeout(),\n            onStateChange: (newState) => {\n                if (newState === TransactionState.Terminated) {\n                    // Remove the terminated transaction from the core.\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    this.core.userAgentClients.delete(userAgentClientId);\n                    // FIXME: HACK: Our transaction may have been swapped out with a new one\n                    // post authentication (see above), so make sure to only to dispose of\n                    // ourselves if this terminating transaction is our current transaction.\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    if (transaction === this._transaction) {\n                        this.dispose();\n                    }\n                }\n            },\n            onTransportError: (error) => this.onTransportError(error),\n            receiveResponse: (message) => this.receiveResponse(message)\n        };\n        // Create a new transaction with us as the user.\n        const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n        this._transaction = transaction;\n        // Add the new transaction to the core.\n        const userAgentClientId = transaction.id + transaction.request.method;\n        this.core.userAgentClients.set(userAgentClientId, this);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}