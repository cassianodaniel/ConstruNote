{"ast":null,"code":"/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport class SessionDescriptionHandler {\n  /**\n   * Constructor\n   * @param logger - A logger\n   * @param mediaStreamFactory - A factory to provide a MediaStream\n   * @param options - Options passed from the SessionDescriptionHandleFactory\n   */\n  constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n    logger.debug(\"SessionDescriptionHandler.constructor\");\n    this.logger = logger;\n    this.mediaStreamFactory = mediaStreamFactory;\n    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n    this._localMediaStream = new MediaStream();\n    this._remoteMediaStream = new MediaStream();\n    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);\n    this.initPeerConnectionEventHandlers();\n  }\n  /**\n   * The local media stream currently being sent.\n   *\n   * @remarks\n   * The local media stream initially has no tracks, so the presence of tracks\n   * should not be assumed. Furthermore, tracks may be added or removed if the\n   * local media changes - for example, on upgrade from audio only to a video session.\n   * At any given time there will be at most one audio track and one video track\n   * (it's possible that this restriction may not apply to sub-classes).\n   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n   * to detect when a new track becomes available:\n   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n   */\n\n\n  get localMediaStream() {\n    return this._localMediaStream;\n  }\n  /**\n   * The remote media stream currently being received.\n   *\n   * @remarks\n   * The remote media stream initially has no tracks, so the presence of tracks\n   * should not be assumed. Furthermore, tracks may be added or removed if the\n   * remote media changes - for example, on upgrade from audio only to a video session.\n   * At any given time there will be at most one audio track and one video track\n   * (it's possible that this restriction may not apply to sub-classes).\n   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n   * to detect when a new track becomes available:\n   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n   */\n\n\n  get remoteMediaStream() {\n    return this._remoteMediaStream;\n  }\n  /**\n   * The data channel. Undefined before it is created.\n   */\n\n\n  get dataChannel() {\n    return this._dataChannel;\n  }\n  /**\n   * The peer connection. Undefined if peer connection has closed.\n   *\n   * @remarks\n   * While access to the underlying `RTCPeerConnection` is provided, note that\n   * using methods with modify it may break the operation of this class.\n   * In particular, this class depends on exclusive access to the\n   * event handler properties. If you need access to the peer connection\n   * events, either register for events using `addEventListener()` on\n   * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n   * this `SessionDescriptionHandler`.\n   */\n\n\n  get peerConnection() {\n    return this._peerConnection;\n  }\n  /**\n   * A delegate which provides access to the peer connection event handlers.\n   *\n   * @remarks\n   * Setting the peer connection event handlers directly is not supported\n   * and may break this class. As this class depends on exclusive access\n   * to them, a delegate may be set which provides alternative access to\n   * the event handlers in a fashion which is supported.\n   */\n\n\n  get peerConnectionDelegate() {\n    return this._peerConnectionDelegate;\n  }\n\n  set peerConnectionDelegate(delegate) {\n    this._peerConnectionDelegate = delegate;\n  } // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n\n\n  static dispatchAddTrackEvent(stream, track) {\n    stream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", {\n      track\n    }));\n  } // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n\n\n  static dispatchRemoveTrackEvent(stream, track) {\n    stream.dispatchEvent(new MediaStreamTrackEvent(\"removetrack\", {\n      track\n    }));\n  }\n  /**\n   * Stop tracks and close peer connection.\n   */\n\n\n  close() {\n    this.logger.debug(\"SessionDescriptionHandler.close\");\n\n    if (this._peerConnection === undefined) {\n      return;\n    }\n\n    this._peerConnection.getReceivers().forEach(receiver => {\n      receiver.track && receiver.track.stop();\n    });\n\n    this._peerConnection.getSenders().forEach(sender => {\n      sender.track && sender.track.stop();\n    });\n\n    if (this._dataChannel) {\n      this._dataChannel.close();\n    }\n\n    this._peerConnection.close();\n\n    this._peerConnection = undefined;\n  }\n  /**\n   * Creates an offer or answer.\n   * @param options - Options bucket.\n   * @param modifiers - Modifiers.\n   */\n\n\n  getDescription(options, modifiers) {\n    var _a, _b;\n\n    this.logger.debug(\"SessionDescriptionHandler.getDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // Callback on data channel creation\n\n\n    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // ICE will restart upon applying an offer created with the iceRestart option\n\n    const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart; // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n\n    const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;\n    return this.getLocalMediaStream(options).then(() => this.createDataChannel(options)).then(() => this.createLocalOfferOrAnswer(options)).then(sessionDescription => this.applyModifiers(sessionDescription, modifiers)).then(sessionDescription => this.setLocalSessionDescription(sessionDescription)).then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout)).then(() => this.getLocalSessionDescription()).then(sessionDescription => {\n      return {\n        body: sessionDescription.sdp,\n        contentType: \"application/sdp\"\n      };\n    }).catch(error => {\n      this.logger.error(\"SessionDescriptionHandler.getDescription failed - \" + error);\n      throw error;\n    });\n  }\n  /**\n   * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n   * @param contentType - The content type that is in the SIP Message.\n   */\n\n\n  hasDescription(contentType) {\n    this.logger.debug(\"SessionDescriptionHandler.hasDescription\");\n    return contentType === \"application/sdp\";\n  }\n  /**\n   * Send DTMF via RTP (RFC 4733).\n   * Returns true if DTMF send is successful, false otherwise.\n   * @param tones - A string containing DTMF digits.\n   * @param options - Options object to be used by sendDtmf.\n   */\n\n\n  sendDtmf(tones, options) {\n    this.logger.debug(\"SessionDescriptionHandler.sendDtmf\");\n\n    if (this._peerConnection === undefined) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - peer connection closed\");\n      return false;\n    }\n\n    const senders = this._peerConnection.getSenders();\n\n    if (senders.length === 0) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no senders\");\n      return false;\n    }\n\n    const dtmfSender = senders[0].dtmf;\n\n    if (!dtmfSender) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no DTMF sender\");\n      return false;\n    }\n\n    const duration = options === null || options === void 0 ? void 0 : options.duration;\n    const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;\n\n    try {\n      dtmfSender.insertDTMF(tones, duration, interToneGap);\n    } catch (e) {\n      this.logger.error(e);\n      return false;\n    }\n\n    this.logger.log(\"SessionDescriptionHandler.sendDtmf sent via RTP: \" + tones.toString());\n    return true;\n  }\n  /**\n   * Sets an offer or answer.\n   * @param sdp - The session description.\n   * @param options - Options bucket.\n   * @param modifiers - Modifiers.\n   */\n\n\n  setDescription(sdp, options, modifiers) {\n    this.logger.debug(\"SessionDescriptionHandler.setDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // Callback on data channel creation\n\n\n    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // SDP type\n\n    const type = this._peerConnection.signalingState === \"have-local-offer\" ? \"answer\" : \"offer\";\n    return this.getLocalMediaStream(options).then(() => this.applyModifiers({\n      sdp,\n      type\n    }, modifiers)).then(sessionDescription => this.setRemoteSessionDescription(sessionDescription)).catch(error => {\n      this.logger.error(\"SessionDescriptionHandler.setDescription failed - \" + error);\n      throw error;\n    });\n  }\n  /**\n   * Applies modifiers to SDP prior to setting the local or remote description.\n   * @param sdp - SDP to modify.\n   * @param modifiers - Modifiers to apply.\n   */\n\n\n  applyModifiers(sdp, modifiers) {\n    this.logger.debug(\"SessionDescriptionHandler.applyModifiers\");\n\n    if (!modifiers || modifiers.length === 0) {\n      return Promise.resolve(sdp);\n    }\n\n    return modifiers.reduce((cur, next) => cur.then(next), Promise.resolve(sdp)).then(modified => {\n      this.logger.debug(\"SessionDescriptionHandler.applyModifiers - modified sdp\");\n\n      if (!modified.sdp || !modified.type) {\n        throw new Error(\"Invalid SDP.\");\n      }\n\n      return {\n        sdp: modified.sdp,\n        type: modified.type\n      };\n    });\n  }\n  /**\n   * Create a data channel.\n   * @remarks\n   * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n   * Only creates a data channel if creating a local offer.\n   * Only if one does not already exist.\n   * @param options - Session description handler options.\n   */\n\n\n  createDataChannel(options) {\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // only create a data channel if requested\n\n\n    if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {\n      return Promise.resolve();\n    } // do not create a data channel if we already have one\n\n\n    if (this._dataChannel) {\n      return Promise.resolve();\n    }\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable, assume we are creating a local offer so create a data channel\n        this.logger.debug(\"SessionDescriptionHandler.createDataChannel - creating data channel\");\n\n        try {\n          this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || \"\", options === null || options === void 0 ? void 0 : options.dataChannelOptions);\n\n          if (this.onDataChannel) {\n            this.onDataChannel(this._dataChannel);\n          }\n\n          return Promise.resolve();\n        } catch (error) {\n          return Promise.reject(error);\n        }\n\n      case \"have-remote-offer\":\n        return Promise.resolve();\n\n      case \"have-local-offer\":\n      case \"have-local-pranswer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n  }\n  /**\n   * Depending on current signaling state, create a local offer or answer.\n   * @param options - Session description handler options.\n   */\n\n\n  createLocalOfferOrAnswer(options) {\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable, assume we are creating a local offer\n        this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer\");\n        return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);\n\n      case \"have-remote-offer\":\n        // if we have a remote offer, assume we are creating a local answer\n        this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer\");\n        return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);\n\n      case \"have-local-offer\":\n      case \"have-local-pranswer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n  }\n  /**\n   * Get a media stream from the media stream factory and set the local media stream.\n   * @param options - Session description handler options.\n   */\n\n\n  getLocalMediaStream(options) {\n    this.logger.debug(\"SessionDescriptionHandler.getLocalMediaStream\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints); // if we already have a local media stream...\n\n    if (this.localMediaStreamConstraints) {\n      // ignore constraint \"downgrades\"\n      constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n      constraints.video = constraints.video || this.localMediaStreamConstraints.video; // if constraints have not changed, do not get a new media stream\n\n      if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n        return Promise.resolve();\n      }\n    } else {\n      // if no constraints have been specified, default to audio for initial media stream\n      if (constraints.audio === undefined && constraints.video === undefined) {\n        constraints = {\n          audio: true\n        };\n      }\n    }\n\n    this.localMediaStreamConstraints = constraints;\n    return this.mediaStreamFactory(constraints, this).then(mediaStream => this.setLocalMediaStream(mediaStream));\n  }\n  /**\n   * Sets the peer connection's sender tracks and local media stream tracks.\n   *\n   * @remarks\n   * Only the first audio and video tracks of the provided MediaStream are utilized.\n   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n   *\n   * @param stream - Media stream containing tracks to be utilized.\n   */\n\n\n  setLocalMediaStream(stream) {\n    this.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream\");\n\n    if (!this._peerConnection) {\n      throw new Error(\"Peer connection undefined.\");\n    }\n\n    const pc = this._peerConnection;\n    const localStream = this._localMediaStream;\n    const trackUpdates = [];\n\n    const updateTrack = newTrack => {\n      const kind = newTrack.kind;\n\n      if (kind !== \"audio\" && kind !== \"video\") {\n        throw new Error(`Unknown new track kind ${kind}.`);\n      }\n\n      const sender = pc.getSenders().find(sender => sender.track && sender.track.kind === kind);\n\n      if (sender) {\n        trackUpdates.push(new Promise(resolve => {\n          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);\n          resolve();\n        }).then(() => sender.replaceTrack(newTrack).then(() => {\n          const oldTrack = localStream.getTracks().find(localTrack => localTrack.kind === kind);\n\n          if (oldTrack) {\n            oldTrack.stop();\n            localStream.removeTrack(oldTrack);\n            SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n          }\n\n          localStream.addTrack(newTrack);\n          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n        }).catch(error => {\n          this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);\n          throw error;\n        })));\n      } else {\n        trackUpdates.push(new Promise(resolve => {\n          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);\n          resolve();\n        }).then(() => {\n          // Review: could make streamless tracks a configurable option?\n          // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n          try {\n            pc.addTrack(newTrack, localStream);\n          } catch (error) {\n            this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);\n            throw error;\n          }\n\n          localStream.addTrack(newTrack);\n          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n        }));\n      }\n    }; // update peer connection audio tracks\n\n\n    const audioTracks = stream.getAudioTracks();\n\n    if (audioTracks.length) {\n      updateTrack(audioTracks[0]);\n    } // update peer connection video tracks\n\n\n    const videoTracks = stream.getVideoTracks();\n\n    if (videoTracks.length) {\n      updateTrack(videoTracks[0]);\n    }\n\n    return trackUpdates.reduce((p, x) => p.then(() => x), Promise.resolve());\n  }\n  /**\n   * Gets the peer connection's local session description.\n   */\n\n\n  getLocalSessionDescription() {\n    this.logger.debug(\"SessionDescriptionHandler.getLocalSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    const sdp = this._peerConnection.localDescription;\n\n    if (!sdp) {\n      return Promise.reject(new Error(\"Failed to get local session description\"));\n    }\n\n    return Promise.resolve(sdp);\n  }\n  /**\n   * Sets the peer connection's local session description.\n   * @param sessionDescription - sessionDescription The session description.\n   */\n\n\n  setLocalSessionDescription(sessionDescription) {\n    this.logger.debug(\"SessionDescriptionHandler.setLocalSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    return this._peerConnection.setLocalDescription(sessionDescription);\n  }\n  /**\n   * Sets the peer connection's remote session description.\n   * @param sessionDescription - The session description.\n   */\n\n\n  setRemoteSessionDescription(sessionDescription) {\n    this.logger.debug(\"SessionDescriptionHandler.setRemoteSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    const sdp = sessionDescription.sdp;\n    let type;\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable assume this is a remote offer\n        type = \"offer\";\n        break;\n\n      case \"have-local-offer\":\n        // if we made an offer, assume this is a remote answer\n        type = \"answer\";\n        break;\n\n      case \"have-local-pranswer\":\n      case \"have-remote-offer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n\n    if (!sdp) {\n      this.logger.error(\"SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp\");\n      return Promise.reject(new Error(\"SDP is undefined\"));\n    }\n\n    return this._peerConnection.setRemoteDescription({\n      sdp,\n      type\n    });\n  }\n  /**\n   * Sets a remote media stream track.\n   *\n   * @remarks\n   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n   *\n   * @param track - Media stream track to be utilized.\n   */\n\n\n  setRemoteTrack(track) {\n    this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack\");\n    const remoteStream = this._remoteMediaStream;\n\n    if (remoteStream.getTrackById(track.id)) {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);\n    } else if (track.kind === \"audio\") {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n      remoteStream.getAudioTracks().forEach(track => {\n        track.stop();\n        remoteStream.removeTrack(track);\n        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n      });\n      remoteStream.addTrack(track);\n      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n    } else if (track.kind === \"video\") {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n      remoteStream.getVideoTracks().forEach(track => {\n        track.stop();\n        remoteStream.removeTrack(track);\n        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n      });\n      remoteStream.addTrack(track);\n      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n    }\n  }\n  /**\n   * Called when ICE gathering completes and resolves any waiting promise.\n   */\n\n\n  iceGatheringComplete() {\n    this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete\"); // clear timer if need be\n\n    if (this.iceGatheringCompleteTimeoutId !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - clearing timeout\");\n      clearTimeout(this.iceGatheringCompleteTimeoutId);\n      this.iceGatheringCompleteTimeoutId = undefined;\n    } // resolve and cleanup promise if need be\n\n\n    if (this.iceGatheringCompletePromise !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - resolving promise\");\n      this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();\n      this.iceGatheringCompletePromise = undefined;\n      this.iceGatheringCompleteResolve = undefined;\n      this.iceGatheringCompleteReject = undefined;\n    }\n  }\n  /**\n   * Wait for ICE gathering to complete.\n   * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n   * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n   */\n\n\n  waitForIceGatheringComplete(restart = false, timeout = 0) {\n    this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(\"Peer connection closed.\");\n    } // guard already complete\n\n\n    if (!restart && this._peerConnection.iceGatheringState === \"complete\") {\n      this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - already complete\");\n      return Promise.resolve();\n    } // only one may be waiting, reject any prior\n\n\n    if (this.iceGatheringCompletePromise !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise\");\n      this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error(\"Promise superseded.\"));\n      this.iceGatheringCompletePromise = undefined;\n      this.iceGatheringCompleteResolve = undefined;\n      this.iceGatheringCompleteReject = undefined;\n    }\n\n    this.iceGatheringCompletePromise = new Promise((resolve, reject) => {\n      this.iceGatheringCompleteResolve = resolve;\n      this.iceGatheringCompleteReject = reject;\n\n      if (timeout > 0) {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in \" + timeout);\n        this.iceGatheringCompleteTimeoutId = setTimeout(() => {\n          this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout\");\n          this.iceGatheringComplete();\n        }, timeout);\n      }\n    });\n    return this.iceGatheringCompletePromise;\n  }\n  /**\n   * Initializes the peer connection event handlers\n   */\n\n\n  initPeerConnectionEventHandlers() {\n    this.logger.debug(\"SessionDescriptionHandler.initPeerConnectionEventHandlers\");\n    if (!this._peerConnection) throw new Error(\"Peer connection undefined.\");\n    const peerConnection = this._peerConnection;\n\n    peerConnection.onconnectionstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.connectionState;\n      this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {\n        this._peerConnectionDelegate.onconnectionstatechange(event);\n      }\n    };\n\n    peerConnection.ondatachannel = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.ondatachannel`);\n      this._dataChannel = event.channel;\n\n      if (this.onDataChannel) {\n        this.onDataChannel(this._dataChannel);\n      }\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {\n        this._peerConnectionDelegate.ondatachannel(event);\n      }\n    };\n\n    peerConnection.onicecandidate = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onicecandidate`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {\n        this._peerConnectionDelegate.onicecandidate(event);\n      }\n    };\n\n    peerConnection.onicecandidateerror = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {\n        this._peerConnectionDelegate.onicecandidateerror(event);\n      }\n    };\n\n    peerConnection.oniceconnectionstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.iceConnectionState;\n      this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {\n        this._peerConnectionDelegate.oniceconnectionstatechange(event);\n      }\n    };\n\n    peerConnection.onicegatheringstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.iceGatheringState;\n      this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);\n\n      if (newState === \"complete\") {\n        this.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n      }\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {\n        this._peerConnectionDelegate.onicegatheringstatechange(event);\n      }\n    };\n\n    peerConnection.onnegotiationneeded = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {\n        this._peerConnectionDelegate.onnegotiationneeded(event);\n      }\n    };\n\n    peerConnection.onsignalingstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.signalingState;\n      this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {\n        this._peerConnectionDelegate.onsignalingstatechange(event);\n      }\n    };\n\n    peerConnection.onstatsended = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onstatsended`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {\n        this._peerConnectionDelegate.onstatsended(event);\n      }\n    };\n\n    peerConnection.ontrack = event => {\n      var _a;\n\n      const kind = event.track.kind;\n      const enabled = event.track.enabled ? \"enabled\" : \"disabled\";\n      this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);\n      this.setRemoteTrack(event.track);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {\n        this._peerConnectionDelegate.ontrack(event);\n      }\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/session-description-handler/session-description-handler.js"],"names":["SessionDescriptionHandler","constructor","logger","mediaStreamFactory","sessionDescriptionHandlerConfiguration","debug","_localMediaStream","MediaStream","_remoteMediaStream","_peerConnection","RTCPeerConnection","peerConnectionConfiguration","initPeerConnectionEventHandlers","localMediaStream","remoteMediaStream","dataChannel","_dataChannel","peerConnection","peerConnectionDelegate","_peerConnectionDelegate","delegate","dispatchAddTrackEvent","stream","track","dispatchEvent","MediaStreamTrackEvent","dispatchRemoveTrackEvent","close","undefined","getReceivers","forEach","receiver","stop","getSenders","sender","getDescription","options","modifiers","_a","_b","Promise","reject","Error","onDataChannel","iceRestart","offerOptions","iceTimeout","iceGatheringTimeout","getLocalMediaStream","then","createDataChannel","createLocalOfferOrAnswer","sessionDescription","applyModifiers","setLocalSessionDescription","waitForIceGatheringComplete","getLocalSessionDescription","body","sdp","contentType","catch","error","hasDescription","sendDtmf","tones","senders","length","dtmfSender","dtmf","duration","interToneGap","insertDTMF","e","log","toString","setDescription","type","signalingState","setRemoteSessionDescription","resolve","reduce","cur","next","modified","dataChannelLabel","dataChannelOptions","createOffer","createAnswer","answerOptions","constraints","Object","assign","localMediaStreamConstraints","audio","video","JSON","stringify","mediaStream","setLocalMediaStream","pc","localStream","trackUpdates","updateTrack","newTrack","kind","find","push","replaceTrack","oldTrack","getTracks","localTrack","removeTrack","addTrack","audioTracks","getAudioTracks","videoTracks","getVideoTracks","p","x","localDescription","setLocalDescription","setRemoteDescription","setRemoteTrack","remoteStream","getTrackById","id","iceGatheringComplete","iceGatheringCompleteTimeoutId","clearTimeout","iceGatheringCompletePromise","iceGatheringCompleteResolve","iceGatheringCompleteReject","restart","timeout","iceGatheringState","setTimeout","onconnectionstatechange","event","newState","connectionState","ondatachannel","channel","onicecandidate","onicecandidateerror","oniceconnectionstatechange","iceConnectionState","onicegatheringstatechange","onnegotiationneeded","onsignalingstatechange","onstatsended","ontrack","enabled"],"mappings":"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","sourcesContent":["/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport class SessionDescriptionHandler {\n    /**\n     * Constructor\n     * @param logger - A logger\n     * @param mediaStreamFactory - A factory to provide a MediaStream\n     * @param options - Options passed from the SessionDescriptionHandleFactory\n     */\n    constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n        logger.debug(\"SessionDescriptionHandler.constructor\");\n        this.logger = logger;\n        this.mediaStreamFactory = mediaStreamFactory;\n        this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n        this._localMediaStream = new MediaStream();\n        this._remoteMediaStream = new MediaStream();\n        this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);\n        this.initPeerConnectionEventHandlers();\n    }\n    /**\n     * The local media stream currently being sent.\n     *\n     * @remarks\n     * The local media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * local media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get localMediaStream() {\n        return this._localMediaStream;\n    }\n    /**\n     * The remote media stream currently being received.\n     *\n     * @remarks\n     * The remote media stream initially has no tracks, so the presence of tracks\n     * should not be assumed. Furthermore, tracks may be added or removed if the\n     * remote media changes - for example, on upgrade from audio only to a video session.\n     * At any given time there will be at most one audio track and one video track\n     * (it's possible that this restriction may not apply to sub-classes).\n     * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n     * to detect when a new track becomes available:\n     * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n     */\n    get remoteMediaStream() {\n        return this._remoteMediaStream;\n    }\n    /**\n     * The data channel. Undefined before it is created.\n     */\n    get dataChannel() {\n        return this._dataChannel;\n    }\n    /**\n     * The peer connection. Undefined if peer connection has closed.\n     *\n     * @remarks\n     * While access to the underlying `RTCPeerConnection` is provided, note that\n     * using methods with modify it may break the operation of this class.\n     * In particular, this class depends on exclusive access to the\n     * event handler properties. If you need access to the peer connection\n     * events, either register for events using `addEventListener()` on\n     * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n     * this `SessionDescriptionHandler`.\n     */\n    get peerConnection() {\n        return this._peerConnection;\n    }\n    /**\n     * A delegate which provides access to the peer connection event handlers.\n     *\n     * @remarks\n     * Setting the peer connection event handlers directly is not supported\n     * and may break this class. As this class depends on exclusive access\n     * to them, a delegate may be set which provides alternative access to\n     * the event handlers in a fashion which is supported.\n     */\n    get peerConnectionDelegate() {\n        return this._peerConnectionDelegate;\n    }\n    set peerConnectionDelegate(delegate) {\n        this._peerConnectionDelegate = delegate;\n    }\n    // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n    static dispatchAddTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", { track }));\n    }\n    // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n    static dispatchRemoveTrackEvent(stream, track) {\n        stream.dispatchEvent(new MediaStreamTrackEvent(\"removetrack\", { track }));\n    }\n    /**\n     * Stop tracks and close peer connection.\n     */\n    close() {\n        this.logger.debug(\"SessionDescriptionHandler.close\");\n        if (this._peerConnection === undefined) {\n            return;\n        }\n        this._peerConnection.getReceivers().forEach((receiver) => {\n            receiver.track && receiver.track.stop();\n        });\n        this._peerConnection.getSenders().forEach((sender) => {\n            sender.track && sender.track.stop();\n        });\n        if (this._dataChannel) {\n            this._dataChannel.close();\n        }\n        this._peerConnection.close();\n        this._peerConnection = undefined;\n    }\n    /**\n     * Creates an offer or answer.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    getDescription(options, modifiers) {\n        var _a, _b;\n        this.logger.debug(\"SessionDescriptionHandler.getDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;\n        // ICE will restart upon applying an offer created with the iceRestart option\n        const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart;\n        // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n        const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined\n            ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;\n        return this.getLocalMediaStream(options)\n            .then(() => this.createDataChannel(options))\n            .then(() => this.createLocalOfferOrAnswer(options))\n            .then((sessionDescription) => this.applyModifiers(sessionDescription, modifiers))\n            .then((sessionDescription) => this.setLocalSessionDescription(sessionDescription))\n            .then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout))\n            .then(() => this.getLocalSessionDescription())\n            .then((sessionDescription) => {\n            return {\n                body: sessionDescription.sdp,\n                contentType: \"application/sdp\"\n            };\n        })\n            .catch((error) => {\n            this.logger.error(\"SessionDescriptionHandler.getDescription failed - \" + error);\n            throw error;\n        });\n    }\n    /**\n     * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n     * @param contentType - The content type that is in the SIP Message.\n     */\n    hasDescription(contentType) {\n        this.logger.debug(\"SessionDescriptionHandler.hasDescription\");\n        return contentType === \"application/sdp\";\n    }\n    /**\n     * Send DTMF via RTP (RFC 4733).\n     * Returns true if DTMF send is successful, false otherwise.\n     * @param tones - A string containing DTMF digits.\n     * @param options - Options object to be used by sendDtmf.\n     */\n    sendDtmf(tones, options) {\n        this.logger.debug(\"SessionDescriptionHandler.sendDtmf\");\n        if (this._peerConnection === undefined) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - peer connection closed\");\n            return false;\n        }\n        const senders = this._peerConnection.getSenders();\n        if (senders.length === 0) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no senders\");\n            return false;\n        }\n        const dtmfSender = senders[0].dtmf;\n        if (!dtmfSender) {\n            this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no DTMF sender\");\n            return false;\n        }\n        const duration = options === null || options === void 0 ? void 0 : options.duration;\n        const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;\n        try {\n            dtmfSender.insertDTMF(tones, duration, interToneGap);\n        }\n        catch (e) {\n            this.logger.error(e);\n            return false;\n        }\n        this.logger.log(\"SessionDescriptionHandler.sendDtmf sent via RTP: \" + tones.toString());\n        return true;\n    }\n    /**\n     * Sets an offer or answer.\n     * @param sdp - The session description.\n     * @param options - Options bucket.\n     * @param modifiers - Modifiers.\n     */\n    setDescription(sdp, options, modifiers) {\n        this.logger.debug(\"SessionDescriptionHandler.setDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // Callback on data channel creation\n        this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel;\n        // SDP type\n        const type = this._peerConnection.signalingState === \"have-local-offer\" ? \"answer\" : \"offer\";\n        return this.getLocalMediaStream(options)\n            .then(() => this.applyModifiers({ sdp, type }, modifiers))\n            .then((sessionDescription) => this.setRemoteSessionDescription(sessionDescription))\n            .catch((error) => {\n            this.logger.error(\"SessionDescriptionHandler.setDescription failed - \" + error);\n            throw error;\n        });\n    }\n    /**\n     * Applies modifiers to SDP prior to setting the local or remote description.\n     * @param sdp - SDP to modify.\n     * @param modifiers - Modifiers to apply.\n     */\n    applyModifiers(sdp, modifiers) {\n        this.logger.debug(\"SessionDescriptionHandler.applyModifiers\");\n        if (!modifiers || modifiers.length === 0) {\n            return Promise.resolve(sdp);\n        }\n        return modifiers\n            .reduce((cur, next) => cur.then(next), Promise.resolve(sdp))\n            .then((modified) => {\n            this.logger.debug(\"SessionDescriptionHandler.applyModifiers - modified sdp\");\n            if (!modified.sdp || !modified.type) {\n                throw new Error(\"Invalid SDP.\");\n            }\n            return { sdp: modified.sdp, type: modified.type };\n        });\n    }\n    /**\n     * Create a data channel.\n     * @remarks\n     * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n     * Only creates a data channel if creating a local offer.\n     * Only if one does not already exist.\n     * @param options - Session description handler options.\n     */\n    createDataChannel(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        // only create a data channel if requested\n        if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {\n            return Promise.resolve();\n        }\n        // do not create a data channel if we already have one\n        if (this._dataChannel) {\n            return Promise.resolve();\n        }\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable, assume we are creating a local offer so create a data channel\n                this.logger.debug(\"SessionDescriptionHandler.createDataChannel - creating data channel\");\n                try {\n                    this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || \"\", options === null || options === void 0 ? void 0 : options.dataChannelOptions);\n                    if (this.onDataChannel) {\n                        this.onDataChannel(this._dataChannel);\n                    }\n                    return Promise.resolve();\n                }\n                catch (error) {\n                    return Promise.reject(error);\n                }\n            case \"have-remote-offer\":\n                return Promise.resolve();\n            case \"have-local-offer\":\n            case \"have-local-pranswer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Depending on current signaling state, create a local offer or answer.\n     * @param options - Session description handler options.\n     */\n    createLocalOfferOrAnswer(options) {\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable, assume we are creating a local offer\n                this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer\");\n                return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);\n            case \"have-remote-offer\":\n                // if we have a remote offer, assume we are creating a local answer\n                this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer\");\n                return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);\n            case \"have-local-offer\":\n            case \"have-local-pranswer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n    }\n    /**\n     * Get a media stream from the media stream factory and set the local media stream.\n     * @param options - Session description handler options.\n     */\n    getLocalMediaStream(options) {\n        this.logger.debug(\"SessionDescriptionHandler.getLocalMediaStream\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints);\n        // if we already have a local media stream...\n        if (this.localMediaStreamConstraints) {\n            // ignore constraint \"downgrades\"\n            constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n            constraints.video = constraints.video || this.localMediaStreamConstraints.video;\n            // if constraints have not changed, do not get a new media stream\n            if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) &&\n                JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n                return Promise.resolve();\n            }\n        }\n        else {\n            // if no constraints have been specified, default to audio for initial media stream\n            if (constraints.audio === undefined && constraints.video === undefined) {\n                constraints = { audio: true };\n            }\n        }\n        this.localMediaStreamConstraints = constraints;\n        return this.mediaStreamFactory(constraints, this).then((mediaStream) => this.setLocalMediaStream(mediaStream));\n    }\n    /**\n     * Sets the peer connection's sender tracks and local media stream tracks.\n     *\n     * @remarks\n     * Only the first audio and video tracks of the provided MediaStream are utilized.\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param stream - Media stream containing tracks to be utilized.\n     */\n    setLocalMediaStream(stream) {\n        this.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream\");\n        if (!this._peerConnection) {\n            throw new Error(\"Peer connection undefined.\");\n        }\n        const pc = this._peerConnection;\n        const localStream = this._localMediaStream;\n        const trackUpdates = [];\n        const updateTrack = (newTrack) => {\n            const kind = newTrack.kind;\n            if (kind !== \"audio\" && kind !== \"video\") {\n                throw new Error(`Unknown new track kind ${kind}.`);\n            }\n            const sender = pc.getSenders().find((sender) => sender.track && sender.track.kind === kind);\n            if (sender) {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);\n                    resolve();\n                }).then(() => sender\n                    .replaceTrack(newTrack)\n                    .then(() => {\n                    const oldTrack = localStream.getTracks().find((localTrack) => localTrack.kind === kind);\n                    if (oldTrack) {\n                        oldTrack.stop();\n                        localStream.removeTrack(oldTrack);\n                        SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                })\n                    .catch((error) => {\n                    this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);\n                    throw error;\n                })));\n            }\n            else {\n                trackUpdates.push(new Promise((resolve) => {\n                    this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);\n                    resolve();\n                }).then(() => {\n                    // Review: could make streamless tracks a configurable option?\n                    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n                    try {\n                        pc.addTrack(newTrack, localStream);\n                    }\n                    catch (error) {\n                        this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);\n                        throw error;\n                    }\n                    localStream.addTrack(newTrack);\n                    SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n                }));\n            }\n        };\n        // update peer connection audio tracks\n        const audioTracks = stream.getAudioTracks();\n        if (audioTracks.length) {\n            updateTrack(audioTracks[0]);\n        }\n        // update peer connection video tracks\n        const videoTracks = stream.getVideoTracks();\n        if (videoTracks.length) {\n            updateTrack(videoTracks[0]);\n        }\n        return trackUpdates.reduce((p, x) => p.then(() => x), Promise.resolve());\n    }\n    /**\n     * Gets the peer connection's local session description.\n     */\n    getLocalSessionDescription() {\n        this.logger.debug(\"SessionDescriptionHandler.getLocalSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        const sdp = this._peerConnection.localDescription;\n        if (!sdp) {\n            return Promise.reject(new Error(\"Failed to get local session description\"));\n        }\n        return Promise.resolve(sdp);\n    }\n    /**\n     * Sets the peer connection's local session description.\n     * @param sessionDescription - sessionDescription The session description.\n     */\n    setLocalSessionDescription(sessionDescription) {\n        this.logger.debug(\"SessionDescriptionHandler.setLocalSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        return this._peerConnection.setLocalDescription(sessionDescription);\n    }\n    /**\n     * Sets the peer connection's remote session description.\n     * @param sessionDescription - The session description.\n     */\n    setRemoteSessionDescription(sessionDescription) {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteSessionDescription\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(new Error(\"Peer connection closed.\"));\n        }\n        const sdp = sessionDescription.sdp;\n        let type;\n        switch (this._peerConnection.signalingState) {\n            case \"stable\":\n                // if we are stable assume this is a remote offer\n                type = \"offer\";\n                break;\n            case \"have-local-offer\":\n                // if we made an offer, assume this is a remote answer\n                type = \"answer\";\n                break;\n            case \"have-local-pranswer\":\n            case \"have-remote-offer\":\n            case \"have-remote-pranswer\":\n            case \"closed\":\n            default:\n                return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n        }\n        if (!sdp) {\n            this.logger.error(\"SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp\");\n            return Promise.reject(new Error(\"SDP is undefined\"));\n        }\n        return this._peerConnection.setRemoteDescription({ sdp, type });\n    }\n    /**\n     * Sets a remote media stream track.\n     *\n     * @remarks\n     * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n     *\n     * @param track - Media stream track to be utilized.\n     */\n    setRemoteTrack(track) {\n        this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack\");\n        const remoteStream = this._remoteMediaStream;\n        if (remoteStream.getTrackById(track.id)) {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);\n        }\n        else if (track.kind === \"audio\") {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getAudioTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n        else if (track.kind === \"video\") {\n            this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n            remoteStream.getVideoTracks().forEach((track) => {\n                track.stop();\n                remoteStream.removeTrack(track);\n                SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n            });\n            remoteStream.addTrack(track);\n            SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n        }\n    }\n    /**\n     * Called when ICE gathering completes and resolves any waiting promise.\n     */\n    iceGatheringComplete() {\n        this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete\");\n        // clear timer if need be\n        if (this.iceGatheringCompleteTimeoutId !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - clearing timeout\");\n            clearTimeout(this.iceGatheringCompleteTimeoutId);\n            this.iceGatheringCompleteTimeoutId = undefined;\n        }\n        // resolve and cleanup promise if need be\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - resolving promise\");\n            this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n    }\n    /**\n     * Wait for ICE gathering to complete.\n     * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n     * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n     */\n    waitForIceGatheringComplete(restart = false, timeout = 0) {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete\");\n        if (this._peerConnection === undefined) {\n            return Promise.reject(\"Peer connection closed.\");\n        }\n        // guard already complete\n        if (!restart && this._peerConnection.iceGatheringState === \"complete\") {\n            this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - already complete\");\n            return Promise.resolve();\n        }\n        // only one may be waiting, reject any prior\n        if (this.iceGatheringCompletePromise !== undefined) {\n            this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise\");\n            this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error(\"Promise superseded.\"));\n            this.iceGatheringCompletePromise = undefined;\n            this.iceGatheringCompleteResolve = undefined;\n            this.iceGatheringCompleteReject = undefined;\n        }\n        this.iceGatheringCompletePromise = new Promise((resolve, reject) => {\n            this.iceGatheringCompleteResolve = resolve;\n            this.iceGatheringCompleteReject = reject;\n            if (timeout > 0) {\n                this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in \" + timeout);\n                this.iceGatheringCompleteTimeoutId = setTimeout(() => {\n                    this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout\");\n                    this.iceGatheringComplete();\n                }, timeout);\n            }\n        });\n        return this.iceGatheringCompletePromise;\n    }\n    /**\n     * Initializes the peer connection event handlers\n     */\n    initPeerConnectionEventHandlers() {\n        this.logger.debug(\"SessionDescriptionHandler.initPeerConnectionEventHandlers\");\n        if (!this._peerConnection)\n            throw new Error(\"Peer connection undefined.\");\n        const peerConnection = this._peerConnection;\n        peerConnection.onconnectionstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.connectionState;\n            this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {\n                this._peerConnectionDelegate.onconnectionstatechange(event);\n            }\n        };\n        peerConnection.ondatachannel = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.ondatachannel`);\n            this._dataChannel = event.channel;\n            if (this.onDataChannel) {\n                this.onDataChannel(this._dataChannel);\n            }\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {\n                this._peerConnectionDelegate.ondatachannel(event);\n            }\n        };\n        peerConnection.onicecandidate = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onicecandidate`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {\n                this._peerConnectionDelegate.onicecandidate(event);\n            }\n        };\n        peerConnection.onicecandidateerror = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {\n                this._peerConnectionDelegate.onicecandidateerror(event);\n            }\n        };\n        peerConnection.oniceconnectionstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.iceConnectionState;\n            this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {\n                this._peerConnectionDelegate.oniceconnectionstatechange(event);\n            }\n        };\n        peerConnection.onicegatheringstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.iceGatheringState;\n            this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);\n            if (newState === \"complete\") {\n                this.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n            }\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {\n                this._peerConnectionDelegate.onicegatheringstatechange(event);\n            }\n        };\n        peerConnection.onnegotiationneeded = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {\n                this._peerConnectionDelegate.onnegotiationneeded(event);\n            }\n        };\n        peerConnection.onsignalingstatechange = (event) => {\n            var _a;\n            const newState = peerConnection.signalingState;\n            this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {\n                this._peerConnectionDelegate.onsignalingstatechange(event);\n            }\n        };\n        peerConnection.onstatsended = (event) => {\n            var _a;\n            this.logger.debug(`SessionDescriptionHandler.onstatsended`);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onstatsended) {\n                this._peerConnectionDelegate.onstatsended(event);\n            }\n        };\n        peerConnection.ontrack = (event) => {\n            var _a;\n            const kind = event.track.kind;\n            const enabled = event.track.enabled ? \"enabled\" : \"disabled\";\n            this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);\n            this.setRemoteTrack(event.track);\n            if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {\n                this._peerConnectionDelegate.ontrack(event);\n            }\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}