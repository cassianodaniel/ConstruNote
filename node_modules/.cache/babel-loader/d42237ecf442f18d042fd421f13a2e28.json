{"ast":null,"code":"import DateTime from \"./datetime.js\";\nimport Settings from \"./settings.js\";\nimport Locale from \"./impl/locale.js\";\nimport IANAZone from \"./zones/IANAZone.js\";\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\nimport { hasFormatToParts, hasIntl, hasRelative } from \"./impl/util.js\";\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\n\nexport default class Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = Settings.defaultZone) {\n    const proto = DateTime.local().setZone(zone).set({\n      month: 12\n    });\n    return !zone.universal && proto.offset !== proto.set({\n      month: 6\n    }).offset;\n  }\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n\n\n  static isValidIANAZone(zone) {\n    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);\n  }\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone.isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n\n\n  static normalizeZone(input) {\n    return normalizeZone(input, Settings.defaultZone);\n  }\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n   * @return {[string]}\n   */\n\n\n  static months(length = \"long\", {\n    locale = null,\n    numberingSystem = null,\n    outputCalendar = \"gregory\"\n  } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length);\n  }\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {[string]}\n   */\n\n\n  static monthsFormat(length = \"long\", {\n    locale = null,\n    numberingSystem = null,\n    outputCalendar = \"gregory\"\n  } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);\n  }\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n   * @return {[string]}\n   */\n\n\n  static weekdays(length = \"long\", {\n    locale = null,\n    numberingSystem = null\n  } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length);\n  }\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link weekdays}\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @return {[string]}\n   */\n\n\n  static weekdaysFormat(length = \"long\", {\n    locale = null,\n    numberingSystem = null\n  } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length, true);\n  }\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n   * @return {[string]}\n   */\n\n\n  static meridiems({\n    locale = null\n  } = {}) {\n    return Locale.create(locale).meridiems();\n  }\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n   * @return {[string]}\n   */\n\n\n  static eras(length = \"short\", {\n    locale = null\n  } = {}) {\n    return Locale.create(locale, null, \"gregory\").eras(length);\n  }\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `zones`: whether this environment supports IANA timezones\n   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n   * * `intl`: whether this environment supports general internationalization\n   * * `relative`: whether this environment supports relative time formatting\n   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n   * @return {Object}\n   */\n\n\n  static features() {\n    let intl = false,\n        intlTokens = false,\n        zones = false,\n        relative = false;\n\n    if (hasIntl()) {\n      intl = true;\n      intlTokens = hasFormatToParts();\n      relative = hasRelative();\n\n      try {\n        zones = new Intl.DateTimeFormat(\"en\", {\n          timeZone: \"America/New_York\"\n        }).resolvedOptions().timeZone === \"America/New_York\";\n      } catch (e) {\n        zones = false;\n      }\n    }\n\n    return {\n      intl,\n      intlTokens,\n      zones,\n      relative\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/luxon/src/info.js"],"names":["DateTime","Settings","Locale","IANAZone","normalizeZone","hasFormatToParts","hasIntl","hasRelative","Info","hasDST","zone","defaultZone","proto","local","setZone","set","month","universal","offset","isValidIANAZone","isValidSpecifier","isValidZone","input","months","length","locale","numberingSystem","outputCalendar","create","monthsFormat","weekdays","weekdaysFormat","meridiems","eras","features","intl","intlTokens","zones","relative","Intl","DateTimeFormat","timeZone","resolvedOptions","e"],"mappings":"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","sourcesContent":["import DateTime from \"./datetime.js\";\nimport Settings from \"./settings.js\";\nimport Locale from \"./impl/locale.js\";\nimport IANAZone from \"./zones/IANAZone.js\";\nimport { normalizeZone } from \"./impl/zoneUtil.js\";\n\nimport { hasFormatToParts, hasIntl, hasRelative } from \"./impl/util.js\";\n\n/**\n * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.\n */\nexport default class Info {\n  /**\n   * Return whether the specified zone contains a DST.\n   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.\n   * @return {boolean}\n   */\n  static hasDST(zone = Settings.defaultZone) {\n    const proto = DateTime.local()\n      .setZone(zone)\n      .set({ month: 12 });\n\n    return !zone.universal && proto.offset !== proto.set({ month: 6 }).offset;\n  }\n\n  /**\n   * Return whether the specified zone is a valid IANA specifier.\n   * @param {string} zone - Zone to check\n   * @return {boolean}\n   */\n  static isValidIANAZone(zone) {\n    return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);\n  }\n\n  /**\n   * Converts the input into a {@link Zone} instance.\n   *\n   * * If `input` is already a Zone instance, it is returned unchanged.\n   * * If `input` is a string containing a valid time zone name, a Zone instance\n   *   with that name is returned.\n   * * If `input` is a string that doesn't refer to a known time zone, a Zone\n   *   instance with {@link Zone.isValid} == false is returned.\n   * * If `input is a number, a Zone instance with the specified fixed offset\n   *   in minutes is returned.\n   * * If `input` is `null` or `undefined`, the default zone is returned.\n   * @param {string|Zone|number} [input] - the value to be converted\n   * @return {Zone}\n   */\n  static normalizeZone(input) {\n    return normalizeZone(input, Settings.defaultZone);\n  }\n\n  /**\n   * Return an array of standalone month names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @example Info.months()[0] //=> 'January'\n   * @example Info.months('short')[0] //=> 'Jan'\n   * @example Info.months('numeric')[0] //=> '1'\n   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'\n   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'\n   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'\n   * @return {[string]}\n   */\n  static months(\n    length = \"long\",\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length);\n  }\n\n  /**\n   * Return an array of format month names.\n   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that\n   * changes the string.\n   * See {@link months}\n   * @param {string} [length='long'] - the length of the month representation, such as \"numeric\", \"2-digit\", \"narrow\", \"short\", \"long\"\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @param {string} [opts.outputCalendar='gregory'] - the calendar\n   * @return {[string]}\n   */\n  static monthsFormat(\n    length = \"long\",\n    { locale = null, numberingSystem = null, outputCalendar = \"gregory\" } = {}\n  ) {\n    return Locale.create(locale, numberingSystem, outputCalendar).months(length, true);\n  }\n\n  /**\n   * Return an array of standalone week names.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @example Info.weekdays()[0] //=> 'Monday'\n   * @example Info.weekdays('short')[0] //=> 'Mon'\n   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'\n   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'\n   * @return {[string]}\n   */\n  static weekdays(length = \"long\", { locale = null, numberingSystem = null } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length);\n  }\n\n  /**\n   * Return an array of format week names.\n   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that\n   * changes the string.\n   * See {@link weekdays}\n   * @param {string} [length='long'] - the length of the weekday representation, such as \"narrow\", \"short\", \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale=null] - the locale code\n   * @param {string} [opts.numberingSystem=null] - the numbering system\n   * @return {[string]}\n   */\n  static weekdaysFormat(length = \"long\", { locale = null, numberingSystem = null } = {}) {\n    return Locale.create(locale, numberingSystem, null).weekdays(length, true);\n  }\n\n  /**\n   * Return an array of meridiems.\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.meridiems() //=> [ 'AM', 'PM' ]\n   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]\n   * @return {[string]}\n   */\n  static meridiems({ locale = null } = {}) {\n    return Locale.create(locale).meridiems();\n  }\n\n  /**\n   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.\n   * @param {string} [length='short'] - the length of the era representation, such as \"short\" or \"long\".\n   * @param {Object} opts - options\n   * @param {string} [opts.locale] - the locale code\n   * @example Info.eras() //=> [ 'BC', 'AD' ]\n   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]\n   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]\n   * @return {[string]}\n   */\n  static eras(length = \"short\", { locale = null } = {}) {\n    return Locale.create(locale, null, \"gregory\").eras(length);\n  }\n\n  /**\n   * Return the set of available features in this environment.\n   * Some features of Luxon are not available in all environments. For example, on older browsers, timezone support is not available. Use this function to figure out if that's the case.\n   * Keys:\n   * * `zones`: whether this environment supports IANA timezones\n   * * `intlTokens`: whether this environment supports internationalized token-based formatting/parsing\n   * * `intl`: whether this environment supports general internationalization\n   * * `relative`: whether this environment supports relative time formatting\n   * @example Info.features() //=> { intl: true, intlTokens: false, zones: true, relative: false }\n   * @return {Object}\n   */\n  static features() {\n    let intl = false,\n      intlTokens = false,\n      zones = false,\n      relative = false;\n\n    if (hasIntl()) {\n      intl = true;\n      intlTokens = hasFormatToParts();\n      relative = hasRelative();\n\n      try {\n        zones =\n          new Intl.DateTimeFormat(\"en\", { timeZone: \"America/New_York\" }).resolvedOptions()\n            .timeZone === \"America/New_York\";\n      } catch (e) {\n        zones = false;\n      }\n    }\n\n    return { intl, intlTokens, zones, relative };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}