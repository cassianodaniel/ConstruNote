{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { C, NameAddrHeader } from \"../messages\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { ReSubscribeUserAgentClient } from \"../user-agents/re-subscribe-user-agent-client\";\nimport { Dialog } from \"./dialog\";\n/**\n * Subscription Dialog.\n * @remarks\n * SIP-Specific Event Notification\n *\n * Abstract\n *\n *    This document describes an extension to the Session Initiation\n *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n *    to provide an extensible framework by which SIP nodes can request\n *    notification from remote nodes indicating that certain events have\n *    occurred.\n *\n *    Note that the event notification mechanisms defined herein are NOT\n *    intended to be a general-purpose infrastructure for all classes of\n *    event subscription and notification.\n *\n *    This document represents a backwards-compatible improvement on the\n *    original mechanism described by RFC 3265, taking into account several\n *    years of implementation experience.  Accordingly, this document\n *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to\n *    accommodate some small changes to the mechanism that were discussed\n *    in that document.\n *\n *  https://tools.ietf.org/html/rfc6665\n * @public\n */\n\nexport var SubscriptionDialog = /*#__PURE__*/function (_Dialog) {\n  _inherits(SubscriptionDialog, _Dialog);\n\n  var _super = _createSuper(SubscriptionDialog);\n\n  function SubscriptionDialog(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {\n    var _this;\n\n    _classCallCheck(this, SubscriptionDialog);\n\n    _this = _super.call(this, core, state);\n    _this.delegate = delegate;\n    _this._autoRefresh = false;\n    _this._subscriptionEvent = subscriptionEvent;\n    _this._subscriptionExpires = subscriptionExpires;\n    _this._subscriptionExpiresInitial = subscriptionExpires;\n    _this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n    _this._subscriptionRefresh = undefined;\n    _this._subscriptionRefreshLastSet = undefined;\n    _this._subscriptionState = subscriptionState;\n    _this.logger = core.loggerFactory.getLogger(\"sip.subscribe-dialog\");\n\n    _this.logger.log(\"SUBSCRIBE dialog \".concat(_this.id, \" constructed\"));\n\n    return _this;\n  }\n  /**\n   * When a UAC receives a response that establishes a dialog, it\n   * constructs the state of the dialog.  This state MUST be maintained\n   * for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.2\n   * @param outgoingRequestMessage - Outgoing request message for dialog.\n   * @param incomingResponseMessage - Incoming response message creating dialog.\n   */\n\n\n  _createClass(SubscriptionDialog, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(SubscriptionDialog.prototype), \"dispose\", this).call(this);\n\n      if (this.N) {\n        clearTimeout(this.N);\n        this.N = undefined;\n      }\n\n      this.refreshTimerClear();\n      this.logger.log(\"SUBSCRIBE dialog \".concat(this.id, \" destroyed\"));\n    }\n  }, {\n    key: \"receiveRequest\",\n\n    /**\n     * Receive in dialog request message from transport.\n     * @param message -  The incoming request message.\n     */\n    value: function receiveRequest(message) {\n      this.logger.log(\"SUBSCRIBE dialog \".concat(this.id, \" received \").concat(message.method, \" request\")); // Request within a dialog out of sequence guard.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n      if (!this.sequenceGuard(message)) {\n        this.logger.log(\"SUBSCRIBE dialog \".concat(this.id, \" rejected out of order \").concat(message.method, \" request.\"));\n        return;\n      } // Request within a dialog common processing.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      _get(_getPrototypeOf(SubscriptionDialog.prototype), \"receiveRequest\", this).call(this, message); // Switch on method and then delegate.\n\n\n      switch (message.method) {\n        case C.NOTIFY:\n          this.onNotify(message);\n          break;\n\n        default:\n          this.logger.log(\"SUBSCRIBE dialog \".concat(this.id, \" received unimplemented \").concat(message.method, \" request\"));\n          this.core.replyStateless(message, {\n            statusCode: 501\n          });\n          break;\n      }\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var allowHeader = \"Allow: \" + AllowedMethods.toString();\n      var options = {};\n      options.extraHeaders = (options.extraHeaders || []).slice();\n      options.extraHeaders.push(allowHeader);\n      options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n      options.extraHeaders.push(\"Expires: \" + this.subscriptionExpiresInitial);\n      options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n      return this.subscribe(undefined, options);\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     * @param delegate - Delegate to handle responses.\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(delegate) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n        // FIXME: This needs to be a proper exception\n        throw new Error(\"Invalid state \".concat(this.subscriptionState, \". May only re-subscribe while in state \\\"pending\\\" or \\\"active\\\".\"));\n      }\n\n      this.logger.log(\"SUBSCRIBE dialog \".concat(this.id, \" sending SUBSCRIBE request\"));\n      var uac = new ReSubscribeUserAgentClient(this, delegate, options); // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).\n\n      if (this.N) {\n        clearTimeout(this.N);\n        this.N = undefined;\n      } // When refreshing a subscription, a subscriber starts Timer N, set to\n      // 64*T1, when it sends the SUBSCRIBE request.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n\n\n      this.N = setTimeout(function () {\n        return _this2.timerN();\n      }, Timers.TIMER_N);\n      return uac;\n    }\n    /**\n     * 4.4.1.  Dialog Creation and Termination\n     * A subscription is destroyed after a notifier sends a NOTIFY request\n     * with a \"Subscription-State\" of \"terminated\", or in certain error\n     * situations described elsewhere in this document.\n     * https://tools.ietf.org/html/rfc6665#section-4.4.1\n     */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this.stateTransition(SubscriptionState.Terminated);\n      this.onTerminated();\n    }\n    /**\n     * 4.1.2.3.  Unsubscribing\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var allowHeader = \"Allow: \" + AllowedMethods.toString();\n      var options = {};\n      options.extraHeaders = (options.extraHeaders || []).slice();\n      options.extraHeaders.push(allowHeader);\n      options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n      options.extraHeaders.push(\"Expires: 0\");\n      options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n      return this.subscribe(undefined, options);\n    }\n    /**\n     * Handle in dialog NOTIFY requests.\n     * This does not include the first NOTIFY which created the dialog.\n     * @param message - The incoming NOTIFY request message.\n     */\n\n  }, {\n    key: \"onNotify\",\n    value: function onNotify(message) {\n      // If, for some reason, the event package designated in the \"Event\"\n      // header field of the NOTIFY request is not supported, the subscriber\n      // will respond with a 489 (Bad Event) response.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n      var event = message.parseHeader(\"Event\").event;\n\n      if (!event || event !== this.subscriptionEvent) {\n        this.core.replyStateless(message, {\n          statusCode: 489\n        });\n        return;\n      } // In the state diagram, \"Re-subscription times out\" means that an\n      // attempt to refresh or update the subscription using a new SUBSCRIBE\n      // request does not result in a NOTIFY request before the corresponding\n      // Timer N expires.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.2\n\n\n      if (this.N) {\n        clearTimeout(this.N);\n        this.N = undefined;\n      } // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n      // indicate the status of the subscription.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n      var subscriptionState = message.parseHeader(\"Subscription-State\");\n\n      if (!subscriptionState || !subscriptionState.state) {\n        this.core.replyStateless(message, {\n          statusCode: 489\n        });\n        return;\n      }\n\n      var state = subscriptionState.state;\n      var expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined; // Update our state and expiration.\n\n      switch (state) {\n        case \"pending\":\n          this.stateTransition(SubscriptionState.Pending, expires);\n          break;\n\n        case \"active\":\n          this.stateTransition(SubscriptionState.Active, expires);\n          break;\n\n        case \"terminated\":\n          this.stateTransition(SubscriptionState.Terminated, expires);\n          break;\n\n        default:\n          this.logger.warn(\"Unrecognized subscription state.\");\n          break;\n      } // Delegate remainder of NOTIFY handling.\n\n\n      var uas = new NotifyUserAgentServer(this, message);\n\n      if (this.delegate && this.delegate.onNotify) {\n        this.delegate.onNotify(uas);\n      } else {\n        uas.accept();\n      }\n    }\n  }, {\n    key: \"onRefresh\",\n    value: function onRefresh(request) {\n      if (this.delegate && this.delegate.onRefresh) {\n        this.delegate.onRefresh(request);\n      }\n    }\n  }, {\n    key: \"onTerminated\",\n    value: function onTerminated() {\n      if (this.delegate && this.delegate.onTerminated) {\n        this.delegate.onTerminated();\n      }\n    }\n  }, {\n    key: \"refreshTimerClear\",\n    value: function refreshTimerClear() {\n      if (this.refreshTimer) {\n        clearTimeout(this.refreshTimer);\n        this.refreshTimer = undefined;\n      }\n    }\n  }, {\n    key: \"refreshTimerSet\",\n    value: function refreshTimerSet() {\n      var _this3 = this;\n\n      this.refreshTimerClear();\n\n      if (this.autoRefresh && this.subscriptionExpires > 0) {\n        var refresh = this.subscriptionExpires * 900;\n        this._subscriptionRefresh = Math.floor(refresh / 1000);\n        this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);\n        this.refreshTimer = setTimeout(function () {\n          _this3.refreshTimer = undefined;\n          _this3._subscriptionRefresh = undefined;\n          _this3._subscriptionRefreshLastSet = undefined;\n\n          _this3.onRefresh(_this3.refresh());\n        }, refresh);\n      }\n    }\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState, newExpires) {\n      var _this4 = this;\n\n      // Assert valid state transitions.\n      var invalidStateTransition = function invalidStateTransition() {\n        _this4.logger.warn(\"Invalid subscription state transition from \".concat(_this4.subscriptionState, \" to \").concat(newState));\n      };\n\n      switch (newState) {\n        case SubscriptionState.Initial:\n          invalidStateTransition();\n          return;\n\n        case SubscriptionState.NotifyWait:\n          invalidStateTransition();\n          return;\n\n        case SubscriptionState.Pending:\n          if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending) {\n            invalidStateTransition();\n            return;\n          }\n\n          break;\n\n        case SubscriptionState.Active:\n          if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n            invalidStateTransition();\n            return;\n          }\n\n          break;\n\n        case SubscriptionState.Terminated:\n          if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n            invalidStateTransition();\n            return;\n          }\n\n          break;\n\n        default:\n          invalidStateTransition();\n          return;\n      } // If the \"Subscription-State\" value is \"pending\", the subscription has\n      // been received by the notifier, but there is insufficient policy\n      // information to grant or deny the subscription yet.  If the header\n      // field also contains an \"expires\" parameter, the subscriber SHOULD\n      // take it as the authoritative subscription duration and adjust\n      // accordingly.  No further action is necessary on the part of the\n      // subscriber.  The \"retry-after\" and \"reason\" parameters have no\n      // semantics for \"pending\".\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n      if (newState === SubscriptionState.Pending) {\n        if (newExpires) {\n          this.subscriptionExpires = newExpires;\n        }\n      } // If the \"Subscription-State\" header field value is \"active\", it means\n      // that the subscription has been accepted and (in general) has been\n      // authorized.  If the header field also contains an \"expires\"\n      // parameter, the subscriber SHOULD take it as the authoritative\n      // subscription duration and adjust accordingly.  The \"retry-after\" and\n      // \"reason\" parameters have no semantics for \"active\".\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n      if (newState === SubscriptionState.Active) {\n        if (newExpires) {\n          this.subscriptionExpires = newExpires;\n        }\n      } // If the \"Subscription-State\" value is \"terminated\", the subscriber\n      // MUST consider the subscription terminated.  The \"expires\" parameter\n      // has no semantics for \"terminated\" -- notifiers SHOULD NOT include an\n      // \"expires\" parameter on a \"Subscription-State\" header field with a\n      // value of \"terminated\", and subscribers MUST ignore any such\n      // parameter, if present.\n\n\n      if (newState === SubscriptionState.Terminated) {\n        this.dispose();\n      }\n\n      this._subscriptionState = newState;\n    }\n    /**\n     * When refreshing a subscription, a subscriber starts Timer N, set to\n     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires\n     * prior to the receipt of a NOTIFY request, the subscriber considers\n     * the subscription terminated.  If the subscriber receives a success\n     * response to the SUBSCRIBE request that indicates that no NOTIFY\n     * request will be generated -- such as the 204 response defined for use\n     * with the optional extension described in [RFC5839] -- then it MUST\n     * cancel Timer N.\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n\n  }, {\n    key: \"timerN\",\n    value: function timerN() {\n      this.logger.warn(\"Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.\");\n\n      if (this.subscriptionState !== SubscriptionState.Terminated) {\n        this.stateTransition(SubscriptionState.Terminated);\n        this.onTerminated();\n      }\n    }\n  }, {\n    key: \"autoRefresh\",\n    get: function get() {\n      return this._autoRefresh;\n    },\n    set: function set(autoRefresh) {\n      this._autoRefresh = true;\n      this.refreshTimerSet();\n    }\n  }, {\n    key: \"subscriptionEvent\",\n    get: function get() {\n      return this._subscriptionEvent;\n    }\n    /** Number of seconds until subscription expires. */\n\n  }, {\n    key: \"subscriptionExpires\",\n    get: function get() {\n      var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;\n\n      var secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;\n      return Math.max(secondsUntilExpires, 0);\n    },\n    set: function set(expires) {\n      if (expires < 0) {\n        throw new Error(\"Expires must be greater than or equal to zero.\");\n      }\n\n      this._subscriptionExpires = expires;\n      this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n\n      if (this.autoRefresh) {\n        var refresh = this.subscriptionRefresh;\n\n        if (refresh === undefined || refresh >= expires) {\n          this.refreshTimerSet();\n        }\n      }\n    }\n  }, {\n    key: \"subscriptionExpiresInitial\",\n    get: function get() {\n      return this._subscriptionExpiresInitial;\n    }\n    /** Number of seconds until subscription auto refresh. */\n\n  }, {\n    key: \"subscriptionRefresh\",\n    get: function get() {\n      if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {\n        return undefined;\n      }\n\n      var secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;\n\n      var secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;\n      return Math.max(secondsUntilExpires, 0);\n    }\n  }, {\n    key: \"subscriptionState\",\n    get: function get() {\n      return this._subscriptionState;\n    }\n  }], [{\n    key: \"initialDialogStateForSubscription\",\n    value: function initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {\n      // If the request was sent over TLS, and the Request-URI contained a\n      // SIPS URI, the \"secure\" flag is set to TRUE.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n      var secure = false; // FIXME: Currently no support for TLS.\n      // The route set MUST be set to the list of URIs in the Record-Route\n      // header field from the response, taken in reverse order and preserving\n      // all URI parameters.  If no Record-Route header field is present in\n      // the response, the route set MUST be set to the empty set.  This route\n      // set, even if empty, overrides any pre-existing route set for future\n      // requests in this dialog.  The remote target MUST be set to the URI\n      // from the Contact header field of the response.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n      var routeSet = incomingNotifyRequestMessage.getHeaders(\"record-route\");\n      var contact = incomingNotifyRequestMessage.parseHeader(\"contact\");\n\n      if (!contact) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Contact undefined.\");\n      }\n\n      if (!(contact instanceof NameAddrHeader)) {\n        throw new Error(\"Contact not instance of NameAddrHeader.\");\n      }\n\n      var remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence\n      // number in the CSeq header field of the request.  The remote sequence\n      // number MUST be empty (it is established when the remote UA sends a\n      // request within the dialog).  The call identifier component of the\n      // dialog ID MUST be set to the value of the Call-ID in the request.\n      // The local tag component of the dialog ID MUST be set to the tag in\n      // the From field in the request, and the remote tag component of the\n      // dialog ID MUST be set to the tag in the To field of the response.  A\n      // UAC MUST be prepared to receive a response without a tag in the To\n      // field, in which case the tag is considered to have a value of null.\n      //\n      //    This is to maintain backwards compatibility with RFC 2543, which\n      //    did not mandate To tags.\n      //\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n      var localSequenceNumber = outgoingSubscribeRequestMessage.cseq;\n      var remoteSequenceNumber = undefined;\n      var callId = outgoingSubscribeRequestMessage.callId;\n      var localTag = outgoingSubscribeRequestMessage.fromTag;\n      var remoteTag = incomingNotifyRequestMessage.fromTag;\n\n      if (!callId) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Call id undefined.\");\n      }\n\n      if (!localTag) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"From tag undefined.\");\n      }\n\n      if (!remoteTag) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n      } // The remote URI MUST be set to the URI in the To field, and the local\n      // URI MUST be set to the URI in the From field.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n\n      if (!outgoingSubscribeRequestMessage.from) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"From undefined.\");\n      }\n\n      if (!outgoingSubscribeRequestMessage.to) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"To undefined.\");\n      }\n\n      var localURI = outgoingSubscribeRequestMessage.from.uri;\n      var remoteURI = outgoingSubscribeRequestMessage.to.uri; // A dialog can also be in the \"early\" state, which occurs when it is\n      // created with a provisional response, and then transition to the\n      // \"confirmed\" state when a 2xx final response arrives.\n      // https://tools.ietf.org/html/rfc3261#section-12\n\n      var early = false;\n      var dialogState = {\n        id: callId + localTag + remoteTag,\n        early: early,\n        callId: callId,\n        localTag: localTag,\n        remoteTag: remoteTag,\n        localSequenceNumber: localSequenceNumber,\n        remoteSequenceNumber: remoteSequenceNumber,\n        localURI: localURI,\n        remoteURI: remoteURI,\n        remoteTarget: remoteTarget,\n        routeSet: routeSet,\n        secure: secure\n      };\n      return dialogState;\n    }\n  }]);\n\n  return SubscriptionDialog;\n}(Dialog);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/subscription-dialog.js"],"names":["C","NameAddrHeader","SubscriptionState","Timers","AllowedMethods","NotifyUserAgentServer","ReSubscribeUserAgentClient","Dialog","SubscriptionDialog","subscriptionEvent","subscriptionExpires","subscriptionState","core","state","delegate","_autoRefresh","_subscriptionEvent","_subscriptionExpires","_subscriptionExpiresInitial","_subscriptionExpiresLastSet","Math","floor","Date","now","_subscriptionRefresh","undefined","_subscriptionRefreshLastSet","_subscriptionState","logger","loggerFactory","getLogger","log","id","N","clearTimeout","refreshTimerClear","message","method","sequenceGuard","NOTIFY","onNotify","replyStateless","statusCode","allowHeader","toString","options","extraHeaders","slice","push","subscriptionExpiresInitial","configuration","contact","subscribe","Pending","Active","Error","uac","setTimeout","timerN","TIMER_N","stateTransition","Terminated","onTerminated","event","parseHeader","expires","max","warn","uas","accept","request","onRefresh","refreshTimer","autoRefresh","refresh","newState","newExpires","invalidStateTransition","Initial","NotifyWait","dispose","refreshTimerSet","secondsSinceLastSet","secondsUntilExpires","subscriptionRefresh","outgoingSubscribeRequestMessage","incomingNotifyRequestMessage","secure","routeSet","getHeaders","remoteTarget","uri","localSequenceNumber","cseq","remoteSequenceNumber","callId","localTag","fromTag","remoteTag","from","to","localURI","remoteURI","early","dialogState"],"mappings":"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","sourcesContent":["import { C, NameAddrHeader } from \"../messages\";\nimport { SubscriptionState } from \"../subscription\";\nimport { Timers } from \"../timers\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { ReSubscribeUserAgentClient } from \"../user-agents/re-subscribe-user-agent-client\";\nimport { Dialog } from \"./dialog\";\n/**\n * Subscription Dialog.\n * @remarks\n * SIP-Specific Event Notification\n *\n * Abstract\n *\n *    This document describes an extension to the Session Initiation\n *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n *    to provide an extensible framework by which SIP nodes can request\n *    notification from remote nodes indicating that certain events have\n *    occurred.\n *\n *    Note that the event notification mechanisms defined herein are NOT\n *    intended to be a general-purpose infrastructure for all classes of\n *    event subscription and notification.\n *\n *    This document represents a backwards-compatible improvement on the\n *    original mechanism described by RFC 3265, taking into account several\n *    years of implementation experience.  Accordingly, this document\n *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to\n *    accommodate some small changes to the mechanism that were discussed\n *    in that document.\n *\n *  https://tools.ietf.org/html/rfc6665\n * @public\n */\nexport class SubscriptionDialog extends Dialog {\n    constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {\n        super(core, state);\n        this.delegate = delegate;\n        this._autoRefresh = false;\n        this._subscriptionEvent = subscriptionEvent;\n        this._subscriptionExpires = subscriptionExpires;\n        this._subscriptionExpiresInitial = subscriptionExpires;\n        this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n        this._subscriptionRefresh = undefined;\n        this._subscriptionRefreshLastSet = undefined;\n        this._subscriptionState = subscriptionState;\n        this.logger = core.loggerFactory.getLogger(\"sip.subscribe-dialog\");\n        this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);\n    }\n    /**\n     * When a UAC receives a response that establishes a dialog, it\n     * constructs the state of the dialog.  This state MUST be maintained\n     * for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.2\n     * @param outgoingRequestMessage - Outgoing request message for dialog.\n     * @param incomingResponseMessage - Incoming response message creating dialog.\n     */\n    static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {\n        // If the request was sent over TLS, and the Request-URI contained a\n        // SIPS URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the response, taken in reverse order and preserving\n        // all URI parameters.  If no Record-Route header field is present in\n        // the response, the route set MUST be set to the empty set.  This route\n        // set, even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const routeSet = incomingNotifyRequestMessage.getHeaders(\"record-route\");\n        const contact = incomingNotifyRequestMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The local sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The remote sequence\n        // number MUST be empty (it is established when the remote UA sends a\n        // request within the dialog).  The call identifier component of the\n        // dialog ID MUST be set to the value of the Call-ID in the request.\n        // The local tag component of the dialog ID MUST be set to the tag in\n        // the From field in the request, and the remote tag component of the\n        // dialog ID MUST be set to the tag in the To field of the response.  A\n        // UAC MUST be prepared to receive a response without a tag in the To\n        // field, in which case the tag is considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate To tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;\n        const remoteSequenceNumber = undefined;\n        const callId = outgoingSubscribeRequestMessage.callId;\n        const localTag = outgoingSubscribeRequestMessage.fromTag;\n        const remoteTag = incomingNotifyRequestMessage.fromTag;\n        if (!callId) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Call id undefined.\");\n        }\n        if (!localTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From tag undefined.\");\n        }\n        if (!remoteTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n        }\n        // The remote URI MUST be set to the URI in the To field, and the local\n        // URI MUST be set to the URI in the From field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        if (!outgoingSubscribeRequestMessage.from) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From undefined.\");\n        }\n        if (!outgoingSubscribeRequestMessage.to) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To undefined.\");\n        }\n        const localURI = outgoingSubscribeRequestMessage.from.uri;\n        const remoteURI = outgoingSubscribeRequestMessage.to.uri;\n        // A dialog can also be in the \"early\" state, which occurs when it is\n        // created with a provisional response, and then transition to the\n        // \"confirmed\" state when a 2xx final response arrives.\n        // https://tools.ietf.org/html/rfc3261#section-12\n        const early = false;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    dispose() {\n        super.dispose();\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        this.refreshTimerClear();\n        this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);\n    }\n    get autoRefresh() {\n        return this._autoRefresh;\n    }\n    set autoRefresh(autoRefresh) {\n        this._autoRefresh = true;\n        this.refreshTimerSet();\n    }\n    get subscriptionEvent() {\n        return this._subscriptionEvent;\n    }\n    /** Number of seconds until subscription expires. */\n    get subscriptionExpires() {\n        const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;\n        const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;\n        return Math.max(secondsUntilExpires, 0);\n    }\n    set subscriptionExpires(expires) {\n        if (expires < 0) {\n            throw new Error(\"Expires must be greater than or equal to zero.\");\n        }\n        this._subscriptionExpires = expires;\n        this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n        if (this.autoRefresh) {\n            const refresh = this.subscriptionRefresh;\n            if (refresh === undefined || refresh >= expires) {\n                this.refreshTimerSet();\n            }\n        }\n    }\n    get subscriptionExpiresInitial() {\n        return this._subscriptionExpiresInitial;\n    }\n    /** Number of seconds until subscription auto refresh. */\n    get subscriptionRefresh() {\n        if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {\n            return undefined;\n        }\n        const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;\n        const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;\n        return Math.max(secondsUntilExpires, 0);\n    }\n    get subscriptionState() {\n        return this._subscriptionState;\n    }\n    /**\n     * Receive in dialog request message from transport.\n     * @param message -  The incoming request message.\n     */\n    receiveRequest(message) {\n        this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message.method} request`);\n        // Request within a dialog out of sequence guard.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.sequenceGuard(message)) {\n            this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message.method} request.`);\n            return;\n        }\n        // Request within a dialog common processing.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        super.receiveRequest(message);\n        // Switch on method and then delegate.\n        switch (message.method) {\n            case C.NOTIFY:\n                this.onNotify(message);\n                break;\n            default:\n                this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message.method} request`);\n                this.core.replyStateless(message, { statusCode: 501 });\n                break;\n        }\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n    refresh() {\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const options = {};\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n        options.extraHeaders.push(\"Expires: \" + this.subscriptionExpiresInitial);\n        options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        return this.subscribe(undefined, options);\n    }\n    /**\n     * 4.1.2.2.  Refreshing of Subscriptions\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     * @param delegate - Delegate to handle responses.\n     * @param options - Options bucket.\n     */\n    subscribe(delegate, options = {}) {\n        if (this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n            // FIXME: This needs to be a proper exception\n            throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state \"pending\" or \"active\".`);\n        }\n        this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);\n        const uac = new ReSubscribeUserAgentClient(this, delegate, options);\n        // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        // When refreshing a subscription, a subscriber starts Timer N, set to\n        // 64*T1, when it sends the SUBSCRIBE request.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n        this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n        return uac;\n    }\n    /**\n     * 4.4.1.  Dialog Creation and Termination\n     * A subscription is destroyed after a notifier sends a NOTIFY request\n     * with a \"Subscription-State\" of \"terminated\", or in certain error\n     * situations described elsewhere in this document.\n     * https://tools.ietf.org/html/rfc6665#section-4.4.1\n     */\n    terminate() {\n        this.stateTransition(SubscriptionState.Terminated);\n        this.onTerminated();\n    }\n    /**\n     * 4.1.2.3.  Unsubscribing\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.3\n     */\n    unsubscribe() {\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const options = {};\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n        options.extraHeaders.push(\"Expires: 0\");\n        options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        return this.subscribe(undefined, options);\n    }\n    /**\n     * Handle in dialog NOTIFY requests.\n     * This does not include the first NOTIFY which created the dialog.\n     * @param message - The incoming NOTIFY request message.\n     */\n    onNotify(message) {\n        // If, for some reason, the event package designated in the \"Event\"\n        // header field of the NOTIFY request is not supported, the subscriber\n        // will respond with a 489 (Bad Event) response.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const event = message.parseHeader(\"Event\").event;\n        if (!event || event !== this.subscriptionEvent) {\n            this.core.replyStateless(message, { statusCode: 489 });\n            return;\n        }\n        // In the state diagram, \"Re-subscription times out\" means that an\n        // attempt to refresh or update the subscription using a new SUBSCRIBE\n        // request does not result in a NOTIFY request before the corresponding\n        // Timer N expires.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2\n        if (this.N) {\n            clearTimeout(this.N);\n            this.N = undefined;\n        }\n        // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n        // indicate the status of the subscription.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const subscriptionState = message.parseHeader(\"Subscription-State\");\n        if (!subscriptionState || !subscriptionState.state) {\n            this.core.replyStateless(message, { statusCode: 489 });\n            return;\n        }\n        const state = subscriptionState.state;\n        const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined;\n        // Update our state and expiration.\n        switch (state) {\n            case \"pending\":\n                this.stateTransition(SubscriptionState.Pending, expires);\n                break;\n            case \"active\":\n                this.stateTransition(SubscriptionState.Active, expires);\n                break;\n            case \"terminated\":\n                this.stateTransition(SubscriptionState.Terminated, expires);\n                break;\n            default:\n                this.logger.warn(\"Unrecognized subscription state.\");\n                break;\n        }\n        // Delegate remainder of NOTIFY handling.\n        const uas = new NotifyUserAgentServer(this, message);\n        if (this.delegate && this.delegate.onNotify) {\n            this.delegate.onNotify(uas);\n        }\n        else {\n            uas.accept();\n        }\n    }\n    onRefresh(request) {\n        if (this.delegate && this.delegate.onRefresh) {\n            this.delegate.onRefresh(request);\n        }\n    }\n    onTerminated() {\n        if (this.delegate && this.delegate.onTerminated) {\n            this.delegate.onTerminated();\n        }\n    }\n    refreshTimerClear() {\n        if (this.refreshTimer) {\n            clearTimeout(this.refreshTimer);\n            this.refreshTimer = undefined;\n        }\n    }\n    refreshTimerSet() {\n        this.refreshTimerClear();\n        if (this.autoRefresh && this.subscriptionExpires > 0) {\n            const refresh = this.subscriptionExpires * 900;\n            this._subscriptionRefresh = Math.floor(refresh / 1000);\n            this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);\n            this.refreshTimer = setTimeout(() => {\n                this.refreshTimer = undefined;\n                this._subscriptionRefresh = undefined;\n                this._subscriptionRefreshLastSet = undefined;\n                this.onRefresh(this.refresh());\n            }, refresh);\n        }\n    }\n    stateTransition(newState, newExpires) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);\n        };\n        switch (newState) {\n            case SubscriptionState.Initial:\n                invalidStateTransition();\n                return;\n            case SubscriptionState.NotifyWait:\n                invalidStateTransition();\n                return;\n            case SubscriptionState.Pending:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            case SubscriptionState.Active:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending &&\n                    this.subscriptionState !== SubscriptionState.Active) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            case SubscriptionState.Terminated:\n                if (this.subscriptionState !== SubscriptionState.NotifyWait &&\n                    this.subscriptionState !== SubscriptionState.Pending &&\n                    this.subscriptionState !== SubscriptionState.Active) {\n                    invalidStateTransition();\n                    return;\n                }\n                break;\n            default:\n                invalidStateTransition();\n                return;\n        }\n        // If the \"Subscription-State\" value is \"pending\", the subscription has\n        // been received by the notifier, but there is insufficient policy\n        // information to grant or deny the subscription yet.  If the header\n        // field also contains an \"expires\" parameter, the subscriber SHOULD\n        // take it as the authoritative subscription duration and adjust\n        // accordingly.  No further action is necessary on the part of the\n        // subscriber.  The \"retry-after\" and \"reason\" parameters have no\n        // semantics for \"pending\".\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        if (newState === SubscriptionState.Pending) {\n            if (newExpires) {\n                this.subscriptionExpires = newExpires;\n            }\n        }\n        // If the \"Subscription-State\" header field value is \"active\", it means\n        // that the subscription has been accepted and (in general) has been\n        // authorized.  If the header field also contains an \"expires\"\n        // parameter, the subscriber SHOULD take it as the authoritative\n        // subscription duration and adjust accordingly.  The \"retry-after\" and\n        // \"reason\" parameters have no semantics for \"active\".\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        if (newState === SubscriptionState.Active) {\n            if (newExpires) {\n                this.subscriptionExpires = newExpires;\n            }\n        }\n        // If the \"Subscription-State\" value is \"terminated\", the subscriber\n        // MUST consider the subscription terminated.  The \"expires\" parameter\n        // has no semantics for \"terminated\" -- notifiers SHOULD NOT include an\n        // \"expires\" parameter on a \"Subscription-State\" header field with a\n        // value of \"terminated\", and subscribers MUST ignore any such\n        // parameter, if present.\n        if (newState === SubscriptionState.Terminated) {\n            this.dispose();\n        }\n        this._subscriptionState = newState;\n    }\n    /**\n     * When refreshing a subscription, a subscriber starts Timer N, set to\n     * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires\n     * prior to the receipt of a NOTIFY request, the subscriber considers\n     * the subscription terminated.  If the subscriber receives a success\n     * response to the SUBSCRIBE request that indicates that no NOTIFY\n     * request will be generated -- such as the 204 response defined for use\n     * with the optional extension described in [RFC5839] -- then it MUST\n     * cancel Timer N.\n     * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n     */\n    timerN() {\n        this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);\n        if (this.subscriptionState !== SubscriptionState.Terminated) {\n            this.stateTransition(SubscriptionState.Terminated);\n            this.onTerminated();\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}