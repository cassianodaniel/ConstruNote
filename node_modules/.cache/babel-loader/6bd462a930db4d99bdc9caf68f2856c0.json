{"ast":null,"code":"'use strict';\n\nconst LtxParser = require('ltx/lib/parsers/ltx');\n\nconst Element = require('./Element');\n\nconst EventEmitter = require('events');\n\nconst XMLError = require('./XMLError');\n\nclass Parser extends EventEmitter {\n  constructor() {\n    super();\n    const parser = new LtxParser();\n    this.root = null;\n    this.cursor = null;\n    parser.on('startElement', this.onStartElement.bind(this));\n    parser.on('endElement', this.onEndElement.bind(this));\n    parser.on('text', this.onText.bind(this));\n    this.parser = parser;\n  }\n\n  onStartElement(name, attrs) {\n    const element = new Element(name, attrs);\n    const {\n      root,\n      cursor\n    } = this;\n\n    if (!root) {\n      this.root = element;\n      this.emit('start', element);\n    } else if (cursor !== root) {\n      cursor.append(element);\n    }\n\n    this.cursor = element;\n  }\n\n  onEndElement(name) {\n    const {\n      root,\n      cursor\n    } = this;\n\n    if (name !== cursor.name) {\n      // <foo></bar>\n      this.emit('error', new XMLError(`${cursor.name} must be closed.`));\n      return;\n    }\n\n    if (cursor === root) {\n      this.emit('end', root);\n      return;\n    }\n\n    if (!cursor.parent) {\n      cursor.parent = root;\n      this.emit('element', cursor);\n      this.cursor = root;\n      return;\n    }\n\n    this.cursor = cursor.parent;\n  }\n\n  onText(str) {\n    const {\n      cursor\n    } = this;\n\n    if (!cursor) {\n      this.emit('error', new XMLError(`${str} must be a child.`));\n      return;\n    }\n\n    cursor.t(str);\n  }\n\n  write(data) {\n    this.parser.write(data);\n  }\n\n  end(data) {\n    if (data) {\n      this.parser.write(data);\n    }\n  }\n\n}\n\nParser.XMLError = XMLError;\nmodule.exports = Parser;","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/xml/lib/Parser.js"],"names":["LtxParser","require","Element","EventEmitter","XMLError","Parser","constructor","parser","root","cursor","on","onStartElement","bind","onEndElement","onText","name","attrs","element","emit","append","parent","str","t","write","data","end","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst LtxParser = require('ltx/lib/parsers/ltx')\nconst Element = require('./Element')\nconst EventEmitter = require('events')\nconst XMLError = require('./XMLError')\n\nclass Parser extends EventEmitter {\n  constructor() {\n    super()\n    const parser = new LtxParser()\n    this.root = null\n    this.cursor = null\n\n    parser.on('startElement', this.onStartElement.bind(this))\n    parser.on('endElement', this.onEndElement.bind(this))\n    parser.on('text', this.onText.bind(this))\n\n    this.parser = parser\n  }\n\n  onStartElement(name, attrs) {\n    const element = new Element(name, attrs)\n\n    const {root, cursor} = this\n\n    if (!root) {\n      this.root = element\n      this.emit('start', element)\n    } else if (cursor !== root) {\n      cursor.append(element)\n    }\n\n    this.cursor = element\n  }\n\n  onEndElement(name) {\n    const {root, cursor} = this\n    if (name !== cursor.name) {\n      // <foo></bar>\n      this.emit('error', new XMLError(`${cursor.name} must be closed.`))\n      return\n    }\n\n    if (cursor === root) {\n      this.emit('end', root)\n      return\n    }\n\n    if (!cursor.parent) {\n      cursor.parent = root\n      this.emit('element', cursor)\n      this.cursor = root\n      return\n    }\n\n    this.cursor = cursor.parent\n  }\n\n  onText(str) {\n    const {cursor} = this\n    if (!cursor) {\n      this.emit('error', new XMLError(`${str} must be a child.`))\n      return\n    }\n\n    cursor.t(str)\n  }\n\n  write(data) {\n    this.parser.write(data)\n  }\n\n  end(data) {\n    if (data) {\n      this.parser.write(data)\n    }\n  }\n}\n\nParser.XMLError = XMLError\n\nmodule.exports = Parser\n"]},"metadata":{},"sourceType":"script"}