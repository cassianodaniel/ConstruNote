{"ast":null,"code":"import { Invitation, Inviter, Messager, Registerer, RegistererState, RequestPendingError, SessionState, UserAgent, UserAgentState } from \"../../../api\";\nimport { holdModifier } from \"../modifiers\";\nimport { SessionDescriptionHandler } from \"../session-description-handler\";\nimport { Transport } from \"../transport\";\n/**\n * A simple SIP user class.\n * @remarks\n * While this class is completely functional for simple use cases, it is not intended\n * to provide an interface which is suitable for most (must less all) applications.\n * While this class has many limitations (for example, it only handles a single concurrent session),\n * it is, however, intended to serve as a simple example of using the SIP.js API.\n * @public\n */\n\nexport class SimpleUser {\n  /**\n   * Constructs a new instance of the `SimpleUser` class.\n   * @param server - SIP WebSocket Server URL.\n   * @param options - Options bucket. See {@link SimpleUserOptions} for details.\n   */\n  constructor(server, options = {}) {\n    this.attemptingReconnection = false;\n    this.connectRequested = false;\n    this.held = false;\n    this.registerer = undefined;\n    this.registerRequested = false;\n    this.session = undefined; // Delegate\n\n    this.delegate = options.delegate; // Copy options\n\n    this.options = Object.assign({}, options); // UserAgentOptions\n\n    const userAgentOptions = Object.assign({}, options.userAgentOptions); // Transport\n\n    if (!userAgentOptions.transportConstructor) {\n      userAgentOptions.transportConstructor = Transport;\n    } // TransportOptions\n\n\n    if (!userAgentOptions.transportOptions) {\n      userAgentOptions.transportOptions = {\n        server\n      };\n    } // URI\n\n\n    if (!userAgentOptions.uri) {\n      // If an AOR was provided, convert it to a URI\n      if (options.aor) {\n        const uri = UserAgent.makeURI(options.aor);\n\n        if (!uri) {\n          throw new Error(`Failed to create valid URI from ${options.aor}`);\n        }\n\n        userAgentOptions.uri = uri;\n      }\n    } // UserAgent\n\n\n    this.userAgent = new UserAgent(userAgentOptions); // UserAgent's delegate\n\n    this.userAgent.delegate = {\n      // Handle connection with server established\n      onConnect: () => {\n        this.logger.log(`[${this.id}] Connected`);\n\n        if (this.delegate && this.delegate.onServerConnect) {\n          this.delegate.onServerConnect();\n        }\n\n        if (this.registerer && this.registerRequested) {\n          this.logger.log(`[${this.id}] Registering...`);\n          this.registerer.register().catch(e => {\n            this.logger.error(`[${this.id}] Error occurred registering after connection with server was obtained.`);\n            this.logger.error(e.toString());\n          });\n        }\n      },\n      // Handle connection with server lost\n      onDisconnect: error => {\n        this.logger.log(`[${this.id}] Disconnected`);\n\n        if (this.delegate && this.delegate.onServerDisconnect) {\n          this.delegate.onServerDisconnect(error);\n        }\n\n        if (this.session) {\n          this.logger.log(`[${this.id}] Hanging up...`);\n          this.hangup() // cleanup hung calls\n          .catch(e => {\n            this.logger.error(`[${this.id}] Error occurred hanging up call after connection with server was lost.`);\n            this.logger.error(e.toString());\n          });\n        }\n\n        if (this.registerer) {\n          this.logger.log(`[${this.id}] Unregistering...`);\n          this.registerer.unregister() // cleanup invalid registrations\n          .catch(e => {\n            this.logger.error(`[${this.id}] Error occurred unregistering after connection with server was lost.`);\n            this.logger.error(e.toString());\n          });\n        } // Only attempt to reconnect if network/server dropped the connection.\n\n\n        if (error) {\n          this.attemptReconnection();\n        }\n      },\n      // Handle incoming invitations\n      onInvite: invitation => {\n        this.logger.log(`[${this.id}] Received INVITE`); // Guard against a pre-existing session. This implementation only supports one session at a time.\n        // However an incoming INVITE request may be received at any time and/or while in the process\n        // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n\n        if (this.session) {\n          this.logger.warn(`[${this.id}] Session already in progress, rejecting INVITE...`);\n          invitation.reject().then(() => {\n            this.logger.log(`[${this.id}] Rejected INVITE`);\n          }).catch(error => {\n            this.logger.error(`[${this.id}] Failed to reject INVITE`);\n            this.logger.error(error.toString());\n          });\n          return;\n        } // Use our configured constraints as options for any Inviter created as result of a REFER\n\n\n        const referralInviterOptions = {\n          sessionDescriptionHandlerOptions: {\n            constraints: this.constraints\n          }\n        }; // Initialize our session\n\n        this.initSession(invitation, referralInviterOptions); // Delegate\n\n        if (this.delegate && this.delegate.onCallReceived) {\n          this.delegate.onCallReceived();\n        } else {\n          this.logger.warn(`[${this.id}] No handler available, rejecting INVITE...`);\n          invitation.reject().then(() => {\n            this.logger.log(`[${this.id}] Rejected INVITE`);\n          }).catch(error => {\n            this.logger.error(`[${this.id}] Failed to reject INVITE`);\n            this.logger.error(error.toString());\n          });\n        }\n      },\n      // Handle incoming messages\n      onMessage: message => {\n        message.accept().then(() => {\n          if (this.delegate && this.delegate.onMessageReceived) {\n            this.delegate.onMessageReceived(message.request.body);\n          }\n        });\n      }\n    }; // Use the SIP.js logger\n\n    this.logger = this.userAgent.getLogger(\"sip.SimpleUser\"); // Monitor network connectivity and attempt reconnection when we come online\n\n    window.addEventListener(\"online\", () => {\n      this.logger.log(`[${this.id}] Online`);\n      this.attemptReconnection();\n    });\n  }\n  /**\n   * Instance identifier.\n   * @internal\n   */\n\n\n  get id() {\n    return this.options.userAgentOptions && this.options.userAgentOptions.displayName || \"Anonymous\";\n  }\n  /** The local media stream. Undefined if call not answered. */\n\n\n  get localMediaStream() {\n    var _a;\n\n    const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n    }\n\n    return sdh.localMediaStream;\n  }\n  /** The remote media stream. Undefined if call not answered. */\n\n\n  get remoteMediaStream() {\n    var _a;\n\n    const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n    }\n\n    return sdh.remoteMediaStream;\n  }\n  /**\n   * The local audio track, if available.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  get localAudioTrack() {\n    var _a;\n\n    return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"audio\");\n  }\n  /**\n   * The local video track, if available.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  get localVideoTrack() {\n    var _a;\n\n    return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"video\");\n  }\n  /**\n   * The remote audio track, if available.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  get remoteAudioTrack() {\n    var _a;\n\n    return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"audio\");\n  }\n  /**\n   * The remote video track, if available.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  get remoteVideoTrack() {\n    var _a;\n\n    return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"video\");\n  }\n  /**\n   * Connect.\n   * @remarks\n   * Start the UserAgent's WebSocket Transport.\n   */\n\n\n  connect() {\n    this.logger.log(`[${this.id}] Connecting UserAgent...`);\n    this.connectRequested = true;\n\n    if (this.userAgent.state !== UserAgentState.Started) {\n      return this.userAgent.start();\n    }\n\n    return this.userAgent.reconnect();\n  }\n  /**\n   * Disconnect.\n   * @remarks\n   * Stop the UserAgent's WebSocket Transport.\n   */\n\n\n  disconnect() {\n    this.logger.log(`[${this.id}] Disconnecting UserAgent...`);\n    this.connectRequested = false;\n    return this.userAgent.stop();\n  }\n  /**\n   * Return true if connected.\n   */\n\n\n  isConnected() {\n    return this.userAgent.isConnected();\n  }\n  /**\n   * Start receiving incoming calls.\n   * @remarks\n   * Send a REGISTER request for the UserAgent's AOR.\n   * Resolves when the REGISTER request is sent, otherwise rejects.\n   */\n\n\n  register(registererOptions, registererRegisterOptions) {\n    this.logger.log(`[${this.id}] Registering UserAgent...`);\n    this.registerRequested = true;\n\n    if (!this.registerer) {\n      this.registerer = new Registerer(this.userAgent, registererOptions);\n      this.registerer.stateChange.addListener(state => {\n        switch (state) {\n          case RegistererState.Initial:\n            break;\n\n          case RegistererState.Registered:\n            if (this.delegate && this.delegate.onRegistered) {\n              this.delegate.onRegistered();\n            }\n\n            break;\n\n          case RegistererState.Unregistered:\n            if (this.delegate && this.delegate.onUnregistered) {\n              this.delegate.onUnregistered();\n            }\n\n            break;\n\n          case RegistererState.Terminated:\n            this.registerer = undefined;\n            break;\n\n          default:\n            throw new Error(\"Unknown registerer state.\");\n        }\n      });\n    }\n\n    return this.registerer.register(registererRegisterOptions).then(() => {\n      return;\n    });\n  }\n  /**\n   * Stop receiving incoming calls.\n   * @remarks\n   * Send an un-REGISTER request for the UserAgent's AOR.\n   * Resolves when the un-REGISTER request is sent, otherwise rejects.\n   */\n\n\n  unregister(registererUnregisterOptions) {\n    this.logger.log(`[${this.id}] Unregistering UserAgent...`);\n    this.registerRequested = false;\n\n    if (!this.registerer) {\n      return Promise.resolve();\n    }\n\n    return this.registerer.unregister(registererUnregisterOptions).then(() => {\n      return;\n    });\n  }\n  /**\n   * Make an outgoing call.\n   * @remarks\n   * Send an INVITE request to create a new Session.\n   * Resolves when the INVITE request is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if Session is established.\n   * @param destination - The target destination to call. A SIP address to send the INVITE to.\n   * @param inviterOptions - Optional options for Inviter constructor.\n   * @param inviterInviteOptions - Optional options for Inviter.invite().\n   */\n\n\n  call(destination, inviterOptions, inviterInviteOptions) {\n    this.logger.log(`[${this.id}] Beginning Session...`);\n\n    if (this.session) {\n      return Promise.reject(new Error(\"Session already exists.\"));\n    }\n\n    const target = UserAgent.makeURI(destination);\n\n    if (!target) {\n      return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n    } // Use our configured constraints as InviterOptions if none provided\n\n\n    if (!inviterOptions) {\n      inviterOptions = {};\n    }\n\n    if (!inviterOptions.sessionDescriptionHandlerOptions) {\n      inviterOptions.sessionDescriptionHandlerOptions = {};\n    }\n\n    if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {\n      inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n    } // Create a new Inviter for the outgoing Session\n\n\n    const inviter = new Inviter(this.userAgent, target, inviterOptions); // Send INVITE\n\n    return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(() => {\n      return;\n    });\n  }\n  /**\n   * Hangup a call.\n   * @remarks\n   * Send a BYE request, CANCEL request or reject response to end the current Session.\n   * Resolves when the request/response is sent, otherwise rejects.\n   * Use `onCallTerminated` delegate method to determine if and when call is ended.\n   */\n\n\n  hangup() {\n    this.logger.log(`[${this.id}] Hangup...`);\n    return this.terminate();\n  }\n  /**\n   * Answer an incoming call.\n   * @remarks\n   * Accept an incoming INVITE request creating a new Session.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if and when call is established.\n   * @param invitationAcceptOptions - Optional options for Inviter.accept().\n   */\n\n\n  answer(invitationAcceptOptions) {\n    this.logger.log(`[${this.id}] Accepting Invitation...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    if (!(this.session instanceof Invitation)) {\n      return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n    } // Use our configured constraints as InvitationAcceptOptions if none provided\n\n\n    if (!invitationAcceptOptions) {\n      invitationAcceptOptions = {};\n    }\n\n    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {\n      invitationAcceptOptions.sessionDescriptionHandlerOptions = {};\n    }\n\n    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {\n      invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n    }\n\n    return this.session.accept(invitationAcceptOptions);\n  }\n  /**\n   * Decline an incoming call.\n   * @remarks\n   * Reject an incoming INVITE request.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallTerminated` delegate method to determine if and when call is ended.\n   */\n\n\n  decline() {\n    this.logger.log(`[${this.id}] rejecting Invitation...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    if (!(this.session instanceof Invitation)) {\n      return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n    }\n\n    return this.session.reject();\n  }\n  /**\n   * Hold call\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"hold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  hold() {\n    this.logger.log(`[${this.id}] holding session...`);\n    return this.setHold(true);\n  }\n  /**\n   * Unhold call.\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"unhold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  unhold() {\n    this.logger.log(`[${this.id}] unholding session...`);\n    return this.setHold(false);\n  }\n  /**\n   * Hold state.\n   * @remarks\n   * True if session media is on hold.\n   */\n\n\n  isHeld() {\n    return this.held;\n  }\n  /**\n   * Mute call.\n   * @remarks\n   * Disable sender's media tracks.\n   */\n\n\n  mute() {\n    this.logger.log(`[${this.id}] disabling media tracks...`);\n    this.setMute(true);\n  }\n  /**\n   * Unmute call.\n   * @remarks\n   * Enable sender's media tracks.\n   */\n\n\n  unmute() {\n    this.logger.log(`[${this.id}] enabling media tracks...`);\n    this.setMute(false);\n  }\n  /**\n   * Mute state.\n   * @remarks\n   * True if sender's media track is disabled.\n   */\n\n\n  isMuted() {\n    const track = this.localAudioTrack || this.localVideoTrack;\n    return track ? !track.enabled : false;\n  }\n  /**\n   * Send DTMF.\n   * @remarks\n   * Send an INFO request with content type application/dtmf-relay.\n   * @param tone - Tone to send.\n   */\n\n\n  sendDTMF(tone) {\n    this.logger.log(`[${this.id}] sending DTMF...`); // As RFC 6086 states, sending DTMF via INFO is not standardized...\n    //\n    // Companies have been using INFO messages in order to transport\n    // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n    // proprietary and have not been standardized.\n    // https://tools.ietf.org/html/rfc6086#section-2\n    //\n    // It is however widely supported based on this draft:\n    // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n    // Validate tone\n\n    if (!/^[0-9A-D#*,]$/.exec(tone)) {\n      return Promise.reject(new Error(\"Invalid DTMF tone.\"));\n    }\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    } // The UA MUST populate the \"application/dtmf-relay\" body, as defined\n    // earlier, with the button pressed and the duration it was pressed\n    // for.  Technically, this actually requires the INFO to be generated\n    // when the user *releases* the button, however if the user has still\n    // not released a button after 5 seconds, which is the maximum duration\n    // supported by this mechanism, the UA should generate the INFO at that\n    // time.\n    // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3\n\n\n    this.logger.log(`[${this.id}] Sending DTMF tone: ${tone}`);\n    const dtmf = tone;\n    const duration = 2000;\n    const body = {\n      contentDisposition: \"render\",\n      contentType: \"application/dtmf-relay\",\n      content: \"Signal=\" + dtmf + \"\\r\\nDuration=\" + duration\n    };\n    const requestOptions = {\n      body\n    };\n    return this.session.info({\n      requestOptions\n    }).then(() => {\n      return;\n    });\n  }\n  /**\n   * Send a message.\n   * @remarks\n   * Send a MESSAGE request.\n   * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n   */\n\n\n  message(destination, message) {\n    this.logger.log(`[${this.id}] sending message...`);\n    const target = UserAgent.makeURI(destination);\n\n    if (!target) {\n      return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n    }\n\n    return new Messager(this.userAgent, target, message).message();\n  }\n  /** Media constraints. */\n\n\n  get constraints() {\n    var _a;\n\n    let constraints = {\n      audio: true,\n      video: false\n    }; // default to audio only calls\n\n    if ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.constraints) {\n      constraints = Object.assign({}, this.options.media.constraints);\n    }\n\n    return constraints;\n  }\n  /**\n   * Attempt reconnection up to `maxReconnectionAttempts` times.\n   * @param reconnectionAttempt - Current attempt number.\n   */\n\n\n  attemptReconnection(reconnectionAttempt = 1) {\n    const reconnectionAttempts = this.options.reconnectionAttempts || 3;\n    const reconnectionDelay = this.options.reconnectionDelay || 4;\n\n    if (!this.connectRequested) {\n      this.logger.log(`[${this.id}] Reconnection not currently desired`);\n      return; // If intentionally disconnected, don't reconnect.\n    }\n\n    if (this.attemptingReconnection) {\n      this.logger.log(`[${this.id}] Reconnection attempt already in progress`);\n    }\n\n    if (reconnectionAttempt > reconnectionAttempts) {\n      this.logger.log(`[${this.id}] Reconnection maximum attempts reached`);\n      return;\n    }\n\n    if (reconnectionAttempt === 1) {\n      this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n    } else {\n      this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying in ${reconnectionDelay} seconds`);\n    }\n\n    this.attemptingReconnection = true;\n    setTimeout(() => {\n      if (!this.connectRequested) {\n        this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - aborted`);\n        this.attemptingReconnection = false;\n        return; // If intentionally disconnected, don't reconnect.\n      }\n\n      this.userAgent.reconnect().then(() => {\n        this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n        this.attemptingReconnection = false;\n      }).catch(error => {\n        this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n        this.logger.error(error.message);\n        this.attemptingReconnection = false;\n        this.attemptReconnection(++reconnectionAttempt);\n      });\n    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n  }\n  /** Helper function to remove media from html elements. */\n\n\n  cleanupMedia() {\n    if (this.options.media) {\n      if (this.options.media.local) {\n        if (this.options.media.local.video) {\n          this.options.media.local.video.srcObject = null;\n          this.options.media.local.video.pause();\n        }\n      }\n\n      if (this.options.media.remote) {\n        if (this.options.media.remote.audio) {\n          this.options.media.remote.audio.srcObject = null;\n          this.options.media.remote.audio.pause();\n        }\n\n        if (this.options.media.remote.video) {\n          this.options.media.remote.video.srcObject = null;\n          this.options.media.remote.video.pause();\n        }\n      }\n    }\n  }\n  /** Helper function to enable/disable media tracks. */\n\n\n  enableSenderTracks(enable) {\n    if (!this.session) {\n      throw new Error(\"Session does not exist.\");\n    }\n\n    const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    const peerConnection = sessionDescriptionHandler.peerConnection;\n\n    if (!peerConnection) {\n      throw new Error(\"Peer connection closed.\");\n    }\n\n    peerConnection.getSenders().forEach(sender => {\n      if (sender.track) {\n        sender.track.enabled = enable;\n      }\n    });\n  }\n  /**\n   * Setup session delegate and state change handler.\n   * @param session - Session to setup\n   * @param referralInviterOptions - Options for any Inviter created as result of a REFER.\n   */\n\n\n  initSession(session, referralInviterOptions) {\n    // Set session\n    this.session = session; // Call session created callback\n\n    if (this.delegate && this.delegate.onCallCreated) {\n      this.delegate.onCallCreated();\n    } // Setup session state change handler\n\n\n    this.session.stateChange.addListener(state => {\n      if (this.session !== session) {\n        return; // if our session has changed, just return\n      }\n\n      this.logger.log(`[${this.id}] session state changed to ${state}`);\n\n      switch (state) {\n        case SessionState.Initial:\n          break;\n\n        case SessionState.Establishing:\n          break;\n\n        case SessionState.Established:\n          this.setupLocalMedia();\n          this.setupRemoteMedia();\n\n          if (this.delegate && this.delegate.onCallAnswered) {\n            this.delegate.onCallAnswered();\n          }\n\n          break;\n\n        case SessionState.Terminating: // fall through\n\n        case SessionState.Terminated:\n          this.session = undefined;\n          this.cleanupMedia();\n\n          if (this.delegate && this.delegate.onCallHangup) {\n            this.delegate.onCallHangup();\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown session state.\");\n      }\n    }); // Setup delegate\n\n    this.session.delegate = {\n      onInfo: info => {\n        // As RFC 6086 states, sending DTMF via INFO is not standardized...\n        //\n        // Companies have been using INFO messages in order to transport\n        // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n        // proprietary and have not been standardized.\n        // https://tools.ietf.org/html/rfc6086#section-2\n        //\n        // It is however widely supported based on this draft:\n        // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n        var _a; // FIXME: TODO: We should reject correctly...\n        //\n        // If a UA receives an INFO request associated with an Info Package that\n        // the UA has not indicated willingness to receive, the UA MUST send a\n        // 469 (Bad Info Package) response (see Section 11.6), which contains a\n        // Recv-Info header field with Info Packages for which the UA is willing\n        // to receive INFO requests.\n        // https://tools.ietf.org/html/rfc6086#section-4.2.2\n        // No delegate\n\n\n        if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {\n          info.reject();\n          return;\n        } // Invalid content type\n\n\n        const contentType = info.request.getHeader(\"content-type\");\n\n        if (!contentType || !/^application\\/dtmf-relay/i.exec(contentType)) {\n          info.reject();\n          return;\n        } // Invalid body\n\n\n        const body = info.request.body.split(\"\\r\\n\", 2);\n\n        if (body.length !== 2) {\n          info.reject();\n          return;\n        } // Invalid tone\n\n\n        let tone;\n        const toneRegExp = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n\n        if (toneRegExp.test(body[0])) {\n          tone = body[0].replace(toneRegExp, \"$2\");\n        }\n\n        if (!tone) {\n          info.reject();\n          return;\n        } // Invalid duration\n\n\n        let duration;\n        const durationRegExp = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n        if (durationRegExp.test(body[1])) {\n          duration = parseInt(body[1].replace(durationRegExp, \"$2\"), 10);\n        }\n\n        if (!duration) {\n          info.reject();\n          return;\n        }\n\n        info.accept().then(() => {\n          if (this.delegate && this.delegate.onCallDTMFReceived) {\n            if (!tone || !duration) {\n              throw new Error(\"Tone or duration undefined.\");\n            }\n\n            this.delegate.onCallDTMFReceived(tone, duration);\n          }\n        }).catch(error => {\n          this.logger.error(error.message);\n        });\n      },\n      onRefer: referral => {\n        referral.accept().then(() => this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions)).catch(error => {\n          this.logger.error(error.message);\n        });\n      }\n    };\n  }\n  /** Helper function to init send then send invite. */\n\n\n  sendInvite(inviter, inviterOptions, inviterInviteOptions) {\n    // Initialize our session\n    this.initSession(inviter, inviterOptions); // Send the INVITE\n\n    return inviter.invite(inviterInviteOptions).then(() => {\n      this.logger.log(`[${this.id}] sent INVITE`);\n    });\n  }\n  /**\n   * Puts Session on hold.\n   * @param hold - Hold on if true, off if false.\n   */\n\n\n  setHold(hold) {\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    const session = this.session; // Just resolve if we are already in correct state\n\n    if (this.held === hold) {\n      return Promise.resolve();\n    }\n\n    const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          this.held = hold;\n\n          if (this.delegate && this.delegate.onCallHold) {\n            this.delegate.onCallHold(this.held);\n          }\n        },\n        onReject: () => {\n          this.logger.warn(`[${this.id}] re-invite request was rejected`);\n\n          if (this.delegate && this.delegate.onCallHold) {\n            this.delegate.onCallHold(this.held);\n          }\n        }\n      }\n    }; // Session properties used to pass modifiers to the SessionDescriptionHandler:\n    //\n    // 1) Session.sessionDescriptionHandlerModifiers\n    //    - used in all cases when handling the initial INVITE transaction as either UAC or UAS\n    //    - may be set directly at anytime\n    //    - may optionally be set via constructor option\n    //    - may optionally be set via options passed to Inviter.invite() or Invitation.accept()\n    //\n    // 2) Session.sessionDescriptionHandlerModifiersReInvite\n    //    - used in all cases when handling a re-INVITE transaction as either UAC or UAS\n    //    - may be set directly at anytime\n    //    - may optionally be set via constructor option\n    //    - may optionally be set via options passed to Session.invite()\n    // Set the session's SDH re-INVITE modifiers to produce the appropriate SDP offer to place call on hold\n\n    session.sessionDescriptionHandlerModifiersReInvite = hold ? [holdModifier] : []; // Send re-INVITE\n\n    return this.session.invite(options).then(() => {\n      // Reset the session's SDH re-INVITE modifiers.\n      // Note that if the modifiers are not reset, they will be applied\n      // to the SDP answer as well (which we do not want in this case).\n      session.sessionDescriptionHandlerModifiersReInvite = [];\n      this.enableSenderTracks(!hold); // mute/unmute\n    }).catch(error => {\n      if (error instanceof RequestPendingError) {\n        this.logger.error(`[${this.id}] A hold request is already in progress.`);\n      }\n\n      throw error;\n    });\n  }\n  /**\n   * Puts Session on mute.\n   * @param mute - Mute on if true, off if false.\n   */\n\n\n  setMute(mute) {\n    if (!this.session) {\n      this.logger.warn(`[${this.id}] A session is required to enabled/disable media tracks`);\n      return;\n    }\n\n    if (this.session.state !== SessionState.Established) {\n      this.logger.warn(`[${this.id}] An established session is required to enable/disable media tracks`);\n      return;\n    }\n\n    this.enableSenderTracks(!mute);\n  }\n  /** Helper function to attach local media to html elements. */\n\n\n  setupLocalMedia() {\n    var _a, _b;\n\n    if (!this.session) {\n      throw new Error(\"Session does not exist.\");\n    }\n\n    const mediaElement = (_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.local) === null || _b === void 0 ? void 0 : _b.video;\n\n    if (mediaElement) {\n      const localStream = this.localMediaStream;\n\n      if (!localStream) {\n        throw new Error(\"Local media stream undefiend.\");\n      }\n\n      mediaElement.srcObject = localStream;\n      mediaElement.volume = 0;\n      mediaElement.play().catch(error => {\n        this.logger.error(`[${this.id}] Failed to play local media`);\n        this.logger.error(error.message);\n      });\n    }\n  }\n  /** Helper function to attach remote media to html elements. */\n\n\n  setupRemoteMedia() {\n    var _a, _b, _c, _d;\n\n    if (!this.session) {\n      throw new Error(\"Session does not exist.\");\n    }\n\n    const mediaElement = ((_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.video) || ((_d = (_c = this.options.media) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.audio);\n\n    if (mediaElement) {\n      const remoteStream = this.remoteMediaStream;\n\n      if (!remoteStream) {\n        throw new Error(\"Remote media stream undefiend.\");\n      }\n\n      mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action\n\n      mediaElement.srcObject = remoteStream;\n      mediaElement.play().catch(error => {\n        this.logger.error(`[${this.id}] Failed to play remote media`);\n        this.logger.error(error.message);\n      });\n\n      remoteStream.onaddtrack = () => {\n        this.logger.log(`[${this.id}] Remote media onaddtrack`);\n        mediaElement.load(); // Safari hack, as it doesn't work otheriwse\n\n        mediaElement.play().catch(error => {\n          this.logger.error(`[${this.id}] Failed to play remote media`);\n          this.logger.error(error.message);\n        });\n      };\n    }\n  }\n  /**\n   * End a session.\n   * @remarks\n   * Send a BYE request, CANCEL request or reject response to end the current Session.\n   * Resolves when the request/response is sent, otherwise rejects.\n   * Use `onCallTerminated` delegate method to determine if and when Session is terminated.\n   */\n\n\n  terminate() {\n    this.logger.log(`[${this.id}] Terminating...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    switch (this.session.state) {\n      case SessionState.Initial:\n        if (this.session instanceof Inviter) {\n          return this.session.cancel().then(() => {\n            this.logger.log(`[${this.id}] Inviter never sent INVITE (canceled)`);\n          });\n        } else if (this.session instanceof Invitation) {\n          return this.session.reject().then(() => {\n            this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n          });\n        } else {\n          throw new Error(\"Unknown session type.\");\n        }\n\n      case SessionState.Establishing:\n        if (this.session instanceof Inviter) {\n          return this.session.cancel().then(() => {\n            this.logger.log(`[${this.id}] Inviter canceled (sent CANCEL)`);\n          });\n        } else if (this.session instanceof Invitation) {\n          return this.session.reject().then(() => {\n            this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n          });\n        } else {\n          throw new Error(\"Unknown session type.\");\n        }\n\n      case SessionState.Established:\n        return this.session.bye().then(() => {\n          this.logger.log(`[${this.id}] Session ended (sent BYE)`);\n        });\n\n      case SessionState.Terminating:\n        break;\n\n      case SessionState.Terminated:\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    this.logger.log(`[${this.id}] Terminating in state ${this.session.state}, no action taken`);\n    return Promise.resolve();\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/simple-user/simple-user.js"],"names":["Invitation","Inviter","Messager","Registerer","RegistererState","RequestPendingError","SessionState","UserAgent","UserAgentState","holdModifier","SessionDescriptionHandler","Transport","SimpleUser","constructor","server","options","attemptingReconnection","connectRequested","held","registerer","undefined","registerRequested","session","delegate","Object","assign","userAgentOptions","transportConstructor","transportOptions","uri","aor","makeURI","Error","userAgent","onConnect","logger","log","id","onServerConnect","register","catch","e","error","toString","onDisconnect","onServerDisconnect","hangup","unregister","attemptReconnection","onInvite","invitation","warn","reject","then","referralInviterOptions","sessionDescriptionHandlerOptions","constraints","initSession","onCallReceived","onMessage","message","accept","onMessageReceived","request","body","getLogger","window","addEventListener","displayName","localMediaStream","_a","sdh","sessionDescriptionHandler","remoteMediaStream","localAudioTrack","getTracks","find","track","kind","localVideoTrack","remoteAudioTrack","remoteVideoTrack","connect","state","Started","start","reconnect","disconnect","stop","isConnected","registererOptions","registererRegisterOptions","stateChange","addListener","Initial","Registered","onRegistered","Unregistered","onUnregistered","Terminated","registererUnregisterOptions","Promise","resolve","call","destination","inviterOptions","inviterInviteOptions","target","inviter","sendInvite","terminate","answer","invitationAcceptOptions","decline","hold","setHold","unhold","isHeld","mute","setMute","unmute","isMuted","enabled","sendDTMF","tone","exec","dtmf","duration","contentDisposition","contentType","content","requestOptions","info","audio","video","media","reconnectionAttempt","reconnectionAttempts","reconnectionDelay","setTimeout","cleanupMedia","local","srcObject","pause","remote","enableSenderTracks","enable","peerConnection","getSenders","forEach","sender","onCallCreated","Establishing","Established","setupLocalMedia","setupRemoteMedia","onCallAnswered","Terminating","onCallHangup","onInfo","onCallDTMFReceived","getHeader","split","length","toneRegExp","test","replace","durationRegExp","parseInt","onRefer","referral","makeInviter","invite","requestDelegate","onAccept","onCallHold","onReject","sessionDescriptionHandlerModifiersReInvite","_b","mediaElement","localStream","volume","play","_c","_d","remoteStream","autoplay","onaddtrack","load","cancel","bye"],"mappings":"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","sourcesContent":["import { Invitation, Inviter, Messager, Registerer, RegistererState, RequestPendingError, SessionState, UserAgent, UserAgentState } from \"../../../api\";\nimport { holdModifier } from \"../modifiers\";\nimport { SessionDescriptionHandler } from \"../session-description-handler\";\nimport { Transport } from \"../transport\";\n/**\n * A simple SIP user class.\n * @remarks\n * While this class is completely functional for simple use cases, it is not intended\n * to provide an interface which is suitable for most (must less all) applications.\n * While this class has many limitations (for example, it only handles a single concurrent session),\n * it is, however, intended to serve as a simple example of using the SIP.js API.\n * @public\n */\nexport class SimpleUser {\n    /**\n     * Constructs a new instance of the `SimpleUser` class.\n     * @param server - SIP WebSocket Server URL.\n     * @param options - Options bucket. See {@link SimpleUserOptions} for details.\n     */\n    constructor(server, options = {}) {\n        this.attemptingReconnection = false;\n        this.connectRequested = false;\n        this.held = false;\n        this.registerer = undefined;\n        this.registerRequested = false;\n        this.session = undefined;\n        // Delegate\n        this.delegate = options.delegate;\n        // Copy options\n        this.options = Object.assign({}, options);\n        // UserAgentOptions\n        const userAgentOptions = Object.assign({}, options.userAgentOptions);\n        // Transport\n        if (!userAgentOptions.transportConstructor) {\n            userAgentOptions.transportConstructor = Transport;\n        }\n        // TransportOptions\n        if (!userAgentOptions.transportOptions) {\n            userAgentOptions.transportOptions = {\n                server\n            };\n        }\n        // URI\n        if (!userAgentOptions.uri) {\n            // If an AOR was provided, convert it to a URI\n            if (options.aor) {\n                const uri = UserAgent.makeURI(options.aor);\n                if (!uri) {\n                    throw new Error(`Failed to create valid URI from ${options.aor}`);\n                }\n                userAgentOptions.uri = uri;\n            }\n        }\n        // UserAgent\n        this.userAgent = new UserAgent(userAgentOptions);\n        // UserAgent's delegate\n        this.userAgent.delegate = {\n            // Handle connection with server established\n            onConnect: () => {\n                this.logger.log(`[${this.id}] Connected`);\n                if (this.delegate && this.delegate.onServerConnect) {\n                    this.delegate.onServerConnect();\n                }\n                if (this.registerer && this.registerRequested) {\n                    this.logger.log(`[${this.id}] Registering...`);\n                    this.registerer.register().catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred registering after connection with server was obtained.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n            },\n            // Handle connection with server lost\n            onDisconnect: (error) => {\n                this.logger.log(`[${this.id}] Disconnected`);\n                if (this.delegate && this.delegate.onServerDisconnect) {\n                    this.delegate.onServerDisconnect(error);\n                }\n                if (this.session) {\n                    this.logger.log(`[${this.id}] Hanging up...`);\n                    this.hangup() // cleanup hung calls\n                        .catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred hanging up call after connection with server was lost.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n                if (this.registerer) {\n                    this.logger.log(`[${this.id}] Unregistering...`);\n                    this.registerer\n                        .unregister() // cleanup invalid registrations\n                        .catch((e) => {\n                        this.logger.error(`[${this.id}] Error occurred unregistering after connection with server was lost.`);\n                        this.logger.error(e.toString());\n                    });\n                }\n                // Only attempt to reconnect if network/server dropped the connection.\n                if (error) {\n                    this.attemptReconnection();\n                }\n            },\n            // Handle incoming invitations\n            onInvite: (invitation) => {\n                this.logger.log(`[${this.id}] Received INVITE`);\n                // Guard against a pre-existing session. This implementation only supports one session at a time.\n                // However an incoming INVITE request may be received at any time and/or while in the process\n                // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n                if (this.session) {\n                    this.logger.warn(`[${this.id}] Session already in progress, rejecting INVITE...`);\n                    invitation\n                        .reject()\n                        .then(() => {\n                        this.logger.log(`[${this.id}] Rejected INVITE`);\n                    })\n                        .catch((error) => {\n                        this.logger.error(`[${this.id}] Failed to reject INVITE`);\n                        this.logger.error(error.toString());\n                    });\n                    return;\n                }\n                // Use our configured constraints as options for any Inviter created as result of a REFER\n                const referralInviterOptions = {\n                    sessionDescriptionHandlerOptions: { constraints: this.constraints }\n                };\n                // Initialize our session\n                this.initSession(invitation, referralInviterOptions);\n                // Delegate\n                if (this.delegate && this.delegate.onCallReceived) {\n                    this.delegate.onCallReceived();\n                }\n                else {\n                    this.logger.warn(`[${this.id}] No handler available, rejecting INVITE...`);\n                    invitation\n                        .reject()\n                        .then(() => {\n                        this.logger.log(`[${this.id}] Rejected INVITE`);\n                    })\n                        .catch((error) => {\n                        this.logger.error(`[${this.id}] Failed to reject INVITE`);\n                        this.logger.error(error.toString());\n                    });\n                }\n            },\n            // Handle incoming messages\n            onMessage: (message) => {\n                message.accept().then(() => {\n                    if (this.delegate && this.delegate.onMessageReceived) {\n                        this.delegate.onMessageReceived(message.request.body);\n                    }\n                });\n            }\n        };\n        // Use the SIP.js logger\n        this.logger = this.userAgent.getLogger(\"sip.SimpleUser\");\n        // Monitor network connectivity and attempt reconnection when we come online\n        window.addEventListener(\"online\", () => {\n            this.logger.log(`[${this.id}] Online`);\n            this.attemptReconnection();\n        });\n    }\n    /**\n     * Instance identifier.\n     * @internal\n     */\n    get id() {\n        return (this.options.userAgentOptions && this.options.userAgentOptions.displayName) || \"Anonymous\";\n    }\n    /** The local media stream. Undefined if call not answered. */\n    get localMediaStream() {\n        var _a;\n        const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n        if (!sdh) {\n            return undefined;\n        }\n        if (!(sdh instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n        }\n        return sdh.localMediaStream;\n    }\n    /** The remote media stream. Undefined if call not answered. */\n    get remoteMediaStream() {\n        var _a;\n        const sdh = (_a = this.session) === null || _a === void 0 ? void 0 : _a.sessionDescriptionHandler;\n        if (!sdh) {\n            return undefined;\n        }\n        if (!(sdh instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n        }\n        return sdh.remoteMediaStream;\n    }\n    /**\n     * The local audio track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n    get localAudioTrack() {\n        var _a;\n        return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"audio\");\n    }\n    /**\n     * The local video track, if available.\n     * @deprecated Use localMediaStream and get track from the stream.\n     */\n    get localVideoTrack() {\n        var _a;\n        return (_a = this.localMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"video\");\n    }\n    /**\n     * The remote audio track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n    get remoteAudioTrack() {\n        var _a;\n        return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"audio\");\n    }\n    /**\n     * The remote video track, if available.\n     * @deprecated Use remoteMediaStream and get track from the stream.\n     */\n    get remoteVideoTrack() {\n        var _a;\n        return (_a = this.remoteMediaStream) === null || _a === void 0 ? void 0 : _a.getTracks().find((track) => track.kind === \"video\");\n    }\n    /**\n     * Connect.\n     * @remarks\n     * Start the UserAgent's WebSocket Transport.\n     */\n    connect() {\n        this.logger.log(`[${this.id}] Connecting UserAgent...`);\n        this.connectRequested = true;\n        if (this.userAgent.state !== UserAgentState.Started) {\n            return this.userAgent.start();\n        }\n        return this.userAgent.reconnect();\n    }\n    /**\n     * Disconnect.\n     * @remarks\n     * Stop the UserAgent's WebSocket Transport.\n     */\n    disconnect() {\n        this.logger.log(`[${this.id}] Disconnecting UserAgent...`);\n        this.connectRequested = false;\n        return this.userAgent.stop();\n    }\n    /**\n     * Return true if connected.\n     */\n    isConnected() {\n        return this.userAgent.isConnected();\n    }\n    /**\n     * Start receiving incoming calls.\n     * @remarks\n     * Send a REGISTER request for the UserAgent's AOR.\n     * Resolves when the REGISTER request is sent, otherwise rejects.\n     */\n    register(registererOptions, registererRegisterOptions) {\n        this.logger.log(`[${this.id}] Registering UserAgent...`);\n        this.registerRequested = true;\n        if (!this.registerer) {\n            this.registerer = new Registerer(this.userAgent, registererOptions);\n            this.registerer.stateChange.addListener((state) => {\n                switch (state) {\n                    case RegistererState.Initial:\n                        break;\n                    case RegistererState.Registered:\n                        if (this.delegate && this.delegate.onRegistered) {\n                            this.delegate.onRegistered();\n                        }\n                        break;\n                    case RegistererState.Unregistered:\n                        if (this.delegate && this.delegate.onUnregistered) {\n                            this.delegate.onUnregistered();\n                        }\n                        break;\n                    case RegistererState.Terminated:\n                        this.registerer = undefined;\n                        break;\n                    default:\n                        throw new Error(\"Unknown registerer state.\");\n                }\n            });\n        }\n        return this.registerer.register(registererRegisterOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Stop receiving incoming calls.\n     * @remarks\n     * Send an un-REGISTER request for the UserAgent's AOR.\n     * Resolves when the un-REGISTER request is sent, otherwise rejects.\n     */\n    unregister(registererUnregisterOptions) {\n        this.logger.log(`[${this.id}] Unregistering UserAgent...`);\n        this.registerRequested = false;\n        if (!this.registerer) {\n            return Promise.resolve();\n        }\n        return this.registerer.unregister(registererUnregisterOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Make an outgoing call.\n     * @remarks\n     * Send an INVITE request to create a new Session.\n     * Resolves when the INVITE request is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if Session is established.\n     * @param destination - The target destination to call. A SIP address to send the INVITE to.\n     * @param inviterOptions - Optional options for Inviter constructor.\n     * @param inviterInviteOptions - Optional options for Inviter.invite().\n     */\n    call(destination, inviterOptions, inviterInviteOptions) {\n        this.logger.log(`[${this.id}] Beginning Session...`);\n        if (this.session) {\n            return Promise.reject(new Error(\"Session already exists.\"));\n        }\n        const target = UserAgent.makeURI(destination);\n        if (!target) {\n            return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n        }\n        // Use our configured constraints as InviterOptions if none provided\n        if (!inviterOptions) {\n            inviterOptions = {};\n        }\n        if (!inviterOptions.sessionDescriptionHandlerOptions) {\n            inviterOptions.sessionDescriptionHandlerOptions = {};\n        }\n        if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {\n            inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n        }\n        // Create a new Inviter for the outgoing Session\n        const inviter = new Inviter(this.userAgent, target, inviterOptions);\n        // Send INVITE\n        return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(() => {\n            return;\n        });\n    }\n    /**\n     * Hangup a call.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n    hangup() {\n        this.logger.log(`[${this.id}] Hangup...`);\n        return this.terminate();\n    }\n    /**\n     * Answer an incoming call.\n     * @remarks\n     * Accept an incoming INVITE request creating a new Session.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallAnswered` delegate method to determine if and when call is established.\n     * @param invitationAcceptOptions - Optional options for Inviter.accept().\n     */\n    answer(invitationAcceptOptions) {\n        this.logger.log(`[${this.id}] Accepting Invitation...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        if (!(this.session instanceof Invitation)) {\n            return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n        }\n        // Use our configured constraints as InvitationAcceptOptions if none provided\n        if (!invitationAcceptOptions) {\n            invitationAcceptOptions = {};\n        }\n        if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {\n            invitationAcceptOptions.sessionDescriptionHandlerOptions = {};\n        }\n        if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {\n            invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n        }\n        return this.session.accept(invitationAcceptOptions);\n    }\n    /**\n     * Decline an incoming call.\n     * @remarks\n     * Reject an incoming INVITE request.\n     * Resolves with the response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when call is ended.\n     */\n    decline() {\n        this.logger.log(`[${this.id}] rejecting Invitation...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        if (!(this.session instanceof Invitation)) {\n            return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n        }\n        return this.session.reject();\n    }\n    /**\n     * Hold call\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"hold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n    hold() {\n        this.logger.log(`[${this.id}] holding session...`);\n        return this.setHold(true);\n    }\n    /**\n     * Unhold call.\n     * @remarks\n     * Send a re-INVITE with new offer indicating \"unhold\".\n     * Resolves when the re-INVITE request is sent, otherwise rejects.\n     * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n     * See: https://tools.ietf.org/html/rfc6337\n     */\n    unhold() {\n        this.logger.log(`[${this.id}] unholding session...`);\n        return this.setHold(false);\n    }\n    /**\n     * Hold state.\n     * @remarks\n     * True if session media is on hold.\n     */\n    isHeld() {\n        return this.held;\n    }\n    /**\n     * Mute call.\n     * @remarks\n     * Disable sender's media tracks.\n     */\n    mute() {\n        this.logger.log(`[${this.id}] disabling media tracks...`);\n        this.setMute(true);\n    }\n    /**\n     * Unmute call.\n     * @remarks\n     * Enable sender's media tracks.\n     */\n    unmute() {\n        this.logger.log(`[${this.id}] enabling media tracks...`);\n        this.setMute(false);\n    }\n    /**\n     * Mute state.\n     * @remarks\n     * True if sender's media track is disabled.\n     */\n    isMuted() {\n        const track = this.localAudioTrack || this.localVideoTrack;\n        return track ? !track.enabled : false;\n    }\n    /**\n     * Send DTMF.\n     * @remarks\n     * Send an INFO request with content type application/dtmf-relay.\n     * @param tone - Tone to send.\n     */\n    sendDTMF(tone) {\n        this.logger.log(`[${this.id}] sending DTMF...`);\n        // As RFC 6086 states, sending DTMF via INFO is not standardized...\n        //\n        // Companies have been using INFO messages in order to transport\n        // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n        // proprietary and have not been standardized.\n        // https://tools.ietf.org/html/rfc6086#section-2\n        //\n        // It is however widely supported based on this draft:\n        // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n        // Validate tone\n        if (!/^[0-9A-D#*,]$/.exec(tone)) {\n            return Promise.reject(new Error(\"Invalid DTMF tone.\"));\n        }\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        // The UA MUST populate the \"application/dtmf-relay\" body, as defined\n        // earlier, with the button pressed and the duration it was pressed\n        // for.  Technically, this actually requires the INFO to be generated\n        // when the user *releases* the button, however if the user has still\n        // not released a button after 5 seconds, which is the maximum duration\n        // supported by this mechanism, the UA should generate the INFO at that\n        // time.\n        // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3\n        this.logger.log(`[${this.id}] Sending DTMF tone: ${tone}`);\n        const dtmf = tone;\n        const duration = 2000;\n        const body = {\n            contentDisposition: \"render\",\n            contentType: \"application/dtmf-relay\",\n            content: \"Signal=\" + dtmf + \"\\r\\nDuration=\" + duration\n        };\n        const requestOptions = { body };\n        return this.session.info({ requestOptions }).then(() => {\n            return;\n        });\n    }\n    /**\n     * Send a message.\n     * @remarks\n     * Send a MESSAGE request.\n     * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n     */\n    message(destination, message) {\n        this.logger.log(`[${this.id}] sending message...`);\n        const target = UserAgent.makeURI(destination);\n        if (!target) {\n            return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n        }\n        return new Messager(this.userAgent, target, message).message();\n    }\n    /** Media constraints. */\n    get constraints() {\n        var _a;\n        let constraints = { audio: true, video: false }; // default to audio only calls\n        if ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.constraints) {\n            constraints = Object.assign({}, this.options.media.constraints);\n        }\n        return constraints;\n    }\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n    attemptReconnection(reconnectionAttempt = 1) {\n        const reconnectionAttempts = this.options.reconnectionAttempts || 3;\n        const reconnectionDelay = this.options.reconnectionDelay || 4;\n        if (!this.connectRequested) {\n            this.logger.log(`[${this.id}] Reconnection not currently desired`);\n            return; // If intentionally disconnected, don't reconnect.\n        }\n        if (this.attemptingReconnection) {\n            this.logger.log(`[${this.id}] Reconnection attempt already in progress`);\n        }\n        if (reconnectionAttempt > reconnectionAttempts) {\n            this.logger.log(`[${this.id}] Reconnection maximum attempts reached`);\n            return;\n        }\n        if (reconnectionAttempt === 1) {\n            this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n        }\n        else {\n            this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying in ${reconnectionDelay} seconds`);\n        }\n        this.attemptingReconnection = true;\n        setTimeout(() => {\n            if (!this.connectRequested) {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - aborted`);\n                this.attemptingReconnection = false;\n                return; // If intentionally disconnected, don't reconnect.\n            }\n            this.userAgent\n                .reconnect()\n                .then(() => {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n                this.attemptingReconnection = false;\n            })\n                .catch((error) => {\n                this.logger.log(`[${this.id}] Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n                this.logger.error(error.message);\n                this.attemptingReconnection = false;\n                this.attemptReconnection(++reconnectionAttempt);\n            });\n        }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /** Helper function to remove media from html elements. */\n    cleanupMedia() {\n        if (this.options.media) {\n            if (this.options.media.local) {\n                if (this.options.media.local.video) {\n                    this.options.media.local.video.srcObject = null;\n                    this.options.media.local.video.pause();\n                }\n            }\n            if (this.options.media.remote) {\n                if (this.options.media.remote.audio) {\n                    this.options.media.remote.audio.srcObject = null;\n                    this.options.media.remote.audio.pause();\n                }\n                if (this.options.media.remote.video) {\n                    this.options.media.remote.video.srcObject = null;\n                    this.options.media.remote.video.pause();\n                }\n            }\n        }\n    }\n    /** Helper function to enable/disable media tracks. */\n    enableSenderTracks(enable) {\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n        }\n        const peerConnection = sessionDescriptionHandler.peerConnection;\n        if (!peerConnection) {\n            throw new Error(\"Peer connection closed.\");\n        }\n        peerConnection.getSenders().forEach((sender) => {\n            if (sender.track) {\n                sender.track.enabled = enable;\n            }\n        });\n    }\n    /**\n     * Setup session delegate and state change handler.\n     * @param session - Session to setup\n     * @param referralInviterOptions - Options for any Inviter created as result of a REFER.\n     */\n    initSession(session, referralInviterOptions) {\n        // Set session\n        this.session = session;\n        // Call session created callback\n        if (this.delegate && this.delegate.onCallCreated) {\n            this.delegate.onCallCreated();\n        }\n        // Setup session state change handler\n        this.session.stateChange.addListener((state) => {\n            if (this.session !== session) {\n                return; // if our session has changed, just return\n            }\n            this.logger.log(`[${this.id}] session state changed to ${state}`);\n            switch (state) {\n                case SessionState.Initial:\n                    break;\n                case SessionState.Establishing:\n                    break;\n                case SessionState.Established:\n                    this.setupLocalMedia();\n                    this.setupRemoteMedia();\n                    if (this.delegate && this.delegate.onCallAnswered) {\n                        this.delegate.onCallAnswered();\n                    }\n                    break;\n                case SessionState.Terminating:\n                // fall through\n                case SessionState.Terminated:\n                    this.session = undefined;\n                    this.cleanupMedia();\n                    if (this.delegate && this.delegate.onCallHangup) {\n                        this.delegate.onCallHangup();\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unknown session state.\");\n            }\n        });\n        // Setup delegate\n        this.session.delegate = {\n            onInfo: (info) => {\n                // As RFC 6086 states, sending DTMF via INFO is not standardized...\n                //\n                // Companies have been using INFO messages in order to transport\n                // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n                // proprietary and have not been standardized.\n                // https://tools.ietf.org/html/rfc6086#section-2\n                //\n                // It is however widely supported based on this draft:\n                // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n                var _a;\n                // FIXME: TODO: We should reject correctly...\n                //\n                // If a UA receives an INFO request associated with an Info Package that\n                // the UA has not indicated willingness to receive, the UA MUST send a\n                // 469 (Bad Info Package) response (see Section 11.6), which contains a\n                // Recv-Info header field with Info Packages for which the UA is willing\n                // to receive INFO requests.\n                // https://tools.ietf.org/html/rfc6086#section-4.2.2\n                // No delegate\n                if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {\n                    info.reject();\n                    return;\n                }\n                // Invalid content type\n                const contentType = info.request.getHeader(\"content-type\");\n                if (!contentType || !/^application\\/dtmf-relay/i.exec(contentType)) {\n                    info.reject();\n                    return;\n                }\n                // Invalid body\n                const body = info.request.body.split(\"\\r\\n\", 2);\n                if (body.length !== 2) {\n                    info.reject();\n                    return;\n                }\n                // Invalid tone\n                let tone;\n                const toneRegExp = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n                if (toneRegExp.test(body[0])) {\n                    tone = body[0].replace(toneRegExp, \"$2\");\n                }\n                if (!tone) {\n                    info.reject();\n                    return;\n                }\n                // Invalid duration\n                let duration;\n                const durationRegExp = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n                if (durationRegExp.test(body[1])) {\n                    duration = parseInt(body[1].replace(durationRegExp, \"$2\"), 10);\n                }\n                if (!duration) {\n                    info.reject();\n                    return;\n                }\n                info\n                    .accept()\n                    .then(() => {\n                    if (this.delegate && this.delegate.onCallDTMFReceived) {\n                        if (!tone || !duration) {\n                            throw new Error(\"Tone or duration undefined.\");\n                        }\n                        this.delegate.onCallDTMFReceived(tone, duration);\n                    }\n                })\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                });\n            },\n            onRefer: (referral) => {\n                referral\n                    .accept()\n                    .then(() => this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions))\n                    .catch((error) => {\n                    this.logger.error(error.message);\n                });\n            }\n        };\n    }\n    /** Helper function to init send then send invite. */\n    sendInvite(inviter, inviterOptions, inviterInviteOptions) {\n        // Initialize our session\n        this.initSession(inviter, inviterOptions);\n        // Send the INVITE\n        return inviter.invite(inviterInviteOptions).then(() => {\n            this.logger.log(`[${this.id}] sent INVITE`);\n        });\n    }\n    /**\n     * Puts Session on hold.\n     * @param hold - Hold on if true, off if false.\n     */\n    setHold(hold) {\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        const session = this.session;\n        // Just resolve if we are already in correct state\n        if (this.held === hold) {\n            return Promise.resolve();\n        }\n        const sessionDescriptionHandler = this.session.sessionDescriptionHandler;\n        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n            throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n        }\n        const options = {\n            requestDelegate: {\n                onAccept: () => {\n                    this.held = hold;\n                    if (this.delegate && this.delegate.onCallHold) {\n                        this.delegate.onCallHold(this.held);\n                    }\n                },\n                onReject: () => {\n                    this.logger.warn(`[${this.id}] re-invite request was rejected`);\n                    if (this.delegate && this.delegate.onCallHold) {\n                        this.delegate.onCallHold(this.held);\n                    }\n                }\n            }\n        };\n        // Session properties used to pass modifiers to the SessionDescriptionHandler:\n        //\n        // 1) Session.sessionDescriptionHandlerModifiers\n        //    - used in all cases when handling the initial INVITE transaction as either UAC or UAS\n        //    - may be set directly at anytime\n        //    - may optionally be set via constructor option\n        //    - may optionally be set via options passed to Inviter.invite() or Invitation.accept()\n        //\n        // 2) Session.sessionDescriptionHandlerModifiersReInvite\n        //    - used in all cases when handling a re-INVITE transaction as either UAC or UAS\n        //    - may be set directly at anytime\n        //    - may optionally be set via constructor option\n        //    - may optionally be set via options passed to Session.invite()\n        // Set the session's SDH re-INVITE modifiers to produce the appropriate SDP offer to place call on hold\n        session.sessionDescriptionHandlerModifiersReInvite = hold ? [holdModifier] : [];\n        // Send re-INVITE\n        return this.session\n            .invite(options)\n            .then(() => {\n            // Reset the session's SDH re-INVITE modifiers.\n            // Note that if the modifiers are not reset, they will be applied\n            // to the SDP answer as well (which we do not want in this case).\n            session.sessionDescriptionHandlerModifiersReInvite = [];\n            this.enableSenderTracks(!hold); // mute/unmute\n        })\n            .catch((error) => {\n            if (error instanceof RequestPendingError) {\n                this.logger.error(`[${this.id}] A hold request is already in progress.`);\n            }\n            throw error;\n        });\n    }\n    /**\n     * Puts Session on mute.\n     * @param mute - Mute on if true, off if false.\n     */\n    setMute(mute) {\n        if (!this.session) {\n            this.logger.warn(`[${this.id}] A session is required to enabled/disable media tracks`);\n            return;\n        }\n        if (this.session.state !== SessionState.Established) {\n            this.logger.warn(`[${this.id}] An established session is required to enable/disable media tracks`);\n            return;\n        }\n        this.enableSenderTracks(!mute);\n    }\n    /** Helper function to attach local media to html elements. */\n    setupLocalMedia() {\n        var _a, _b;\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const mediaElement = (_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.local) === null || _b === void 0 ? void 0 : _b.video;\n        if (mediaElement) {\n            const localStream = this.localMediaStream;\n            if (!localStream) {\n                throw new Error(\"Local media stream undefiend.\");\n            }\n            mediaElement.srcObject = localStream;\n            mediaElement.volume = 0;\n            mediaElement.play().catch((error) => {\n                this.logger.error(`[${this.id}] Failed to play local media`);\n                this.logger.error(error.message);\n            });\n        }\n    }\n    /** Helper function to attach remote media to html elements. */\n    setupRemoteMedia() {\n        var _a, _b, _c, _d;\n        if (!this.session) {\n            throw new Error(\"Session does not exist.\");\n        }\n        const mediaElement = ((_b = (_a = this.options.media) === null || _a === void 0 ? void 0 : _a.remote) === null || _b === void 0 ? void 0 : _b.video) || ((_d = (_c = this.options.media) === null || _c === void 0 ? void 0 : _c.remote) === null || _d === void 0 ? void 0 : _d.audio);\n        if (mediaElement) {\n            const remoteStream = this.remoteMediaStream;\n            if (!remoteStream) {\n                throw new Error(\"Remote media stream undefiend.\");\n            }\n            mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action\n            mediaElement.srcObject = remoteStream;\n            mediaElement.play().catch((error) => {\n                this.logger.error(`[${this.id}] Failed to play remote media`);\n                this.logger.error(error.message);\n            });\n            remoteStream.onaddtrack = () => {\n                this.logger.log(`[${this.id}] Remote media onaddtrack`);\n                mediaElement.load(); // Safari hack, as it doesn't work otheriwse\n                mediaElement.play().catch((error) => {\n                    this.logger.error(`[${this.id}] Failed to play remote media`);\n                    this.logger.error(error.message);\n                });\n            };\n        }\n    }\n    /**\n     * End a session.\n     * @remarks\n     * Send a BYE request, CANCEL request or reject response to end the current Session.\n     * Resolves when the request/response is sent, otherwise rejects.\n     * Use `onCallTerminated` delegate method to determine if and when Session is terminated.\n     */\n    terminate() {\n        this.logger.log(`[${this.id}] Terminating...`);\n        if (!this.session) {\n            return Promise.reject(new Error(\"Session does not exist.\"));\n        }\n        switch (this.session.state) {\n            case SessionState.Initial:\n                if (this.session instanceof Inviter) {\n                    return this.session.cancel().then(() => {\n                        this.logger.log(`[${this.id}] Inviter never sent INVITE (canceled)`);\n                    });\n                }\n                else if (this.session instanceof Invitation) {\n                    return this.session.reject().then(() => {\n                        this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n                    });\n                }\n                else {\n                    throw new Error(\"Unknown session type.\");\n                }\n            case SessionState.Establishing:\n                if (this.session instanceof Inviter) {\n                    return this.session.cancel().then(() => {\n                        this.logger.log(`[${this.id}] Inviter canceled (sent CANCEL)`);\n                    });\n                }\n                else if (this.session instanceof Invitation) {\n                    return this.session.reject().then(() => {\n                        this.logger.log(`[${this.id}] Invitation rejected (sent 480)`);\n                    });\n                }\n                else {\n                    throw new Error(\"Unknown session type.\");\n                }\n            case SessionState.Established:\n                return this.session.bye().then(() => {\n                    this.logger.log(`[${this.id}] Session ended (sent BYE)`);\n                });\n            case SessionState.Terminating:\n                break;\n            case SessionState.Terminated:\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        this.logger.log(`[${this.id}] Terminating in state ${this.session.state}, no action taken`);\n        return Promise.resolve();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}