{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { C, fromBodyLegacy, SubscriptionState as SubscriptionDialogState } from \"../core\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Notification } from \"./notification\";\nimport { Subscription } from \"./subscription\";\nimport { SubscriptionState } from \"./subscription-state\";\n/**\n * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).\n *\n * @remarks\n * This is (more or less) an implementation of a \"subscriber\" as\n * defined in RFC 6665 \"SIP-Specific Event Notifications\".\n * https://tools.ietf.org/html/rfc6665\n *\n * @example\n * ```ts\n * // Create a new subscriber.\n * const targetURI = new URI(\"sip\", \"alice\", \"example.com\");\n * const eventType = \"example-name\"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml\n * const subscriber = new Subscriber(userAgent, targetURI, eventType);\n *\n * // Add delegate to handle event notifications.\n * subscriber.delegate = {\n *   onNotify: (notification: Notification) => {\n *     // handle notification here\n *   }\n * };\n *\n * // Monitor subscription state changes.\n * subscriber.stateChange.addListener((newState: SubscriptionState) => {\n *   if (newState === SubscriptionState.Terminated) {\n *     // handle state change here\n *   }\n * });\n *\n * // Attempt to establish the subscription\n * subscriber.subscribe();\n *\n * // Sometime later when done with subscription\n * subscriber.unsubscribe();\n * ```\n *\n * @public\n */\n\nexport var Subscriber = /*#__PURE__*/function (_Subscription) {\n  _inherits(Subscriber, _Subscription);\n\n  var _super = _createSuper(Subscriber);\n\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - The request URI identifying the subscribed event.\n   * @param eventType - The event type identifying the subscribed event.\n   * @param options - Options bucket. See {@link SubscriberOptions} for details.\n   */\n  function Subscriber(userAgent, targetURI, eventType) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, Subscriber);\n\n    _this = _super.call(this, userAgent, options);\n    _this.body = undefined;\n    _this.logger = userAgent.getLogger(\"sip.Subscriber\");\n\n    if (options.body) {\n      _this.body = {\n        body: options.body,\n        contentType: options.contentType ? options.contentType : \"application/sdp\"\n      };\n    }\n\n    _this.targetURI = targetURI; // Subscription event\n\n    _this.event = eventType; // Subscription expires\n\n    if (options.expires === undefined) {\n      _this.expires = 3600;\n    } else if (typeof options.expires !== \"number\") {\n      // pre-typescript type guard\n      _this.logger.warn(\"Option \\\"expires\\\" must be a number. Using default of 3600.\");\n\n      _this.expires = 3600;\n    } else {\n      _this.expires = options.expires;\n    } // Subscription extra headers\n\n\n    _this.extraHeaders = (options.extraHeaders || []).slice(); // Subscription context.\n\n    _this.subscriberRequest = _this.initSubscriberRequest();\n    _this.outgoingRequestMessage = _this.subscriberRequest.message; // Add to UserAgent's collection\n\n    _this.id = _this.outgoingRequestMessage.callId + _this.outgoingRequestMessage.from.parameters.tag + _this.event;\n    _this._userAgent._subscriptions[_this.id] = _assertThisInitialized(_this);\n    return _this;\n  }\n  /**\n   * Destructor.\n   * @internal\n   */\n\n\n  _createClass(Subscriber, [{\n    key: \"dispose\",\n    value: function dispose() {\n      var _this2 = this;\n\n      if (this.disposed) {\n        return Promise.resolve();\n      }\n\n      this.logger.log(\"Subscription \".concat(this.id, \" in state \").concat(this.state, \" is being disposed\")); // Remove from the user agent's subscription collection\n\n      delete this._userAgent._subscriptions[this.id]; // Clear timers\n\n      if (this.retryAfterTimer) {\n        clearTimeout(this.retryAfterTimer);\n        this.retryAfterTimer = undefined;\n      } // Dispose subscriber request\n\n\n      this.subscriberRequest.dispose(); // Make sure to dispose of our parent, then unsubscribe the\n      // subscription dialog (if need be) and resolve when it has terminated.\n\n      return _get(_getPrototypeOf(Subscriber.prototype), \"dispose\", this).call(this).then(function () {\n        // If we have never subscribed there is nothing to wait on.\n        // If we are already transitioned to terminated there is no need to unsubscribe again.\n        if (_this2.state !== SubscriptionState.Subscribed) {\n          return;\n        }\n\n        if (!_this2._dialog) {\n          throw new Error(\"Dialog undefined.\");\n        }\n\n        if (_this2._dialog.subscriptionState === SubscriptionDialogState.Pending || _this2._dialog.subscriptionState === SubscriptionDialogState.Active) {\n          var dialog = _this2._dialog; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n          return new Promise(function (resolve, reject) {\n            dialog.delegate = {\n              onTerminated: function onTerminated() {\n                return resolve();\n              }\n            };\n            dialog.unsubscribe();\n          });\n        }\n      });\n    }\n    /**\n     * Subscribe to event notifications.\n     *\n     * @remarks\n     * Send an initial SUBSCRIBE request if no subscription as been established.\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      switch (this.subscriberRequest.state) {\n        case SubscriptionDialogState.Initial:\n          // we can end up here when retrying so only state transition if in SubscriptionState.Initial state\n          if (this.state === SubscriptionState.Initial) {\n            this.stateTransition(SubscriptionState.NotifyWait);\n          }\n\n          this.subscriberRequest.subscribe().then(function (result) {\n            if (result.success) {\n              if (result.success.subscription) {\n                _this3._dialog = result.success.subscription;\n                _this3._dialog.delegate = {\n                  onNotify: function onNotify(request) {\n                    return _this3.onNotify(request);\n                  },\n                  onRefresh: function onRefresh(request) {\n                    return _this3.onRefresh(request);\n                  },\n                  onTerminated: function onTerminated() {\n                    // If a call to unsubscribe will state transition to SubscriptionState.Terminated,\n                    // but we can end up here after that if the NOTIFY never arrives and timer N fires.\n                    if (_this3.state !== SubscriptionState.Terminated) {\n                      _this3.stateTransition(SubscriptionState.Terminated);\n                    }\n                  }\n                };\n              }\n\n              _this3.onNotify(result.success.request);\n            } else if (result.failure) {\n              _this3.unsubscribe();\n            }\n          });\n          break;\n\n        case SubscriptionDialogState.NotifyWait:\n          break;\n\n        case SubscriptionDialogState.Pending:\n          break;\n\n        case SubscriptionDialogState.Active:\n          if (this._dialog) {\n            var request = this._dialog.refresh();\n\n            request.delegate = {\n              onAccept: function onAccept(response) {\n                return _this3.onAccepted(response);\n              },\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              onRedirect: function onRedirect(response) {\n                return _this3.unsubscribe();\n              },\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              onReject: function onReject(response) {\n                return _this3.unsubscribe();\n              }\n            };\n          }\n\n          break;\n\n        case SubscriptionDialogState.Terminated:\n          break;\n\n        default:\n          break;\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * {@inheritDoc Subscription.unsubscribe}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.disposed) {\n        return Promise.resolve();\n      }\n\n      switch (this.subscriberRequest.state) {\n        case SubscriptionDialogState.Initial:\n          break;\n\n        case SubscriptionDialogState.NotifyWait:\n          break;\n\n        case SubscriptionDialogState.Pending:\n          if (this._dialog) {\n            this._dialog.unsubscribe(); // responses intentionally ignored\n\n          }\n\n          break;\n\n        case SubscriptionDialogState.Active:\n          if (this._dialog) {\n            this._dialog.unsubscribe(); // responses intentionally ignored\n\n          }\n\n          break;\n\n        case SubscriptionDialogState.Terminated:\n          break;\n\n        default:\n          throw new Error(\"Unknown state.\");\n      }\n\n      this.stateTransition(SubscriptionState.Terminated);\n      return Promise.resolve();\n    }\n    /**\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     * @deprecated Use `subscribe` instead.\n     * @internal\n     */\n\n  }, {\n    key: \"_refresh\",\n    value: function _refresh() {\n      if (this.subscriberRequest.state === SubscriptionDialogState.Active) {\n        return this.subscribe();\n      }\n\n      return Promise.resolve();\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"onAccepted\",\n    value: function onAccepted(response) {// NOTE: If you think you should do something with this response,\n      // please make sure you understand what it is you are doing and why.\n      // Per the RFC, the first NOTIFY is all that actually matters.\n    }\n    /** @internal */\n\n  }, {\n    key: \"onNotify\",\n    value: function onNotify(request) {\n      var _this4 = this;\n\n      // If we've set state to done, no further processing should take place\n      // and we are only interested in cleaning up after the appropriate NOTIFY.\n      if (this.disposed) {\n        request.accept();\n        return;\n      } // State transition if needed.\n\n\n      if (this.state !== SubscriptionState.Subscribed) {\n        this.stateTransition(SubscriptionState.Subscribed);\n      } // Delegate notification.\n\n\n      if (this.delegate && this.delegate.onNotify) {\n        var notification = new Notification(request);\n        this.delegate.onNotify(notification);\n      } else {\n        request.accept();\n      } //  If the \"Subscription-State\" value is SubscriptionState.Terminated, the subscriber\n      //  MUST consider the subscription terminated.  The \"expires\" parameter\n      //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an\n      //  \"expires\" parameter on a \"Subscription-State\" header field with a\n      //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such\n      //  parameter, if present.  If a reason code is present, the client\n      //  should behave as described below.  If no reason code or an unknown\n      //  reason code is present, the client MAY attempt to re-subscribe at any\n      //  time (unless a \"retry-after\" parameter is present, in which case the\n      //  client SHOULD NOT attempt re-subscription until after the number of\n      //  seconds specified by the \"retry-after\" parameter).  The reason codes\n      //  defined by this document are:\n      // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n      var subscriptionState = request.message.parseHeader(\"Subscription-State\");\n\n      if (subscriptionState && subscriptionState.state) {\n        switch (subscriptionState.state) {\n          case \"terminated\":\n            if (subscriptionState.reason) {\n              this.logger.log(\"Terminated subscription with reason \".concat(subscriptionState.reason));\n\n              switch (subscriptionState.reason) {\n                case \"deactivated\":\n                case \"timeout\":\n                  this.initSubscriberRequest();\n                  this.subscribe();\n                  return;\n\n                case \"probation\":\n                case \"giveup\":\n                  this.initSubscriberRequest();\n\n                  if (subscriptionState.params && subscriptionState.params[\"retry-after\"]) {\n                    this.retryAfterTimer = setTimeout(function () {\n                      _this4.subscribe();\n                    }, subscriptionState.params[\"retry-after\"]);\n                  } else {\n                    this.subscribe();\n                  }\n\n                  return;\n\n                case \"rejected\":\n                case \"noresource\":\n                case \"invariant\":\n                  break;\n              }\n            }\n\n            this.unsubscribe();\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"onRefresh\",\n    value: function onRefresh(request) {\n      var _this5 = this;\n\n      request.delegate = {\n        onAccept: function onAccept(response) {\n          return _this5.onAccepted(response);\n        }\n      };\n    }\n  }, {\n    key: \"initSubscriberRequest\",\n    value: function initSubscriberRequest() {\n      var _this6 = this;\n\n      var options = {\n        extraHeaders: this.extraHeaders,\n        body: this.body ? fromBodyLegacy(this.body) : undefined\n      }; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n      this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);\n      this.subscriberRequest.delegate = {\n        onAccept: function onAccept(response) {\n          return _this6.onAccepted(response);\n        }\n      };\n      return this.subscriberRequest;\n    }\n  }]);\n\n  return Subscriber;\n}(Subscription);\n\nvar SubscriberRequest = /*#__PURE__*/function () {\n  function SubscriberRequest(core, target, event, expires, options, delegate) {\n    _classCallCheck(this, SubscriberRequest);\n\n    this.core = core;\n    this.target = target;\n    this.event = event;\n    this.expires = expires;\n    this.subscribed = false;\n    this.logger = core.loggerFactory.getLogger(\"sip.Subscriber\");\n    this.delegate = delegate;\n    var allowHeader = \"Allow: \" + AllowedMethods.toString();\n    var extraHeaders = (options && options.extraHeaders || []).slice();\n    extraHeaders.push(allowHeader);\n    extraHeaders.push(\"Event: \" + this.event);\n    extraHeaders.push(\"Expires: \" + this.expires);\n    extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    var body = options && options.body;\n    this.message = core.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);\n  }\n  /** Destructor. */\n\n\n  _createClass(SubscriberRequest, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.request) {\n        this.request.waitNotifyStop();\n        this.request.dispose();\n        this.request = undefined;\n      }\n    }\n    /** Subscription state. */\n\n  }, {\n    key: \"subscribe\",\n\n    /**\n     * Establish subscription.\n     * @param options Options bucket.\n     */\n    value: function subscribe() {\n      var _this7 = this;\n\n      if (this.subscribed) {\n        return Promise.reject(new Error(\"Not in initial state. Did you call subscribe more than once?\"));\n      }\n\n      this.subscribed = true;\n      return new Promise(function (resolve) {\n        if (!_this7.message) {\n          throw new Error(\"Message undefined.\");\n        }\n\n        _this7.request = _this7.core.subscribe(_this7.message, {\n          // This SUBSCRIBE request will be confirmed with a final response.\n          // 200-class responses indicate that the subscription has been accepted\n          // and that a NOTIFY request will be sent immediately.\n          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n          onAccept: function onAccept(response) {\n            if (_this7.delegate && _this7.delegate.onAccept) {\n              _this7.delegate.onAccept(response);\n            }\n          },\n          // Due to the potential for out-of-order messages, packet loss, and\n          // forking, the subscriber MUST be prepared to receive NOTIFY requests\n          // before the SUBSCRIBE transaction has completed.\n          // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n          onNotify: function onNotify(requestWithSubscription) {\n            _this7.subscription = requestWithSubscription.subscription;\n\n            if (_this7.subscription) {\n              _this7.subscription.autoRefresh = true;\n            }\n\n            resolve({\n              success: requestWithSubscription\n            });\n          },\n          // If this Timer N expires prior to the receipt of a NOTIFY request,\n          // the subscriber considers the subscription failed, and cleans up\n          // any state associated with the subscription attempt.\n          // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n          onNotifyTimeout: function onNotifyTimeout() {\n            resolve({\n              failure: {}\n            });\n          },\n          // This SUBSCRIBE request will be confirmed with a final response.\n          // Non-200-class final responses indicate that no subscription or new\n          // dialog usage has been created, and no subsequent NOTIFY request will\n          // be sent.\n          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n          onRedirect: function onRedirect(response) {\n            resolve({\n              failure: {\n                response: response\n              }\n            });\n          },\n          // This SUBSCRIBE request will be confirmed with a final response.\n          // Non-200-class final responses indicate that no subscription or new\n          // dialog usage has been created, and no subsequent NOTIFY request will\n          // be sent.\n          // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n          onReject: function onReject(response) {\n            resolve({\n              failure: {\n                response: response\n              }\n            });\n          }\n        });\n      });\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      if (this.subscription) {\n        return this.subscription.subscriptionState;\n      } else if (this.subscribed) {\n        return SubscriptionDialogState.NotifyWait;\n      } else {\n        return SubscriptionDialogState.Initial;\n      }\n    }\n  }]);\n\n  return SubscriberRequest;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/subscriber.js"],"names":["C","fromBodyLegacy","SubscriptionState","SubscriptionDialogState","AllowedMethods","Notification","Subscription","Subscriber","userAgent","targetURI","eventType","options","body","undefined","logger","getLogger","contentType","event","expires","warn","extraHeaders","slice","subscriberRequest","initSubscriberRequest","outgoingRequestMessage","message","id","callId","from","parameters","tag","_userAgent","_subscriptions","disposed","Promise","resolve","log","state","retryAfterTimer","clearTimeout","dispose","then","Subscribed","_dialog","Error","subscriptionState","Pending","Active","dialog","reject","delegate","onTerminated","unsubscribe","Initial","stateTransition","NotifyWait","subscribe","result","success","subscription","onNotify","request","onRefresh","Terminated","failure","refresh","onAccept","response","onAccepted","onRedirect","onReject","accept","notification","parseHeader","reason","params","setTimeout","SubscriberRequest","userAgentCore","core","target","subscribed","loggerFactory","allowHeader","toString","push","configuration","contact","makeOutgoingRequestMessage","SUBSCRIBE","aor","waitNotifyStop","requestWithSubscription","autoRefresh","onNotifyTimeout"],"mappings":"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","sourcesContent":["import { C, fromBodyLegacy, SubscriptionState as SubscriptionDialogState } from \"../core\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods\";\nimport { Notification } from \"./notification\";\nimport { Subscription } from \"./subscription\";\nimport { SubscriptionState } from \"./subscription-state\";\n/**\n * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).\n *\n * @remarks\n * This is (more or less) an implementation of a \"subscriber\" as\n * defined in RFC 6665 \"SIP-Specific Event Notifications\".\n * https://tools.ietf.org/html/rfc6665\n *\n * @example\n * ```ts\n * // Create a new subscriber.\n * const targetURI = new URI(\"sip\", \"alice\", \"example.com\");\n * const eventType = \"example-name\"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml\n * const subscriber = new Subscriber(userAgent, targetURI, eventType);\n *\n * // Add delegate to handle event notifications.\n * subscriber.delegate = {\n *   onNotify: (notification: Notification) => {\n *     // handle notification here\n *   }\n * };\n *\n * // Monitor subscription state changes.\n * subscriber.stateChange.addListener((newState: SubscriptionState) => {\n *   if (newState === SubscriptionState.Terminated) {\n *     // handle state change here\n *   }\n * });\n *\n * // Attempt to establish the subscription\n * subscriber.subscribe();\n *\n * // Sometime later when done with subscription\n * subscriber.unsubscribe();\n * ```\n *\n * @public\n */\nexport class Subscriber extends Subscription {\n    /**\n     * Constructor.\n     * @param userAgent - User agent. See {@link UserAgent} for details.\n     * @param targetURI - The request URI identifying the subscribed event.\n     * @param eventType - The event type identifying the subscribed event.\n     * @param options - Options bucket. See {@link SubscriberOptions} for details.\n     */\n    constructor(userAgent, targetURI, eventType, options = {}) {\n        super(userAgent, options);\n        this.body = undefined;\n        this.logger = userAgent.getLogger(\"sip.Subscriber\");\n        if (options.body) {\n            this.body = {\n                body: options.body,\n                contentType: options.contentType ? options.contentType : \"application/sdp\"\n            };\n        }\n        this.targetURI = targetURI;\n        // Subscription event\n        this.event = eventType;\n        // Subscription expires\n        if (options.expires === undefined) {\n            this.expires = 3600;\n        }\n        else if (typeof options.expires !== \"number\") {\n            // pre-typescript type guard\n            this.logger.warn(`Option \"expires\" must be a number. Using default of 3600.`);\n            this.expires = 3600;\n        }\n        else {\n            this.expires = options.expires;\n        }\n        // Subscription extra headers\n        this.extraHeaders = (options.extraHeaders || []).slice();\n        // Subscription context.\n        this.subscriberRequest = this.initSubscriberRequest();\n        this.outgoingRequestMessage = this.subscriberRequest.message;\n        // Add to UserAgent's collection\n        this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event;\n        this._userAgent._subscriptions[this.id] = this;\n    }\n    /**\n     * Destructor.\n     * @internal\n     */\n    dispose() {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`);\n        // Remove from the user agent's subscription collection\n        delete this._userAgent._subscriptions[this.id];\n        // Clear timers\n        if (this.retryAfterTimer) {\n            clearTimeout(this.retryAfterTimer);\n            this.retryAfterTimer = undefined;\n        }\n        // Dispose subscriber request\n        this.subscriberRequest.dispose();\n        // Make sure to dispose of our parent, then unsubscribe the\n        // subscription dialog (if need be) and resolve when it has terminated.\n        return super.dispose().then(() => {\n            // If we have never subscribed there is nothing to wait on.\n            // If we are already transitioned to terminated there is no need to unsubscribe again.\n            if (this.state !== SubscriptionState.Subscribed) {\n                return;\n            }\n            if (!this._dialog) {\n                throw new Error(\"Dialog undefined.\");\n            }\n            if (this._dialog.subscriptionState === SubscriptionDialogState.Pending ||\n                this._dialog.subscriptionState === SubscriptionDialogState.Active) {\n                const dialog = this._dialog;\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                return new Promise((resolve, reject) => {\n                    dialog.delegate = {\n                        onTerminated: () => resolve()\n                    };\n                    dialog.unsubscribe();\n                });\n            }\n        });\n    }\n    /**\n     * Subscribe to event notifications.\n     *\n     * @remarks\n     * Send an initial SUBSCRIBE request if no subscription as been established.\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    subscribe(options = {}) {\n        switch (this.subscriberRequest.state) {\n            case SubscriptionDialogState.Initial:\n                // we can end up here when retrying so only state transition if in SubscriptionState.Initial state\n                if (this.state === SubscriptionState.Initial) {\n                    this.stateTransition(SubscriptionState.NotifyWait);\n                }\n                this.subscriberRequest.subscribe().then((result) => {\n                    if (result.success) {\n                        if (result.success.subscription) {\n                            this._dialog = result.success.subscription;\n                            this._dialog.delegate = {\n                                onNotify: (request) => this.onNotify(request),\n                                onRefresh: (request) => this.onRefresh(request),\n                                onTerminated: () => {\n                                    // If a call to unsubscribe will state transition to SubscriptionState.Terminated,\n                                    // but we can end up here after that if the NOTIFY never arrives and timer N fires.\n                                    if (this.state !== SubscriptionState.Terminated) {\n                                        this.stateTransition(SubscriptionState.Terminated);\n                                    }\n                                }\n                            };\n                        }\n                        this.onNotify(result.success.request);\n                    }\n                    else if (result.failure) {\n                        this.unsubscribe();\n                    }\n                });\n                break;\n            case SubscriptionDialogState.NotifyWait:\n                break;\n            case SubscriptionDialogState.Pending:\n                break;\n            case SubscriptionDialogState.Active:\n                if (this._dialog) {\n                    const request = this._dialog.refresh();\n                    request.delegate = {\n                        onAccept: (response) => this.onAccepted(response),\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        onRedirect: (response) => this.unsubscribe(),\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        onReject: (response) => this.unsubscribe()\n                    };\n                }\n                break;\n            case SubscriptionDialogState.Terminated:\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve();\n    }\n    /**\n     * {@inheritDoc Subscription.unsubscribe}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    unsubscribe(options = {}) {\n        if (this.disposed) {\n            return Promise.resolve();\n        }\n        switch (this.subscriberRequest.state) {\n            case SubscriptionDialogState.Initial:\n                break;\n            case SubscriptionDialogState.NotifyWait:\n                break;\n            case SubscriptionDialogState.Pending:\n                if (this._dialog) {\n                    this._dialog.unsubscribe();\n                    // responses intentionally ignored\n                }\n                break;\n            case SubscriptionDialogState.Active:\n                if (this._dialog) {\n                    this._dialog.unsubscribe();\n                    // responses intentionally ignored\n                }\n                break;\n            case SubscriptionDialogState.Terminated:\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        this.stateTransition(SubscriptionState.Terminated);\n        return Promise.resolve();\n    }\n    /**\n     * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n     * @deprecated Use `subscribe` instead.\n     * @internal\n     */\n    _refresh() {\n        if (this.subscriberRequest.state === SubscriptionDialogState.Active) {\n            return this.subscribe();\n        }\n        return Promise.resolve();\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onAccepted(response) {\n        // NOTE: If you think you should do something with this response,\n        // please make sure you understand what it is you are doing and why.\n        // Per the RFC, the first NOTIFY is all that actually matters.\n    }\n    /** @internal */\n    onNotify(request) {\n        // If we've set state to done, no further processing should take place\n        // and we are only interested in cleaning up after the appropriate NOTIFY.\n        if (this.disposed) {\n            request.accept();\n            return;\n        }\n        // State transition if needed.\n        if (this.state !== SubscriptionState.Subscribed) {\n            this.stateTransition(SubscriptionState.Subscribed);\n        }\n        // Delegate notification.\n        if (this.delegate && this.delegate.onNotify) {\n            const notification = new Notification(request);\n            this.delegate.onNotify(notification);\n        }\n        else {\n            request.accept();\n        }\n        //  If the \"Subscription-State\" value is SubscriptionState.Terminated, the subscriber\n        //  MUST consider the subscription terminated.  The \"expires\" parameter\n        //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an\n        //  \"expires\" parameter on a \"Subscription-State\" header field with a\n        //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such\n        //  parameter, if present.  If a reason code is present, the client\n        //  should behave as described below.  If no reason code or an unknown\n        //  reason code is present, the client MAY attempt to re-subscribe at any\n        //  time (unless a \"retry-after\" parameter is present, in which case the\n        //  client SHOULD NOT attempt re-subscription until after the number of\n        //  seconds specified by the \"retry-after\" parameter).  The reason codes\n        //  defined by this document are:\n        // https://tools.ietf.org/html/rfc6665#section-4.1.3\n        const subscriptionState = request.message.parseHeader(\"Subscription-State\");\n        if (subscriptionState && subscriptionState.state) {\n            switch (subscriptionState.state) {\n                case \"terminated\":\n                    if (subscriptionState.reason) {\n                        this.logger.log(`Terminated subscription with reason ${subscriptionState.reason}`);\n                        switch (subscriptionState.reason) {\n                            case \"deactivated\":\n                            case \"timeout\":\n                                this.initSubscriberRequest();\n                                this.subscribe();\n                                return;\n                            case \"probation\":\n                            case \"giveup\":\n                                this.initSubscriberRequest();\n                                if (subscriptionState.params && subscriptionState.params[\"retry-after\"]) {\n                                    this.retryAfterTimer = setTimeout(() => {\n                                        this.subscribe();\n                                    }, subscriptionState.params[\"retry-after\"]);\n                                }\n                                else {\n                                    this.subscribe();\n                                }\n                                return;\n                            case \"rejected\":\n                            case \"noresource\":\n                            case \"invariant\":\n                                break;\n                        }\n                    }\n                    this.unsubscribe();\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    /** @internal */\n    onRefresh(request) {\n        request.delegate = {\n            onAccept: (response) => this.onAccepted(response)\n        };\n    }\n    initSubscriberRequest() {\n        const options = {\n            extraHeaders: this.extraHeaders,\n            body: this.body ? fromBodyLegacy(this.body) : undefined\n        };\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);\n        this.subscriberRequest.delegate = {\n            onAccept: (response) => this.onAccepted(response)\n        };\n        return this.subscriberRequest;\n    }\n}\nclass SubscriberRequest {\n    constructor(core, target, event, expires, options, delegate) {\n        this.core = core;\n        this.target = target;\n        this.event = event;\n        this.expires = expires;\n        this.subscribed = false;\n        this.logger = core.loggerFactory.getLogger(\"sip.Subscriber\");\n        this.delegate = delegate;\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        const extraHeaders = ((options && options.extraHeaders) || []).slice();\n        extraHeaders.push(allowHeader);\n        extraHeaders.push(\"Event: \" + this.event);\n        extraHeaders.push(\"Expires: \" + this.expires);\n        extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n        const body = options && options.body;\n        this.message = core.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);\n    }\n    /** Destructor. */\n    dispose() {\n        if (this.request) {\n            this.request.waitNotifyStop();\n            this.request.dispose();\n            this.request = undefined;\n        }\n    }\n    /** Subscription state. */\n    get state() {\n        if (this.subscription) {\n            return this.subscription.subscriptionState;\n        }\n        else if (this.subscribed) {\n            return SubscriptionDialogState.NotifyWait;\n        }\n        else {\n            return SubscriptionDialogState.Initial;\n        }\n    }\n    /**\n     * Establish subscription.\n     * @param options Options bucket.\n     */\n    subscribe() {\n        if (this.subscribed) {\n            return Promise.reject(new Error(\"Not in initial state. Did you call subscribe more than once?\"));\n        }\n        this.subscribed = true;\n        return new Promise((resolve) => {\n            if (!this.message) {\n                throw new Error(\"Message undefined.\");\n            }\n            this.request = this.core.subscribe(this.message, {\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // 200-class responses indicate that the subscription has been accepted\n                // and that a NOTIFY request will be sent immediately.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onAccept: (response) => {\n                    if (this.delegate && this.delegate.onAccept) {\n                        this.delegate.onAccept(response);\n                    }\n                },\n                // Due to the potential for out-of-order messages, packet loss, and\n                // forking, the subscriber MUST be prepared to receive NOTIFY requests\n                // before the SUBSCRIBE transaction has completed.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n                onNotify: (requestWithSubscription) => {\n                    this.subscription = requestWithSubscription.subscription;\n                    if (this.subscription) {\n                        this.subscription.autoRefresh = true;\n                    }\n                    resolve({ success: requestWithSubscription });\n                },\n                // If this Timer N expires prior to the receipt of a NOTIFY request,\n                // the subscriber considers the subscription failed, and cleans up\n                // any state associated with the subscription attempt.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n                onNotifyTimeout: () => {\n                    resolve({ failure: {} });\n                },\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // Non-200-class final responses indicate that no subscription or new\n                // dialog usage has been created, and no subsequent NOTIFY request will\n                // be sent.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onRedirect: (response) => {\n                    resolve({ failure: { response } });\n                },\n                // This SUBSCRIBE request will be confirmed with a final response.\n                // Non-200-class final responses indicate that no subscription or new\n                // dialog usage has been created, and no subsequent NOTIFY request will\n                // be sent.\n                // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n                onReject: (response) => {\n                    resolve({ failure: { response } });\n                }\n            });\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}