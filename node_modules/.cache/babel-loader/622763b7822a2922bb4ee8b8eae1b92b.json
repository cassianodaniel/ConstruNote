{"ast":null,"code":"import { C, NameAddrHeader } from \"../messages\";\n/**\n * Dialog.\n * @remarks\n * A key concept for a user agent is that of a dialog.  A dialog\n * represents a peer-to-peer SIP relationship between two user agents\n * that persists for some time.  The dialog facilitates sequencing of\n * messages between the user agents and proper routing of requests\n * between both of them.  The dialog represents a context in which to\n * interpret SIP messages.\n * https://tools.ietf.org/html/rfc3261#section-12\n * @public\n */\n\nexport class Dialog {\n  /**\n   * Dialog constructor.\n   * @param core - User agent core.\n   * @param dialogState - Initial dialog state.\n   */\n  constructor(core, dialogState) {\n    this.core = core;\n    this.dialogState = dialogState;\n    this.core.dialogs.set(this.id, this);\n  }\n  /**\n   * When a UAC receives a response that establishes a dialog, it\n   * constructs the state of the dialog.  This state MUST be maintained\n   * for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.2\n   * @param outgoingRequestMessage - Outgoing request message for dialog.\n   * @param incomingResponseMessage - Incoming response message creating dialog.\n   */\n\n\n  static initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {\n    // If the request was sent over TLS, and the Request-URI contained a\n    // SIPS URI, the \"secure\" flag is set to TRUE.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n    const secure = false; // FIXME: Currently no support for TLS.\n    // The route set MUST be set to the list of URIs in the Record-Route\n    // header field from the response, taken in reverse order and preserving\n    // all URI parameters.  If no Record-Route header field is present in\n    // the response, the route set MUST be set to the empty set.  This route\n    // set, even if empty, overrides any pre-existing route set for future\n    // requests in this dialog.  The remote target MUST be set to the URI\n    // from the Contact header field of the response.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const routeSet = incomingResponseMessage.getHeaders(\"record-route\").reverse(); // When a UAS responds to a request with a response that establishes a\n    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n    // header field values from the request into the response (including the\n    // URIs, URI parameters, and any Record-Route header field parameters,\n    // whether they are known or unknown to the UAS) and MUST maintain the\n    // order of those values.  The UAS MUST add a Contact header field to\n    // the response.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n    const contact = incomingResponseMessage.parseHeader(\"contact\");\n\n    if (!contact) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Contact undefined.\");\n    }\n\n    if (!(contact instanceof NameAddrHeader)) {\n      throw new Error(\"Contact not instance of NameAddrHeader.\");\n    }\n\n    const remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence\n    // number in the CSeq header field of the request.  The remote sequence\n    // number MUST be empty (it is established when the remote UA sends a\n    // request within the dialog).  The call identifier component of the\n    // dialog ID MUST be set to the value of the Call-ID in the request.\n    // The local tag component of the dialog ID MUST be set to the tag in\n    // the From field in the request, and the remote tag component of the\n    // dialog ID MUST be set to the tag in the To field of the response.  A\n    // UAC MUST be prepared to receive a response without a tag in the To\n    // field, in which case the tag is considered to have a value of null.\n    //\n    //    This is to maintain backwards compatibility with RFC 2543, which\n    //    did not mandate To tags.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const localSequenceNumber = outgoingRequestMessage.cseq;\n    const remoteSequenceNumber = undefined;\n    const callId = outgoingRequestMessage.callId;\n    const localTag = outgoingRequestMessage.fromTag;\n    const remoteTag = incomingResponseMessage.toTag;\n\n    if (!callId) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Call id undefined.\");\n    }\n\n    if (!localTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From tag undefined.\");\n    }\n\n    if (!remoteTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n    } // The remote URI MUST be set to the URI in the To field, and the local\n    // URI MUST be set to the URI in the From field.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n\n    if (!outgoingRequestMessage.from) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From undefined.\");\n    }\n\n    if (!outgoingRequestMessage.to) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To undefined.\");\n    }\n\n    const localURI = outgoingRequestMessage.from.uri;\n    const remoteURI = outgoingRequestMessage.to.uri; // A dialog can also be in the \"early\" state, which occurs when it is\n    // created with a provisional response, and then transition to the\n    // \"confirmed\" state when a 2xx final response arrives.\n    // https://tools.ietf.org/html/rfc3261#section-12\n\n    if (!incomingResponseMessage.statusCode) {\n      throw new Error(\"Incoming response status code undefined.\");\n    }\n\n    const early = incomingResponseMessage.statusCode < 200 ? true : false;\n    const dialogState = {\n      id: callId + localTag + remoteTag,\n      early,\n      callId,\n      localTag,\n      remoteTag,\n      localSequenceNumber,\n      remoteSequenceNumber,\n      localURI,\n      remoteURI,\n      remoteTarget,\n      routeSet,\n      secure\n    };\n    return dialogState;\n  }\n  /**\n   * The UAS then constructs the state of the dialog.  This state MUST be\n   * maintained for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.1\n   * @param incomingRequestMessage - Incoming request message creating dialog.\n   * @param toTag - Tag in the To field in the response to the incoming request.\n   */\n\n\n  static initialDialogStateForUserAgentServer(incomingRequestMessage, toTag, early = false) {\n    // If the request arrived over TLS, and the Request-URI contained a SIPS\n    // URI, the \"secure\" flag is set to TRUE.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n    const secure = false; // FIXME: Currently no support for TLS.\n    // The route set MUST be set to the list of URIs in the Record-Route\n    // header field from the request, taken in order and preserving all URI\n    // parameters.  If no Record-Route header field is present in the\n    // request, the route set MUST be set to the empty set.  This route set,\n    // even if empty, overrides any pre-existing route set for future\n    // requests in this dialog.  The remote target MUST be set to the URI\n    // from the Contact header field of the request.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n    const routeSet = incomingRequestMessage.getHeaders(\"record-route\");\n    const contact = incomingRequestMessage.parseHeader(\"contact\");\n\n    if (!contact) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Contact undefined.\");\n    }\n\n    if (!(contact instanceof NameAddrHeader)) {\n      throw new Error(\"Contact not instance of NameAddrHeader.\");\n    }\n\n    const remoteTarget = contact.uri; // The remote sequence number MUST be set to the value of the sequence\n    // number in the CSeq header field of the request.  The local sequence\n    // number MUST be empty.  The call identifier component of the dialog ID\n    // MUST be set to the value of the Call-ID in the request.  The local\n    // tag component of the dialog ID MUST be set to the tag in the To field\n    // in the response to the request (which always includes a tag), and the\n    // remote tag component of the dialog ID MUST be set to the tag from the\n    // From field in the request.  A UAS MUST be prepared to receive a\n    // request without a tag in the From field, in which case the tag is\n    // considered to have a value of null.\n    //\n    //    This is to maintain backwards compatibility with RFC 2543, which\n    //    did not mandate From tags.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n    const remoteSequenceNumber = incomingRequestMessage.cseq;\n    const localSequenceNumber = undefined;\n    const callId = incomingRequestMessage.callId;\n    const localTag = toTag;\n    const remoteTag = incomingRequestMessage.fromTag; // The remote URI MUST be set to the URI in the From field, and the\n    // local URI MUST be set to the URI in the To field.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n    const remoteURI = incomingRequestMessage.from.uri;\n    const localURI = incomingRequestMessage.to.uri;\n    const dialogState = {\n      id: callId + localTag + remoteTag,\n      early,\n      callId,\n      localTag,\n      remoteTag,\n      localSequenceNumber,\n      remoteSequenceNumber,\n      localURI,\n      remoteURI,\n      remoteTarget,\n      routeSet,\n      secure\n    };\n    return dialogState;\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    this.core.dialogs.delete(this.id);\n  }\n  /**\n   * A dialog is identified at each UA with a dialog ID, which consists of\n   * a Call-ID value, a local tag and a remote tag.  The dialog ID at each\n   * UA involved in the dialog is not the same.  Specifically, the local\n   * tag at one UA is identical to the remote tag at the peer UA.  The\n   * tags are opaque tokens that facilitate the generation of unique\n   * dialog IDs.\n   * https://tools.ietf.org/html/rfc3261#section-12\n   */\n\n\n  get id() {\n    return this.dialogState.id;\n  }\n  /**\n   * A dialog can also be in the \"early\" state, which occurs when it is\n   * created with a provisional response, and then it transition to the\n   * \"confirmed\" state when a 2xx final response received or is sent.\n   *\n   * Note: RFC 3261 is concise on when a dialog is \"confirmed\", but it\n   * can be a point of confusion if an INVITE dialog is \"confirmed\" after\n   * a 2xx is sent or after receiving the ACK for the 2xx response.\n   * With careful reading it can be inferred a dialog is always is\n   * \"confirmed\" when the 2xx is sent (regardless of type of dialog).\n   * However a INVITE dialog does have additional considerations\n   * when it is confirmed but an ACK has not yet been received (in\n   * particular with regard to a callee sending BYE requests).\n   */\n\n\n  get early() {\n    return this.dialogState.early;\n  }\n  /** Call identifier component of the dialog id. */\n\n\n  get callId() {\n    return this.dialogState.callId;\n  }\n  /** Local tag component of the dialog id. */\n\n\n  get localTag() {\n    return this.dialogState.localTag;\n  }\n  /** Remote tag component of the dialog id. */\n\n\n  get remoteTag() {\n    return this.dialogState.remoteTag;\n  }\n  /** Local sequence number (used to order requests from the UA to its peer). */\n\n\n  get localSequenceNumber() {\n    return this.dialogState.localSequenceNumber;\n  }\n  /** Remote sequence number (used to order requests from its peer to the UA). */\n\n\n  get remoteSequenceNumber() {\n    return this.dialogState.remoteSequenceNumber;\n  }\n  /** Local URI. */\n\n\n  get localURI() {\n    return this.dialogState.localURI;\n  }\n  /** Remote URI. */\n\n\n  get remoteURI() {\n    return this.dialogState.remoteURI;\n  }\n  /** Remote target. */\n\n\n  get remoteTarget() {\n    return this.dialogState.remoteTarget;\n  }\n  /**\n   * Route set, which is an ordered list of URIs. The route set is the\n   * list of servers that need to be traversed to send a request to the peer.\n   */\n\n\n  get routeSet() {\n    return this.dialogState.routeSet;\n  }\n  /**\n   * If the request was sent over TLS, and the Request-URI contained\n   * a SIPS URI, the \"secure\" flag is set to true. *NOT IMPLEMENTED*\n   */\n\n\n  get secure() {\n    return this.dialogState.secure;\n  }\n  /** The user agent core servicing this dialog. */\n\n\n  get userAgentCore() {\n    return this.core;\n  }\n  /** Confirm the dialog. Only matters if dialog is currently early. */\n\n\n  confirm() {\n    this.dialogState.early = false;\n  }\n  /**\n   * Requests sent within a dialog, as any other requests, are atomic.  If\n   * a particular request is accepted by the UAS, all the state changes\n   * associated with it are performed.  If the request is rejected, none\n   * of the state changes are performed.\n   *\n   *    Note that some requests, such as INVITEs, affect several pieces of\n   *    state.\n   *\n   * https://tools.ietf.org/html/rfc3261#section-12.2.2\n   * @param message - Incoming request message within this dialog.\n   */\n\n\n  receiveRequest(message) {\n    // ACK guard.\n    // By convention, the handling of ACKs is the responsibility\n    // the particular dialog implementation. For example, see SessionDialog.\n    // Furthermore, ACKs have same sequence number as the associated INVITE.\n    if (message.method === C.ACK) {\n      return;\n    } // If the remote sequence number was not empty, but the sequence number\n    // of the request is lower than the remote sequence number, the request\n    // is out of order and MUST be rejected with a 500 (Server Internal\n    // Error) response.  If the remote sequence number was not empty, and\n    // the sequence number of the request is greater than the remote\n    // sequence number, the request is in order.  It is possible for the\n    // CSeq sequence number to be higher than the remote sequence number by\n    // more than one.  This is not an error condition, and a UAS SHOULD be\n    // prepared to receive and process requests with CSeq values more than\n    // one higher than the previous received request.  The UAS MUST then set\n    // the remote sequence number to the value of the sequence number in the\n    // CSeq header field value in the request.\n    //\n    //    If a proxy challenges a request generated by the UAC, the UAC has\n    //    to resubmit the request with credentials.  The resubmitted request\n    //    will have a new CSeq number.  The UAS will never see the first\n    //    request, and thus, it will notice a gap in the CSeq number space.\n    //    Such a gap does not represent any error condition.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    if (this.remoteSequenceNumber) {\n      if (message.cseq <= this.remoteSequenceNumber) {\n        throw new Error(\"Out of sequence in dialog request. Did you forget to call sequenceGuard()?\");\n      }\n\n      this.dialogState.remoteSequenceNumber = message.cseq;\n    } // If the remote sequence number is empty, it MUST be set to the value\n    // of the sequence number in the CSeq header field value in the request.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    if (!this.remoteSequenceNumber) {\n      this.dialogState.remoteSequenceNumber = message.cseq;\n    } // When a UAS receives a target refresh request, it MUST replace the\n    // dialog's remote target URI with the URI from the Contact header field\n    // in that request, if present.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n    // Note: \"target refresh request\" processing delegated to sub-class.\n\n  }\n  /**\n   * If the dialog identifier in the 2xx response matches the dialog\n   * identifier of an existing dialog, the dialog MUST be transitioned to\n   * the \"confirmed\" state, and the route set for the dialog MUST be\n   * recomputed based on the 2xx response using the procedures of Section\n   * 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n   * constructed using the procedures of Section 12.1.2.\n   *\n   * Note that the only piece of state that is recomputed is the route\n   * set.  Other pieces of state such as the highest sequence numbers\n   * (remote and local) sent within the dialog are not recomputed.  The\n   * route set only is recomputed for backwards compatibility.  RFC\n   * 2543 did not mandate mirroring of the Record-Route header field in\n   * a 1xx, only 2xx.  However, we cannot update the entire state of\n   * the dialog, since mid-dialog requests may have been sent within\n   * the early dialog, modifying the sequence numbers, for example.\n   *\n   *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n   */\n\n\n  recomputeRouteSet(message) {\n    this.dialogState.routeSet = message.getHeaders(\"record-route\").reverse();\n  }\n  /**\n   * A request within a dialog is constructed by using many of the\n   * components of the state stored as part of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n   * @param method - Outgoing request method.\n   */\n\n\n  createOutgoingRequestMessage(method, options) {\n    // The URI in the To field of the request MUST be set to the remote URI\n    // from the dialog state.  The tag in the To header field of the request\n    // MUST be set to the remote tag of the dialog ID.  The From URI of the\n    // request MUST be set to the local URI from the dialog state.  The tag\n    // in the From header field of the request MUST be set to the local tag\n    // of the dialog ID.  If the value of the remote or local tags is null,\n    // the tag parameter MUST be omitted from the To or From header fields,\n    // respectively.\n    //\n    //    Usage of the URI from the To and From fields in the original\n    //    request within subsequent requests is done for backwards\n    //    compatibility with RFC 2543, which used the URI for dialog\n    //    identification.  In this specification, only the tags are used for\n    //    dialog identification.  It is expected that mandatory reflection\n    //    of the original To and From URI in mid-dialog requests will be\n    //    deprecated in a subsequent revision of this specification.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n    const toUri = this.remoteURI;\n    const toTag = this.remoteTag;\n    const fromUri = this.localURI;\n    const fromTag = this.localTag; // The Call-ID of the request MUST be set to the Call-ID of the dialog.\n    // Requests within a dialog MUST contain strictly monotonically\n    // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n    // in each direction (excepting ACK and CANCEL of course, whose numbers\n    // equal the requests being acknowledged or cancelled).  Therefore, if\n    // the local sequence number is not empty, the value of the local\n    // sequence number MUST be incremented by one, and this value MUST be\n    // placed into the CSeq header field.  If the local sequence number is\n    // empty, an initial value MUST be chosen using the guidelines of\n    // Section 8.1.1.5.  The method field in the CSeq header field value\n    // MUST match the method of the request.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n\n    const callId = this.callId;\n    let cseq;\n\n    if (options && options.cseq) {\n      cseq = options.cseq;\n    } else if (!this.dialogState.localSequenceNumber) {\n      cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5\n    } else {\n      cseq = this.dialogState.localSequenceNumber += 1;\n    } // The UAC uses the remote target and route set to build the Request-URI\n    // and Route header field of the request.\n    //\n    // If the route set is empty, the UAC MUST place the remote target URI\n    // into the Request-URI.  The UAC MUST NOT add a Route header field to\n    // the request.\n    //\n    // If the route set is not empty, and the first URI in the route set\n    // contains the lr parameter (see Section 19.1.1), the UAC MUST place\n    // the remote target URI into the Request-URI and MUST include a Route\n    // header field containing the route set values in order, including all\n    // parameters.\n    //\n    // If the route set is not empty, and its first URI does not contain the\n    // lr parameter, the UAC MUST place the first URI from the route set\n    // into the Request-URI, stripping any parameters that are not allowed\n    // in a Request-URI.  The UAC MUST add a Route header field containing\n    // the remainder of the route set values in order, including all\n    // parameters.  The UAC MUST then place the remote target URI into the\n    // Route header field as the last value.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n    // The lr parameter, when present, indicates that the element\n    // responsible for this resource implements the routing mechanisms\n    // specified in this document.  This parameter will be used in the\n    // URIs proxies place into Record-Route header field values, and\n    // may appear in the URIs in a pre-existing route set.\n    //\n    // This parameter is used to achieve backwards compatibility with\n    // systems implementing the strict-routing mechanisms of RFC 2543\n    // and the rfc2543bis drafts up to bis-05.  An element preparing\n    // to send a request based on a URI not containing this parameter\n    // can assume the receiving element implements strict-routing and\n    // reformat the message to preserve the information in the\n    // Request-URI.\n    // https://tools.ietf.org/html/rfc3261#section-19.1.1\n    // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n\n\n    const ruri = this.remoteTarget;\n    const routeSet = this.routeSet;\n    const extraHeaders = options && options.extraHeaders;\n    const body = options && options.body; // The relative order of header fields with different field names is not\n    // significant.  However, it is RECOMMENDED that header fields which are\n    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n    // Max-Forwards, and Proxy-Authorization, for example) appear towards\n    // the top of the message to facilitate rapid parsing.\n    // https://tools.ietf.org/html/rfc3261#section-7.3.1\n\n    const message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {\n      callId,\n      cseq,\n      fromTag,\n      toTag,\n      routeSet\n    }, extraHeaders, body);\n    return message;\n  }\n  /**\n   * Increment the local sequence number by one.\n   * It feels like this should be protected, but the current authentication handling currently\n   * needs this to keep the dialog in sync when \"auto re-sends\" request messages.\n   * @internal\n   */\n\n\n  incrementLocalSequenceNumber() {\n    if (!this.dialogState.localSequenceNumber) {\n      throw new Error(\"Local sequence number undefined.\");\n    }\n\n    this.dialogState.localSequenceNumber += 1;\n  }\n  /**\n   * If the remote sequence number was not empty, but the sequence number\n   * of the request is lower than the remote sequence number, the request\n   * is out of order and MUST be rejected with a 500 (Server Internal\n   * Error) response.\n   * https://tools.ietf.org/html/rfc3261#section-12.2.2\n   * @param request - Incoming request to guard.\n   * @returns True if the program execution is to continue in the branch in question.\n   *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.\n   */\n\n\n  sequenceGuard(message) {\n    // ACK guard.\n    // By convention, handling of unexpected ACKs is responsibility\n    // the particular dialog implementation. For example, see SessionDialog.\n    // Furthermore, we cannot reply to an \"out of sequence\" ACK.\n    if (message.method === C.ACK) {\n      return true;\n    } // Note: We are rejecting on \"less than or equal to\" the remote\n    // sequence number (excepting ACK whose numbers equal the requests\n    // being acknowledged or cancelled), which is the correct thing to\n    // do in our case. The only time a request with the same sequence number\n    // will show up here if is a) it is a very late retransmission of a\n    // request we already handled or b) it is a different request with the\n    // same sequence number which would be violation of the standard.\n    // Request retransmissions are absorbed by the transaction layer,\n    // so any request with a duplicate sequence number getting here\n    // would have to be a retransmission after the transaction terminated\n    // or a broken request (with unique via branch value).\n    // Requests within a dialog MUST contain strictly monotonically\n    // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n    // in each direction (excepting ACK and CANCEL of course, whose numbers\n    // equal the requests being acknowledged or cancelled).  Therefore, if\n    // the local sequence number is not empty, the value of the local\n    // sequence number MUST be incremented by one, and this value MUST be\n    // placed into the CSeq header field.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n\n\n    if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {\n      this.core.replyStateless(message, {\n        statusCode: 500\n      });\n      return false;\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/dialog.js"],"names":["C","NameAddrHeader","Dialog","constructor","core","dialogState","dialogs","set","id","initialDialogStateForUserAgentClient","outgoingRequestMessage","incomingResponseMessage","secure","routeSet","getHeaders","reverse","contact","parseHeader","Error","remoteTarget","uri","localSequenceNumber","cseq","remoteSequenceNumber","undefined","callId","localTag","fromTag","remoteTag","toTag","from","to","localURI","remoteURI","statusCode","early","initialDialogStateForUserAgentServer","incomingRequestMessage","dispose","delete","userAgentCore","confirm","receiveRequest","message","method","ACK","recomputeRouteSet","createOutgoingRequestMessage","options","toUri","fromUri","ruri","extraHeaders","body","makeOutgoingRequestMessage","incrementLocalSequenceNumber","sequenceGuard","replyStateless"],"mappings":"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","sourcesContent":["import { C, NameAddrHeader } from \"../messages\";\n/**\n * Dialog.\n * @remarks\n * A key concept for a user agent is that of a dialog.  A dialog\n * represents a peer-to-peer SIP relationship between two user agents\n * that persists for some time.  The dialog facilitates sequencing of\n * messages between the user agents and proper routing of requests\n * between both of them.  The dialog represents a context in which to\n * interpret SIP messages.\n * https://tools.ietf.org/html/rfc3261#section-12\n * @public\n */\nexport class Dialog {\n    /**\n     * Dialog constructor.\n     * @param core - User agent core.\n     * @param dialogState - Initial dialog state.\n     */\n    constructor(core, dialogState) {\n        this.core = core;\n        this.dialogState = dialogState;\n        this.core.dialogs.set(this.id, this);\n    }\n    /**\n     * When a UAC receives a response that establishes a dialog, it\n     * constructs the state of the dialog.  This state MUST be maintained\n     * for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.2\n     * @param outgoingRequestMessage - Outgoing request message for dialog.\n     * @param incomingResponseMessage - Incoming response message creating dialog.\n     */\n    static initialDialogStateForUserAgentClient(outgoingRequestMessage, incomingResponseMessage) {\n        // If the request was sent over TLS, and the Request-URI contained a\n        // SIPS URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the response, taken in reverse order and preserving\n        // all URI parameters.  If no Record-Route header field is present in\n        // the response, the route set MUST be set to the empty set.  This route\n        // set, even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const routeSet = incomingResponseMessage.getHeaders(\"record-route\").reverse();\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const contact = incomingResponseMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The local sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The remote sequence\n        // number MUST be empty (it is established when the remote UA sends a\n        // request within the dialog).  The call identifier component of the\n        // dialog ID MUST be set to the value of the Call-ID in the request.\n        // The local tag component of the dialog ID MUST be set to the tag in\n        // the From field in the request, and the remote tag component of the\n        // dialog ID MUST be set to the tag in the To field of the response.  A\n        // UAC MUST be prepared to receive a response without a tag in the To\n        // field, in which case the tag is considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate To tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        const localSequenceNumber = outgoingRequestMessage.cseq;\n        const remoteSequenceNumber = undefined;\n        const callId = outgoingRequestMessage.callId;\n        const localTag = outgoingRequestMessage.fromTag;\n        const remoteTag = incomingResponseMessage.toTag;\n        if (!callId) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Call id undefined.\");\n        }\n        if (!localTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From tag undefined.\");\n        }\n        if (!remoteTag) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n        }\n        // The remote URI MUST be set to the URI in the To field, and the local\n        // URI MUST be set to the URI in the From field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.2\n        if (!outgoingRequestMessage.from) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"From undefined.\");\n        }\n        if (!outgoingRequestMessage.to) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"To undefined.\");\n        }\n        const localURI = outgoingRequestMessage.from.uri;\n        const remoteURI = outgoingRequestMessage.to.uri;\n        // A dialog can also be in the \"early\" state, which occurs when it is\n        // created with a provisional response, and then transition to the\n        // \"confirmed\" state when a 2xx final response arrives.\n        // https://tools.ietf.org/html/rfc3261#section-12\n        if (!incomingResponseMessage.statusCode) {\n            throw new Error(\"Incoming response status code undefined.\");\n        }\n        const early = incomingResponseMessage.statusCode < 200 ? true : false;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    /**\n     * The UAS then constructs the state of the dialog.  This state MUST be\n     * maintained for the duration of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.1.1\n     * @param incomingRequestMessage - Incoming request message creating dialog.\n     * @param toTag - Tag in the To field in the response to the incoming request.\n     */\n    static initialDialogStateForUserAgentServer(incomingRequestMessage, toTag, early = false) {\n        // If the request arrived over TLS, and the Request-URI contained a SIPS\n        // URI, the \"secure\" flag is set to TRUE.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const secure = false; // FIXME: Currently no support for TLS.\n        // The route set MUST be set to the list of URIs in the Record-Route\n        // header field from the request, taken in order and preserving all URI\n        // parameters.  If no Record-Route header field is present in the\n        // request, the route set MUST be set to the empty set.  This route set,\n        // even if empty, overrides any pre-existing route set for future\n        // requests in this dialog.  The remote target MUST be set to the URI\n        // from the Contact header field of the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const routeSet = incomingRequestMessage.getHeaders(\"record-route\");\n        const contact = incomingRequestMessage.parseHeader(\"contact\");\n        if (!contact) {\n            // TODO: Review to make sure this will never happen\n            throw new Error(\"Contact undefined.\");\n        }\n        if (!(contact instanceof NameAddrHeader)) {\n            throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n        const remoteTarget = contact.uri;\n        // The remote sequence number MUST be set to the value of the sequence\n        // number in the CSeq header field of the request.  The local sequence\n        // number MUST be empty.  The call identifier component of the dialog ID\n        // MUST be set to the value of the Call-ID in the request.  The local\n        // tag component of the dialog ID MUST be set to the tag in the To field\n        // in the response to the request (which always includes a tag), and the\n        // remote tag component of the dialog ID MUST be set to the tag from the\n        // From field in the request.  A UAS MUST be prepared to receive a\n        // request without a tag in the From field, in which case the tag is\n        // considered to have a value of null.\n        //\n        //    This is to maintain backwards compatibility with RFC 2543, which\n        //    did not mandate From tags.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const remoteSequenceNumber = incomingRequestMessage.cseq;\n        const localSequenceNumber = undefined;\n        const callId = incomingRequestMessage.callId;\n        const localTag = toTag;\n        const remoteTag = incomingRequestMessage.fromTag;\n        // The remote URI MUST be set to the URI in the From field, and the\n        // local URI MUST be set to the URI in the To field.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const remoteURI = incomingRequestMessage.from.uri;\n        const localURI = incomingRequestMessage.to.uri;\n        const dialogState = {\n            id: callId + localTag + remoteTag,\n            early,\n            callId,\n            localTag,\n            remoteTag,\n            localSequenceNumber,\n            remoteSequenceNumber,\n            localURI,\n            remoteURI,\n            remoteTarget,\n            routeSet,\n            secure\n        };\n        return dialogState;\n    }\n    /** Destructor. */\n    dispose() {\n        this.core.dialogs.delete(this.id);\n    }\n    /**\n     * A dialog is identified at each UA with a dialog ID, which consists of\n     * a Call-ID value, a local tag and a remote tag.  The dialog ID at each\n     * UA involved in the dialog is not the same.  Specifically, the local\n     * tag at one UA is identical to the remote tag at the peer UA.  The\n     * tags are opaque tokens that facilitate the generation of unique\n     * dialog IDs.\n     * https://tools.ietf.org/html/rfc3261#section-12\n     */\n    get id() {\n        return this.dialogState.id;\n    }\n    /**\n     * A dialog can also be in the \"early\" state, which occurs when it is\n     * created with a provisional response, and then it transition to the\n     * \"confirmed\" state when a 2xx final response received or is sent.\n     *\n     * Note: RFC 3261 is concise on when a dialog is \"confirmed\", but it\n     * can be a point of confusion if an INVITE dialog is \"confirmed\" after\n     * a 2xx is sent or after receiving the ACK for the 2xx response.\n     * With careful reading it can be inferred a dialog is always is\n     * \"confirmed\" when the 2xx is sent (regardless of type of dialog).\n     * However a INVITE dialog does have additional considerations\n     * when it is confirmed but an ACK has not yet been received (in\n     * particular with regard to a callee sending BYE requests).\n     */\n    get early() {\n        return this.dialogState.early;\n    }\n    /** Call identifier component of the dialog id. */\n    get callId() {\n        return this.dialogState.callId;\n    }\n    /** Local tag component of the dialog id. */\n    get localTag() {\n        return this.dialogState.localTag;\n    }\n    /** Remote tag component of the dialog id. */\n    get remoteTag() {\n        return this.dialogState.remoteTag;\n    }\n    /** Local sequence number (used to order requests from the UA to its peer). */\n    get localSequenceNumber() {\n        return this.dialogState.localSequenceNumber;\n    }\n    /** Remote sequence number (used to order requests from its peer to the UA). */\n    get remoteSequenceNumber() {\n        return this.dialogState.remoteSequenceNumber;\n    }\n    /** Local URI. */\n    get localURI() {\n        return this.dialogState.localURI;\n    }\n    /** Remote URI. */\n    get remoteURI() {\n        return this.dialogState.remoteURI;\n    }\n    /** Remote target. */\n    get remoteTarget() {\n        return this.dialogState.remoteTarget;\n    }\n    /**\n     * Route set, which is an ordered list of URIs. The route set is the\n     * list of servers that need to be traversed to send a request to the peer.\n     */\n    get routeSet() {\n        return this.dialogState.routeSet;\n    }\n    /**\n     * If the request was sent over TLS, and the Request-URI contained\n     * a SIPS URI, the \"secure\" flag is set to true. *NOT IMPLEMENTED*\n     */\n    get secure() {\n        return this.dialogState.secure;\n    }\n    /** The user agent core servicing this dialog. */\n    get userAgentCore() {\n        return this.core;\n    }\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    confirm() {\n        this.dialogState.early = false;\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     *\n     *    Note that some requests, such as INVITEs, affect several pieces of\n     *    state.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n    receiveRequest(message) {\n        // ACK guard.\n        // By convention, the handling of ACKs is the responsibility\n        // the particular dialog implementation. For example, see SessionDialog.\n        // Furthermore, ACKs have same sequence number as the associated INVITE.\n        if (message.method === C.ACK) {\n            return;\n        }\n        // If the remote sequence number was not empty, but the sequence number\n        // of the request is lower than the remote sequence number, the request\n        // is out of order and MUST be rejected with a 500 (Server Internal\n        // Error) response.  If the remote sequence number was not empty, and\n        // the sequence number of the request is greater than the remote\n        // sequence number, the request is in order.  It is possible for the\n        // CSeq sequence number to be higher than the remote sequence number by\n        // more than one.  This is not an error condition, and a UAS SHOULD be\n        // prepared to receive and process requests with CSeq values more than\n        // one higher than the previous received request.  The UAS MUST then set\n        // the remote sequence number to the value of the sequence number in the\n        // CSeq header field value in the request.\n        //\n        //    If a proxy challenges a request generated by the UAC, the UAC has\n        //    to resubmit the request with credentials.  The resubmitted request\n        //    will have a new CSeq number.  The UAS will never see the first\n        //    request, and thus, it will notice a gap in the CSeq number space.\n        //    Such a gap does not represent any error condition.\n        //\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (this.remoteSequenceNumber) {\n            if (message.cseq <= this.remoteSequenceNumber) {\n                throw new Error(\"Out of sequence in dialog request. Did you forget to call sequenceGuard()?\");\n            }\n            this.dialogState.remoteSequenceNumber = message.cseq;\n        }\n        // If the remote sequence number is empty, it MUST be set to the value\n        // of the sequence number in the CSeq header field value in the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.remoteSequenceNumber) {\n            this.dialogState.remoteSequenceNumber = message.cseq;\n        }\n        // When a UAS receives a target refresh request, it MUST replace the\n        // dialog's remote target URI with the URI from the Contact header field\n        // in that request, if present.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        // Note: \"target refresh request\" processing delegated to sub-class.\n    }\n    /**\n     * If the dialog identifier in the 2xx response matches the dialog\n     * identifier of an existing dialog, the dialog MUST be transitioned to\n     * the \"confirmed\" state, and the route set for the dialog MUST be\n     * recomputed based on the 2xx response using the procedures of Section\n     * 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n     * constructed using the procedures of Section 12.1.2.\n     *\n     * Note that the only piece of state that is recomputed is the route\n     * set.  Other pieces of state such as the highest sequence numbers\n     * (remote and local) sent within the dialog are not recomputed.  The\n     * route set only is recomputed for backwards compatibility.  RFC\n     * 2543 did not mandate mirroring of the Record-Route header field in\n     * a 1xx, only 2xx.  However, we cannot update the entire state of\n     * the dialog, since mid-dialog requests may have been sent within\n     * the early dialog, modifying the sequence numbers, for example.\n     *\n     *  https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     */\n    recomputeRouteSet(message) {\n        this.dialogState.routeSet = message.getHeaders(\"record-route\").reverse();\n    }\n    /**\n     * A request within a dialog is constructed by using many of the\n     * components of the state stored as part of the dialog.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n     * @param method - Outgoing request method.\n     */\n    createOutgoingRequestMessage(method, options) {\n        // The URI in the To field of the request MUST be set to the remote URI\n        // from the dialog state.  The tag in the To header field of the request\n        // MUST be set to the remote tag of the dialog ID.  The From URI of the\n        // request MUST be set to the local URI from the dialog state.  The tag\n        // in the From header field of the request MUST be set to the local tag\n        // of the dialog ID.  If the value of the remote or local tags is null,\n        // the tag parameter MUST be omitted from the To or From header fields,\n        // respectively.\n        //\n        //    Usage of the URI from the To and From fields in the original\n        //    request within subsequent requests is done for backwards\n        //    compatibility with RFC 2543, which used the URI for dialog\n        //    identification.  In this specification, only the tags are used for\n        //    dialog identification.  It is expected that mandatory reflection\n        //    of the original To and From URI in mid-dialog requests will be\n        //    deprecated in a subsequent revision of this specification.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        const toUri = this.remoteURI;\n        const toTag = this.remoteTag;\n        const fromUri = this.localURI;\n        const fromTag = this.localTag;\n        // The Call-ID of the request MUST be set to the Call-ID of the dialog.\n        // Requests within a dialog MUST contain strictly monotonically\n        // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n        // in each direction (excepting ACK and CANCEL of course, whose numbers\n        // equal the requests being acknowledged or cancelled).  Therefore, if\n        // the local sequence number is not empty, the value of the local\n        // sequence number MUST be incremented by one, and this value MUST be\n        // placed into the CSeq header field.  If the local sequence number is\n        // empty, an initial value MUST be chosen using the guidelines of\n        // Section 8.1.1.5.  The method field in the CSeq header field value\n        // MUST match the method of the request.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        const callId = this.callId;\n        let cseq;\n        if (options && options.cseq) {\n            cseq = options.cseq;\n        }\n        else if (!this.dialogState.localSequenceNumber) {\n            cseq = this.dialogState.localSequenceNumber = 1; // https://tools.ietf.org/html/rfc3261#section-8.1.1.5\n        }\n        else {\n            cseq = this.dialogState.localSequenceNumber += 1;\n        }\n        // The UAC uses the remote target and route set to build the Request-URI\n        // and Route header field of the request.\n        //\n        // If the route set is empty, the UAC MUST place the remote target URI\n        // into the Request-URI.  The UAC MUST NOT add a Route header field to\n        // the request.\n        //\n        // If the route set is not empty, and the first URI in the route set\n        // contains the lr parameter (see Section 19.1.1), the UAC MUST place\n        // the remote target URI into the Request-URI and MUST include a Route\n        // header field containing the route set values in order, including all\n        // parameters.\n        //\n        // If the route set is not empty, and its first URI does not contain the\n        // lr parameter, the UAC MUST place the first URI from the route set\n        // into the Request-URI, stripping any parameters that are not allowed\n        // in a Request-URI.  The UAC MUST add a Route header field containing\n        // the remainder of the route set values in order, including all\n        // parameters.  The UAC MUST then place the remote target URI into the\n        // Route header field as the last value.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        // The lr parameter, when present, indicates that the element\n        // responsible for this resource implements the routing mechanisms\n        // specified in this document.  This parameter will be used in the\n        // URIs proxies place into Record-Route header field values, and\n        // may appear in the URIs in a pre-existing route set.\n        //\n        // This parameter is used to achieve backwards compatibility with\n        // systems implementing the strict-routing mechanisms of RFC 2543\n        // and the rfc2543bis drafts up to bis-05.  An element preparing\n        // to send a request based on a URI not containing this parameter\n        // can assume the receiving element implements strict-routing and\n        // reformat the message to preserve the information in the\n        // Request-URI.\n        // https://tools.ietf.org/html/rfc3261#section-19.1.1\n        // NOTE: Not backwards compatible with RFC 2543 (no support for strict-routing).\n        const ruri = this.remoteTarget;\n        const routeSet = this.routeSet;\n        const extraHeaders = options && options.extraHeaders;\n        const body = options && options.body;\n        // The relative order of header fields with different field names is not\n        // significant.  However, it is RECOMMENDED that header fields which are\n        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n        // Max-Forwards, and Proxy-Authorization, for example) appear towards\n        // the top of the message to facilitate rapid parsing.\n        // https://tools.ietf.org/html/rfc3261#section-7.3.1\n        const message = this.userAgentCore.makeOutgoingRequestMessage(method, ruri, fromUri, toUri, {\n            callId,\n            cseq,\n            fromTag,\n            toTag,\n            routeSet\n        }, extraHeaders, body);\n        return message;\n    }\n    /**\n     * Increment the local sequence number by one.\n     * It feels like this should be protected, but the current authentication handling currently\n     * needs this to keep the dialog in sync when \"auto re-sends\" request messages.\n     * @internal\n     */\n    incrementLocalSequenceNumber() {\n        if (!this.dialogState.localSequenceNumber) {\n            throw new Error(\"Local sequence number undefined.\");\n        }\n        this.dialogState.localSequenceNumber += 1;\n    }\n    /**\n     * If the remote sequence number was not empty, but the sequence number\n     * of the request is lower than the remote sequence number, the request\n     * is out of order and MUST be rejected with a 500 (Server Internal\n     * Error) response.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param request - Incoming request to guard.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise a 500 Server Internal Error was stateless sent and request processing must stop.\n     */\n    sequenceGuard(message) {\n        // ACK guard.\n        // By convention, handling of unexpected ACKs is responsibility\n        // the particular dialog implementation. For example, see SessionDialog.\n        // Furthermore, we cannot reply to an \"out of sequence\" ACK.\n        if (message.method === C.ACK) {\n            return true;\n        }\n        // Note: We are rejecting on \"less than or equal to\" the remote\n        // sequence number (excepting ACK whose numbers equal the requests\n        // being acknowledged or cancelled), which is the correct thing to\n        // do in our case. The only time a request with the same sequence number\n        // will show up here if is a) it is a very late retransmission of a\n        // request we already handled or b) it is a different request with the\n        // same sequence number which would be violation of the standard.\n        // Request retransmissions are absorbed by the transaction layer,\n        // so any request with a duplicate sequence number getting here\n        // would have to be a retransmission after the transaction terminated\n        // or a broken request (with unique via branch value).\n        // Requests within a dialog MUST contain strictly monotonically\n        // increasing and contiguous CSeq sequence numbers (increasing-by-one)\n        // in each direction (excepting ACK and CANCEL of course, whose numbers\n        // equal the requests being acknowledged or cancelled).  Therefore, if\n        // the local sequence number is not empty, the value of the local\n        // sequence number MUST be incremented by one, and this value MUST be\n        // placed into the CSeq header field.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.1.1\n        if (this.remoteSequenceNumber && message.cseq <= this.remoteSequenceNumber) {\n            this.core.replyStateless(message, { statusCode: 500 });\n            return false;\n        }\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}