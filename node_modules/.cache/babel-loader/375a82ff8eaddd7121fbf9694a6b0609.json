{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createSuper\");\n\nvar _require = require('@xmpp/events'),\n    EventEmitter = _require.EventEmitter,\n    promise = _require.promise;\n\nvar jid = require('@xmpp/jid');\n\nvar xml = require('@xmpp/xml');\n\nvar StreamError = require('./lib/StreamError');\n\nvar _require2 = require('./lib/util'),\n    parseHost = _require2.parseHost,\n    parseService = _require2.parseService;\n\nvar NS_STREAM = 'urn:ietf:params:xml:ns:xmpp-streams';\nvar NS_JABBER_STREAM = 'http://etherx.jabber.org/streams';\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  var _super = _createSuper(Connection);\n\n  function Connection() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this);\n    _this.jid = null;\n    _this.timeout = 2000;\n    _this.options = options;\n    _this.socketListeners = Object.create(null);\n    _this.parserListeners = Object.create(null);\n    _this.status = 'offline';\n    _this.socket = null;\n    _this.parser = null;\n    _this.root = null;\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"_reset\",\n    value: function _reset() {\n      this.jid = null;\n      this.status = 'offline';\n\n      this._detachSocket();\n\n      this._detachParser();\n    }\n  }, {\n    key: \"_streamError\",\n    value: function () {\n      var _streamError2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(condition, children) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return this.send( // prettier-ignore\n                xml('stream:error', {}, [xml(condition, {\n                  xmlns: NS_STREAM\n                }, children)]));\n\n              case 3:\n                _context.next = 7;\n                break;\n\n              case 5:\n                _context.prev = 5;\n                _context.t0 = _context[\"catch\"](0);\n\n              case 7:\n                return _context.abrupt(\"return\", this._end());\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 5]]);\n      }));\n\n      function _streamError(_x, _x2) {\n        return _streamError2.apply(this, arguments);\n      }\n\n      return _streamError;\n    }()\n  }, {\n    key: \"_onData\",\n    value: function _onData(data) {\n      var str = data.toString('utf8');\n      this.emit('input', str);\n      this.parser.write(str);\n    }\n  }, {\n    key: \"_onParserError\",\n    value: function _onParserError(error) {\n      // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-bad-format\n      // \"This error can be used instead of the more specific XML-related errors,\n      // such as <bad-namespace-prefix/>, <invalid-xml/>, <not-well-formed/>, <restricted-xml/>,\n      // and <unsupported-encoding/>. However, the more specific errors are RECOMMENDED.\"\n      this._streamError('bad-format');\n\n      this._detachParser();\n\n      this.emit('error', error);\n    }\n  }, {\n    key: \"_attachSocket\",\n    value: function _attachSocket(socket) {\n      var _this2 = this;\n\n      var sock = this.socket = socket;\n      var listeners = this.socketListeners;\n      listeners.data = this._onData.bind(this);\n\n      listeners.close = function (dirty, event) {\n        _this2._reset();\n\n        _this2._status('disconnect', {\n          clean: !dirty,\n          event: event\n        });\n      };\n\n      listeners.connect = function () {\n        _this2._status('connect');\n      };\n\n      listeners.error = function (error) {\n        _this2.emit('error', error);\n      };\n\n      sock.on('close', listeners.close);\n      sock.on('data', listeners.data);\n      sock.on('error', listeners.error);\n      sock.on('connect', listeners.connect);\n    }\n  }, {\n    key: \"_detachSocket\",\n    value: function _detachSocket() {\n      var socketListeners = this.socketListeners,\n          socket = this.socket;\n      Object.getOwnPropertyNames(socketListeners).forEach(function (k) {\n        socket.removeListener(k, socketListeners[k]);\n        delete socketListeners[k];\n      });\n      this.socket = null;\n      return socket;\n    }\n  }, {\n    key: \"_onElement\",\n    value: function _onElement(element) {\n      var isStreamError = element.is('error', NS_JABBER_STREAM);\n\n      if (isStreamError) {\n        this._onStreamError(element);\n      }\n\n      this.emit('element', element);\n      this.emit(this.isStanza(element) ? 'stanza' : 'nonza', element);\n\n      if (isStreamError) {\n        // \"Stream Errors Are Unrecoverable\"\n        // \"The entity that receives the stream error then SHALL close the stream\"\n        this._end();\n      }\n    } // https://xmpp.org/rfcs/rfc6120.html#streams-error\n\n  }, {\n    key: \"_onStreamError\",\n    value: function _onStreamError(element) {\n      var error = StreamError.fromElement(element);\n\n      if (error.condition === 'see-other-host') {\n        return this._onSeeOtherHost(error);\n      }\n\n      this.emit('error', error);\n    } // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-see-other-host\n\n  }, {\n    key: \"_onSeeOtherHost\",\n    value: function () {\n      var _onSeeOtherHost2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(error) {\n        var _parseService, protocol, host, _parseHost, port, service, _this$options, domain, lang;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _parseService = parseService(this.options.service), protocol = _parseService.protocol;\n                host = error.element.getChildText('see-other-host');\n                _parseHost = parseHost(host), port = _parseHost.port;\n\n                if (port) {\n                  service = \"\".concat(protocol || 'xmpp:', \"//\").concat(host);\n                } else {\n                  service = (protocol ? \"\".concat(protocol, \"//\") : '') + host;\n                }\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return promise(this, 'disconnect');\n\n              case 7:\n                _this$options = this.options, domain = _this$options.domain, lang = _this$options.lang;\n                _context2.next = 10;\n                return this.connect(service);\n\n              case 10:\n                _context2.next = 12;\n                return this.open({\n                  domain: domain,\n                  lang: lang\n                });\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](4);\n                this.emit('error', _context2.t0);\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 14]]);\n      }));\n\n      function _onSeeOtherHost(_x3) {\n        return _onSeeOtherHost2.apply(this, arguments);\n      }\n\n      return _onSeeOtherHost;\n    }()\n  }, {\n    key: \"_attachParser\",\n    value: function _attachParser(p) {\n      var _this3 = this;\n\n      var parser = this.parser = p;\n      var listeners = this.parserListeners;\n      listeners.element = this._onElement.bind(this);\n      listeners.error = this._onParserError.bind(this);\n\n      listeners.end = function (element) {\n        _this3._detachParser();\n\n        _this3._status('close', element);\n      };\n\n      listeners.start = function (element) {\n        _this3._status('open', element);\n      };\n\n      parser.on('error', listeners.error);\n      parser.on('element', listeners.element);\n      parser.on('end', listeners.end);\n      parser.on('start', listeners.start);\n    }\n  }, {\n    key: \"_detachParser\",\n    value: function _detachParser() {\n      var _this4 = this;\n\n      var listeners = this.parserListeners;\n      Object.getOwnPropertyNames(listeners).forEach(function (k) {\n        _this4.parser.removeListener(k, listeners[k]);\n\n        delete listeners[k];\n      });\n      this.parser = null;\n    }\n  }, {\n    key: \"_jid\",\n    value: function _jid(id) {\n      this.jid = jid(id);\n      return this.jid;\n    }\n  }, {\n    key: \"_status\",\n    value: function _status(status) {\n      this.status = status;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      this.emit.apply(this, ['status', status].concat(args));\n      this.emit.apply(this, [status].concat(args));\n    }\n  }, {\n    key: \"_end\",\n    value: function () {\n      var _end2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var el;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.close();\n\n              case 3:\n                el = _context3.sent;\n                _context3.next = 8;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](0);\n\n              case 8:\n                _context3.prev = 8;\n                _context3.next = 11;\n                return this.disconnect();\n\n              case 11:\n                _context3.next = 15;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t1 = _context3[\"catch\"](8);\n\n              case 15:\n                return _context3.abrupt(\"return\", el);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 6], [8, 13]]);\n      }));\n\n      function _end() {\n        return _end2.apply(this, arguments);\n      }\n\n      return _end;\n    }()\n    /**\n     * Opens the socket then opens the stream\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this$options2, service, domain, lang, promiseOnline;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.status !== 'offline')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('Connection is not offline');\n\n              case 2:\n                _this$options2 = this.options, service = _this$options2.service, domain = _this$options2.domain, lang = _this$options2.lang;\n                _context4.next = 5;\n                return this.connect(service);\n\n              case 5:\n                promiseOnline = promise(this, 'online');\n                _context4.next = 8;\n                return this.open({\n                  domain: domain,\n                  lang: lang\n                });\n\n              case 8:\n                return _context4.abrupt(\"return\", promiseOnline);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Connects the socket\n     */\n\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(service) {\n        var socket;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._status('connecting', service);\n\n                socket = new this.Socket();\n\n                this._attachSocket(socket); // The 'connect' status is set by the socket 'connect' listener\n\n\n                socket.connect(this.socketParameters(service));\n                return _context5.abrupt(\"return\", promise(socket, 'connect'));\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function connect(_x4) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * Disconnects the socket\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var timeout,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                timeout = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : this.timeout;\n                if (this.socket) this._status('disconnecting');\n                this.socket.end(); // The 'disconnect' status is set by the socket 'close' listener\n\n                _context6.next = 5;\n                return promise(this.socket, 'close', 'error', timeout);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n    /**\n     * Opens the stream\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(options) {\n        var _options, domain, lang, _options$timeout, timeout, headerElement;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._status('opening');\n\n                if (typeof options === 'string') {\n                  options = {\n                    domain: options\n                  };\n                }\n\n                _options = options, domain = _options.domain, lang = _options.lang, _options$timeout = _options.timeout, timeout = _options$timeout === void 0 ? this.timeout : _options$timeout;\n                headerElement = this.headerElement();\n                headerElement.attrs.to = domain;\n                headerElement.attrs['xml:lang'] = lang;\n                this.root = headerElement;\n\n                this._attachParser(new this.Parser());\n\n                _context7.next = 10;\n                return this.write(this.header(headerElement));\n\n              case 10:\n                return _context7.abrupt(\"return\", promise(this, 'open', 'error', timeout));\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function open(_x5) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Closes the stream then closes the socket\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var el;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.next = 2;\n                return this._end();\n\n              case 2:\n                el = _context8.sent;\n                if (this.status !== 'offline') this._status('offline', el);\n                return _context8.abrupt(\"return\", el);\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Closes the stream and wait for the server to close it\n     * https://xmpp.org/rfcs/rfc6120.html#streams-close\n     * https://tools.ietf.org/html/rfc7395#section-3.6\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var timeout,\n            p,\n            _yield$p,\n            _yield$p2,\n            el,\n            _args9 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                timeout = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : this.timeout;\n                p = Promise.all([promise(this.parser, 'end', 'error', timeout), this.write(this.footer(this.footerElement()))]);\n                if (this.parser && this.socket) this._status('closing');\n                _context9.next = 5;\n                return p;\n\n              case 5:\n                _yield$p = _context9.sent;\n                _yield$p2 = _slicedToArray(_yield$p, 1);\n                el = _yield$p2[0];\n                this.root = null;\n                return _context9.abrupt(\"return\", el);\n\n              case 10:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Restart the stream\n     * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation-restart\n     */\n\n  }, {\n    key: \"restart\",\n    value: function () {\n      var _restart = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var _this$options3, domain, lang;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._detachParser();\n\n                _this$options3 = this.options, domain = _this$options3.domain, lang = _this$options3.lang;\n                return _context10.abrupt(\"return\", this.open({\n                  domain: domain,\n                  lang: lang\n                }));\n\n              case 3:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function restart() {\n        return _restart.apply(this, arguments);\n      }\n\n      return restart;\n    }()\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(element) {\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                element.parent = this.root;\n                this.emit('outgoing', element);\n                _context11.next = 4;\n                return this.write(element);\n\n              case 4:\n                this.emit('send', element);\n\n              case 5:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function send(_x6) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n  }, {\n    key: \"sendReceive\",\n    value: function sendReceive(element) {\n      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.timeout;\n      return Promise.all([this.send(element), promise(this, 'element', 'error', timeout)]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            el = _ref2[1];\n\n        return el;\n      });\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      var _this5 = this;\n\n      return new Promise(function (resolve, reject) {\n        // https://xmpp.org/rfcs/rfc6120.html#streams-close\n        // \"Refrain from sending any further data over its outbound stream to the other entity\"\n        if (_this5.status === 'closing') {\n          reject(new Error('Connection is closing'));\n          return;\n        }\n\n        var str = data.toString('utf8');\n\n        _this5.socket.write(str, function (err) {\n          if (err) {\n            return reject(err);\n          }\n\n          _this5.emit('output', str);\n\n          resolve();\n        });\n      });\n    }\n  }, {\n    key: \"isStanza\",\n    value: function isStanza(element) {\n      var name = element.name;\n      return name === 'iq' || name === 'message' || name === 'presence';\n    }\n  }, {\n    key: \"isNonza\",\n    value: function isNonza(element) {\n      return !this.isStanza(element);\n    } // Override\n\n  }, {\n    key: \"header\",\n    value: function header(el) {\n      return el.toString();\n    } // Override\n\n  }, {\n    key: \"headerElement\",\n    value: function headerElement() {\n      return new xml.Element('', {\n        version: '1.0',\n        xmlns: this.NS\n      });\n    } // Override\n\n  }, {\n    key: \"footer\",\n    value: function footer(el) {\n      return el.toString();\n    } // Override\n\n  }, {\n    key: \"footerElement\",\n    value: function footerElement() {} // Override\n\n  }, {\n    key: \"socketParameters\",\n    value: function socketParameters() {}\n  }]);\n\n  return Connection;\n}(EventEmitter); // Overrirde\n\n\nConnection.prototype.NS = '';\nConnection.prototype.Socket = null;\nConnection.prototype.Parser = null;\nmodule.exports = Connection;","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/connection/index.js"],"names":["require","EventEmitter","promise","jid","xml","StreamError","parseHost","parseService","NS_STREAM","NS_JABBER_STREAM","Connection","options","timeout","socketListeners","Object","create","parserListeners","status","socket","parser","root","_detachSocket","_detachParser","condition","children","send","xmlns","_end","data","str","toString","emit","write","error","_streamError","sock","listeners","_onData","bind","close","dirty","event","_reset","_status","clean","connect","on","getOwnPropertyNames","forEach","k","removeListener","element","isStreamError","is","_onStreamError","isStanza","fromElement","_onSeeOtherHost","service","protocol","host","getChildText","port","domain","lang","open","p","_onElement","_onParserError","end","start","id","args","el","disconnect","Error","promiseOnline","Socket","_attachSocket","socketParameters","headerElement","attrs","to","_attachParser","Parser","header","Promise","all","footer","footerElement","parent","then","resolve","reject","err","name","Element","version","NS","prototype","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst {EventEmitter, promise} = require('@xmpp/events')\nconst jid = require('@xmpp/jid')\nconst xml = require('@xmpp/xml')\nconst StreamError = require('./lib/StreamError')\nconst {parseHost, parseService} = require('./lib/util')\n\nconst NS_STREAM = 'urn:ietf:params:xml:ns:xmpp-streams'\nconst NS_JABBER_STREAM = 'http://etherx.jabber.org/streams'\n\nclass Connection extends EventEmitter {\n  constructor(options = {}) {\n    super()\n    this.jid = null\n    this.timeout = 2000\n    this.options = options\n    this.socketListeners = Object.create(null)\n    this.parserListeners = Object.create(null)\n    this.status = 'offline'\n    this.socket = null\n    this.parser = null\n    this.root = null\n  }\n\n  _reset() {\n    this.jid = null\n    this.status = 'offline'\n    this._detachSocket()\n    this._detachParser()\n  }\n\n  async _streamError(condition, children) {\n    try {\n      await this.send(\n        // prettier-ignore\n        xml('stream:error', {}, [\n          xml(condition, {xmlns: NS_STREAM}, children),\n        ])\n      )\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {}\n\n    return this._end()\n  }\n\n  _onData(data) {\n    const str = data.toString('utf8')\n    this.emit('input', str)\n    this.parser.write(str)\n  }\n\n  _onParserError(error) {\n    // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-bad-format\n    // \"This error can be used instead of the more specific XML-related errors,\n    // such as <bad-namespace-prefix/>, <invalid-xml/>, <not-well-formed/>, <restricted-xml/>,\n    // and <unsupported-encoding/>. However, the more specific errors are RECOMMENDED.\"\n    this._streamError('bad-format')\n    this._detachParser()\n    this.emit('error', error)\n  }\n\n  _attachSocket(socket) {\n    const sock = (this.socket = socket)\n    const listeners = this.socketListeners\n\n    listeners.data = this._onData.bind(this)\n\n    listeners.close = (dirty, event) => {\n      this._reset()\n      this._status('disconnect', {clean: !dirty, event})\n    }\n\n    listeners.connect = () => {\n      this._status('connect')\n    }\n\n    listeners.error = error => {\n      this.emit('error', error)\n    }\n\n    sock.on('close', listeners.close)\n    sock.on('data', listeners.data)\n    sock.on('error', listeners.error)\n    sock.on('connect', listeners.connect)\n  }\n\n  _detachSocket() {\n    const {socketListeners, socket} = this\n    Object.getOwnPropertyNames(socketListeners).forEach(k => {\n      socket.removeListener(k, socketListeners[k])\n      delete socketListeners[k]\n    })\n    this.socket = null\n    return socket\n  }\n\n  _onElement(element) {\n    const isStreamError = element.is('error', NS_JABBER_STREAM)\n\n    if (isStreamError) {\n      this._onStreamError(element)\n    }\n\n    this.emit('element', element)\n    this.emit(this.isStanza(element) ? 'stanza' : 'nonza', element)\n\n    if (isStreamError) {\n      // \"Stream Errors Are Unrecoverable\"\n      // \"The entity that receives the stream error then SHALL close the stream\"\n      this._end()\n    }\n  }\n\n  // https://xmpp.org/rfcs/rfc6120.html#streams-error\n  _onStreamError(element) {\n    const error = StreamError.fromElement(element)\n\n    if (error.condition === 'see-other-host') {\n      return this._onSeeOtherHost(error)\n    }\n\n    this.emit('error', error)\n  }\n\n  // https://xmpp.org/rfcs/rfc6120.html#streams-error-conditions-see-other-host\n  async _onSeeOtherHost(error) {\n    const {protocol} = parseService(this.options.service)\n\n    const host = error.element.getChildText('see-other-host')\n    const {port} = parseHost(host)\n\n    let service\n    if (port) {\n      service = `${protocol || 'xmpp:'}//${host}`\n    } else {\n      service = (protocol ? `${protocol}//` : '') + host\n    }\n\n    try {\n      await promise(this, 'disconnect')\n      const {domain, lang} = this.options\n      await this.connect(service)\n      await this.open({domain, lang})\n    } catch (err) {\n      this.emit('error', err)\n    }\n  }\n\n  _attachParser(p) {\n    const parser = (this.parser = p)\n    const listeners = this.parserListeners\n\n    listeners.element = this._onElement.bind(this)\n    listeners.error = this._onParserError.bind(this)\n\n    listeners.end = element => {\n      this._detachParser()\n      this._status('close', element)\n    }\n\n    listeners.start = element => {\n      this._status('open', element)\n    }\n\n    parser.on('error', listeners.error)\n    parser.on('element', listeners.element)\n    parser.on('end', listeners.end)\n    parser.on('start', listeners.start)\n  }\n\n  _detachParser() {\n    const listeners = this.parserListeners\n    Object.getOwnPropertyNames(listeners).forEach(k => {\n      this.parser.removeListener(k, listeners[k])\n      delete listeners[k]\n    })\n    this.parser = null\n  }\n\n  _jid(id) {\n    this.jid = jid(id)\n    return this.jid\n  }\n\n  _status(status, ...args) {\n    this.status = status\n    this.emit('status', status, ...args)\n    this.emit(status, ...args)\n  }\n\n  async _end() {\n    let el\n    try {\n      el = await this.close()\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {}\n\n    try {\n      await this.disconnect()\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {}\n\n    return el\n  }\n\n  /**\n   * Opens the socket then opens the stream\n   */\n  async start() {\n    if (this.status !== 'offline') {\n      throw new Error('Connection is not offline')\n    }\n\n    const {service, domain, lang} = this.options\n\n    await this.connect(service)\n\n    const promiseOnline = promise(this, 'online')\n\n    await this.open({domain, lang})\n\n    return promiseOnline\n  }\n\n  /**\n   * Connects the socket\n   */\n  async connect(service) {\n    this._status('connecting', service)\n    const socket = new this.Socket()\n    this._attachSocket(socket)\n    // The 'connect' status is set by the socket 'connect' listener\n    socket.connect(this.socketParameters(service))\n    return promise(socket, 'connect')\n  }\n\n  /**\n   * Disconnects the socket\n   * https://xmpp.org/rfcs/rfc6120.html#streams-close\n   * https://tools.ietf.org/html/rfc7395#section-3.6\n   */\n  async disconnect(timeout = this.timeout) {\n    if (this.socket) this._status('disconnecting')\n\n    this.socket.end()\n\n    // The 'disconnect' status is set by the socket 'close' listener\n    await promise(this.socket, 'close', 'error', timeout)\n  }\n\n  /**\n   * Opens the stream\n   */\n  async open(options) {\n    this._status('opening')\n\n    if (typeof options === 'string') {\n      options = {domain: options}\n    }\n\n    const {domain, lang, timeout = this.timeout} = options\n\n    const headerElement = this.headerElement()\n    headerElement.attrs.to = domain\n    headerElement.attrs['xml:lang'] = lang\n    this.root = headerElement\n\n    this._attachParser(new this.Parser())\n\n    await this.write(this.header(headerElement))\n    return promise(this, 'open', 'error', timeout)\n  }\n\n  /**\n   * Closes the stream then closes the socket\n   * https://xmpp.org/rfcs/rfc6120.html#streams-close\n   * https://tools.ietf.org/html/rfc7395#section-3.6\n   */\n  async stop() {\n    const el = await this._end()\n    if (this.status !== 'offline') this._status('offline', el)\n    return el\n  }\n\n  /**\n   * Closes the stream and wait for the server to close it\n   * https://xmpp.org/rfcs/rfc6120.html#streams-close\n   * https://tools.ietf.org/html/rfc7395#section-3.6\n   */\n  async close(timeout = this.timeout) {\n    const p = Promise.all([\n      promise(this.parser, 'end', 'error', timeout),\n      this.write(this.footer(this.footerElement())),\n    ])\n\n    if (this.parser && this.socket) this._status('closing')\n    const [el] = await p\n    this.root = null\n    return el\n    // The 'close' status is set by the parser 'end' listener\n  }\n\n  /**\n   * Restart the stream\n   * https://xmpp.org/rfcs/rfc6120.html#streams-negotiation-restart\n   */\n  async restart() {\n    this._detachParser()\n    const {domain, lang} = this.options\n    return this.open({domain, lang})\n  }\n\n  async send(element) {\n    element.parent = this.root\n    this.emit('outgoing', element)\n    await this.write(element)\n    this.emit('send', element)\n  }\n\n  sendReceive(element, timeout = this.timeout) {\n    return Promise.all([\n      this.send(element),\n      promise(this, 'element', 'error', timeout),\n    ]).then(([, el]) => el)\n  }\n\n  write(data) {\n    return new Promise((resolve, reject) => {\n      // https://xmpp.org/rfcs/rfc6120.html#streams-close\n      // \"Refrain from sending any further data over its outbound stream to the other entity\"\n      if (this.status === 'closing') {\n        reject(new Error('Connection is closing'))\n        return\n      }\n\n      const str = data.toString('utf8')\n      this.socket.write(str, err => {\n        if (err) {\n          return reject(err)\n        }\n\n        this.emit('output', str)\n        resolve()\n      })\n    })\n  }\n\n  isStanza(element) {\n    const {name} = element\n    return name === 'iq' || name === 'message' || name === 'presence'\n  }\n\n  isNonza(element) {\n    return !this.isStanza(element)\n  }\n\n  // Override\n  header(el) {\n    return el.toString()\n  }\n\n  // Override\n  headerElement() {\n    return new xml.Element('', {\n      version: '1.0',\n      xmlns: this.NS,\n    })\n  }\n\n  // Override\n  footer(el) {\n    return el.toString()\n  }\n\n  // Override\n  footerElement() {}\n\n  // Override\n  socketParameters() {}\n}\n\n// Overrirde\nConnection.prototype.NS = ''\nConnection.prototype.Socket = null\nConnection.prototype.Parser = null\n\nmodule.exports = Connection\n"]},"metadata":{},"sourceType":"script"}