{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Dialog, SessionDialog } from \"../dialogs\";\nimport { TransactionStateError } from \"../exceptions\";\nimport { SignalingState } from \"../session\";\nimport { InviteServerTransaction } from \"../transactions\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { UserAgentServer } from \"./user-agent-server\";\n/**\n * INVITE UAS.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.3 UAS Processing\n * https://tools.ietf.org/html/rfc3261#section-13.3\n * @public\n */\n\nexport var InviteUserAgentServer = /*#__PURE__*/function (_UserAgentServer) {\n  _inherits(InviteUserAgentServer, _UserAgentServer);\n\n  var _super = _createSuper(InviteUserAgentServer);\n\n  function InviteUserAgentServer(core, message, delegate) {\n    var _this;\n\n    _classCallCheck(this, InviteUserAgentServer);\n\n    _this = _super.call(this, InviteServerTransaction, core, message, delegate);\n    _this.core = core;\n    return _this;\n  }\n\n  _createClass(InviteUserAgentServer, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.earlyDialog) {\n        this.earlyDialog.dispose();\n      }\n\n      _get(_getPrototypeOf(InviteUserAgentServer.prototype), \"dispose\", this).call(this);\n    }\n    /**\n     * 13.3.1.4 The INVITE is Accepted\n     * The UAS core generates a 2xx response.  This response establishes a\n     * dialog, and therefore follows the procedures of Section 12.1.1 in\n     * addition to those of Section 8.2.6.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n     * @param options - Accept options bucket.\n     */\n\n  }, {\n    key: \"accept\",\n    value: function accept() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        statusCode: 200\n      };\n\n      if (!this.acceptable) {\n        throw new TransactionStateError(\"\".concat(this.message.method, \" not acceptable in state \").concat(this.transaction.state, \".\"));\n      } // This response establishes a dialog...\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n      if (!this.confirmedDialog) {\n        if (this.earlyDialog) {\n          this.earlyDialog.confirm();\n          this.confirmedDialog = this.earlyDialog;\n          this.earlyDialog = undefined;\n        } else {\n          var transaction = this.transaction;\n\n          if (!(transaction instanceof InviteServerTransaction)) {\n            throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n          }\n\n          var state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);\n          this.confirmedDialog = new SessionDialog(transaction, this.core, state);\n        }\n      } // When a UAS responds to a request with a response that establishes a\n      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n      // header field values from the request into the response (including the\n      // URIs, URI parameters, and any Record-Route header field parameters,\n      // whether they are known or unknown to the UAS) and MUST maintain the\n      // order of those values.  The UAS MUST add a Contact header field to\n      // the response.  The Contact header field contains an address where the\n      // UAS would like to be contacted for subsequent requests in the dialog\n      // (which includes the ACK for a 2xx response in the case of an INVITE).\n      // Generally, the host portion of this URI is the IP address or FQDN of\n      // the host.  The URI provided in the Contact header field MUST be a SIP\n      // or SIPS URI.  If the request that initiated the dialog contained a\n      // SIPS URI in the Request-URI or in the top Record-Route header field\n      // value, if there was any, or the Contact header field if there was no\n      // Record-Route header field, the Contact header field in the response\n      // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n      // same URI can be used in messages outside this dialog).  The same way,\n      // the scope of the URI in the Contact header field of the INVITE is not\n      // limited to this dialog either.  It can therefore be used in messages\n      // to the UAC even outside this dialog.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n      var recordRouteHeader = this.message.getHeaders(\"record-route\").map(function (header) {\n        return \"Record-Route: \".concat(header);\n      });\n      var contactHeader = \"Contact: \".concat(this.core.configuration.contact.toString()); // A 2xx response to an INVITE SHOULD contain the Allow header field and\n      // the Supported header field, and MAY contain the Accept header field.\n      // Including these header fields allows the UAC to determine the\n      // features and extensions supported by the UAS for the duration of the\n      // call, without probing.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n      // FIXME: TODO: This should not be hard coded.\n\n      var allowHeader = \"Allow: \" + AllowedMethods.toString(); // FIXME: TODO: Supported header (see reply())\n      // FIXME: TODO: Accept header\n      // If the INVITE request contained an offer, and the UAS had not yet\n      // sent an answer, the 2xx MUST contain an answer.  If the INVITE did\n      // not contain an offer, the 2xx MUST contain an offer if the UAS had\n      // not yet sent an offer.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n      if (!options.body) {\n        if (this.confirmedDialog.signalingState === SignalingState.Stable) {\n          options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response\n        } else if (this.confirmedDialog.signalingState === SignalingState.Initial || this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {\n          throw new Error(\"Response must have a body.\");\n        }\n      }\n\n      options.statusCode = options.statusCode || 200;\n      options.extraHeaders = options.extraHeaders || [];\n      options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n      options.extraHeaders.push(allowHeader);\n      options.extraHeaders.push(contactHeader);\n\n      var response = _get(_getPrototypeOf(InviteUserAgentServer.prototype), \"accept\", this).call(this, options);\n\n      var session = this.confirmedDialog;\n      var result = Object.assign(Object.assign({}, response), {\n        session: session\n      }); // Update dialog signaling state\n\n      if (options.body) {\n        // Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        if (this.confirmedDialog.signalingState !== SignalingState.Stable) {\n          this.confirmedDialog.signalingStateTransition(options.body);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * 13.3.1.1 Progress\n     * If the UAS is not able to answer the invitation immediately, it can\n     * choose to indicate some kind of progress to the UAC (for example, an\n     * indication that a phone is ringing).  This is accomplished with a\n     * provisional response between 101 and 199.  These provisional\n     * responses establish early dialogs and therefore follow the procedures\n     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY\n     * send as many provisional responses as it likes.  Each of these MUST\n     * indicate the same dialog ID.  However, these will not be delivered\n     * reliably.\n     *\n     * If the UAS desires an extended period of time to answer the INVITE,\n     * it will need to ask for an \"extension\" in order to prevent proxies\n     * from canceling the transaction.  A proxy has the option of canceling\n     * a transaction when there is a gap of 3 minutes between responses in a\n     * transaction.  To prevent cancellation, the UAS MUST send a non-100\n     * provisional response at every minute, to handle the possibility of\n     * lost provisional responses.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1\n     * @param options - Progress options bucket.\n     */\n\n  }, {\n    key: \"progress\",\n    value: function progress() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        statusCode: 180\n      };\n\n      if (!this.progressable) {\n        throw new TransactionStateError(\"\".concat(this.message.method, \" not progressable in state \").concat(this.transaction.state, \".\"));\n      } // This response establishes a dialog...\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n      if (!this.earlyDialog) {\n        var transaction = this.transaction;\n\n        if (!(transaction instanceof InviteServerTransaction)) {\n          throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n        }\n\n        var state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);\n        this.earlyDialog = new SessionDialog(transaction, this.core, state);\n      } // When a UAS responds to a request with a response that establishes a\n      // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n      // header field values from the request into the response (including the\n      // URIs, URI parameters, and any Record-Route header field parameters,\n      // whether they are known or unknown to the UAS) and MUST maintain the\n      // order of those values.  The UAS MUST add a Contact header field to\n      // the response.  The Contact header field contains an address where the\n      // UAS would like to be contacted for subsequent requests in the dialog\n      // (which includes the ACK for a 2xx response in the case of an INVITE).\n      // Generally, the host portion of this URI is the IP address or FQDN of\n      // the host.  The URI provided in the Contact header field MUST be a SIP\n      // or SIPS URI.  If the request that initiated the dialog contained a\n      // SIPS URI in the Request-URI or in the top Record-Route header field\n      // value, if there was any, or the Contact header field if there was no\n      // Record-Route header field, the Contact header field in the response\n      // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n      // same URI can be used in messages outside this dialog).  The same way,\n      // the scope of the URI in the Contact header field of the INVITE is not\n      // limited to this dialog either.  It can therefore be used in messages\n      // to the UAC even outside this dialog.\n      // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n      var recordRouteHeader = this.message.getHeaders(\"record-route\").map(function (header) {\n        return \"Record-Route: \".concat(header);\n      });\n      var contactHeader = \"Contact: \".concat(this.core.configuration.contact);\n      options.extraHeaders = options.extraHeaders || [];\n      options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n      options.extraHeaders.push(contactHeader);\n\n      var response = _get(_getPrototypeOf(InviteUserAgentServer.prototype), \"progress\", this).call(this, options);\n\n      var session = this.earlyDialog;\n      var result = Object.assign(Object.assign({}, response), {\n        session: session\n      }); // Update dialog signaling state\n\n      if (options.body) {\n        // Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        if (this.earlyDialog.signalingState !== SignalingState.Stable) {\n          this.earlyDialog.signalingStateTransition(options.body);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * 13.3.1.2 The INVITE is Redirected\n     * If the UAS decides to redirect the call, a 3xx response is sent.  A\n     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved\n     * Temporarily) response SHOULD contain a Contact header field\n     * containing one or more URIs of new addresses to be tried.  The\n     * response is passed to the INVITE server transaction, which will deal\n     * with its retransmissions.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2\n     * @param contacts - Contacts to redirect to.\n     * @param options - Redirect options bucket.\n     */\n\n  }, {\n    key: \"redirect\",\n    value: function redirect(contacts) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        statusCode: 302\n      };\n      return _get(_getPrototypeOf(InviteUserAgentServer.prototype), \"redirect\", this).call(this, contacts, options);\n    }\n    /**\n     * 13.3.1.3 The INVITE is Rejected\n     * A common scenario occurs when the callee is currently not willing or\n     * able to take additional calls at this end system.  A 486 (Busy Here)\n     * SHOULD be returned in such a scenario.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n     * @param options - Reject options bucket.\n     */\n\n  }, {\n    key: \"reject\",\n    value: function reject() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        statusCode: 486\n      };\n      return _get(_getPrototypeOf(InviteUserAgentServer.prototype), \"reject\", this).call(this, options);\n    }\n  }]);\n\n  return InviteUserAgentServer;\n}(UserAgentServer);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/invite-user-agent-server.js"],"names":["Dialog","SessionDialog","TransactionStateError","SignalingState","InviteServerTransaction","AllowedMethods","UserAgentServer","InviteUserAgentServer","core","message","delegate","earlyDialog","dispose","options","statusCode","acceptable","method","transaction","state","confirmedDialog","confirm","undefined","Error","initialDialogStateForUserAgentServer","toTag","recordRouteHeader","getHeaders","map","header","contactHeader","configuration","contact","toString","allowHeader","body","signalingState","Stable","answer","Initial","HaveRemoteOffer","extraHeaders","concat","push","response","session","result","Object","assign","signalingStateTransition","progressable","contacts"],"mappings":";;;;;;AAAA,SAASA,MAAT,EAAiBC,aAAjB,QAAsC,YAAtC;AACA,SAASC,qBAAT,QAAsC,eAAtC;AACA,SAASC,cAAT,QAA+B,YAA/B;AACA,SAASC,uBAAT,QAAwC,iBAAxC;AACA,SAASC,cAAT,QAA+B,oCAA/B;AACA,SAASC,eAAT,QAAgC,qBAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,WAAaC,qBAAb;AAAA;;AAAA;;AACI,iCAAYC,IAAZ,EAAkBC,OAAlB,EAA2BC,QAA3B,EAAqC;AAAA;;AAAA;;AACjC,8BAAMN,uBAAN,EAA+BI,IAA/B,EAAqCC,OAArC,EAA8CC,QAA9C;AACA,UAAKF,IAAL,GAAYA,IAAZ;AAFiC;AAGpC;;AAJL;AAAA;AAAA,8BAKc;AACN,UAAI,KAAKG,WAAT,EAAsB;AAClB,aAAKA,WAAL,CAAiBC,OAAjB;AACH;;AACD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAlBA;AAAA;AAAA,6BAmB0C;AAAA,UAA/BC,OAA+B,uEAArB;AAAEC,QAAAA,UAAU,EAAE;AAAd,OAAqB;;AAClC,UAAI,CAAC,KAAKC,UAAV,EAAsB;AAClB,cAAM,IAAIb,qBAAJ,WAA6B,KAAKO,OAAL,CAAaO,MAA1C,sCAA4E,KAAKC,WAAL,CAAiBC,KAA7F,OAAN;AACH,OAHiC,CAIlC;AACA;;;AACA,UAAI,CAAC,KAAKC,eAAV,EAA2B;AACvB,YAAI,KAAKR,WAAT,EAAsB;AAClB,eAAKA,WAAL,CAAiBS,OAAjB;AACA,eAAKD,eAAL,GAAuB,KAAKR,WAA5B;AACA,eAAKA,WAAL,GAAmBU,SAAnB;AACH,SAJD,MAKK;AACD,cAAMJ,WAAW,GAAG,KAAKA,WAAzB;;AACA,cAAI,EAAEA,WAAW,YAAYb,uBAAzB,CAAJ,EAAuD;AACnD,kBAAM,IAAIkB,KAAJ,CAAU,sDAAV,CAAN;AACH;;AACD,cAAMJ,KAAK,GAAGlB,MAAM,CAACuB,oCAAP,CAA4C,KAAKd,OAAjD,EAA0D,KAAKe,KAA/D,CAAd;AACA,eAAKL,eAAL,GAAuB,IAAIlB,aAAJ,CAAkBgB,WAAlB,EAA+B,KAAKT,IAApC,EAA0CU,KAA1C,CAAvB;AACH;AACJ,OApBiC,CAqBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMO,iBAAiB,GAAG,KAAKhB,OAAL,CAAaiB,UAAb,CAAwB,cAAxB,EAAwCC,GAAxC,CAA4C,UAACC,MAAD;AAAA,uCAA6BA,MAA7B;AAAA,OAA5C,CAA1B;AACA,UAAMC,aAAa,sBAAe,KAAKrB,IAAL,CAAUsB,aAAV,CAAwBC,OAAxB,CAAgCC,QAAhC,EAAf,CAAnB,CA3CkC,CA4ClC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,WAAW,GAAG,YAAY5B,cAAc,CAAC2B,QAAf,EAAhC,CAnDkC,CAoDlC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,CAACnB,OAAO,CAACqB,IAAb,EAAmB;AACf,YAAI,KAAKf,eAAL,CAAqBgB,cAArB,KAAwChC,cAAc,CAACiC,MAA3D,EAAmE;AAC/DvB,UAAAA,OAAO,CAACqB,IAAR,GAAe,KAAKf,eAAL,CAAqBkB,MAApC,CAD+D,CACnB;AAC/C,SAFD,MAGK,IAAI,KAAKlB,eAAL,CAAqBgB,cAArB,KAAwChC,cAAc,CAACmC,OAAvD,IACL,KAAKnB,eAAL,CAAqBgB,cAArB,KAAwChC,cAAc,CAACoC,eADtD,EACuE;AACxE,gBAAM,IAAIjB,KAAJ,CAAU,4BAAV,CAAN;AACH;AACJ;;AACDT,MAAAA,OAAO,CAACC,UAAR,GAAqBD,OAAO,CAACC,UAAR,IAAsB,GAA3C;AACAD,MAAAA,OAAO,CAAC2B,YAAR,GAAuB3B,OAAO,CAAC2B,YAAR,IAAwB,EAA/C;AACA3B,MAAAA,OAAO,CAAC2B,YAAR,GAAuB3B,OAAO,CAAC2B,YAAR,CAAqBC,MAArB,CAA4BhB,iBAA5B,CAAvB;AACAZ,MAAAA,OAAO,CAAC2B,YAAR,CAAqBE,IAArB,CAA0BT,WAA1B;AACApB,MAAAA,OAAO,CAAC2B,YAAR,CAAqBE,IAArB,CAA0Bb,aAA1B;;AACA,UAAMc,QAAQ,qFAAgB9B,OAAhB,CAAd;;AACA,UAAM+B,OAAO,GAAG,KAAKzB,eAArB;AACA,UAAM0B,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,QAAlB,CAAd,EAA2C;AAAEC,QAAAA,OAAO,EAAPA;AAAF,OAA3C,CAAf,CA3EkC,CA4ElC;;AACA,UAAI/B,OAAO,CAACqB,IAAZ,EAAkB;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,KAAKf,eAAL,CAAqBgB,cAArB,KAAwChC,cAAc,CAACiC,MAA3D,EAAmE;AAC/D,eAAKjB,eAAL,CAAqB6B,wBAArB,CAA8CnC,OAAO,CAACqB,IAAtD;AACH;AACJ;;AACD,aAAOW,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlIA;AAAA;AAAA,+BAmI4C;AAAA,UAA/BhC,OAA+B,uEAArB;AAAEC,QAAAA,UAAU,EAAE;AAAd,OAAqB;;AACpC,UAAI,CAAC,KAAKmC,YAAV,EAAwB;AACpB,cAAM,IAAI/C,qBAAJ,WAA6B,KAAKO,OAAL,CAAaO,MAA1C,wCAA8E,KAAKC,WAAL,CAAiBC,KAA/F,OAAN;AACH,OAHmC,CAIpC;AACA;;;AACA,UAAI,CAAC,KAAKP,WAAV,EAAuB;AACnB,YAAMM,WAAW,GAAG,KAAKA,WAAzB;;AACA,YAAI,EAAEA,WAAW,YAAYb,uBAAzB,CAAJ,EAAuD;AACnD,gBAAM,IAAIkB,KAAJ,CAAU,sDAAV,CAAN;AACH;;AACD,YAAMJ,KAAK,GAAGlB,MAAM,CAACuB,oCAAP,CAA4C,KAAKd,OAAjD,EAA0D,KAAKe,KAA/D,EAAsE,IAAtE,CAAd;AACA,aAAKb,WAAL,GAAmB,IAAIV,aAAJ,CAAkBgB,WAAlB,EAA+B,KAAKT,IAApC,EAA0CU,KAA1C,CAAnB;AACH,OAbmC,CAcpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMO,iBAAiB,GAAG,KAAKhB,OAAL,CAAaiB,UAAb,CAAwB,cAAxB,EAAwCC,GAAxC,CAA4C,UAACC,MAAD;AAAA,uCAA6BA,MAA7B;AAAA,OAA5C,CAA1B;AACA,UAAMC,aAAa,sBAAe,KAAKrB,IAAL,CAAUsB,aAAV,CAAwBC,OAAvC,CAAnB;AACAlB,MAAAA,OAAO,CAAC2B,YAAR,GAAuB3B,OAAO,CAAC2B,YAAR,IAAwB,EAA/C;AACA3B,MAAAA,OAAO,CAAC2B,YAAR,GAAuB3B,OAAO,CAAC2B,YAAR,CAAqBC,MAArB,CAA4BhB,iBAA5B,CAAvB;AACAZ,MAAAA,OAAO,CAAC2B,YAAR,CAAqBE,IAArB,CAA0Bb,aAA1B;;AACA,UAAMc,QAAQ,uFAAkB9B,OAAlB,CAAd;;AACA,UAAM+B,OAAO,GAAG,KAAKjC,WAArB;AACA,UAAMkC,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,QAAlB,CAAd,EAA2C;AAAEC,QAAAA,OAAO,EAAPA;AAAF,OAA3C,CAAf,CA1CoC,CA2CpC;;AACA,UAAI/B,OAAO,CAACqB,IAAZ,EAAkB;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAI,KAAKvB,WAAL,CAAiBwB,cAAjB,KAAoChC,cAAc,CAACiC,MAAvD,EAA+D;AAC3D,eAAKzB,WAAL,CAAiBqC,wBAAjB,CAA0CnC,OAAO,CAACqB,IAAlD;AACH;AACJ;;AACD,aAAOW,MAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvMA;AAAA;AAAA,6BAwMaK,QAxMb,EAwMsD;AAAA,UAA/BrC,OAA+B,uEAArB;AAAEC,QAAAA,UAAU,EAAE;AAAd,OAAqB;AAC9C,iGAAsBoC,QAAtB,EAAgCrC,OAAhC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAlNA;AAAA;AAAA,6BAmN0C;AAAA,UAA/BA,OAA+B,uEAArB;AAAEC,QAAAA,UAAU,EAAE;AAAd,OAAqB;AAClC,+FAAoBD,OAApB;AACH;AArNL;;AAAA;AAAA,EAA2CP,eAA3C","sourcesContent":["import { Dialog, SessionDialog } from \"../dialogs\";\nimport { TransactionStateError } from \"../exceptions\";\nimport { SignalingState } from \"../session\";\nimport { InviteServerTransaction } from \"../transactions\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods\";\nimport { UserAgentServer } from \"./user-agent-server\";\n/**\n * INVITE UAS.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.3 UAS Processing\n * https://tools.ietf.org/html/rfc3261#section-13.3\n * @public\n */\nexport class InviteUserAgentServer extends UserAgentServer {\n    constructor(core, message, delegate) {\n        super(InviteServerTransaction, core, message, delegate);\n        this.core = core;\n    }\n    dispose() {\n        if (this.earlyDialog) {\n            this.earlyDialog.dispose();\n        }\n        super.dispose();\n    }\n    /**\n     * 13.3.1.4 The INVITE is Accepted\n     * The UAS core generates a 2xx response.  This response establishes a\n     * dialog, and therefore follows the procedures of Section 12.1.1 in\n     * addition to those of Section 8.2.6.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n     * @param options - Accept options bucket.\n     */\n    accept(options = { statusCode: 200 }) {\n        if (!this.acceptable) {\n            throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n        }\n        // This response establishes a dialog...\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!this.confirmedDialog) {\n            if (this.earlyDialog) {\n                this.earlyDialog.confirm();\n                this.confirmedDialog = this.earlyDialog;\n                this.earlyDialog = undefined;\n            }\n            else {\n                const transaction = this.transaction;\n                if (!(transaction instanceof InviteServerTransaction)) {\n                    throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n                }\n                const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);\n                this.confirmedDialog = new SessionDialog(transaction, this.core, state);\n            }\n        }\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.  The Contact header field contains an address where the\n        // UAS would like to be contacted for subsequent requests in the dialog\n        // (which includes the ACK for a 2xx response in the case of an INVITE).\n        // Generally, the host portion of this URI is the IP address or FQDN of\n        // the host.  The URI provided in the Contact header field MUST be a SIP\n        // or SIPS URI.  If the request that initiated the dialog contained a\n        // SIPS URI in the Request-URI or in the top Record-Route header field\n        // value, if there was any, or the Contact header field if there was no\n        // Record-Route header field, the Contact header field in the response\n        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n        // same URI can be used in messages outside this dialog).  The same way,\n        // the scope of the URI in the Contact header field of the INVITE is not\n        // limited to this dialog either.  It can therefore be used in messages\n        // to the UAC even outside this dialog.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const recordRouteHeader = this.message.getHeaders(\"record-route\").map((header) => `Record-Route: ${header}`);\n        const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`;\n        // A 2xx response to an INVITE SHOULD contain the Allow header field and\n        // the Supported header field, and MAY contain the Accept header field.\n        // Including these header fields allows the UAC to determine the\n        // features and extensions supported by the UAS for the duration of the\n        // call, without probing.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        // FIXME: TODO: This should not be hard coded.\n        const allowHeader = \"Allow: \" + AllowedMethods.toString();\n        // FIXME: TODO: Supported header (see reply())\n        // FIXME: TODO: Accept header\n        // If the INVITE request contained an offer, and the UAS had not yet\n        // sent an answer, the 2xx MUST contain an answer.  If the INVITE did\n        // not contain an offer, the 2xx MUST contain an offer if the UAS had\n        // not yet sent an offer.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!options.body) {\n            if (this.confirmedDialog.signalingState === SignalingState.Stable) {\n                options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response\n            }\n            else if (this.confirmedDialog.signalingState === SignalingState.Initial ||\n                this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {\n                throw new Error(\"Response must have a body.\");\n            }\n        }\n        options.statusCode = options.statusCode || 200;\n        options.extraHeaders = options.extraHeaders || [];\n        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n        options.extraHeaders.push(allowHeader);\n        options.extraHeaders.push(contactHeader);\n        const response = super.accept(options);\n        const session = this.confirmedDialog;\n        const result = Object.assign(Object.assign({}, response), { session });\n        // Update dialog signaling state\n        if (options.body) {\n            // Once the UAS has sent or received an answer to the initial\n            // offer, it MUST NOT generate subsequent offers in any responses\n            // to the initial INVITE.  This means that a UAS based on this\n            // specification alone can never generate subsequent offers until\n            // completion of the initial transaction.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            if (this.confirmedDialog.signalingState !== SignalingState.Stable) {\n                this.confirmedDialog.signalingStateTransition(options.body);\n            }\n        }\n        return result;\n    }\n    /**\n     * 13.3.1.1 Progress\n     * If the UAS is not able to answer the invitation immediately, it can\n     * choose to indicate some kind of progress to the UAC (for example, an\n     * indication that a phone is ringing).  This is accomplished with a\n     * provisional response between 101 and 199.  These provisional\n     * responses establish early dialogs and therefore follow the procedures\n     * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY\n     * send as many provisional responses as it likes.  Each of these MUST\n     * indicate the same dialog ID.  However, these will not be delivered\n     * reliably.\n     *\n     * If the UAS desires an extended period of time to answer the INVITE,\n     * it will need to ask for an \"extension\" in order to prevent proxies\n     * from canceling the transaction.  A proxy has the option of canceling\n     * a transaction when there is a gap of 3 minutes between responses in a\n     * transaction.  To prevent cancellation, the UAS MUST send a non-100\n     * provisional response at every minute, to handle the possibility of\n     * lost provisional responses.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.1\n     * @param options - Progress options bucket.\n     */\n    progress(options = { statusCode: 180 }) {\n        if (!this.progressable) {\n            throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n        }\n        // This response establishes a dialog...\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n        if (!this.earlyDialog) {\n            const transaction = this.transaction;\n            if (!(transaction instanceof InviteServerTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n            const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);\n            this.earlyDialog = new SessionDialog(transaction, this.core, state);\n        }\n        // When a UAS responds to a request with a response that establishes a\n        // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n        // header field values from the request into the response (including the\n        // URIs, URI parameters, and any Record-Route header field parameters,\n        // whether they are known or unknown to the UAS) and MUST maintain the\n        // order of those values.  The UAS MUST add a Contact header field to\n        // the response.  The Contact header field contains an address where the\n        // UAS would like to be contacted for subsequent requests in the dialog\n        // (which includes the ACK for a 2xx response in the case of an INVITE).\n        // Generally, the host portion of this URI is the IP address or FQDN of\n        // the host.  The URI provided in the Contact header field MUST be a SIP\n        // or SIPS URI.  If the request that initiated the dialog contained a\n        // SIPS URI in the Request-URI or in the top Record-Route header field\n        // value, if there was any, or the Contact header field if there was no\n        // Record-Route header field, the Contact header field in the response\n        // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n        // same URI can be used in messages outside this dialog).  The same way,\n        // the scope of the URI in the Contact header field of the INVITE is not\n        // limited to this dialog either.  It can therefore be used in messages\n        // to the UAC even outside this dialog.\n        // https://tools.ietf.org/html/rfc3261#section-12.1.1\n        const recordRouteHeader = this.message.getHeaders(\"record-route\").map((header) => `Record-Route: ${header}`);\n        const contactHeader = `Contact: ${this.core.configuration.contact}`;\n        options.extraHeaders = options.extraHeaders || [];\n        options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n        options.extraHeaders.push(contactHeader);\n        const response = super.progress(options);\n        const session = this.earlyDialog;\n        const result = Object.assign(Object.assign({}, response), { session });\n        // Update dialog signaling state\n        if (options.body) {\n            // Once the UAS has sent or received an answer to the initial\n            // offer, it MUST NOT generate subsequent offers in any responses\n            // to the initial INVITE.  This means that a UAS based on this\n            // specification alone can never generate subsequent offers until\n            // completion of the initial transaction.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            if (this.earlyDialog.signalingState !== SignalingState.Stable) {\n                this.earlyDialog.signalingStateTransition(options.body);\n            }\n        }\n        return result;\n    }\n    /**\n     * 13.3.1.2 The INVITE is Redirected\n     * If the UAS decides to redirect the call, a 3xx response is sent.  A\n     * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved\n     * Temporarily) response SHOULD contain a Contact header field\n     * containing one or more URIs of new addresses to be tried.  The\n     * response is passed to the INVITE server transaction, which will deal\n     * with its retransmissions.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.2\n     * @param contacts - Contacts to redirect to.\n     * @param options - Redirect options bucket.\n     */\n    redirect(contacts, options = { statusCode: 302 }) {\n        return super.redirect(contacts, options);\n    }\n    /**\n     * 13.3.1.3 The INVITE is Rejected\n     * A common scenario occurs when the callee is currently not willing or\n     * able to take additional calls at this end system.  A 486 (Busy Here)\n     * SHOULD be returned in such a scenario.\n     * https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n     * @param options - Reject options bucket.\n     */\n    reject(options = { statusCode: 486 }) {\n        return super.reject(options);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}