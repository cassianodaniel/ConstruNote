{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { EmitterImpl } from \"../../../api/emitter\";\nimport { StateTransitionError } from \"../../../api/exceptions\";\nimport { TransportState } from \"../../../api/transport-state\";\nimport { Grammar } from \"../../../core\";\n/**\n * Transport for SIP over secure WebSocket (WSS).\n * @public\n */\n\nexport var Transport = /*#__PURE__*/function () {\n  function Transport(logger, options) {\n    _classCallCheck(this, Transport);\n\n    this._state = TransportState.Disconnected;\n    this.transitioningState = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // logger\n\n    this.logger = logger; // guard deprecated options (remove this in version 16.x)\n\n    if (options) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var optionsDeprecated = options;\n      var wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;\n      var maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;\n\n      if (wsServersDeprecated !== undefined) {\n        var deprecatedMessage = \"The transport option \\\"wsServers\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        var _deprecatedMessage = \"The transport option \\\"maxReconnectionAttempts\\\" as has apparently been specified and has been deprecated. \" + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n\n        this.logger.warn(_deprecatedMessage);\n      } // hack\n\n\n      if (wsServersDeprecated && !options.server) {\n        if (typeof wsServersDeprecated === \"string\") {\n          options.server = wsServersDeprecated;\n        }\n\n        if (wsServersDeprecated instanceof Array) {\n          options.server = wsServersDeprecated[0];\n        }\n      }\n    } // initialize configuration\n\n\n    this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options); // validate server URL\n\n    var url = this.configuration.server;\n    var parsed = Grammar.parse(url, \"absoluteURI\");\n\n    if (parsed === -1) {\n      this.logger.error(\"Invalid WebSocket Server URL \\\"\".concat(url, \"\\\"\"));\n      throw new Error(\"Invalid WebSocket Server URL\");\n    }\n\n    if (![\"wss\", \"ws\", \"udp\"].includes(parsed.scheme)) {\n      this.logger.error(\"Invalid scheme in WebSocket Server URL \\\"\".concat(url, \"\\\"\"));\n      throw new Error(\"Invalid scheme in WebSocket Server URL\");\n    }\n\n    this._protocol = parsed.scheme.toUpperCase();\n  }\n\n  _createClass(Transport, [{\n    key: \"dispose\",\n    value: function dispose() {\n      return this.disconnect();\n    }\n    /**\n     * The protocol.\n     *\n     * @remarks\n     * Formatted as defined for the Via header sent-protocol transport.\n     * https://tools.ietf.org/html/rfc3261#section-20.42\n     */\n\n  }, {\n    key: \"connect\",\n\n    /**\n     * Connect to network.\n     * Resolves once connected. Otherwise rejects with an Error.\n     */\n    value: function connect() {\n      return this._connect();\n    }\n    /**\n     * Disconnect from network.\n     * Resolves once disconnected. Otherwise rejects with an Error.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      return this._disconnect();\n    }\n    /**\n     * Returns true if the `state` equals \"Connected\".\n     * @remarks\n     * This is equivalent to `state === TransportState.Connected`.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.state === TransportState.Connected;\n    }\n    /**\n     * Sends a message.\n     * Resolves once message is sent. Otherwise rejects with an Error.\n     * @param message - Message to send.\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(message) {\n      // Error handling is independent of whether the message was a request or\n      // response.\n      //\n      // If the transport user asks for a message to be sent over an\n      // unreliable transport, and the result is an ICMP error, the behavior\n      // depends on the type of ICMP error.  Host, network, port or protocol\n      // unreachable errors, or parameter problem errors SHOULD cause the\n      // transport layer to inform the transport user of a failure in sending.\n      // Source quench and TTL exceeded ICMP errors SHOULD be ignored.\n      //\n      // If the transport user asks for a request to be sent over a reliable\n      // transport, and the result is a connection failure, the transport\n      // layer SHOULD inform the transport user of a failure in sending.\n      // https://tools.ietf.org/html/rfc3261#section-18.4\n      return this._send(message);\n    }\n  }, {\n    key: \"_connect\",\n    value: function _connect() {\n      var _this = this;\n\n      this.logger.log(\"Connecting \".concat(this.server));\n\n      switch (this.state) {\n        case TransportState.Connecting:\n          // If `state` is \"Connecting\", `state` MUST NOT transition before returning.\n          if (this.transitioningState) {\n            return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n          }\n\n          if (!this.connectPromise) {\n            throw new Error(\"Connect promise must be defined.\");\n          }\n\n          return this.connectPromise;\n        // Already connecting\n\n        case TransportState.Connected:\n          // If `state` is \"Connected\", `state` MUST NOT transition before returning.\n          if (this.transitioningState) {\n            return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n          }\n\n          if (this.connectPromise) {\n            throw new Error(\"Connect promise must not be defined.\");\n          }\n\n          return Promise.resolve();\n        // Already connected\n\n        case TransportState.Disconnecting:\n          // If `state` is \"Disconnecting\", `state` MUST transition to \"Connecting\" before returning\n          if (this.connectPromise) {\n            throw new Error(\"Connect promise must not be defined.\");\n          }\n\n          try {\n            this.transitionState(TransportState.Connecting);\n          } catch (e) {\n            if (e instanceof StateTransitionError) {\n              return Promise.reject(e); // Loop detected\n            }\n\n            throw e;\n          }\n\n          break;\n\n        case TransportState.Disconnected:\n          // If `state` is \"Disconnected\" `state` MUST transition to \"Connecting\" before returning\n          if (this.connectPromise) {\n            throw new Error(\"Connect promise must not be defined.\");\n          }\n\n          try {\n            this.transitionState(TransportState.Connecting);\n          } catch (e) {\n            if (e instanceof StateTransitionError) {\n              return Promise.reject(e); // Loop detected\n            }\n\n            throw e;\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown state\");\n      }\n\n      var ws;\n\n      try {\n        // WebSocket()\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket\n        ws = new WebSocket(this.server, \"sip\");\n        ws.binaryType = \"arraybuffer\"; // set data type of received binary messages\n\n        ws.addEventListener(\"close\", function (ev) {\n          return _this.onWebSocketClose(ev, ws);\n        });\n        ws.addEventListener(\"error\", function (ev) {\n          return _this.onWebSocketError(ev, ws);\n        });\n        ws.addEventListener(\"open\", function (ev) {\n          return _this.onWebSocketOpen(ev, ws);\n        });\n        ws.addEventListener(\"message\", function (ev) {\n          return _this.onWebSocketMessage(ev, ws);\n        });\n        this._ws = ws;\n      } catch (error) {\n        this._ws = undefined;\n        this.logger.error(\"WebSocket construction failed.\");\n        this.logger.error(error);\n        return new Promise(function (resolve, reject) {\n          _this.connectResolve = resolve;\n          _this.connectReject = reject; // The `state` MUST transition to \"Disconnecting\" or \"Disconnected\" before rejecting\n\n          _this.transitionState(TransportState.Disconnected, error);\n        });\n      }\n\n      this.connectPromise = new Promise(function (resolve, reject) {\n        _this.connectResolve = resolve;\n        _this.connectReject = reject;\n        _this.connectTimeout = setTimeout(function () {\n          _this.logger.warn(\"Connect timed out. \" + \"Exceeded time set in configuration.connectionTimeout: \" + _this.configuration.connectionTimeout + \"s.\");\n\n          ws.close(1000); // careful here to use a local reference instead of this._ws\n        }, _this.configuration.connectionTimeout * 1000);\n      });\n      return this.connectPromise;\n    }\n  }, {\n    key: \"_disconnect\",\n    value: function _disconnect() {\n      var _this2 = this;\n\n      this.logger.log(\"Disconnecting \".concat(this.server));\n\n      switch (this.state) {\n        case TransportState.Connecting:\n          // If `state` is \"Connecting\", `state` MUST transition to \"Disconnecting\" before returning.\n          if (this.disconnectPromise) {\n            throw new Error(\"Disconnect promise must not be defined.\");\n          }\n\n          try {\n            this.transitionState(TransportState.Disconnecting);\n          } catch (e) {\n            if (e instanceof StateTransitionError) {\n              return Promise.reject(e); // Loop detected\n            }\n\n            throw e;\n          }\n\n          break;\n\n        case TransportState.Connected:\n          // If `state` is \"Connected\", `state` MUST transition to \"Disconnecting\" before returning.\n          if (this.disconnectPromise) {\n            throw new Error(\"Disconnect promise must not be defined.\");\n          }\n\n          try {\n            this.transitionState(TransportState.Disconnecting);\n          } catch (e) {\n            if (e instanceof StateTransitionError) {\n              return Promise.reject(e); // Loop detected\n            }\n\n            throw e;\n          }\n\n          break;\n\n        case TransportState.Disconnecting:\n          // If `state` is \"Disconnecting\", `state` MUST NOT transition before returning.\n          if (this.transitioningState) {\n            return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n          }\n\n          if (!this.disconnectPromise) {\n            throw new Error(\"Disconnect promise must be defined.\");\n          }\n\n          return this.disconnectPromise;\n        // Already disconnecting\n\n        case TransportState.Disconnected:\n          // If `state` is \"Disconnected\", `state` MUST NOT transition before returning.\n          if (this.transitioningState) {\n            return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n          }\n\n          if (this.disconnectPromise) {\n            throw new Error(\"Disconnect promise must not be defined.\");\n          }\n\n          return Promise.resolve();\n        // Already disconnected\n\n        default:\n          throw new Error(\"Unknown state\");\n      }\n\n      if (!this._ws) {\n        throw new Error(\"WebSocket must be defined.\");\n      }\n\n      var ws = this._ws;\n      this.disconnectPromise = new Promise(function (resolve, reject) {\n        _this2.disconnectResolve = resolve;\n        _this2.disconnectReject = reject;\n\n        try {\n          // WebSocket.close()\n          // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n          ws.close(1000); // careful here to use a local reference instead of this._ws\n        } catch (error) {\n          // Treating this as a coding error as it apparently can only happen\n          // if you pass close() invalid parameters (so it should never happen)\n          _this2.logger.error(\"WebSocket close failed.\");\n\n          _this2.logger.error(error);\n\n          throw error;\n        }\n      });\n      return this.disconnectPromise;\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(message) {\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Sending WebSocket message:\\n\\n\" + message + \"\\n\");\n      }\n\n      if (this._state !== TransportState.Connected) {\n        return Promise.reject(new Error(\"Not connected.\"));\n      }\n\n      if (!this._ws) {\n        throw new Error(\"WebSocket undefined.\");\n      }\n\n      try {\n        // WebSocket.send()\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n        this._ws.send(message);\n      } catch (error) {\n        if (error instanceof Error) {\n          return Promise.reject(error);\n        }\n\n        return Promise.reject(new Error(\"WebSocket send failed.\"));\n      }\n\n      return Promise.resolve();\n    }\n    /**\n     * WebSocket \"onclose\" event handler.\n     * @param ev - Event.\n     */\n\n  }, {\n    key: \"onWebSocketClose\",\n    value: function onWebSocketClose(ev, ws) {\n      if (ws !== this._ws) {\n        return;\n      }\n\n      var message = \"WebSocket closed \".concat(this.server, \" (code: \").concat(ev.code, \")\");\n      var error = !this.disconnectPromise ? new Error(message) : undefined;\n\n      if (error) {\n        this.logger.warn(\"WebSocket closed unexpectedly\");\n      }\n\n      this.logger.log(message); // We are about to transition to disconnected, so clear our web socket\n\n      this._ws = undefined; // The `state` MUST transition to \"Disconnected\" before resolving (assuming `state` is not already \"Disconnected\").\n\n      this.transitionState(TransportState.Disconnected, error);\n    }\n    /**\n     * WebSocket \"onerror\" event handler.\n     * @param ev - Event.\n     */\n\n  }, {\n    key: \"onWebSocketError\",\n    value: function onWebSocketError(ev, ws) {\n      if (ws !== this._ws) {\n        return;\n      }\n\n      this.logger.error(\"WebSocket error occurred.\");\n    }\n    /**\n     * WebSocket \"onmessage\" event handler.\n     * @param ev - Event.\n     */\n\n  }, {\n    key: \"onWebSocketMessage\",\n    value: function onWebSocketMessage(ev, ws) {\n      if (ws !== this._ws) {\n        return;\n      }\n\n      var data = ev.data;\n      var finishedData; // CRLF Keep Alive response from server. Clear our keep alive timeout.\n\n      if (/^(\\r\\n)+$/.test(data)) {\n        this.clearKeepAliveTimeout();\n\n        if (this.configuration.traceSip === true) {\n          this.logger.log(\"Received WebSocket message with CRLF Keep Alive response\");\n        }\n\n        return;\n      }\n\n      if (!data) {\n        this.logger.warn(\"Received empty message, discarding...\");\n        return;\n      }\n\n      if (typeof data !== \"string\") {\n        // WebSocket binary message.\n        try {\n          finishedData = new TextDecoder().decode(new Uint8Array(data)); // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.\n          // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.\n          // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.\n          // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));\n        } catch (err) {\n          this.logger.error(err);\n          this.logger.error(\"Received WebSocket binary message failed to be converted into string, message discarded\");\n          return;\n        }\n\n        if (this.configuration.traceSip === true) {\n          this.logger.log(\"Received WebSocket binary message:\\n\\n\" + finishedData + \"\\n\");\n        }\n      } else {\n        // WebSocket text message.\n        finishedData = data;\n\n        if (this.configuration.traceSip === true) {\n          this.logger.log(\"Received WebSocket text message:\\n\\n\" + finishedData + \"\\n\");\n        }\n      }\n\n      if (this.state !== TransportState.Connected) {\n        this.logger.warn(\"Received message while not connected, discarding...\");\n        return;\n      }\n\n      if (this.onMessage) {\n        try {\n          this.onMessage(finishedData);\n        } catch (e) {\n          this.logger.error(e);\n          this.logger.error(\"Exception thrown by onMessage callback\");\n          throw e; // rethrow unhandled exception\n        }\n      }\n    }\n    /**\n     * WebSocket \"onopen\" event handler.\n     * @param ev - Event.\n     */\n\n  }, {\n    key: \"onWebSocketOpen\",\n    value: function onWebSocketOpen(ev, ws) {\n      if (ws !== this._ws) {\n        return;\n      }\n\n      if (this._state === TransportState.Connecting) {\n        this.logger.log(\"WebSocket opened \".concat(this.server));\n        this.transitionState(TransportState.Connected);\n      }\n    }\n    /**\n     * Helper function to generate an Error.\n     * @param state - State transitioning to.\n     */\n\n  }, {\n    key: \"transitionLoopDetectedError\",\n    value: function transitionLoopDetectedError(state) {\n      var message = \"A state transition loop has been detected.\";\n      message += \" An attempt to transition from \".concat(this._state, \" to \").concat(state, \" before the prior transition completed.\");\n      message += \" Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?\";\n      this.logger.error(message);\n      return new StateTransitionError(\"Loop detected.\");\n    }\n    /**\n     * Transition transport state.\n     * @internal\n     */\n\n  }, {\n    key: \"transitionState\",\n    value: function transitionState(newState, error) {\n      var _this3 = this;\n\n      var invalidTransition = function invalidTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this3._state, \" to \").concat(newState));\n      };\n\n      if (this.transitioningState) {\n        throw this.transitionLoopDetectedError(newState);\n      }\n\n      this.transitioningState = true; // Validate state transition\n\n      switch (this._state) {\n        case TransportState.Connecting:\n          if (newState !== TransportState.Connected && newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n            invalidTransition();\n          }\n\n          break;\n\n        case TransportState.Connected:\n          if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n            invalidTransition();\n          }\n\n          break;\n\n        case TransportState.Disconnecting:\n          if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {\n            invalidTransition();\n          }\n\n          break;\n\n        case TransportState.Disconnected:\n          if (newState !== TransportState.Connecting) {\n            invalidTransition();\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown state.\");\n      } // Update state\n\n\n      var oldState = this._state;\n      this._state = newState; // Local copies of connect promises (guarding against callbacks changing them indirectly)\n      // const connectPromise = this.connectPromise;\n\n      var connectResolve = this.connectResolve;\n      var connectReject = this.connectReject; // Reset connect promises if no longer connecting\n\n      if (oldState === TransportState.Connecting) {\n        this.connectPromise = undefined;\n        this.connectResolve = undefined;\n        this.connectReject = undefined;\n      } // Local copies of disconnect promises (guarding against callbacks changing them indirectly)\n      // const disconnectPromise = this.disconnectPromise;\n\n\n      var disconnectResolve = this.disconnectResolve;\n      var disconnectReject = this.disconnectReject; // Reset disconnect promises if no longer disconnecting\n\n      if (oldState === TransportState.Disconnecting) {\n        this.disconnectPromise = undefined;\n        this.disconnectResolve = undefined;\n        this.disconnectReject = undefined;\n      } // Clear any outstanding connect timeout\n\n\n      if (this.connectTimeout) {\n        clearTimeout(this.connectTimeout);\n        this.connectTimeout = undefined;\n      }\n\n      this.logger.log(\"Transitioned from \".concat(oldState, \" to \").concat(this._state));\n\n      this._stateEventEmitter.emit(this._state); //  Transition to Connected\n\n\n      if (newState === TransportState.Connected) {\n        this.startSendingKeepAlives();\n\n        if (this.onConnect) {\n          try {\n            this.onConnect();\n          } catch (e) {\n            this.logger.error(e);\n            this.logger.error(\"Exception thrown by onConnect callback\");\n            throw e; // rethrow unhandled exception\n          }\n        }\n      } //  Transition from Connected\n\n\n      if (oldState === TransportState.Connected) {\n        this.stopSendingKeepAlives();\n\n        if (this.onDisconnect) {\n          try {\n            if (error) {\n              this.onDisconnect(error);\n            } else {\n              this.onDisconnect();\n            }\n          } catch (e) {\n            this.logger.error(e);\n            this.logger.error(\"Exception thrown by onDisconnect callback\");\n            throw e; // rethrow unhandled exception\n          }\n        }\n      } // Complete connect promise\n\n\n      if (oldState === TransportState.Connecting) {\n        if (!connectResolve) {\n          throw new Error(\"Connect resolve undefined.\");\n        }\n\n        if (!connectReject) {\n          throw new Error(\"Connect reject undefined.\");\n        }\n\n        newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error(\"Connect aborted.\"));\n      } // Complete disconnect promise\n\n\n      if (oldState === TransportState.Disconnecting) {\n        if (!disconnectResolve) {\n          throw new Error(\"Disconnect resolve undefined.\");\n        }\n\n        if (!disconnectReject) {\n          throw new Error(\"Disconnect reject undefined.\");\n        }\n\n        newState === TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error(\"Disconnect aborted.\"));\n      }\n\n      this.transitioningState = false;\n    } // TODO: Review \"KeepAlive Stuff\".\n    // It is not clear if it works and there are no tests for it.\n    // It was blindly lifted the keep alive code unchanged from earlier transport code.\n    //\n    // From the RFC...\n    //\n    // SIP WebSocket Clients and Servers may keep their WebSocket\n    // connections open by sending periodic WebSocket \"Ping\" frames as\n    // described in [RFC6455], Section 5.5.2.\n    // ...\n    // The indication and use of the CRLF NAT keep-alive mechanism defined\n    // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or\n    // [RFC6223] are, of course, usable over the transport defined in this\n    // specification.\n    // https://tools.ietf.org/html/rfc7118#section-6\n    //\n    // and...\n    //\n    // The Ping frame contains an opcode of 0x9.\n    // https://tools.ietf.org/html/rfc6455#section-5.5.2\n    //\n    // ==============================\n    // KeepAlive Stuff\n    // ==============================\n\n  }, {\n    key: \"clearKeepAliveTimeout\",\n    value: function clearKeepAliveTimeout() {\n      if (this.keepAliveDebounceTimeout) {\n        clearTimeout(this.keepAliveDebounceTimeout);\n      }\n\n      this.keepAliveDebounceTimeout = undefined;\n    }\n    /**\n     * Send a keep-alive (a double-CRLF sequence).\n     */\n\n  }, {\n    key: \"sendKeepAlive\",\n    value: function sendKeepAlive() {\n      var _this4 = this;\n\n      if (this.keepAliveDebounceTimeout) {\n        // We already have an outstanding keep alive, do not send another.\n        return Promise.resolve();\n      }\n\n      this.keepAliveDebounceTimeout = setTimeout(function () {\n        _this4.clearKeepAliveTimeout();\n      }, this.configuration.keepAliveDebounce * 1000);\n      return this.send(\"\\r\\n\\r\\n\");\n    }\n    /**\n     * Start sending keep-alives.\n     */\n\n  }, {\n    key: \"startSendingKeepAlives\",\n    value: function startSendingKeepAlives() {\n      var _this5 = this;\n\n      // Compute an amount of time in seconds to wait before sending another keep-alive.\n      var computeKeepAliveTimeout = function computeKeepAliveTimeout(upperBound) {\n        var lowerBound = upperBound * 0.8;\n        return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n      };\n\n      if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n        this.keepAliveInterval = setInterval(function () {\n          _this5.sendKeepAlive();\n\n          _this5.startSendingKeepAlives();\n        }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n      }\n    }\n    /**\n     * Stop sending keep-alives.\n     */\n\n  }, {\n    key: \"stopSendingKeepAlives\",\n    value: function stopSendingKeepAlives() {\n      if (this.keepAliveInterval) {\n        clearInterval(this.keepAliveInterval);\n      }\n\n      if (this.keepAliveDebounceTimeout) {\n        clearTimeout(this.keepAliveDebounceTimeout);\n      }\n\n      this.keepAliveInterval = undefined;\n      this.keepAliveDebounceTimeout = undefined;\n    }\n  }, {\n    key: \"protocol\",\n    get: function get() {\n      return this._protocol;\n    }\n    /**\n     * The URL of the WebSocket Server.\n     */\n\n  }, {\n    key: \"server\",\n    get: function get() {\n      return this.configuration.server;\n    }\n    /**\n     * Transport state.\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n    /**\n     * Transport state change emitter.\n     */\n\n  }, {\n    key: \"stateChange\",\n    get: function get() {\n      return this._stateEventEmitter;\n    }\n    /**\n     * The WebSocket.\n     */\n\n  }, {\n    key: \"ws\",\n    get: function get() {\n      return this._ws;\n    }\n  }]);\n\n  return Transport;\n}();\nTransport.defaultOptions = {\n  server: \"\",\n  connectionTimeout: 5,\n  keepAliveInterval: 0,\n  keepAliveDebounce: 10,\n  traceSip: true\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/transport/transport.js"],"names":["EmitterImpl","StateTransitionError","TransportState","Grammar","Transport","logger","options","_state","Disconnected","transitioningState","_stateEventEmitter","optionsDeprecated","wsServersDeprecated","wsServers","maxReconnectionAttemptsDeprecated","maxReconnectionAttempts","undefined","deprecatedMessage","warn","server","Array","configuration","Object","assign","defaultOptions","url","parsed","parse","error","Error","includes","scheme","_protocol","toUpperCase","disconnect","_connect","_disconnect","state","Connected","message","_send","log","Connecting","Promise","reject","transitionLoopDetectedError","connectPromise","resolve","Disconnecting","transitionState","e","ws","WebSocket","binaryType","addEventListener","ev","onWebSocketClose","onWebSocketError","onWebSocketOpen","onWebSocketMessage","_ws","connectResolve","connectReject","connectTimeout","setTimeout","connectionTimeout","close","disconnectPromise","disconnectResolve","disconnectReject","traceSip","send","code","data","finishedData","test","clearKeepAliveTimeout","TextDecoder","decode","Uint8Array","err","onMessage","newState","invalidTransition","oldState","clearTimeout","emit","startSendingKeepAlives","onConnect","stopSendingKeepAlives","onDisconnect","keepAliveDebounceTimeout","keepAliveDebounce","computeKeepAliveTimeout","upperBound","lowerBound","Math","random","keepAliveInterval","setInterval","sendKeepAlive","clearInterval"],"mappings":"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","sourcesContent":["import { EmitterImpl } from \"../../../api/emitter\";\nimport { StateTransitionError } from \"../../../api/exceptions\";\nimport { TransportState } from \"../../../api/transport-state\";\nimport { Grammar } from \"../../../core\";\n/**\n * Transport for SIP over secure WebSocket (WSS).\n * @public\n */\nexport class Transport {\n    constructor(logger, options) {\n        this._state = TransportState.Disconnected;\n        this.transitioningState = false;\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // logger\n        this.logger = logger;\n        // guard deprecated options (remove this in version 16.x)\n        if (options) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const optionsDeprecated = options;\n            const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;\n            const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;\n            if (wsServersDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"wsServers\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            if (maxReconnectionAttemptsDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            // hack\n            if (wsServersDeprecated && !options.server) {\n                if (typeof wsServersDeprecated === \"string\") {\n                    options.server = wsServersDeprecated;\n                }\n                if (wsServersDeprecated instanceof Array) {\n                    options.server = wsServersDeprecated[0];\n                }\n            }\n        }\n        // initialize configuration\n        this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options);\n        // validate server URL\n        const url = this.configuration.server;\n        const parsed = Grammar.parse(url, \"absoluteURI\");\n        if (parsed === -1) {\n            this.logger.error(`Invalid WebSocket Server URL \"${url}\"`);\n            throw new Error(\"Invalid WebSocket Server URL\");\n        }\n        if (![\"wss\", \"ws\", \"udp\"].includes(parsed.scheme)) {\n            this.logger.error(`Invalid scheme in WebSocket Server URL \"${url}\"`);\n            throw new Error(\"Invalid scheme in WebSocket Server URL\");\n        }\n        this._protocol = parsed.scheme.toUpperCase();\n    }\n    dispose() {\n        return this.disconnect();\n    }\n    /**\n     * The protocol.\n     *\n     * @remarks\n     * Formatted as defined for the Via header sent-protocol transport.\n     * https://tools.ietf.org/html/rfc3261#section-20.42\n     */\n    get protocol() {\n        return this._protocol;\n    }\n    /**\n     * The URL of the WebSocket Server.\n     */\n    get server() {\n        return this.configuration.server;\n    }\n    /**\n     * Transport state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Transport state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * The WebSocket.\n     */\n    get ws() {\n        return this._ws;\n    }\n    /**\n     * Connect to network.\n     * Resolves once connected. Otherwise rejects with an Error.\n     */\n    connect() {\n        return this._connect();\n    }\n    /**\n     * Disconnect from network.\n     * Resolves once disconnected. Otherwise rejects with an Error.\n     */\n    disconnect() {\n        return this._disconnect();\n    }\n    /**\n     * Returns true if the `state` equals \"Connected\".\n     * @remarks\n     * This is equivalent to `state === TransportState.Connected`.\n     */\n    isConnected() {\n        return this.state === TransportState.Connected;\n    }\n    /**\n     * Sends a message.\n     * Resolves once message is sent. Otherwise rejects with an Error.\n     * @param message - Message to send.\n     */\n    send(message) {\n        // Error handling is independent of whether the message was a request or\n        // response.\n        //\n        // If the transport user asks for a message to be sent over an\n        // unreliable transport, and the result is an ICMP error, the behavior\n        // depends on the type of ICMP error.  Host, network, port or protocol\n        // unreachable errors, or parameter problem errors SHOULD cause the\n        // transport layer to inform the transport user of a failure in sending.\n        // Source quench and TTL exceeded ICMP errors SHOULD be ignored.\n        //\n        // If the transport user asks for a request to be sent over a reliable\n        // transport, and the result is a connection failure, the transport\n        // layer SHOULD inform the transport user of a failure in sending.\n        // https://tools.ietf.org/html/rfc3261#section-18.4\n        return this._send(message);\n    }\n    _connect() {\n        this.logger.log(`Connecting ${this.server}`);\n        switch (this.state) {\n            case TransportState.Connecting:\n                // If `state` is \"Connecting\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n                }\n                if (!this.connectPromise) {\n                    throw new Error(\"Connect promise must be defined.\");\n                }\n                return this.connectPromise; // Already connecting\n            case TransportState.Connected:\n                // If `state` is \"Connected\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n                }\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                return Promise.resolve(); // Already connected\n            case TransportState.Disconnecting:\n                // If `state` is \"Disconnecting\", `state` MUST transition to \"Connecting\" before returning\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Connecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Disconnected:\n                // If `state` is \"Disconnected\" `state` MUST transition to \"Connecting\" before returning\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Connecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        let ws;\n        try {\n            // WebSocket()\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket\n            ws = new WebSocket(this.server, \"sip\");\n            ws.binaryType = \"arraybuffer\"; // set data type of received binary messages\n            ws.addEventListener(\"close\", (ev) => this.onWebSocketClose(ev, ws));\n            ws.addEventListener(\"error\", (ev) => this.onWebSocketError(ev, ws));\n            ws.addEventListener(\"open\", (ev) => this.onWebSocketOpen(ev, ws));\n            ws.addEventListener(\"message\", (ev) => this.onWebSocketMessage(ev, ws));\n            this._ws = ws;\n        }\n        catch (error) {\n            this._ws = undefined;\n            this.logger.error(\"WebSocket construction failed.\");\n            this.logger.error(error);\n            return new Promise((resolve, reject) => {\n                this.connectResolve = resolve;\n                this.connectReject = reject;\n                // The `state` MUST transition to \"Disconnecting\" or \"Disconnected\" before rejecting\n                this.transitionState(TransportState.Disconnected, error);\n            });\n        }\n        this.connectPromise = new Promise((resolve, reject) => {\n            this.connectResolve = resolve;\n            this.connectReject = reject;\n            this.connectTimeout = setTimeout(() => {\n                this.logger.warn(\"Connect timed out. \" +\n                    \"Exceeded time set in configuration.connectionTimeout: \" +\n                    this.configuration.connectionTimeout +\n                    \"s.\");\n                ws.close(1000); // careful here to use a local reference instead of this._ws\n            }, this.configuration.connectionTimeout * 1000);\n        });\n        return this.connectPromise;\n    }\n    _disconnect() {\n        this.logger.log(`Disconnecting ${this.server}`);\n        switch (this.state) {\n            case TransportState.Connecting:\n                // If `state` is \"Connecting\", `state` MUST transition to \"Disconnecting\" before returning.\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Disconnecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Connected:\n                // If `state` is \"Connected\", `state` MUST transition to \"Disconnecting\" before returning.\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Disconnecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Disconnecting:\n                // If `state` is \"Disconnecting\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n                }\n                if (!this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must be defined.\");\n                }\n                return this.disconnectPromise; // Already disconnecting\n            case TransportState.Disconnected:\n                // If `state` is \"Disconnected\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n                }\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                return Promise.resolve(); // Already disconnected\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        if (!this._ws) {\n            throw new Error(\"WebSocket must be defined.\");\n        }\n        const ws = this._ws;\n        this.disconnectPromise = new Promise((resolve, reject) => {\n            this.disconnectResolve = resolve;\n            this.disconnectReject = reject;\n            try {\n                // WebSocket.close()\n                // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n                ws.close(1000); // careful here to use a local reference instead of this._ws\n            }\n            catch (error) {\n                // Treating this as a coding error as it apparently can only happen\n                // if you pass close() invalid parameters (so it should never happen)\n                this.logger.error(\"WebSocket close failed.\");\n                this.logger.error(error);\n                throw error;\n            }\n        });\n        return this.disconnectPromise;\n    }\n    _send(message) {\n        if (this.configuration.traceSip === true) {\n            this.logger.log(\"Sending WebSocket message:\\n\\n\" + message + \"\\n\");\n        }\n        if (this._state !== TransportState.Connected) {\n            return Promise.reject(new Error(\"Not connected.\"));\n        }\n        if (!this._ws) {\n            throw new Error(\"WebSocket undefined.\");\n        }\n        try {\n            // WebSocket.send()\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n            this._ws.send(message);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                return Promise.reject(error);\n            }\n            return Promise.reject(new Error(\"WebSocket send failed.\"));\n        }\n        return Promise.resolve();\n    }\n    /**\n     * WebSocket \"onclose\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketClose(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        const message = `WebSocket closed ${this.server} (code: ${ev.code})`;\n        const error = !this.disconnectPromise ? new Error(message) : undefined;\n        if (error) {\n            this.logger.warn(\"WebSocket closed unexpectedly\");\n        }\n        this.logger.log(message);\n        // We are about to transition to disconnected, so clear our web socket\n        this._ws = undefined;\n        // The `state` MUST transition to \"Disconnected\" before resolving (assuming `state` is not already \"Disconnected\").\n        this.transitionState(TransportState.Disconnected, error);\n    }\n    /**\n     * WebSocket \"onerror\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketError(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        this.logger.error(\"WebSocket error occurred.\");\n    }\n    /**\n     * WebSocket \"onmessage\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketMessage(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        const data = ev.data;\n        let finishedData;\n        // CRLF Keep Alive response from server. Clear our keep alive timeout.\n        if (/^(\\r\\n)+$/.test(data)) {\n            this.clearKeepAliveTimeout();\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket message with CRLF Keep Alive response\");\n            }\n            return;\n        }\n        if (!data) {\n            this.logger.warn(\"Received empty message, discarding...\");\n            return;\n        }\n        if (typeof data !== \"string\") {\n            // WebSocket binary message.\n            try {\n                finishedData = new TextDecoder().decode(new Uint8Array(data));\n                // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.\n                // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.\n                // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.\n                // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));\n            }\n            catch (err) {\n                this.logger.error(err);\n                this.logger.error(\"Received WebSocket binary message failed to be converted into string, message discarded\");\n                return;\n            }\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket binary message:\\n\\n\" + finishedData + \"\\n\");\n            }\n        }\n        else {\n            // WebSocket text message.\n            finishedData = data;\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket text message:\\n\\n\" + finishedData + \"\\n\");\n            }\n        }\n        if (this.state !== TransportState.Connected) {\n            this.logger.warn(\"Received message while not connected, discarding...\");\n            return;\n        }\n        if (this.onMessage) {\n            try {\n                this.onMessage(finishedData);\n            }\n            catch (e) {\n                this.logger.error(e);\n                this.logger.error(\"Exception thrown by onMessage callback\");\n                throw e; // rethrow unhandled exception\n            }\n        }\n    }\n    /**\n     * WebSocket \"onopen\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketOpen(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        if (this._state === TransportState.Connecting) {\n            this.logger.log(`WebSocket opened ${this.server}`);\n            this.transitionState(TransportState.Connected);\n        }\n    }\n    /**\n     * Helper function to generate an Error.\n     * @param state - State transitioning to.\n     */\n    transitionLoopDetectedError(state) {\n        let message = `A state transition loop has been detected.`;\n        message += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;\n        message += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;\n        this.logger.error(message);\n        return new StateTransitionError(\"Loop detected.\");\n    }\n    /**\n     * Transition transport state.\n     * @internal\n     */\n    transitionState(newState, error) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        if (this.transitioningState) {\n            throw this.transitionLoopDetectedError(newState);\n        }\n        this.transitioningState = true;\n        // Validate state transition\n        switch (this._state) {\n            case TransportState.Connecting:\n                if (newState !== TransportState.Connected &&\n                    newState !== TransportState.Disconnecting &&\n                    newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Connected:\n                if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Disconnecting:\n                if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Disconnected:\n                if (newState !== TransportState.Connecting) {\n                    invalidTransition();\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        // Update state\n        const oldState = this._state;\n        this._state = newState;\n        // Local copies of connect promises (guarding against callbacks changing them indirectly)\n        // const connectPromise = this.connectPromise;\n        const connectResolve = this.connectResolve;\n        const connectReject = this.connectReject;\n        // Reset connect promises if no longer connecting\n        if (oldState === TransportState.Connecting) {\n            this.connectPromise = undefined;\n            this.connectResolve = undefined;\n            this.connectReject = undefined;\n        }\n        // Local copies of disconnect promises (guarding against callbacks changing them indirectly)\n        // const disconnectPromise = this.disconnectPromise;\n        const disconnectResolve = this.disconnectResolve;\n        const disconnectReject = this.disconnectReject;\n        // Reset disconnect promises if no longer disconnecting\n        if (oldState === TransportState.Disconnecting) {\n            this.disconnectPromise = undefined;\n            this.disconnectResolve = undefined;\n            this.disconnectReject = undefined;\n        }\n        // Clear any outstanding connect timeout\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n        this.logger.log(`Transitioned from ${oldState} to ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        //  Transition to Connected\n        if (newState === TransportState.Connected) {\n            this.startSendingKeepAlives();\n            if (this.onConnect) {\n                try {\n                    this.onConnect();\n                }\n                catch (e) {\n                    this.logger.error(e);\n                    this.logger.error(\"Exception thrown by onConnect callback\");\n                    throw e; // rethrow unhandled exception\n                }\n            }\n        }\n        //  Transition from Connected\n        if (oldState === TransportState.Connected) {\n            this.stopSendingKeepAlives();\n            if (this.onDisconnect) {\n                try {\n                    if (error) {\n                        this.onDisconnect(error);\n                    }\n                    else {\n                        this.onDisconnect();\n                    }\n                }\n                catch (e) {\n                    this.logger.error(e);\n                    this.logger.error(\"Exception thrown by onDisconnect callback\");\n                    throw e; // rethrow unhandled exception\n                }\n            }\n        }\n        // Complete connect promise\n        if (oldState === TransportState.Connecting) {\n            if (!connectResolve) {\n                throw new Error(\"Connect resolve undefined.\");\n            }\n            if (!connectReject) {\n                throw new Error(\"Connect reject undefined.\");\n            }\n            newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error(\"Connect aborted.\"));\n        }\n        // Complete disconnect promise\n        if (oldState === TransportState.Disconnecting) {\n            if (!disconnectResolve) {\n                throw new Error(\"Disconnect resolve undefined.\");\n            }\n            if (!disconnectReject) {\n                throw new Error(\"Disconnect reject undefined.\");\n            }\n            newState === TransportState.Disconnected\n                ? disconnectResolve()\n                : disconnectReject(error || new Error(\"Disconnect aborted.\"));\n        }\n        this.transitioningState = false;\n    }\n    // TODO: Review \"KeepAlive Stuff\".\n    // It is not clear if it works and there are no tests for it.\n    // It was blindly lifted the keep alive code unchanged from earlier transport code.\n    //\n    // From the RFC...\n    //\n    // SIP WebSocket Clients and Servers may keep their WebSocket\n    // connections open by sending periodic WebSocket \"Ping\" frames as\n    // described in [RFC6455], Section 5.5.2.\n    // ...\n    // The indication and use of the CRLF NAT keep-alive mechanism defined\n    // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or\n    // [RFC6223] are, of course, usable over the transport defined in this\n    // specification.\n    // https://tools.ietf.org/html/rfc7118#section-6\n    //\n    // and...\n    //\n    // The Ping frame contains an opcode of 0x9.\n    // https://tools.ietf.org/html/rfc6455#section-5.5.2\n    //\n    // ==============================\n    // KeepAlive Stuff\n    // ==============================\n    clearKeepAliveTimeout() {\n        if (this.keepAliveDebounceTimeout) {\n            clearTimeout(this.keepAliveDebounceTimeout);\n        }\n        this.keepAliveDebounceTimeout = undefined;\n    }\n    /**\n     * Send a keep-alive (a double-CRLF sequence).\n     */\n    sendKeepAlive() {\n        if (this.keepAliveDebounceTimeout) {\n            // We already have an outstanding keep alive, do not send another.\n            return Promise.resolve();\n        }\n        this.keepAliveDebounceTimeout = setTimeout(() => {\n            this.clearKeepAliveTimeout();\n        }, this.configuration.keepAliveDebounce * 1000);\n        return this.send(\"\\r\\n\\r\\n\");\n    }\n    /**\n     * Start sending keep-alives.\n     */\n    startSendingKeepAlives() {\n        // Compute an amount of time in seconds to wait before sending another keep-alive.\n        const computeKeepAliveTimeout = (upperBound) => {\n            const lowerBound = upperBound * 0.8;\n            return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n        };\n        if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n            this.keepAliveInterval = setInterval(() => {\n                this.sendKeepAlive();\n                this.startSendingKeepAlives();\n            }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n        }\n    }\n    /**\n     * Stop sending keep-alives.\n     */\n    stopSendingKeepAlives() {\n        if (this.keepAliveInterval) {\n            clearInterval(this.keepAliveInterval);\n        }\n        if (this.keepAliveDebounceTimeout) {\n            clearTimeout(this.keepAliveDebounceTimeout);\n        }\n        this.keepAliveInterval = undefined;\n        this.keepAliveDebounceTimeout = undefined;\n    }\n}\nTransport.defaultOptions = {\n    server: \"\",\n    connectionTimeout: 5,\n    keepAliveInterval: 0,\n    keepAliveDebounce: 10,\n    traceSip: true\n};\n"]},"metadata":{},"sourceType":"module"}