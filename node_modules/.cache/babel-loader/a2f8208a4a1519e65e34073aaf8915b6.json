{"ast":null,"code":"import { DigestAuthentication, Grammar, IncomingRequestMessage, IncomingResponseMessage, Levels, LoggerFactory, Parser, URI, UserAgentCore } from \"../core\";\nimport { createRandomToken, utf8Length } from \"../core/messages/utils\";\nimport { defaultSessionDescriptionHandlerFactory } from \"../platform/web/session-description-handler\";\nimport { Transport as WebTransport } from \"../platform/web/transport\";\nimport { LIBRARY_VERSION } from \"../version\";\nimport { EmitterImpl } from \"./emitter\";\nimport { Invitation } from \"./invitation\";\nimport { Inviter } from \"./inviter\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { SIPExtension, UserAgentRegisteredOptionTags } from \"./user-agent-options\";\nimport { UserAgentState } from \"./user-agent-state\";\n/**\n * A user agent sends and receives requests using a `Transport`.\n *\n * @remarks\n * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)\n * and acts on behalf of that user to send and receive SIP requests. The user agent can\n * register to receive incoming requests, as well as create and send outbound messages.\n * The user agent also maintains the Transport over which its signaling travels.\n *\n * @public\n */\n\nexport class UserAgent {\n  /**\n   * Constructs a new instance of the `UserAgent` class.\n   * @param options - Options bucket. See {@link UserAgentOptions} for details.\n   */\n  constructor(options = {}) {\n    /** @internal */\n    this._publishers = {};\n    /** @internal */\n\n    this._registerers = {};\n    /** @internal */\n\n    this._sessions = {};\n    /** @internal */\n\n    this._subscriptions = {};\n    this._state = UserAgentState.Stopped;\n    /** Unload listener. */\n\n    this.unloadListener = () => {\n      this.stop();\n    }; // state emitter\n\n\n    this._stateEventEmitter = new EmitterImpl(); // initialize delegate\n\n    this.delegate = options.delegate; // initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), {\n      sipjsId: createRandomToken(5)\n    }), {\n      uri: new URI(\"sip\", \"anonymous.\" + createRandomToken(6), \"anonymous.invalid\")\n    }), {\n      viaHost: createRandomToken(12) + \".invalid\"\n    }), UserAgent.stripUndefinedProperties(options)); // viaHost is hack\n\n    if (this.options.hackIpInContact) {\n      if (typeof this.options.hackIpInContact === \"boolean\" && this.options.hackIpInContact) {\n        const from = 1;\n        const to = 254;\n        const octet = Math.floor(Math.random() * (to - from + 1) + from); // random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n\n        this.options.viaHost = \"192.0.2.\" + octet;\n      } else if (this.options.hackIpInContact) {\n        this.options.viaHost = this.options.hackIpInContact;\n      }\n    } // initialize logger & logger factory\n\n\n    this.loggerFactory = new LoggerFactory();\n    this.logger = this.loggerFactory.getLogger(\"sip.UserAgent\");\n    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;\n    this.loggerFactory.connector = this.options.logConnector;\n\n    switch (this.options.logLevel) {\n      case \"error\":\n        this.loggerFactory.level = Levels.error;\n        break;\n\n      case \"warn\":\n        this.loggerFactory.level = Levels.warn;\n        break;\n\n      case \"log\":\n        this.loggerFactory.level = Levels.log;\n        break;\n\n      case \"debug\":\n        this.loggerFactory.level = Levels.debug;\n        break;\n\n      default:\n        break;\n    }\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(key => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value = this.options[key];\n\n        switch (key) {\n          case \"uri\":\n          case \"sessionDescriptionHandlerFactory\":\n            this.logger.log(\"路 \" + key + \": \" + value);\n            break;\n\n          case \"authorizationPassword\":\n            this.logger.log(\"路 \" + key + \": \" + \"NOT SHOWN\");\n            break;\n\n          case \"transportConstructor\":\n            this.logger.log(\"路 \" + key + \": \" + value.name);\n            break;\n\n          default:\n            this.logger.log(\"路 \" + key + \": \" + JSON.stringify(value));\n        }\n      });\n    } // guard deprecated transport options (remove this in version 16.x)\n\n\n    if (this.options.transportOptions) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const optionsDeprecated = this.options.transportOptions;\n      const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;\n      const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (reconnectionTimeoutDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      } // hack\n\n\n      if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {\n        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;\n      }\n\n      if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {\n        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;\n      }\n    } // guard deprecated user agent options (remove this in version 16.x)\n\n\n    if (options.reconnectionDelay !== undefined) {\n      const deprecatedMessage = `The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n      this.logger.warn(deprecatedMessage);\n    }\n\n    if (options.reconnectionAttempts !== undefined) {\n      const deprecatedMessage = `The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n      this.logger.warn(deprecatedMessage);\n    } // Initialize Transport\n\n\n    this._transport = new this.options.transportConstructor(this.getLogger(\"sip.Transport\"), this.options.transportOptions);\n    this.initTransportCallbacks(); // Initialize Contact\n\n    this._contact = this.initContact(); // Initialize UserAgentCore\n\n    this._userAgentCore = this.initCore();\n\n    if (this.options.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Create a URI instance from a string.\n   * @param uri - The string to parse.\n   *\n   * @example\n   * ```ts\n   * const uri = UserAgent.makeURI(\"sip:edgar@example.com\");\n   * ```\n   */\n\n\n  static makeURI(uri) {\n    return Grammar.URIParse(uri);\n  }\n  /** Default user agent options. */\n\n\n  static defaultOptions() {\n    return {\n      allowLegacyNotifications: false,\n      authorizationHa1: \"\",\n      authorizationPassword: \"\",\n      authorizationUsername: \"\",\n      autoStart: false,\n      autoStop: true,\n      delegate: {},\n      displayName: \"\",\n      forceRport: false,\n      hackAllowUnregisteredOptionTags: false,\n      hackIpInContact: false,\n      hackViaTcp: false,\n      hackWssInTransport: false,\n      logBuiltinEnabled: true,\n      logConfiguration: true,\n      logConnector: () => {\n        /* noop */\n      },\n      logLevel: \"log\",\n      noAnswerTimeout: 60,\n      preloadedRouteSet: [],\n      reconnectionAttempts: 0,\n      reconnectionDelay: 4,\n      sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),\n      sessionDescriptionHandlerFactoryOptions: {},\n      sipExtension100rel: SIPExtension.Unsupported,\n      sipExtensionReplaces: SIPExtension.Unsupported,\n      sipExtensionExtraSupported: [],\n      sipjsId: \"\",\n      transportConstructor: WebTransport,\n      transportOptions: {},\n      uri: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n      userAgentString: \"SIP.js/\" + LIBRARY_VERSION,\n      viaHost: \"\"\n    };\n  }\n  /**\n   * Strip properties with undefined values from options.\n   * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n   * https://github.com/Microsoft/TypeScript/issues/13195\n   * @param options - Options to reduce\n   */\n\n\n  static stripUndefinedProperties(options) {\n    return Object.keys(options).reduce((object, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (options[key] !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        object[key] = options[key];\n      }\n\n      return object;\n    }, {});\n  }\n  /**\n   * User agent configuration.\n   */\n\n\n  get configuration() {\n    return this.options;\n  }\n  /**\n   * User agent contact.\n   */\n\n\n  get contact() {\n    return this._contact;\n  }\n  /**\n   * User agent state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * User agent state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * User agent transport.\n   */\n\n\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * User agent core.\n   */\n\n\n  get userAgentCore() {\n    return this._userAgentCore;\n  }\n  /**\n   * The logger.\n   */\n\n\n  getLogger(category, label) {\n    return this.loggerFactory.getLogger(category, label);\n  }\n  /**\n   * The logger factory.\n   */\n\n\n  getLoggerFactory() {\n    return this.loggerFactory;\n  }\n  /**\n   * True if transport is connected.\n   */\n\n\n  isConnected() {\n    return this.transport.isConnected();\n  }\n  /**\n   * Reconnect the transport.\n   */\n\n\n  reconnect() {\n    if (this.state === UserAgentState.Stopped) {\n      return Promise.reject(new Error(\"User agent stopped.\"));\n    } // Make sure we don't call synchronously\n\n\n    return Promise.resolve().then(() => this.transport.connect());\n  }\n  /**\n   * Start the user agent.\n   *\n   * @remarks\n   * Resolves if transport connects, otherwise rejects.\n   *\n   * @example\n   * ```ts\n   * userAgent.start()\n   *   .then(() => {\n   *     // userAgent.isConnected() === true\n   *   })\n   *   .catch((error: Error) => {\n   *     // userAgent.isConnected() === false\n   *   });\n   * ```\n   */\n\n\n  start() {\n    if (this.state === UserAgentState.Started) {\n      this.logger.warn(`User agent already started`);\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Starting ${this.configuration.uri}`); // Transition state\n\n    this.transitionState(UserAgentState.Started); // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.\n    // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this\n    // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.\n    // Should this perhaps be deprecated?\n    //\n    // Add window unload event listener\n\n    if (this.options.autoStop) {\n      // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n      const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n\n      if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && !googleChromePackagedApp) {\n        window.addEventListener(\"unload\", this.unloadListener);\n      }\n    }\n\n    return this.transport.connect();\n  }\n  /**\n   * Stop the user agent.\n   *\n   * @remarks\n   * Resolves when the user agent has completed a graceful shutdown.\n   * ```txt\n   * 1) Sessions terminate.\n   * 2) Registerers unregister.\n   * 3) Subscribers unsubscribe.\n   * 4) Publishers unpublish.\n   * 5) Transport disconnects.\n   * 6) User Agent Core resets.\n   * ```\n   * NOTE: While this is a \"graceful shutdown\", it can also be very slow one if you\n   * are waiting for the returned Promise to resolve. The disposal of the clients and\n   * dialogs is done serially - waiting on one to finish before moving on to the next.\n   * This can be slow if there are lot of subscriptions to unsubscribe for example.\n   *\n   * THE SLOW PACE IS INTENTIONAL!\n   * While one could spin them all down in parallel, this could slam the remote server.\n   * It is bad practice to denial of service attack (DoS attack) servers!!!\n   * Moreover, production servers will automatically blacklist clients which send too\n   * many requests in too short a period of time - dropping any additional requests.\n   *\n   * If a different approach to disposing is needed, one can implement whatever is\n   * needed and execute that prior to calling `stop()`. Alternatively one may simply\n   * not wait for the Promise returned by `stop()` to complete.\n   */\n\n\n  async stop() {\n    if (this.state === UserAgentState.Stopped) {\n      this.logger.warn(`User agent already stopped`);\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Stopping ${this.configuration.uri}`); // Transition state\n\n    this.transitionState(UserAgentState.Stopped); // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?\n    // Remove window unload event listener\n\n    if (this.options.autoStop) {\n      // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n      const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n\n      if (typeof window !== \"undefined\" && window.removeEventListener && !googleChromePackagedApp) {\n        window.removeEventListener(\"unload\", this.unloadListener);\n      }\n    } // Be careful here to use a local references as start() can be called\n    // again before we complete and we don't want to touch new clients\n    // and we don't want to step on the new instances (or vice versa).\n\n\n    const publishers = Object.assign({}, this._publishers);\n    const registerers = Object.assign({}, this._registerers);\n    const sessions = Object.assign({}, this._sessions);\n    const subscriptions = Object.assign({}, this._subscriptions);\n    const transport = this.transport;\n    const userAgentCore = this.userAgentCore; //\n    // At this point we have completed the state transition and everything\n    // following will effectively run async and MUST NOT cause any issues\n    // if UserAgent.start() is called while the following code continues.\n    //\n    // TODO: Minor optimization.\n    // The disposal in all cases involves, in part, sending messages which\n    // is not worth doing if the transport is not connected as we know attempting\n    // to send messages will be futile. But none of these disposal methods check\n    // if that's is the case and it would be easy for them to do so at this point.\n    // Dispose of Registerers\n\n    this.logger.log(`Dispose of registerers`);\n\n    for (const id in registerers) {\n      if (registerers[id]) {\n        await registerers[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._registerers[id];\n          throw error;\n        });\n      }\n    } // Dispose of Sessions\n\n\n    this.logger.log(`Dispose of sessions`);\n\n    for (const id in sessions) {\n      if (sessions[id]) {\n        await sessions[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._sessions[id];\n          throw error;\n        });\n      }\n    } // Dispose of Subscriptions\n\n\n    this.logger.log(`Dispose of subscriptions`);\n\n    for (const id in subscriptions) {\n      if (subscriptions[id]) {\n        await subscriptions[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._subscriptions[id];\n          throw error;\n        });\n      }\n    } // Dispose of Publishers\n\n\n    this.logger.log(`Dispose of publishers`);\n\n    for (const id in publishers) {\n      if (publishers[id]) {\n        await publishers[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._publishers[id];\n          throw error;\n        });\n      }\n    } // Dispose of the transport (disconnecting)\n\n\n    this.logger.log(`Dispose of transport`);\n    await transport.dispose().catch(error => {\n      this.logger.error(error.message);\n      throw error;\n    }); // Dispose of the user agent core (resetting)\n\n    this.logger.log(`Dispose of core`);\n    userAgentCore.dispose();\n  }\n  /**\n   * Used to avoid circular references.\n   * @internal\n   */\n\n\n  _makeInviter(targetURI, options) {\n    return new Inviter(this, targetURI, options);\n  }\n  /**\n   * Attempt reconnection up to `maxReconnectionAttempts` times.\n   * @param reconnectionAttempt - Current attempt number.\n   */\n\n\n  attemptReconnection(reconnectionAttempt = 1) {\n    const reconnectionAttempts = this.options.reconnectionAttempts;\n    const reconnectionDelay = this.options.reconnectionDelay;\n\n    if (reconnectionAttempt > reconnectionAttempts) {\n      this.logger.log(`Maximum reconnection attempts reached`);\n      return;\n    }\n\n    this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n    setTimeout(() => {\n      this.reconnect().then(() => {\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n      }).catch(error => {\n        this.logger.error(error.message);\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n        this.attemptReconnection(++reconnectionAttempt);\n      });\n    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n  }\n  /**\n   * Initialize contact.\n   */\n\n\n  initContact() {\n    const contactName = createRandomToken(8); // FIXME: should be configurable\n\n    const contactTransport = this.options.hackWssInTransport ? \"wss\" : \"ws\"; // FIXME: clearly broken for non ws transports\n\n    const contact = {\n      pubGruu: undefined,\n      tempGruu: undefined,\n      uri: new URI(\"sip\", contactName, this.options.viaHost, undefined, {\n        transport: contactTransport\n      }),\n      toString: (contactToStringOptions = {}) => {\n        const anonymous = contactToStringOptions.anonymous || false;\n        const outbound = contactToStringOptions.outbound || false;\n        let contactString = \"<\";\n\n        if (anonymous) {\n          contactString += this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${contactTransport}`;\n        } else {\n          contactString += this.contact.pubGruu || this.contact.uri;\n        }\n\n        if (outbound) {\n          contactString += \";ob\";\n        }\n\n        contactString += \">\";\n        return contactString;\n      }\n    };\n    return contact;\n  }\n  /**\n   * Initialize user agent core.\n   */\n\n\n  initCore() {\n    // supported options\n    let supportedOptionTags = [];\n    supportedOptionTags.push(\"outbound\"); // TODO: is this really supported?\n\n    if (this.options.sipExtension100rel === SIPExtension.Supported) {\n      supportedOptionTags.push(\"100rel\");\n    }\n\n    if (this.options.sipExtensionReplaces === SIPExtension.Supported) {\n      supportedOptionTags.push(\"replaces\");\n    }\n\n    if (this.options.sipExtensionExtraSupported) {\n      supportedOptionTags.push(...this.options.sipExtensionExtraSupported);\n    }\n\n    if (!this.options.hackAllowUnregisteredOptionTags) {\n      supportedOptionTags = supportedOptionTags.filter(optionTag => UserAgentRegisteredOptionTags[optionTag]);\n    }\n\n    supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values\n    // FIXME: TODO: This was ported, but this is and was just plain broken.\n\n    const supportedOptionTagsResponse = supportedOptionTags.slice();\n\n    if (this.contact.pubGruu || this.contact.tempGruu) {\n      supportedOptionTagsResponse.push(\"gruu\");\n    } // core configuration\n\n\n    const userAgentCoreConfiguration = {\n      aor: this.options.uri,\n      contact: this.contact,\n      displayName: this.options.displayName,\n      loggerFactory: this.loggerFactory,\n      hackViaTcp: this.options.hackViaTcp,\n      routeSet: this.options.preloadedRouteSet,\n      supportedOptionTags,\n      supportedOptionTagsResponse,\n      sipjsId: this.options.sipjsId,\n      userAgentHeaderFieldValue: this.options.userAgentString,\n      viaForceRport: this.options.forceRport,\n      viaHost: this.options.viaHost,\n      authenticationFactory: () => {\n        const username = this.options.authorizationUsername ? this.options.authorizationUsername : this.options.uri.user; // if authorization username not provided, use uri user as username\n\n        const password = this.options.authorizationPassword ? this.options.authorizationPassword : undefined;\n        const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : undefined;\n        return new DigestAuthentication(this.getLoggerFactory(), ha1, username, password);\n      },\n      transportAccessor: () => this.transport\n    };\n    const userAgentCoreDelegate = {\n      onInvite: incomingInviteRequest => {\n        var _a;\n\n        const invitation = new Invitation(this, incomingInviteRequest);\n        incomingInviteRequest.delegate = {\n          onCancel: cancel => {\n            invitation._onCancel(cancel);\n          },\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          onTransportError: error => {\n            // A server transaction MUST NOT discard transaction state based only on\n            // encountering a non-recoverable transport error when sending a\n            // response.  Instead, the associated INVITE server transaction state\n            // machine MUST remain in its current state.  (Timers will eventually\n            // cause it to transition to the \"Terminated\" state).\n            // https://tools.ietf.org/html/rfc6026#section-7.1\n            // As noted in the comment above, we are to leaving it to the transaction\n            // timers to eventually cause the transaction to sort itself out in the case\n            // of a transport failure in an invite server transaction. This delegate method\n            // is here simply here for completeness and to make it clear that it provides\n            // nothing more than informational hook into the core. That is, if you think\n            // you should be trying to deal with a transport error here, you are likely wrong.\n            this.logger.error(\"A transport error has occurred while handling an incoming INVITE request.\");\n          }\n        }; // FIXME: Ported - 100 Trying send should be configurable.\n        // Only required if TU will not respond in 200ms.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n        incomingInviteRequest.trying(); // The Replaces header contains information used to match an existing\n        // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE\n        // with a Replaces header, the User Agent (UA) attempts to match this\n        // information with a confirmed or early dialog.\n        // https://tools.ietf.org/html/rfc3891#section-3\n\n        if (this.options.sipExtensionReplaces !== SIPExtension.Unsupported) {\n          const message = incomingInviteRequest.message;\n          const replaces = message.parseHeader(\"replaces\");\n\n          if (replaces) {\n            const callId = replaces.call_id;\n\n            if (typeof callId !== \"string\") {\n              throw new Error(\"Type of call id is not string\");\n            }\n\n            const toTag = replaces.replaces_to_tag;\n\n            if (typeof toTag !== \"string\") {\n              throw new Error(\"Type of to tag is not string\");\n            }\n\n            const fromTag = replaces.replaces_from_tag;\n\n            if (typeof fromTag !== \"string\") {\n              throw new Error(\"type of from tag is not string\");\n            }\n\n            const targetDialogId = callId + toTag + fromTag;\n            const targetDialog = this.userAgentCore.dialogs.get(targetDialogId); // If no match is found, the UAS rejects the INVITE and returns a 481\n            // Call/Transaction Does Not Exist response.  Likewise, if the Replaces\n            // header field matches a dialog which was not created with an INVITE,\n            // the UAS MUST reject the request with a 481 response.\n            // https://tools.ietf.org/html/rfc3891#section-3\n\n            if (!targetDialog) {\n              invitation.reject({\n                statusCode: 481\n              });\n              return;\n            } // If the Replaces header field matches a confirmed dialog, it checks\n            // for the presence of the \"early-only\" flag in the Replaces header\n            // field.  (This flag allows the UAC to prevent a potentially\n            // undesirable race condition described in Section 7.1.) If the flag is\n            // present, the UA rejects the request with a 486 Busy response.\n            // https://tools.ietf.org/html/rfc3891#section-3\n\n\n            if (!targetDialog.early && replaces.early_only === true) {\n              invitation.reject({\n                statusCode: 486\n              });\n              return;\n            } // Provide a handle on the session being replaced.\n\n\n            const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || undefined;\n\n            if (!targetSession) {\n              throw new Error(\"Session does not exist.\");\n            }\n\n            invitation._replacee = targetSession;\n          }\n        } // Delegate invitation handling.\n\n\n        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {\n          if (invitation.autoSendAnInitialProvisionalResponse) {\n            invitation.progress().then(() => {\n              var _a;\n\n              if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {\n                throw new Error(\"onInvite undefined.\");\n              }\n\n              this.delegate.onInvite(invitation);\n            });\n            return;\n          }\n\n          this.delegate.onInvite(invitation);\n          return;\n        } // A common scenario occurs when the callee is currently not willing or\n        // able to take additional calls at this end system.  A 486 (Busy Here)\n        // SHOULD be returned in such a scenario.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n\n\n        invitation.reject({\n          statusCode: 486\n        });\n      },\n      onMessage: incomingMessageRequest => {\n        if (this.delegate && this.delegate.onMessage) {\n          const message = new Message(incomingMessageRequest);\n          this.delegate.onMessage(message);\n        } else {\n          // Accept the MESSAGE request, but do nothing with it.\n          incomingMessageRequest.accept();\n        }\n      },\n      onNotify: incomingNotifyRequest => {\n        // NOTIFY requests are sent to inform subscribers of changes in state to\n        // which the subscriber has a subscription.  Subscriptions are created\n        // using the SUBSCRIBE method.  In legacy implementations, it is\n        // possible that other means of subscription creation have been used.\n        // However, this specification does not allow the creation of\n        // subscriptions except through SUBSCRIBE requests and (for backwards-\n        // compatibility) REFER requests [RFC3515].\n        // https://tools.ietf.org/html/rfc6665#section-3.2\n        if (this.delegate && this.delegate.onNotify) {\n          const notification = new Notification(incomingNotifyRequest);\n          this.delegate.onNotify(notification);\n        } else {\n          // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,\n          // the use of out of dialog NOTIFY is obsolete, but...\n          if (this.options.allowLegacyNotifications) {\n            incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.\n          } else {\n            incomingNotifyRequest.reject({\n              statusCode: 481\n            });\n          }\n        }\n      },\n      onRefer: incomingReferRequest => {\n        this.logger.warn(\"Received an out of dialog REFER request\"); // TOOD: this.delegate.onRefer(...)\n\n        if (this.delegate && this.delegate.onReferRequest) {\n          this.delegate.onReferRequest(incomingReferRequest);\n        } else {\n          incomingReferRequest.reject({\n            statusCode: 405\n          });\n        }\n      },\n      onRegister: incomingRegisterRequest => {\n        this.logger.warn(\"Received an out of dialog REGISTER request\"); // TOOD: this.delegate.onRegister(...)\n\n        if (this.delegate && this.delegate.onRegisterRequest) {\n          this.delegate.onRegisterRequest(incomingRegisterRequest);\n        } else {\n          incomingRegisterRequest.reject({\n            statusCode: 405\n          });\n        }\n      },\n      onSubscribe: incomingSubscribeRequest => {\n        this.logger.warn(\"Received an out of dialog SUBSCRIBE request\"); // TOOD: this.delegate.onSubscribe(...)\n\n        if (this.delegate && this.delegate.onSubscribeRequest) {\n          this.delegate.onSubscribeRequest(incomingSubscribeRequest);\n        } else {\n          incomingSubscribeRequest.reject({\n            statusCode: 405\n          });\n        }\n      }\n    };\n    return new UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);\n  }\n\n  initTransportCallbacks() {\n    this.transport.onConnect = () => this.onTransportConnect();\n\n    this.transport.onDisconnect = error => this.onTransportDisconnect(error);\n\n    this.transport.onMessage = message => this.onTransportMessage(message);\n  }\n\n  onTransportConnect() {\n    if (this.state === UserAgentState.Stopped) {\n      return;\n    }\n\n    if (this.delegate && this.delegate.onConnect) {\n      this.delegate.onConnect();\n    }\n  }\n\n  onTransportDisconnect(error) {\n    if (this.state === UserAgentState.Stopped) {\n      return;\n    }\n\n    if (this.delegate && this.delegate.onDisconnect) {\n      this.delegate.onDisconnect(error);\n    } // Only attempt to reconnect if network/server dropped the connection.\n\n\n    if (error && this.options.reconnectionAttempts > 0) {\n      this.attemptReconnection();\n    }\n  }\n\n  onTransportMessage(messageString) {\n    const message = Parser.parseMessage(messageString, this.getLogger(\"sip.Parser\"));\n\n    if (!message) {\n      this.logger.warn(\"Failed to parse incoming message. Dropping.\");\n      return;\n    }\n\n    if (this.state === UserAgentState.Stopped && message instanceof IncomingRequestMessage) {\n      this.logger.warn(`Received ${message.method} request while stopped. Dropping.`);\n      return;\n    } // A valid SIP request formulated by a UAC MUST, at a minimum, contain\n    // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,\n    // and Via; all of these header fields are mandatory in all SIP\n    // requests.\n    // https://tools.ietf.org/html/rfc3261#section-8.1.1\n\n\n    const hasMinimumHeaders = () => {\n      const mandatoryHeaders = [\"from\", \"to\", \"call_id\", \"cseq\", \"via\"];\n\n      for (const header of mandatoryHeaders) {\n        if (!message.hasHeader(header)) {\n          this.logger.warn(`Missing mandatory header field : ${header}.`);\n          return false;\n        }\n      }\n\n      return true;\n    }; // Request Checks\n\n\n    if (message instanceof IncomingRequestMessage) {\n      // This is port of SanityCheck.minimumHeaders().\n      if (!hasMinimumHeaders()) {\n        this.logger.warn(`Request missing mandatory header field. Dropping.`);\n        return;\n      } // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).\n      // Custom SIP.js check to reject request from ourself (this instance of SIP.js).\n      // This is port of SanityCheck.rfc3261_16_3_4().\n\n\n      if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {\n        this.userAgentCore.replyStateless(message, {\n          statusCode: 482\n        });\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to reject requests if body length wrong.\n      // This is port of SanityCheck.rfc3261_18_3_request().\n\n\n      const len = utf8Length(message.body);\n      const contentLength = message.getHeader(\"content-length\");\n\n      if (contentLength && len < Number(contentLength)) {\n        this.userAgentCore.replyStateless(message, {\n          statusCode: 400\n        });\n        return;\n      }\n    } // Response Checks\n\n\n    if (message instanceof IncomingResponseMessage) {\n      // This is port of SanityCheck.minimumHeaders().\n      if (!hasMinimumHeaders()) {\n        this.logger.warn(`Response missing mandatory header field. Dropping.`);\n        return;\n      } // Custom SIP.js check to drop responses if multiple Via headers.\n      // This is port of SanityCheck.rfc3261_8_1_3_3().\n\n\n      if (message.getHeaders(\"via\").length > 1) {\n        this.logger.warn(\"More than one Via header field present in the response. Dropping.\");\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to drop responses if bad Via header.\n      // This is port of SanityCheck.rfc3261_18_1_2().\n\n\n      if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {\n        this.logger.warn(\"Via sent-by in the response does not match UA Via host value. Dropping.\");\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to reject requests if body length wrong.\n      // This is port of SanityCheck.rfc3261_18_3_response().\n\n\n      const len = utf8Length(message.body);\n      const contentLength = message.getHeader(\"content-length\");\n\n      if (contentLength && len < Number(contentLength)) {\n        this.logger.warn(\"Message body length is lower than the value in Content-Length header field. Dropping.\");\n        return;\n      }\n    } // Handle Request\n\n\n    if (message instanceof IncomingRequestMessage) {\n      this.userAgentCore.receiveIncomingRequestFromTransport(message);\n      return;\n    } // Handle Response\n\n\n    if (message instanceof IncomingResponseMessage) {\n      this.userAgentCore.receiveIncomingResponseFromTransport(message);\n      return;\n    }\n\n    throw new Error(\"Invalid message type.\");\n  }\n  /**\n   * Transition state.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  transitionState(newState, error) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate state transition\n\n\n    switch (this._state) {\n      case UserAgentState.Started:\n        if (newState !== UserAgentState.Stopped) {\n          invalidTransition();\n        }\n\n        break;\n\n      case UserAgentState.Stopped:\n        if (newState !== UserAgentState.Started) {\n          invalidTransition();\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    } // Update state\n\n\n    this.logger.log(`Transitioned from ${this._state} to ${newState}`);\n    this._state = newState;\n\n    this._stateEventEmitter.emit(this._state);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/api/user-agent.js"],"names":["DigestAuthentication","Grammar","IncomingRequestMessage","IncomingResponseMessage","Levels","LoggerFactory","Parser","URI","UserAgentCore","createRandomToken","utf8Length","defaultSessionDescriptionHandlerFactory","Transport","WebTransport","LIBRARY_VERSION","EmitterImpl","Invitation","Inviter","Message","Notification","SIPExtension","UserAgentRegisteredOptionTags","UserAgentState","UserAgent","constructor","options","_publishers","_registerers","_sessions","_subscriptions","_state","Stopped","unloadListener","stop","_stateEventEmitter","delegate","Object","assign","defaultOptions","sipjsId","uri","viaHost","stripUndefinedProperties","hackIpInContact","from","to","octet","Math","floor","random","loggerFactory","logger","getLogger","builtinEnabled","logBuiltinEnabled","connector","logConnector","logLevel","level","error","warn","log","debug","logConfiguration","keys","forEach","key","value","name","JSON","stringify","transportOptions","optionsDeprecated","maxReconnectionAttemptsDeprecated","maxReconnectionAttempts","reconnectionTimeoutDeprecated","reconnectionTimeout","undefined","deprecatedMessage","reconnectionDelay","reconnectionAttempts","_transport","transportConstructor","initTransportCallbacks","_contact","initContact","_userAgentCore","initCore","autoStart","start","makeURI","URIParse","allowLegacyNotifications","authorizationHa1","authorizationPassword","authorizationUsername","autoStop","displayName","forceRport","hackAllowUnregisteredOptionTags","hackViaTcp","hackWssInTransport","noAnswerTimeout","preloadedRouteSet","sessionDescriptionHandlerFactory","sessionDescriptionHandlerFactoryOptions","sipExtension100rel","Unsupported","sipExtensionReplaces","sipExtensionExtraSupported","userAgentString","reduce","object","configuration","contact","state","stateChange","transport","userAgentCore","category","label","getLoggerFactory","isConnected","reconnect","Promise","reject","Error","resolve","then","connect","Started","transitionState","googleChromePackagedApp","chrome","app","runtime","window","addEventListener","removeEventListener","publishers","registerers","sessions","subscriptions","id","dispose","catch","message","_makeInviter","targetURI","attemptReconnection","reconnectionAttempt","setTimeout","contactName","contactTransport","pubGruu","tempGruu","toString","contactToStringOptions","anonymous","outbound","contactString","supportedOptionTags","push","Supported","filter","optionTag","Array","Set","supportedOptionTagsResponse","slice","userAgentCoreConfiguration","aor","routeSet","userAgentHeaderFieldValue","viaForceRport","authenticationFactory","username","user","password","ha1","transportAccessor","userAgentCoreDelegate","onInvite","incomingInviteRequest","_a","invitation","onCancel","cancel","_onCancel","onTransportError","trying","replaces","parseHeader","callId","call_id","toTag","replaces_to_tag","fromTag","replaces_from_tag","targetDialogId","targetDialog","dialogs","get","statusCode","early","early_only","targetSession","_replacee","autoSendAnInitialProvisionalResponse","progress","onMessage","incomingMessageRequest","accept","onNotify","incomingNotifyRequest","notification","onRefer","incomingReferRequest","onReferRequest","onRegister","incomingRegisterRequest","onRegisterRequest","onSubscribe","incomingSubscribeRequest","onSubscribeRequest","onConnect","onTransportConnect","onDisconnect","onTransportDisconnect","onTransportMessage","messageString","parseMessage","method","hasMinimumHeaders","mandatoryHeaders","header","hasHeader","substr","replyStateless","len","body","contentLength","getHeader","Number","getHeaders","length","via","host","port","receiveIncomingRequestFromTransport","receiveIncomingResponseFromTransport","newState","invalidTransition","emit"],"mappings":"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","sourcesContent":["import { DigestAuthentication, Grammar, IncomingRequestMessage, IncomingResponseMessage, Levels, LoggerFactory, Parser, URI, UserAgentCore } from \"../core\";\nimport { createRandomToken, utf8Length } from \"../core/messages/utils\";\nimport { defaultSessionDescriptionHandlerFactory } from \"../platform/web/session-description-handler\";\nimport { Transport as WebTransport } from \"../platform/web/transport\";\nimport { LIBRARY_VERSION } from \"../version\";\nimport { EmitterImpl } from \"./emitter\";\nimport { Invitation } from \"./invitation\";\nimport { Inviter } from \"./inviter\";\nimport { Message } from \"./message\";\nimport { Notification } from \"./notification\";\nimport { SIPExtension, UserAgentRegisteredOptionTags } from \"./user-agent-options\";\nimport { UserAgentState } from \"./user-agent-state\";\n/**\n * A user agent sends and receives requests using a `Transport`.\n *\n * @remarks\n * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)\n * and acts on behalf of that user to send and receive SIP requests. The user agent can\n * register to receive incoming requests, as well as create and send outbound messages.\n * The user agent also maintains the Transport over which its signaling travels.\n *\n * @public\n */\nexport class UserAgent {\n    /**\n     * Constructs a new instance of the `UserAgent` class.\n     * @param options - Options bucket. See {@link UserAgentOptions} for details.\n     */\n    constructor(options = {}) {\n        /** @internal */\n        this._publishers = {};\n        /** @internal */\n        this._registerers = {};\n        /** @internal */\n        this._sessions = {};\n        /** @internal */\n        this._subscriptions = {};\n        this._state = UserAgentState.Stopped;\n        /** Unload listener. */\n        this.unloadListener = () => {\n            this.stop();\n        };\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // initialize delegate\n        this.delegate = options.delegate;\n        // initialize configuration\n        this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), { sipjsId: createRandomToken(5) }), { uri: new URI(\"sip\", \"anonymous.\" + createRandomToken(6), \"anonymous.invalid\") }), { viaHost: createRandomToken(12) + \".invalid\" }), UserAgent.stripUndefinedProperties(options));\n        // viaHost is hack\n        if (this.options.hackIpInContact) {\n            if (typeof this.options.hackIpInContact === \"boolean\" && this.options.hackIpInContact) {\n                const from = 1;\n                const to = 254;\n                const octet = Math.floor(Math.random() * (to - from + 1) + from);\n                // random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n                this.options.viaHost = \"192.0.2.\" + octet;\n            }\n            else if (this.options.hackIpInContact) {\n                this.options.viaHost = this.options.hackIpInContact;\n            }\n        }\n        // initialize logger & logger factory\n        this.loggerFactory = new LoggerFactory();\n        this.logger = this.loggerFactory.getLogger(\"sip.UserAgent\");\n        this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;\n        this.loggerFactory.connector = this.options.logConnector;\n        switch (this.options.logLevel) {\n            case \"error\":\n                this.loggerFactory.level = Levels.error;\n                break;\n            case \"warn\":\n                this.loggerFactory.level = Levels.warn;\n                break;\n            case \"log\":\n                this.loggerFactory.level = Levels.log;\n                break;\n            case \"debug\":\n                this.loggerFactory.level = Levels.debug;\n                break;\n            default:\n                break;\n        }\n        if (this.options.logConfiguration) {\n            this.logger.log(\"Configuration:\");\n            Object.keys(this.options).forEach((key) => {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const value = this.options[key];\n                switch (key) {\n                    case \"uri\":\n                    case \"sessionDescriptionHandlerFactory\":\n                        this.logger.log(\"路 \" + key + \": \" + value);\n                        break;\n                    case \"authorizationPassword\":\n                        this.logger.log(\"路 \" + key + \": \" + \"NOT SHOWN\");\n                        break;\n                    case \"transportConstructor\":\n                        this.logger.log(\"路 \" + key + \": \" + value.name);\n                        break;\n                    default:\n                        this.logger.log(\"路 \" + key + \": \" + JSON.stringify(value));\n                }\n            });\n        }\n        // guard deprecated transport options (remove this in version 16.x)\n        if (this.options.transportOptions) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const optionsDeprecated = this.options.transportOptions;\n            const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;\n            const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;\n            if (maxReconnectionAttemptsDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            if (reconnectionTimeoutDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            // hack\n            if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {\n                this.options.reconnectionDelay = reconnectionTimeoutDeprecated;\n            }\n            if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {\n                this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;\n            }\n        }\n        // guard deprecated user agent options (remove this in version 16.x)\n        if (options.reconnectionDelay !== undefined) {\n            const deprecatedMessage = `The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. ` +\n                \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n            this.logger.warn(deprecatedMessage);\n        }\n        if (options.reconnectionAttempts !== undefined) {\n            const deprecatedMessage = `The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n            this.logger.warn(deprecatedMessage);\n        }\n        // Initialize Transport\n        this._transport = new this.options.transportConstructor(this.getLogger(\"sip.Transport\"), this.options.transportOptions);\n        this.initTransportCallbacks();\n        // Initialize Contact\n        this._contact = this.initContact();\n        // Initialize UserAgentCore\n        this._userAgentCore = this.initCore();\n        if (this.options.autoStart) {\n            this.start();\n        }\n    }\n    /**\n     * Create a URI instance from a string.\n     * @param uri - The string to parse.\n     *\n     * @example\n     * ```ts\n     * const uri = UserAgent.makeURI(\"sip:edgar@example.com\");\n     * ```\n     */\n    static makeURI(uri) {\n        return Grammar.URIParse(uri);\n    }\n    /** Default user agent options. */\n    static defaultOptions() {\n        return {\n            allowLegacyNotifications: false,\n            authorizationHa1: \"\",\n            authorizationPassword: \"\",\n            authorizationUsername: \"\",\n            autoStart: false,\n            autoStop: true,\n            delegate: {},\n            displayName: \"\",\n            forceRport: false,\n            hackAllowUnregisteredOptionTags: false,\n            hackIpInContact: false,\n            hackViaTcp: false,\n            hackWssInTransport: false,\n            logBuiltinEnabled: true,\n            logConfiguration: true,\n            logConnector: () => {\n                /* noop */\n            },\n            logLevel: \"log\",\n            noAnswerTimeout: 60,\n            preloadedRouteSet: [],\n            reconnectionAttempts: 0,\n            reconnectionDelay: 4,\n            sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),\n            sessionDescriptionHandlerFactoryOptions: {},\n            sipExtension100rel: SIPExtension.Unsupported,\n            sipExtensionReplaces: SIPExtension.Unsupported,\n            sipExtensionExtraSupported: [],\n            sipjsId: \"\",\n            transportConstructor: WebTransport,\n            transportOptions: {},\n            uri: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n            userAgentString: \"SIP.js/\" + LIBRARY_VERSION,\n            viaHost: \"\"\n        };\n    }\n    /**\n     * Strip properties with undefined values from options.\n     * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n     * https://github.com/Microsoft/TypeScript/issues/13195\n     * @param options - Options to reduce\n     */\n    static stripUndefinedProperties(options) {\n        return Object.keys(options).reduce((object, key) => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (options[key] !== undefined) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                object[key] = options[key];\n            }\n            return object;\n        }, {});\n    }\n    /**\n     * User agent configuration.\n     */\n    get configuration() {\n        return this.options;\n    }\n    /**\n     * User agent contact.\n     */\n    get contact() {\n        return this._contact;\n    }\n    /**\n     * User agent state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * User agent state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * User agent transport.\n     */\n    get transport() {\n        return this._transport;\n    }\n    /**\n     * User agent core.\n     */\n    get userAgentCore() {\n        return this._userAgentCore;\n    }\n    /**\n     * The logger.\n     */\n    getLogger(category, label) {\n        return this.loggerFactory.getLogger(category, label);\n    }\n    /**\n     * The logger factory.\n     */\n    getLoggerFactory() {\n        return this.loggerFactory;\n    }\n    /**\n     * True if transport is connected.\n     */\n    isConnected() {\n        return this.transport.isConnected();\n    }\n    /**\n     * Reconnect the transport.\n     */\n    reconnect() {\n        if (this.state === UserAgentState.Stopped) {\n            return Promise.reject(new Error(\"User agent stopped.\"));\n        }\n        // Make sure we don't call synchronously\n        return Promise.resolve().then(() => this.transport.connect());\n    }\n    /**\n     * Start the user agent.\n     *\n     * @remarks\n     * Resolves if transport connects, otherwise rejects.\n     *\n     * @example\n     * ```ts\n     * userAgent.start()\n     *   .then(() => {\n     *     // userAgent.isConnected() === true\n     *   })\n     *   .catch((error: Error) => {\n     *     // userAgent.isConnected() === false\n     *   });\n     * ```\n     */\n    start() {\n        if (this.state === UserAgentState.Started) {\n            this.logger.warn(`User agent already started`);\n            return Promise.resolve();\n        }\n        this.logger.log(`Starting ${this.configuration.uri}`);\n        // Transition state\n        this.transitionState(UserAgentState.Started);\n        // TODO: Review this as it is not clear it has any benefit and at worst causes additional load the server.\n        // On unload it may be best to simply in most scenarios to do nothing. Furthermore and regardless, this\n        // kind of behavior seems more appropriate to be managed by the consumer of the API than the API itself.\n        // Should this perhaps be deprecated?\n        //\n        // Add window unload event listener\n        if (this.options.autoStop) {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n            const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n            if (typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && !googleChromePackagedApp) {\n                window.addEventListener(\"unload\", this.unloadListener);\n            }\n        }\n        return this.transport.connect();\n    }\n    /**\n     * Stop the user agent.\n     *\n     * @remarks\n     * Resolves when the user agent has completed a graceful shutdown.\n     * ```txt\n     * 1) Sessions terminate.\n     * 2) Registerers unregister.\n     * 3) Subscribers unsubscribe.\n     * 4) Publishers unpublish.\n     * 5) Transport disconnects.\n     * 6) User Agent Core resets.\n     * ```\n     * NOTE: While this is a \"graceful shutdown\", it can also be very slow one if you\n     * are waiting for the returned Promise to resolve. The disposal of the clients and\n     * dialogs is done serially - waiting on one to finish before moving on to the next.\n     * This can be slow if there are lot of subscriptions to unsubscribe for example.\n     *\n     * THE SLOW PACE IS INTENTIONAL!\n     * While one could spin them all down in parallel, this could slam the remote server.\n     * It is bad practice to denial of service attack (DoS attack) servers!!!\n     * Moreover, production servers will automatically blacklist clients which send too\n     * many requests in too short a period of time - dropping any additional requests.\n     *\n     * If a different approach to disposing is needed, one can implement whatever is\n     * needed and execute that prior to calling `stop()`. Alternatively one may simply\n     * not wait for the Promise returned by `stop()` to complete.\n     */\n    async stop() {\n        if (this.state === UserAgentState.Stopped) {\n            this.logger.warn(`User agent already stopped`);\n            return Promise.resolve();\n        }\n        this.logger.log(`Stopping ${this.configuration.uri}`);\n        // Transition state\n        this.transitionState(UserAgentState.Stopped);\n        // TODO: See comments with associated complimentary code in start(). Should this perhaps be deprecated?\n        // Remove window unload event listener\n        if (this.options.autoStop) {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners: unload is not available in packaged apps\n            const googleChromePackagedApp = typeof chrome !== \"undefined\" && chrome.app && chrome.app.runtime ? true : false;\n            if (typeof window !== \"undefined\" && window.removeEventListener && !googleChromePackagedApp) {\n                window.removeEventListener(\"unload\", this.unloadListener);\n            }\n        }\n        // Be careful here to use a local references as start() can be called\n        // again before we complete and we don't want to touch new clients\n        // and we don't want to step on the new instances (or vice versa).\n        const publishers = Object.assign({}, this._publishers);\n        const registerers = Object.assign({}, this._registerers);\n        const sessions = Object.assign({}, this._sessions);\n        const subscriptions = Object.assign({}, this._subscriptions);\n        const transport = this.transport;\n        const userAgentCore = this.userAgentCore;\n        //\n        // At this point we have completed the state transition and everything\n        // following will effectively run async and MUST NOT cause any issues\n        // if UserAgent.start() is called while the following code continues.\n        //\n        // TODO: Minor optimization.\n        // The disposal in all cases involves, in part, sending messages which\n        // is not worth doing if the transport is not connected as we know attempting\n        // to send messages will be futile. But none of these disposal methods check\n        // if that's is the case and it would be easy for them to do so at this point.\n        // Dispose of Registerers\n        this.logger.log(`Dispose of registerers`);\n        for (const id in registerers) {\n            if (registerers[id]) {\n                await registerers[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._registerers[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Sessions\n        this.logger.log(`Dispose of sessions`);\n        for (const id in sessions) {\n            if (sessions[id]) {\n                await sessions[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._sessions[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Subscriptions\n        this.logger.log(`Dispose of subscriptions`);\n        for (const id in subscriptions) {\n            if (subscriptions[id]) {\n                await subscriptions[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._subscriptions[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of Publishers\n        this.logger.log(`Dispose of publishers`);\n        for (const id in publishers) {\n            if (publishers[id]) {\n                await publishers[id].dispose().catch((error) => {\n                    this.logger.error(error.message);\n                    delete this._publishers[id];\n                    throw error;\n                });\n            }\n        }\n        // Dispose of the transport (disconnecting)\n        this.logger.log(`Dispose of transport`);\n        await transport.dispose().catch((error) => {\n            this.logger.error(error.message);\n            throw error;\n        });\n        // Dispose of the user agent core (resetting)\n        this.logger.log(`Dispose of core`);\n        userAgentCore.dispose();\n    }\n    /**\n     * Used to avoid circular references.\n     * @internal\n     */\n    _makeInviter(targetURI, options) {\n        return new Inviter(this, targetURI, options);\n    }\n    /**\n     * Attempt reconnection up to `maxReconnectionAttempts` times.\n     * @param reconnectionAttempt - Current attempt number.\n     */\n    attemptReconnection(reconnectionAttempt = 1) {\n        const reconnectionAttempts = this.options.reconnectionAttempts;\n        const reconnectionDelay = this.options.reconnectionDelay;\n        if (reconnectionAttempt > reconnectionAttempts) {\n            this.logger.log(`Maximum reconnection attempts reached`);\n            return;\n        }\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n        setTimeout(() => {\n            this.reconnect()\n                .then(() => {\n                this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n            })\n                .catch((error) => {\n                this.logger.error(error.message);\n                this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n                this.attemptReconnection(++reconnectionAttempt);\n            });\n        }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n    }\n    /**\n     * Initialize contact.\n     */\n    initContact() {\n        const contactName = createRandomToken(8); // FIXME: should be configurable\n        const contactTransport = this.options.hackWssInTransport ? \"wss\" : \"ws\"; // FIXME: clearly broken for non ws transports\n        const contact = {\n            pubGruu: undefined,\n            tempGruu: undefined,\n            uri: new URI(\"sip\", contactName, this.options.viaHost, undefined, { transport: contactTransport }),\n            toString: (contactToStringOptions = {}) => {\n                const anonymous = contactToStringOptions.anonymous || false;\n                const outbound = contactToStringOptions.outbound || false;\n                let contactString = \"<\";\n                if (anonymous) {\n                    contactString += this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${contactTransport}`;\n                }\n                else {\n                    contactString += this.contact.pubGruu || this.contact.uri;\n                }\n                if (outbound) {\n                    contactString += \";ob\";\n                }\n                contactString += \">\";\n                return contactString;\n            }\n        };\n        return contact;\n    }\n    /**\n     * Initialize user agent core.\n     */\n    initCore() {\n        // supported options\n        let supportedOptionTags = [];\n        supportedOptionTags.push(\"outbound\"); // TODO: is this really supported?\n        if (this.options.sipExtension100rel === SIPExtension.Supported) {\n            supportedOptionTags.push(\"100rel\");\n        }\n        if (this.options.sipExtensionReplaces === SIPExtension.Supported) {\n            supportedOptionTags.push(\"replaces\");\n        }\n        if (this.options.sipExtensionExtraSupported) {\n            supportedOptionTags.push(...this.options.sipExtensionExtraSupported);\n        }\n        if (!this.options.hackAllowUnregisteredOptionTags) {\n            supportedOptionTags = supportedOptionTags.filter((optionTag) => UserAgentRegisteredOptionTags[optionTag]);\n        }\n        supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values\n        // FIXME: TODO: This was ported, but this is and was just plain broken.\n        const supportedOptionTagsResponse = supportedOptionTags.slice();\n        if (this.contact.pubGruu || this.contact.tempGruu) {\n            supportedOptionTagsResponse.push(\"gruu\");\n        }\n        // core configuration\n        const userAgentCoreConfiguration = {\n            aor: this.options.uri,\n            contact: this.contact,\n            displayName: this.options.displayName,\n            loggerFactory: this.loggerFactory,\n            hackViaTcp: this.options.hackViaTcp,\n            routeSet: this.options.preloadedRouteSet,\n            supportedOptionTags,\n            supportedOptionTagsResponse,\n            sipjsId: this.options.sipjsId,\n            userAgentHeaderFieldValue: this.options.userAgentString,\n            viaForceRport: this.options.forceRport,\n            viaHost: this.options.viaHost,\n            authenticationFactory: () => {\n                const username = this.options.authorizationUsername\n                    ? this.options.authorizationUsername\n                    : this.options.uri.user; // if authorization username not provided, use uri user as username\n                const password = this.options.authorizationPassword ? this.options.authorizationPassword : undefined;\n                const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : undefined;\n                return new DigestAuthentication(this.getLoggerFactory(), ha1, username, password);\n            },\n            transportAccessor: () => this.transport\n        };\n        const userAgentCoreDelegate = {\n            onInvite: (incomingInviteRequest) => {\n                var _a;\n                const invitation = new Invitation(this, incomingInviteRequest);\n                incomingInviteRequest.delegate = {\n                    onCancel: (cancel) => {\n                        invitation._onCancel(cancel);\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    onTransportError: (error) => {\n                        // A server transaction MUST NOT discard transaction state based only on\n                        // encountering a non-recoverable transport error when sending a\n                        // response.  Instead, the associated INVITE server transaction state\n                        // machine MUST remain in its current state.  (Timers will eventually\n                        // cause it to transition to the \"Terminated\" state).\n                        // https://tools.ietf.org/html/rfc6026#section-7.1\n                        // As noted in the comment above, we are to leaving it to the transaction\n                        // timers to eventually cause the transaction to sort itself out in the case\n                        // of a transport failure in an invite server transaction. This delegate method\n                        // is here simply here for completeness and to make it clear that it provides\n                        // nothing more than informational hook into the core. That is, if you think\n                        // you should be trying to deal with a transport error here, you are likely wrong.\n                        this.logger.error(\"A transport error has occurred while handling an incoming INVITE request.\");\n                    }\n                };\n                // FIXME: Ported - 100 Trying send should be configurable.\n                // Only required if TU will not respond in 200ms.\n                // https://tools.ietf.org/html/rfc3261#section-17.2.1\n                incomingInviteRequest.trying();\n                // The Replaces header contains information used to match an existing\n                // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE\n                // with a Replaces header, the User Agent (UA) attempts to match this\n                // information with a confirmed or early dialog.\n                // https://tools.ietf.org/html/rfc3891#section-3\n                if (this.options.sipExtensionReplaces !== SIPExtension.Unsupported) {\n                    const message = incomingInviteRequest.message;\n                    const replaces = message.parseHeader(\"replaces\");\n                    if (replaces) {\n                        const callId = replaces.call_id;\n                        if (typeof callId !== \"string\") {\n                            throw new Error(\"Type of call id is not string\");\n                        }\n                        const toTag = replaces.replaces_to_tag;\n                        if (typeof toTag !== \"string\") {\n                            throw new Error(\"Type of to tag is not string\");\n                        }\n                        const fromTag = replaces.replaces_from_tag;\n                        if (typeof fromTag !== \"string\") {\n                            throw new Error(\"type of from tag is not string\");\n                        }\n                        const targetDialogId = callId + toTag + fromTag;\n                        const targetDialog = this.userAgentCore.dialogs.get(targetDialogId);\n                        // If no match is found, the UAS rejects the INVITE and returns a 481\n                        // Call/Transaction Does Not Exist response.  Likewise, if the Replaces\n                        // header field matches a dialog which was not created with an INVITE,\n                        // the UAS MUST reject the request with a 481 response.\n                        // https://tools.ietf.org/html/rfc3891#section-3\n                        if (!targetDialog) {\n                            invitation.reject({ statusCode: 481 });\n                            return;\n                        }\n                        // If the Replaces header field matches a confirmed dialog, it checks\n                        // for the presence of the \"early-only\" flag in the Replaces header\n                        // field.  (This flag allows the UAC to prevent a potentially\n                        // undesirable race condition described in Section 7.1.) If the flag is\n                        // present, the UA rejects the request with a 486 Busy response.\n                        // https://tools.ietf.org/html/rfc3891#section-3\n                        if (!targetDialog.early && replaces.early_only === true) {\n                            invitation.reject({ statusCode: 486 });\n                            return;\n                        }\n                        // Provide a handle on the session being replaced.\n                        const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || undefined;\n                        if (!targetSession) {\n                            throw new Error(\"Session does not exist.\");\n                        }\n                        invitation._replacee = targetSession;\n                    }\n                }\n                // Delegate invitation handling.\n                if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {\n                    if (invitation.autoSendAnInitialProvisionalResponse) {\n                        invitation.progress().then(() => {\n                            var _a;\n                            if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {\n                                throw new Error(\"onInvite undefined.\");\n                            }\n                            this.delegate.onInvite(invitation);\n                        });\n                        return;\n                    }\n                    this.delegate.onInvite(invitation);\n                    return;\n                }\n                // A common scenario occurs when the callee is currently not willing or\n                // able to take additional calls at this end system.  A 486 (Busy Here)\n                // SHOULD be returned in such a scenario.\n                // https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n                invitation.reject({ statusCode: 486 });\n            },\n            onMessage: (incomingMessageRequest) => {\n                if (this.delegate && this.delegate.onMessage) {\n                    const message = new Message(incomingMessageRequest);\n                    this.delegate.onMessage(message);\n                }\n                else {\n                    // Accept the MESSAGE request, but do nothing with it.\n                    incomingMessageRequest.accept();\n                }\n            },\n            onNotify: (incomingNotifyRequest) => {\n                // NOTIFY requests are sent to inform subscribers of changes in state to\n                // which the subscriber has a subscription.  Subscriptions are created\n                // using the SUBSCRIBE method.  In legacy implementations, it is\n                // possible that other means of subscription creation have been used.\n                // However, this specification does not allow the creation of\n                // subscriptions except through SUBSCRIBE requests and (for backwards-\n                // compatibility) REFER requests [RFC3515].\n                // https://tools.ietf.org/html/rfc6665#section-3.2\n                if (this.delegate && this.delegate.onNotify) {\n                    const notification = new Notification(incomingNotifyRequest);\n                    this.delegate.onNotify(notification);\n                }\n                else {\n                    // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,\n                    // the use of out of dialog NOTIFY is obsolete, but...\n                    if (this.options.allowLegacyNotifications) {\n                        incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.\n                    }\n                    else {\n                        incomingNotifyRequest.reject({ statusCode: 481 });\n                    }\n                }\n            },\n            onRefer: (incomingReferRequest) => {\n                this.logger.warn(\"Received an out of dialog REFER request\");\n                // TOOD: this.delegate.onRefer(...)\n                if (this.delegate && this.delegate.onReferRequest) {\n                    this.delegate.onReferRequest(incomingReferRequest);\n                }\n                else {\n                    incomingReferRequest.reject({ statusCode: 405 });\n                }\n            },\n            onRegister: (incomingRegisterRequest) => {\n                this.logger.warn(\"Received an out of dialog REGISTER request\");\n                // TOOD: this.delegate.onRegister(...)\n                if (this.delegate && this.delegate.onRegisterRequest) {\n                    this.delegate.onRegisterRequest(incomingRegisterRequest);\n                }\n                else {\n                    incomingRegisterRequest.reject({ statusCode: 405 });\n                }\n            },\n            onSubscribe: (incomingSubscribeRequest) => {\n                this.logger.warn(\"Received an out of dialog SUBSCRIBE request\");\n                // TOOD: this.delegate.onSubscribe(...)\n                if (this.delegate && this.delegate.onSubscribeRequest) {\n                    this.delegate.onSubscribeRequest(incomingSubscribeRequest);\n                }\n                else {\n                    incomingSubscribeRequest.reject({ statusCode: 405 });\n                }\n            }\n        };\n        return new UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);\n    }\n    initTransportCallbacks() {\n        this.transport.onConnect = () => this.onTransportConnect();\n        this.transport.onDisconnect = (error) => this.onTransportDisconnect(error);\n        this.transport.onMessage = (message) => this.onTransportMessage(message);\n    }\n    onTransportConnect() {\n        if (this.state === UserAgentState.Stopped) {\n            return;\n        }\n        if (this.delegate && this.delegate.onConnect) {\n            this.delegate.onConnect();\n        }\n    }\n    onTransportDisconnect(error) {\n        if (this.state === UserAgentState.Stopped) {\n            return;\n        }\n        if (this.delegate && this.delegate.onDisconnect) {\n            this.delegate.onDisconnect(error);\n        }\n        // Only attempt to reconnect if network/server dropped the connection.\n        if (error && this.options.reconnectionAttempts > 0) {\n            this.attemptReconnection();\n        }\n    }\n    onTransportMessage(messageString) {\n        const message = Parser.parseMessage(messageString, this.getLogger(\"sip.Parser\"));\n        if (!message) {\n            this.logger.warn(\"Failed to parse incoming message. Dropping.\");\n            return;\n        }\n        if (this.state === UserAgentState.Stopped && message instanceof IncomingRequestMessage) {\n            this.logger.warn(`Received ${message.method} request while stopped. Dropping.`);\n            return;\n        }\n        // A valid SIP request formulated by a UAC MUST, at a minimum, contain\n        // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,\n        // and Via; all of these header fields are mandatory in all SIP\n        // requests.\n        // https://tools.ietf.org/html/rfc3261#section-8.1.1\n        const hasMinimumHeaders = () => {\n            const mandatoryHeaders = [\"from\", \"to\", \"call_id\", \"cseq\", \"via\"];\n            for (const header of mandatoryHeaders) {\n                if (!message.hasHeader(header)) {\n                    this.logger.warn(`Missing mandatory header field : ${header}.`);\n                    return false;\n                }\n            }\n            return true;\n        };\n        // Request Checks\n        if (message instanceof IncomingRequestMessage) {\n            // This is port of SanityCheck.minimumHeaders().\n            if (!hasMinimumHeaders()) {\n                this.logger.warn(`Request missing mandatory header field. Dropping.`);\n                return;\n            }\n            // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).\n            // Custom SIP.js check to reject request from ourself (this instance of SIP.js).\n            // This is port of SanityCheck.rfc3261_16_3_4().\n            if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {\n                this.userAgentCore.replyStateless(message, { statusCode: 482 });\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to reject requests if body length wrong.\n            // This is port of SanityCheck.rfc3261_18_3_request().\n            const len = utf8Length(message.body);\n            const contentLength = message.getHeader(\"content-length\");\n            if (contentLength && len < Number(contentLength)) {\n                this.userAgentCore.replyStateless(message, { statusCode: 400 });\n                return;\n            }\n        }\n        // Response Checks\n        if (message instanceof IncomingResponseMessage) {\n            // This is port of SanityCheck.minimumHeaders().\n            if (!hasMinimumHeaders()) {\n                this.logger.warn(`Response missing mandatory header field. Dropping.`);\n                return;\n            }\n            // Custom SIP.js check to drop responses if multiple Via headers.\n            // This is port of SanityCheck.rfc3261_8_1_3_3().\n            if (message.getHeaders(\"via\").length > 1) {\n                this.logger.warn(\"More than one Via header field present in the response. Dropping.\");\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to drop responses if bad Via header.\n            // This is port of SanityCheck.rfc3261_18_1_2().\n            if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {\n                this.logger.warn(\"Via sent-by in the response does not match UA Via host value. Dropping.\");\n                return;\n            }\n            // FIXME: This should be Transport check before we get here (Section 18).\n            // Custom SIP.js check to reject requests if body length wrong.\n            // This is port of SanityCheck.rfc3261_18_3_response().\n            const len = utf8Length(message.body);\n            const contentLength = message.getHeader(\"content-length\");\n            if (contentLength && len < Number(contentLength)) {\n                this.logger.warn(\"Message body length is lower than the value in Content-Length header field. Dropping.\");\n                return;\n            }\n        }\n        // Handle Request\n        if (message instanceof IncomingRequestMessage) {\n            this.userAgentCore.receiveIncomingRequestFromTransport(message);\n            return;\n        }\n        // Handle Response\n        if (message instanceof IncomingResponseMessage) {\n            this.userAgentCore.receiveIncomingResponseFromTransport(message);\n            return;\n        }\n        throw new Error(\"Invalid message type.\");\n    }\n    /**\n     * Transition state.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    transitionState(newState, error) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        // Validate state transition\n        switch (this._state) {\n            case UserAgentState.Started:\n                if (newState !== UserAgentState.Stopped) {\n                    invalidTransition();\n                }\n                break;\n            case UserAgentState.Stopped:\n                if (newState !== UserAgentState.Started) {\n                    invalidTransition();\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        // Update state\n        this.logger.log(`Transitioned from ${this._state} to ${newState}`);\n        this._state = newState;\n        this._stateEventEmitter.emit(this._state);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}