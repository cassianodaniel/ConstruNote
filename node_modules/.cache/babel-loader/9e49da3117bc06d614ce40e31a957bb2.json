{"ast":null,"code":"import { getReasonPhrase, newTag, utf8Length } from \"./utils\";\n/**\n * When a UAS wishes to construct a response to a request, it follows\n * the general procedures detailed in the following subsections.\n * Additional behaviors specific to the response code in question, which\n * are not detailed in this section, may also be required.\n * https://tools.ietf.org/html/rfc3261#section-8.2.6\n * @internal\n */\n\nexport function constructOutgoingResponse(message, options) {\n  var CRLF = \"\\r\\n\";\n\n  if (options.statusCode < 100 || options.statusCode > 699) {\n    throw new TypeError(\"Invalid statusCode: \" + options.statusCode);\n  }\n\n  var reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(options.statusCode); // SIP responses are distinguished from requests by having a Status-Line\n  // as their start-line.  A Status-Line consists of the protocol version\n  // followed by a numeric Status-Code and its associated textual phrase,\n  // with each element separated by a single SP character.\n  // https://tools.ietf.org/html/rfc3261#section-7.2\n\n  var response = \"SIP/2.0 \" + options.statusCode + \" \" + reasonPhrase + CRLF; // One largely non-method-specific guideline for the generation of\n  // responses is that UASs SHOULD NOT issue a provisional response for a\n  // non-INVITE request.  Rather, UASs SHOULD generate a final response to\n  // a non-INVITE request as soon as possible.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n\n  if (options.statusCode >= 100 && options.statusCode < 200) {// TODO\n  } // When a 100 (Trying) response is generated, any Timestamp header field\n  // present in the request MUST be copied into this 100 (Trying)\n  // response.  If there is a delay in generating the response, the UAS\n  // SHOULD add a delay value into the Timestamp value in the response.\n  // This value MUST contain the difference between the time of sending of\n  // the response and receipt of the request, measured in seconds.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n\n\n  if (options.statusCode === 100) {// TODO\n  } // The From field of the response MUST equal the From header field of\n  // the request.  The Call-ID header field of the response MUST equal the\n  // Call-ID header field of the request.  The CSeq header field of the\n  // response MUST equal the CSeq field of the request.  The Via header\n  // field values in the response MUST equal the Via header field values\n  // in the request and MUST maintain the same ordering.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n\n\n  var fromHeader = \"From: \" + message.getHeader(\"From\") + CRLF;\n  var callIdHeader = \"Call-ID: \" + message.callId + CRLF;\n  var cSeqHeader = \"CSeq: \" + message.cseq + \" \" + message.method + CRLF;\n  var viaHeaders = message.getHeaders(\"via\").reduce(function (previous, current) {\n    return previous + \"Via: \" + current + CRLF;\n  }, \"\"); // If a request contained a To tag in the request, the To header field\n  // in the response MUST equal that of the request.  However, if the To\n  // header field in the request did not contain a tag, the URI in the To\n  // header field in the response MUST equal the URI in the To header\n  // field; additionally, the UAS MUST add a tag to the To header field in\n  // the response (with the exception of the 100 (Trying) response, in\n  // which a tag MAY be present).  This serves to identify the UAS that is\n  // responding, possibly resulting in a component of a dialog ID.  The\n  // same tag MUST be used for all responses to that request, both final\n  // and provisional (again excepting the 100 (Trying)).\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n\n  var toHeader = \"To: \" + message.getHeader(\"to\");\n\n  if (options.statusCode > 100 && !message.parseHeader(\"to\").hasParam(\"tag\")) {\n    var toTag = options.toTag;\n\n    if (!toTag) {\n      // Stateless UAS Behavior...\n      // o  To header tags MUST be generated for responses in a stateless\n      //    manner - in a manner that will generate the same tag for the\n      //    same request consistently.  For information on tag construction\n      //    see Section 19.3.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.7\n      toTag = newTag(); // FIXME: newTag() currently generates random tags\n    }\n\n    toHeader += \";tag=\" + toTag;\n  }\n\n  toHeader += CRLF; // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)\n  // let recordRouteHeaders = \"\";\n  // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {\n  //   recordRouteHeaders = request.getHeaders(\"record-route\").reduce((previous, current) => {\n  //     return previous + \"Record-Route: \" + current + CRLF;\n  //   }, \"\");\n  // }\n  // FIXME: TODO: needs review...\n\n  var supportedHeader = \"\";\n\n  if (options.supported) {\n    supportedHeader = \"Supported: \" + options.supported.join(\", \") + CRLF;\n  } // FIXME: TODO: needs review...\n\n\n  var userAgentHeader = \"\";\n\n  if (options.userAgent) {\n    userAgentHeader = \"User-Agent: \" + options.userAgent + CRLF;\n  }\n\n  var extensionHeaders = \"\";\n\n  if (options.extraHeaders) {\n    extensionHeaders = options.extraHeaders.reduce(function (previous, current) {\n      return previous + current.trim() + CRLF;\n    }, \"\");\n  } // The relative order of header fields with different field names is not\n  // significant.  However, it is RECOMMENDED that header fields which are\n  // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n  // Max-Forwards, and Proxy-Authorization, for example) appear towards\n  // the top of the message to facilitate rapid parsing.\n  // https://tools.ietf.org/html/rfc3261#section-7.3.1\n  // response += recordRouteHeaders;\n\n\n  response += viaHeaders;\n  response += fromHeader;\n  response += toHeader;\n  response += cSeqHeader;\n  response += callIdHeader;\n  response += supportedHeader;\n  response += userAgentHeader;\n  response += extensionHeaders;\n\n  if (options.body) {\n    response += \"Content-Type: \" + options.body.contentType + CRLF;\n    response += \"Content-Length: \" + utf8Length(options.body.content) + CRLF + CRLF;\n    response += options.body.content;\n  } else {\n    response += \"Content-Length: \" + 0 + CRLF + CRLF;\n  }\n\n  return {\n    message: response\n  };\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/outgoing-response.js"],"names":["getReasonPhrase","newTag","utf8Length","constructOutgoingResponse","message","options","CRLF","statusCode","TypeError","reasonPhrase","response","fromHeader","getHeader","callIdHeader","callId","cSeqHeader","cseq","method","viaHeaders","getHeaders","reduce","previous","current","toHeader","parseHeader","hasParam","toTag","supportedHeader","supported","join","userAgentHeader","userAgent","extensionHeaders","extraHeaders","trim","body","contentType","content"],"mappings":"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","sourcesContent":["import { getReasonPhrase, newTag, utf8Length } from \"./utils\";\n/**\n * When a UAS wishes to construct a response to a request, it follows\n * the general procedures detailed in the following subsections.\n * Additional behaviors specific to the response code in question, which\n * are not detailed in this section, may also be required.\n * https://tools.ietf.org/html/rfc3261#section-8.2.6\n * @internal\n */\nexport function constructOutgoingResponse(message, options) {\n    const CRLF = \"\\r\\n\";\n    if (options.statusCode < 100 || options.statusCode > 699) {\n        throw new TypeError(\"Invalid statusCode: \" + options.statusCode);\n    }\n    const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(options.statusCode);\n    // SIP responses are distinguished from requests by having a Status-Line\n    // as their start-line.  A Status-Line consists of the protocol version\n    // followed by a numeric Status-Code and its associated textual phrase,\n    // with each element separated by a single SP character.\n    // https://tools.ietf.org/html/rfc3261#section-7.2\n    let response = \"SIP/2.0 \" + options.statusCode + \" \" + reasonPhrase + CRLF;\n    // One largely non-method-specific guideline for the generation of\n    // responses is that UASs SHOULD NOT issue a provisional response for a\n    // non-INVITE request.  Rather, UASs SHOULD generate a final response to\n    // a non-INVITE request as soon as possible.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n    if (options.statusCode >= 100 && options.statusCode < 200) {\n        // TODO\n    }\n    // When a 100 (Trying) response is generated, any Timestamp header field\n    // present in the request MUST be copied into this 100 (Trying)\n    // response.  If there is a delay in generating the response, the UAS\n    // SHOULD add a delay value into the Timestamp value in the response.\n    // This value MUST contain the difference between the time of sending of\n    // the response and receipt of the request, measured in seconds.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n    if (options.statusCode === 100) {\n        // TODO\n    }\n    // The From field of the response MUST equal the From header field of\n    // the request.  The Call-ID header field of the response MUST equal the\n    // Call-ID header field of the request.  The CSeq header field of the\n    // response MUST equal the CSeq field of the request.  The Via header\n    // field values in the response MUST equal the Via header field values\n    // in the request and MUST maintain the same ordering.\n    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n    const fromHeader = \"From: \" + message.getHeader(\"From\") + CRLF;\n    const callIdHeader = \"Call-ID: \" + message.callId + CRLF;\n    const cSeqHeader = \"CSeq: \" + message.cseq + \" \" + message.method + CRLF;\n    const viaHeaders = message.getHeaders(\"via\").reduce((previous, current) => {\n        return previous + \"Via: \" + current + CRLF;\n    }, \"\");\n    // If a request contained a To tag in the request, the To header field\n    // in the response MUST equal that of the request.  However, if the To\n    // header field in the request did not contain a tag, the URI in the To\n    // header field in the response MUST equal the URI in the To header\n    // field; additionally, the UAS MUST add a tag to the To header field in\n    // the response (with the exception of the 100 (Trying) response, in\n    // which a tag MAY be present).  This serves to identify the UAS that is\n    // responding, possibly resulting in a component of a dialog ID.  The\n    // same tag MUST be used for all responses to that request, both final\n    // and provisional (again excepting the 100 (Trying)).\n    // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n    let toHeader = \"To: \" + message.getHeader(\"to\");\n    if (options.statusCode > 100 && !message.parseHeader(\"to\").hasParam(\"tag\")) {\n        let toTag = options.toTag;\n        if (!toTag) {\n            // Stateless UAS Behavior...\n            // o  To header tags MUST be generated for responses in a stateless\n            //    manner - in a manner that will generate the same tag for the\n            //    same request consistently.  For information on tag construction\n            //    see Section 19.3.\n            // https://tools.ietf.org/html/rfc3261#section-8.2.7\n            toTag = newTag(); // FIXME: newTag() currently generates random tags\n        }\n        toHeader += \";tag=\" + toTag;\n    }\n    toHeader += CRLF;\n    // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)\n    // let recordRouteHeaders = \"\";\n    // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {\n    //   recordRouteHeaders = request.getHeaders(\"record-route\").reduce((previous, current) => {\n    //     return previous + \"Record-Route: \" + current + CRLF;\n    //   }, \"\");\n    // }\n    // FIXME: TODO: needs review...\n    let supportedHeader = \"\";\n    if (options.supported) {\n        supportedHeader = \"Supported: \" + options.supported.join(\", \") + CRLF;\n    }\n    // FIXME: TODO: needs review...\n    let userAgentHeader = \"\";\n    if (options.userAgent) {\n        userAgentHeader = \"User-Agent: \" + options.userAgent + CRLF;\n    }\n    let extensionHeaders = \"\";\n    if (options.extraHeaders) {\n        extensionHeaders = options.extraHeaders.reduce((previous, current) => {\n            return previous + current.trim() + CRLF;\n        }, \"\");\n    }\n    // The relative order of header fields with different field names is not\n    // significant.  However, it is RECOMMENDED that header fields which are\n    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n    // Max-Forwards, and Proxy-Authorization, for example) appear towards\n    // the top of the message to facilitate rapid parsing.\n    // https://tools.ietf.org/html/rfc3261#section-7.3.1\n    // response += recordRouteHeaders;\n    response += viaHeaders;\n    response += fromHeader;\n    response += toHeader;\n    response += cSeqHeader;\n    response += callIdHeader;\n    response += supportedHeader;\n    response += userAgentHeader;\n    response += extensionHeaders;\n    if (options.body) {\n        response += \"Content-Type: \" + options.body.contentType + CRLF;\n        response += \"Content-Length: \" + utf8Length(options.body.content) + CRLF + CRLF;\n        response += options.body.content;\n    }\n    else {\n        response += \"Content-Length: \" + 0 + CRLF + CRLF;\n    }\n    return { message: response };\n}\n"]},"metadata":{},"sourceType":"module"}