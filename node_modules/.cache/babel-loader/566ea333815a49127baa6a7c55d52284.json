{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { C, getBody, IncomingRequestMessage, IncomingResponseMessage, isBody, NameAddrHeader, OutgoingRequestMessage } from \"../messages\";\nimport { SessionState, SignalingState } from \"../session\";\nimport { Timers } from \"../timers\";\nimport { InviteClientTransaction, InviteServerTransaction, TransactionState } from \"../transactions\";\nimport { ByeUserAgentClient } from \"../user-agents/bye-user-agent-client\";\nimport { ByeUserAgentServer } from \"../user-agents/bye-user-agent-server\";\nimport { InfoUserAgentClient } from \"../user-agents/info-user-agent-client\";\nimport { InfoUserAgentServer } from \"../user-agents/info-user-agent-server\";\nimport { MessageUserAgentClient } from \"../user-agents/message-user-agent-client\";\nimport { MessageUserAgentServer } from \"../user-agents/message-user-agent-server\";\nimport { NotifyUserAgentClient } from \"../user-agents/notify-user-agent-client\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { PrackUserAgentClient } from \"../user-agents/prack-user-agent-client\";\nimport { PrackUserAgentServer } from \"../user-agents/prack-user-agent-server\";\nimport { ReInviteUserAgentClient } from \"../user-agents/re-invite-user-agent-client\";\nimport { ReInviteUserAgentServer } from \"../user-agents/re-invite-user-agent-server\";\nimport { ReferUserAgentClient } from \"../user-agents/refer-user-agent-client\";\nimport { ReferUserAgentServer } from \"../user-agents/refer-user-agent-server\";\nimport { Dialog } from \"./dialog\";\n/**\n * Session Dialog.\n * @public\n */\n\nexport var SessionDialog = /*#__PURE__*/function (_Dialog) {\n  _inherits(SessionDialog, _Dialog);\n\n  var _super = _createSuper(SessionDialog);\n\n  function SessionDialog(initialTransaction, core, state, delegate) {\n    var _this;\n\n    _classCallCheck(this, SessionDialog);\n\n    _this = _super.call(this, core, state);\n    _this.initialTransaction = initialTransaction;\n    /** The state of the offer/answer exchange. */\n\n    _this._signalingState = SignalingState.Initial;\n    /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */\n\n    _this.ackWait = false;\n    /** True if processing an ACK to the initial transaction 2xx (UAS only). */\n\n    _this.ackProcessing = false;\n    _this.delegate = delegate;\n\n    if (initialTransaction instanceof InviteServerTransaction) {\n      // If we're created by an invite server transaction, we're\n      // going to be waiting for an ACK if are to be confirmed.\n      _this.ackWait = true;\n    } // If we're confirmed upon creation start the retransmitting whatever\n    // the 2xx final response was that confirmed us into existence.\n\n\n    if (!_this.early) {\n      _this.start2xxRetransmissionTimer();\n    }\n\n    _this.signalingStateTransition(initialTransaction.request);\n\n    _this.logger = core.loggerFactory.getLogger(\"sip.invite-dialog\");\n\n    _this.logger.log(\"INVITE dialog \".concat(_this.id, \" constructed\"));\n\n    return _this;\n  }\n\n  _createClass(SessionDialog, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(SessionDialog.prototype), \"dispose\", this).call(this);\n\n      this._signalingState = SignalingState.Closed;\n      this._offer = undefined;\n      this._answer = undefined;\n\n      if (this.invite2xxTimer) {\n        clearTimeout(this.invite2xxTimer);\n        this.invite2xxTimer = undefined;\n      } // The UAS MUST still respond to any pending requests received for that\n      // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n      // be generated to those pending requests.\n      // https://tools.ietf.org/html/rfc3261#section-15.1.2\n      // TODO:\n      // this.userAgentServers.forEach((uas) => uas.reply(487));\n\n\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" destroyed\"));\n    } // FIXME: Need real state machine\n\n  }, {\n    key: \"confirm\",\n\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    value: function confirm() {\n      // When we're confirmed start the retransmitting whatever\n      // the 2xx final response that may have confirmed us.\n      if (this.early) {\n        this.start2xxRetransmissionTimer();\n      }\n\n      _get(_getPrototypeOf(SessionDialog.prototype), \"confirm\", this).call(this);\n    }\n    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */\n\n  }, {\n    key: \"reConfirm\",\n    value: function reConfirm() {\n      // When we're confirmed start the retransmitting whatever\n      // the 2xx final response that may have confirmed us.\n      if (this.reinviteUserAgentServer) {\n        this.startReInvite2xxRetransmissionTimer();\n      }\n    }\n    /**\n     * The UAC core MUST generate an ACK request for each 2xx received from\n     * the transaction layer.  The header fields of the ACK are constructed\n     * in the same way as for any request sent within a dialog (see Section\n     * 12) with the exception of the CSeq and the header fields related to\n     * authentication.  The sequence number of the CSeq header field MUST be\n     * the same as the INVITE being acknowledged, but the CSeq method MUST\n     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n     * the 2xx contains an offer (based on the rules above), the ACK MUST\n     * carry an answer in its body.  If the offer in the 2xx response is not\n     * acceptable, the UAC core MUST generate a valid answer in the ACK and\n     * then send a BYE immediately.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     * @param options - ACK options bucket.\n     */\n\n  }, {\n    key: \"ack\",\n    value: function ack() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending ACK request\"));\n      var transaction;\n\n      if (this.reinviteUserAgentClient) {\n        // We're sending ACK for a re-INVITE\n        if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction)) {\n          throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n        }\n\n        transaction = this.reinviteUserAgentClient.transaction;\n        this.reinviteUserAgentClient = undefined;\n      } else {\n        // We're sending ACK for the initial INVITE\n        if (!(this.initialTransaction instanceof InviteClientTransaction)) {\n          throw new Error(\"Initial transaction not instance of InviteClientTransaction.\");\n        }\n\n        transaction = this.initialTransaction;\n      }\n\n      var message = this.createOutgoingRequestMessage(C.ACK, {\n        cseq: transaction.request.cseq,\n        extraHeaders: options.extraHeaders,\n        body: options.body\n      });\n      transaction.ackResponse(message); // See InviteClientTransaction for details.\n\n      this.signalingStateTransition(message);\n      return {\n        message: message\n      };\n    }\n    /**\n     * Terminating a Session\n     *\n     * This section describes the procedures for terminating a session\n     * established by SIP.  The state of the session and the state of the\n     * dialog are very closely related.  When a session is initiated with an\n     * INVITE, each 1xx or 2xx response from a distinct UAS creates a\n     * dialog, and if that response completes the offer/answer exchange, it\n     * also creates a session.  As a result, each session is \"associated\"\n     * with a single dialog - the one which resulted in its creation.  If an\n     * initial INVITE generates a non-2xx final response, that terminates\n     * all sessions (if any) and all dialogs (if any) that were created\n     * through responses to the request.  By virtue of completing the\n     * transaction, a non-2xx final response also prevents further sessions\n     * from being created as a result of the INVITE.  The BYE request is\n     * used to terminate a specific session or attempted session.  In this\n     * case, the specific session is the one with the peer UA on the other\n     * side of the dialog.  When a BYE is received on a dialog, any session\n     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a\n     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either\n     * confirmed or early dialogs, and the callee's UA MAY send a BYE on\n     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n     *\n     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n     * until it has received an ACK for its 2xx response or until the server\n     * transaction times out.  If no SIP extensions have defined other\n     * application layer states associated with the dialog, the BYE also\n     * terminates the dialog.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-15\n     * FIXME: Make these proper Exceptions...\n     * @param options - BYE options bucket.\n     * @returns\n     * Throws `Error` if callee's UA attempts a BYE on an early dialog.\n     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog\n     *                while it's waiting on the ACK for its 2xx response.\n     */\n\n  }, {\n    key: \"bye\",\n    value: function bye(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending BYE request\")); // The caller's UA MAY send a BYE for either\n      // confirmed or early dialogs, and the callee's UA MAY send a BYE on\n      // confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n      //\n      // However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n      // until it has received an ACK for its 2xx response or until the server\n      // transaction times out.\n      // https://tools.ietf.org/html/rfc3261#section-15\n\n      if (this.initialTransaction instanceof InviteServerTransaction) {\n        if (this.early) {\n          // FIXME: TODO: This should throw a proper exception.\n          throw new Error(\"UAS MUST NOT send a BYE on early dialogs.\");\n        }\n\n        if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {\n          // FIXME: TODO: This should throw a proper exception.\n          throw new Error(\"UAS MUST NOT send a BYE on a confirmed dialog \" + \"until it has received an ACK for its 2xx response \" + \"or until the server transaction times out.\");\n        }\n      } // A BYE request is constructed as would any other request within a\n      // dialog, as described in Section 12.\n      //\n      // Once the BYE is constructed, the UAC core creates a new non-INVITE\n      // client transaction, and passes it the BYE request.  The UAC MUST\n      // consider the session terminated (and therefore stop sending or\n      // listening for media) as soon as the BYE request is passed to the\n      // client transaction.  If the response for the BYE is a 481\n      // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no\n      // response at all is received for the BYE (that is, a timeout is\n      // returned by the client transaction), the UAC MUST consider the\n      // session and the dialog terminated.\n      // https://tools.ietf.org/html/rfc3261#section-15.1.1\n\n\n      return new ByeUserAgentClient(this, delegate, options);\n    }\n    /**\n     * An INFO request can be associated with an Info Package (see\n     * Section 5), or associated with a legacy INFO usage (see Section 2).\n     *\n     * The construction of the INFO request is the same as any other\n     * non-target refresh request within an existing invite dialog usage as\n     * described in Section 12.2 of RFC 3261.\n     * https://tools.ietf.org/html/rfc6086#section-4.2.1\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"info\",\n    value: function info(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending INFO request\"));\n\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"Dialog not confirmed.\");\n      }\n\n      return new InfoUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Modifying an Existing Session\n     *\n     * A successful INVITE request (see Section 13) establishes both a\n     * dialog between two user agents and a session using the offer-answer\n     * model.  Section 12 explains how to modify an existing dialog using a\n     * target refresh request (for example, changing the remote target URI\n     * of the dialog).  This section describes how to modify the actual\n     * session.  This modification can involve changing addresses or ports,\n     * adding a media stream, deleting a media stream, and so on.  This is\n     * accomplished by sending a new INVITE request within the same dialog\n     * that established the session.  An INVITE request sent within an\n     * existing dialog is known as a re-INVITE.\n     *\n     *    Note that a single re-INVITE can modify the dialog and the\n     *    parameters of the session at the same time.\n     *\n     * Either the caller or callee can modify an existing session.\n     * https://tools.ietf.org/html/rfc3261#section-14\n     * @param options - Options bucket\n     */\n\n  }, {\n    key: \"invite\",\n    value: function invite(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending INVITE request\"));\n\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"Dialog not confirmed.\");\n      } // Note that a UAC MUST NOT initiate a new INVITE transaction within a\n      // dialog while another INVITE transaction is in progress in either\n      // direction.\n      //\n      //    1. If there is an ongoing INVITE client transaction, the TU MUST\n      //       wait until the transaction reaches the completed or terminated\n      //       state before initiating the new INVITE.\n      //\n      //    2. If there is an ongoing INVITE server transaction, the TU MUST\n      //       wait until the transaction reaches the confirmed or terminated\n      //       state before initiating the new INVITE.\n      //\n      // However, a UA MAY initiate a regular transaction while an INVITE\n      // transaction is in progress.  A UA MAY also initiate an INVITE\n      // transaction while a regular transaction is in progress.\n      // https://tools.ietf.org/html/rfc3261#section-14.1\n\n\n      if (this.reinviteUserAgentClient) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"There is an ongoing re-INVITE client transaction.\");\n      }\n\n      if (this.reinviteUserAgentServer) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"There is an ongoing re-INVITE server transaction.\");\n      }\n\n      return new ReInviteUserAgentClient(this, delegate, options);\n    }\n    /**\n     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a\n     * MESSAGE request is sent within a dialog, it is \"associated\" with any\n     * media session or sessions associated with that dialog.\n     * https://tools.ietf.org/html/rfc3428#section-4\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"message\",\n    value: function message(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending MESSAGE request\"));\n\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"Dialog not confirmed.\");\n      }\n\n      var message = this.createOutgoingRequestMessage(C.MESSAGE, options);\n      return new MessageUserAgentClient(this.core, message, delegate);\n    }\n    /**\n     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent\n     * sending the REFER of the status of the reference.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.4\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"notify\",\n    value: function notify(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending NOTIFY request\"));\n\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"Dialog not confirmed.\");\n      }\n\n      return new NotifyUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Assuming the response is to be transmitted reliably, the UAC MUST\n     * create a new request with method PRACK.  This request is sent within\n     * the dialog associated with the provisional response (indeed, the\n     * provisional response may have created the dialog).  PRACK requests\n     * MAY contain bodies, which are interpreted according to their type and\n     * disposition.\n     * https://tools.ietf.org/html/rfc3262#section-4\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"prack\",\n    value: function prack(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending PRACK request\"));\n      return new PrackUserAgentClient(this, delegate, options);\n    }\n    /**\n     * REFER is a SIP request and is constructed as defined in [1].  A REFER\n     * request MUST contain exactly one Refer-To header field value.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.1\n     * @param options - Options bucket.\n     */\n\n  }, {\n    key: \"refer\",\n    value: function refer(delegate, options) {\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" sending REFER request\"));\n\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"Dialog not confirmed.\");\n      } // FIXME: TODO: Validate Refer-To header field value.\n\n\n      return new ReferUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n\n  }, {\n    key: \"receiveRequest\",\n    value: function receiveRequest(message) {\n      var _this2 = this;\n\n      this.logger.log(\"INVITE dialog \".concat(this.id, \" received \").concat(message.method, \" request\")); // Response retransmissions cease when an ACK request for the\n      // response is received.  This is independent of whatever transport\n      // protocols are used to send the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.1\n\n      if (message.method === C.ACK) {\n        // If ackWait is true, then this is the ACK to the initial INVITE,\n        // otherwise this is an ACK to an in dialog INVITE. In either case,\n        // guard to make sure the sequence number of the ACK matches the INVITE.\n        if (this.ackWait) {\n          if (this.initialTransaction instanceof InviteClientTransaction) {\n            this.logger.warn(\"INVITE dialog \".concat(this.id, \" received unexpected \").concat(message.method, \" request, dropping.\"));\n            return;\n          }\n\n          if (this.initialTransaction.request.cseq !== message.cseq) {\n            this.logger.warn(\"INVITE dialog \".concat(this.id, \" received unexpected \").concat(message.method, \" request, dropping.\"));\n            return;\n          } // Update before the delegate has a chance to handle the\n          // message as delegate may callback into this dialog.\n\n\n          this.ackWait = false;\n        } else {\n          if (!this.reinviteUserAgentServer) {\n            this.logger.warn(\"INVITE dialog \".concat(this.id, \" received unexpected \").concat(message.method, \" request, dropping.\"));\n            return;\n          }\n\n          if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {\n            this.logger.warn(\"INVITE dialog \".concat(this.id, \" received unexpected \").concat(message.method, \" request, dropping.\"));\n            return;\n          }\n\n          this.reinviteUserAgentServer = undefined;\n        }\n\n        this.signalingStateTransition(message);\n\n        if (this.delegate && this.delegate.onAck) {\n          var promiseOrVoid = this.delegate.onAck({\n            message: message\n          });\n\n          if (promiseOrVoid instanceof Promise) {\n            this.ackProcessing = true; // make sure this is always reset to false\n\n            promiseOrVoid.then(function () {\n              return _this2.ackProcessing = false;\n            }).catch(function () {\n              return _this2.ackProcessing = false;\n            });\n          }\n        }\n\n        return;\n      } // Request within a dialog out of sequence guard.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      if (!this.sequenceGuard(message)) {\n        this.logger.log(\"INVITE dialog \".concat(this.id, \" rejected out of order \").concat(message.method, \" request.\"));\n        return;\n      } // Request within a dialog common processing.\n      // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n      _get(_getPrototypeOf(SessionDialog.prototype), \"receiveRequest\", this).call(this, message); // Handle various INVITE related cross-over, glare and race conditions\n\n\n      if (message.method === C.INVITE) {\n        // Hopefully this message is helpful...\n        var warning = function warning() {\n          var reason = _this2.ackWait ? \"waiting for initial ACK\" : \"processing initial ACK\";\n\n          _this2.logger.warn(\"INVITE dialog \".concat(_this2.id, \" received re-INVITE while \").concat(reason));\n\n          var msg = \"RFC 5407 suggests the following to avoid this race condition... \";\n          msg += \" Note: Implementation issues are outside the scope of this document,\";\n          msg += \" but the following tip is provided for avoiding race conditions of\";\n          msg += \" this type.  The caller can delay sending re-INVITE F6 for some period\";\n          msg += \" of time (2 seconds, perhaps), after which the caller can reasonably\";\n          msg += \" assume that its ACK has been received.  Implementors can decouple the\";\n          msg += \" actions of the user (e.g., pressing the hold button) from the actions\";\n          msg += \" of the protocol (the sending of re-INVITE F6), so that the UA can\";\n          msg += \" behave like this.  In this case, it is the implementor's choice as to\";\n          msg += \" how long to wait.  In most cases, such an implementation may be\";\n          msg += \" useful to prevent the type of race condition shown in this section.\";\n          msg += \" This document expresses no preference about whether or not they\";\n          msg += \" should wait for an ACK to be delivered.  After considering the impact\";\n          msg += \" on user experience, implementors should decide whether or not to wait\";\n          msg += \" for a while, because the user experience depends on the\";\n          msg += \" implementation and has no direct bearing on protocol behavior.\";\n\n          _this2.logger.warn(msg);\n\n          return; // drop re-INVITE request message\n        }; // A UAS that receives a second INVITE before it sends the final\n        // response to a first INVITE with a lower CSeq sequence number on the\n        // same dialog MUST return a 500 (Server Internal Error) response to the\n        // second INVITE and MUST include a Retry-After header field with a\n        // randomly chosen value of between 0 and 10 seconds.\n        // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n        var retryAfter = Math.floor(Math.random() * 10) + 1;\n        var extraHeaders = [\"Retry-After: \".concat(retryAfter)]; // There may be ONLY ONE offer/answer negotiation in progress for a\n        // single dialog at any point in time.  Section 4 explains how to ensure\n        // this.\n        // https://tools.ietf.org/html/rfc6337#section-2.2\n\n        if (this.ackProcessing) {\n          // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n          //           transaction associated with an offer/answer is incomplete,\n          //           a UA must reject another INVITE request with a 500\n          //           response.\n          // https://tools.ietf.org/html/rfc6337#section-4.3\n          this.core.replyStateless(message, {\n            statusCode: 500,\n            extraHeaders: extraHeaders\n          });\n          warning();\n          return;\n        } // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the\n        // Moratorium State (Case 1)\n        // https://tools.ietf.org/html/rfc5407#section-3.1.4\n        // 3.1.5.  Callee Receives re-INVITE (Established State) While in the\n        // Moratorium State (Case 2)\n        // https://tools.ietf.org/html/rfc5407#section-3.1.5\n\n\n        if (this.ackWait && this.signalingState !== SignalingState.Stable) {\n          // This scenario is basically the same as that of Section 3.1.4, but\n          // differs in sending an offer in the 200 and an answer in the ACK.  In\n          // contrast to the previous case, the offer in the 200 (F3) and the\n          // offer in the re-INVITE (F6) collide with each other.\n          //\n          // Bob sends a 491 to the re-INVITE (F6) since he is not able to\n          // properly handle a new request until he receives an answer.  (Note:\n          // 500 with a Retry-After header may be returned if the 491 response is\n          // understood to indicate request collision.  However, 491 is\n          // recommended here because 500 applies to so many cases that it is\n          // difficult to determine what the real problem was.)\n          // https://tools.ietf.org/html/rfc5407#section-3.1.5\n          // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n          //           transaction associated with an offer/answer is incomplete,\n          //           a UA must reject another INVITE request with a 500\n          //           response.\n          // https://tools.ietf.org/html/rfc6337#section-4.3\n          this.core.replyStateless(message, {\n            statusCode: 500,\n            extraHeaders: extraHeaders\n          });\n          warning();\n          return;\n        } // A UAS that receives a second INVITE before it sends the final\n        // response to a first INVITE with a lower CSeq sequence number on the\n        // same dialog MUST return a 500 (Server Internal Error) response to the\n        // second INVITE and MUST include a Retry-After header field with a\n        // randomly chosen value of between 0 and 10 seconds.\n        // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n        if (this.reinviteUserAgentServer) {\n          this.core.replyStateless(message, {\n            statusCode: 500,\n            extraHeaders: extraHeaders\n          });\n          return;\n        } // A UAS that receives an INVITE on a dialog while an INVITE it had sent\n        // on that dialog is in progress MUST return a 491 (Request Pending)\n        // response to the received INVITE.\n        // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n        if (this.reinviteUserAgentClient) {\n          this.core.replyStateless(message, {\n            statusCode: 491\n          });\n          return;\n        }\n      } // Requests within a dialog MAY contain Record-Route and Contact header\n      // fields.  However, these requests do not cause the dialog's route set\n      // to be modified, although they may modify the remote target URI.\n      // Specifically, requests that are not target refresh requests do not\n      // modify the dialog's remote target URI, and requests that are target\n      // refresh requests do.  For dialogs that have been established with an\n      // INVITE, the only target refresh request defined is re-INVITE (see\n      // Section 14).  Other extensions may define different target refresh\n      // requests for dialogs established in other ways.\n      //\n      //    Note that an ACK is NOT a target refresh request.\n      //\n      // Target refresh requests only update the dialog's remote target URI,\n      // and not the route set formed from the Record-Route.  Updating the\n      // latter would introduce severe backwards compatibility problems with\n      // RFC 2543-compliant systems.\n      // https://tools.ietf.org/html/rfc3261#section-15\n\n\n      if (message.method === C.INVITE) {\n        // FIXME: parser needs to be typed...\n        var contact = message.parseHeader(\"contact\");\n\n        if (!contact) {\n          // TODO: Review to make sure this will never happen\n          throw new Error(\"Contact undefined.\");\n        }\n\n        if (!(contact instanceof NameAddrHeader)) {\n          throw new Error(\"Contact not instance of NameAddrHeader.\");\n        }\n\n        this.dialogState.remoteTarget = contact.uri;\n      } // Switch on method and then delegate.\n\n\n      switch (message.method) {\n        case C.BYE:\n          // A UAS core receiving a BYE request for an existing dialog MUST follow\n          // the procedures of Section 12.2.2 to process the request.  Once done,\n          // the UAS SHOULD terminate the session (and therefore stop sending and\n          // listening for media).  The only case where it can elect not to are\n          // multicast sessions, where participation is possible even if the other\n          // participant in the dialog has terminated its involvement in the\n          // session.  Whether or not it ends its participation on the session,\n          // the UAS core MUST generate a 2xx response to the BYE, and MUST pass\n          // that to the server transaction for transmission.\n          //\n          // The UAS MUST still respond to any pending requests received for that\n          // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n          // be generated to those pending requests.\n          // https://tools.ietf.org/html/rfc3261#section-15.1.2\n          {\n            var uas = new ByeUserAgentServer(this, message);\n            this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();\n            this.dispose();\n          }\n          break;\n\n        case C.INFO:\n          // If a UA receives an INFO request associated with an Info Package that\n          // the UA has not indicated willingness to receive, the UA MUST send a\n          // 469 (Bad Info Package) response (see Section 11.6), which contains a\n          // Recv-Info header field with Info Packages for which the UA is willing\n          // to receive INFO requests.\n          {\n            var _uas = new InfoUserAgentServer(this, message);\n\n            this.delegate && this.delegate.onInfo ? this.delegate.onInfo(_uas) : _uas.reject({\n              statusCode: 469,\n              extraHeaders: [\"Recv-Info :\"]\n            });\n          }\n          break;\n\n        case C.INVITE:\n          // If the new session description is not acceptable, the UAS can reject\n          // it by returning a 488 (Not Acceptable Here) response for the re-\n          // INVITE.  This response SHOULD include a Warning header field.\n          // https://tools.ietf.org/html/rfc3261#section-14.2\n          {\n            var _uas2 = new ReInviteUserAgentServer(this, message);\n\n            this.signalingStateTransition(message);\n            this.delegate && this.delegate.onInvite ? this.delegate.onInvite(_uas2) : _uas2.reject({\n              statusCode: 488\n            }); // TODO: Warning header field.\n          }\n          break;\n\n        case C.MESSAGE:\n          {\n            var _uas3 = new MessageUserAgentServer(this.core, message);\n\n            this.delegate && this.delegate.onMessage ? this.delegate.onMessage(_uas3) : _uas3.accept();\n          }\n          break;\n\n        case C.NOTIFY:\n          // https://tools.ietf.org/html/rfc3515#section-2.4.4\n          {\n            var _uas4 = new NotifyUserAgentServer(this, message);\n\n            this.delegate && this.delegate.onNotify ? this.delegate.onNotify(_uas4) : _uas4.accept();\n          }\n          break;\n\n        case C.PRACK:\n          // https://tools.ietf.org/html/rfc3262#section-4\n          {\n            var _uas5 = new PrackUserAgentServer(this, message);\n\n            this.delegate && this.delegate.onPrack ? this.delegate.onPrack(_uas5) : _uas5.accept();\n          }\n          break;\n\n        case C.REFER:\n          // https://tools.ietf.org/html/rfc3515#section-2.4.2\n          {\n            var _uas6 = new ReferUserAgentServer(this, message);\n\n            this.delegate && this.delegate.onRefer ? this.delegate.onRefer(_uas6) : _uas6.reject();\n          }\n          break;\n\n        default:\n          {\n            this.logger.log(\"INVITE dialog \".concat(this.id, \" received unimplemented \").concat(message.method, \" request\"));\n            this.core.replyStateless(message, {\n              statusCode: 501\n            });\n          }\n          break;\n      }\n    }\n    /**\n     * Guard against out of order reliable provisional responses and retransmissions.\n     * Returns false if the response should be discarded, otherwise true.\n     * @param message - Incoming response message within this dialog.\n     */\n\n  }, {\n    key: \"reliableSequenceGuard\",\n    value: function reliableSequenceGuard(message) {\n      var statusCode = message.statusCode;\n\n      if (!statusCode) {\n        throw new Error(\"Status code undefined\");\n      }\n\n      if (statusCode > 100 && statusCode < 200) {\n        // If a provisional response is received for an initial request, and\n        // that response contains a Require header field containing the option\n        // tag 100rel, the response is to be sent reliably.  If the response is\n        // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n        // ignored, and the procedures below MUST NOT be used.\n        // https://tools.ietf.org/html/rfc3262#section-4\n        var requireHeader = message.getHeader(\"require\");\n        var rseqHeader = message.getHeader(\"rseq\");\n        var rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n\n        if (rseq) {\n          // Handling of subsequent reliable provisional responses for the same\n          // initial request follows the same rules as above, with the following\n          // difference: reliable provisional responses are guaranteed to be in\n          // order.  As a result, if the UAC receives another reliable provisional\n          // response to the same request, and its RSeq value is not one higher\n          // than the value of the sequence number, that response MUST NOT be\n          // acknowledged with a PRACK, and MUST NOT be processed further by the\n          // UAC.  An implementation MAY discard the response, or MAY cache the\n          // response in the hopes of receiving the missing responses.\n          // https://tools.ietf.org/html/rfc3262#section-4\n          if (this.rseq && this.rseq + 1 !== rseq) {\n            return false;\n          } // Once a reliable provisional response is received, retransmissions of\n          // that response MUST be discarded.  A response is a retransmission when\n          // its dialog ID, CSeq, and RSeq match the original response.  The UAC\n          // MUST maintain a sequence number that indicates the most recently\n          // received in-order reliable provisional response for the initial\n          // request.  This sequence number MUST be maintained until a final\n          // response is received for the initial request.  Its value MUST be\n          // initialized to the RSeq header field in the first reliable\n          // provisional response received for the initial request.\n          // https://tools.ietf.org/html/rfc3262#section-4\n\n\n          this.rseq = this.rseq ? this.rseq + 1 : rseq;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * If not in a stable signaling state, rollback to prior stable signaling state.\n     */\n\n  }, {\n    key: \"signalingStateRollback\",\n    value: function signalingStateRollback() {\n      if (this._signalingState === SignalingState.HaveLocalOffer || this.signalingState === SignalingState.HaveRemoteOffer) {\n        if (this._rollbackOffer && this._rollbackAnswer) {\n          this._signalingState = SignalingState.Stable;\n          this._offer = this._rollbackOffer;\n          this._answer = this._rollbackAnswer;\n        }\n      }\n    }\n    /**\n     * Update the signaling state of the dialog.\n     * @param message - The message to base the update off of.\n     */\n\n  }, {\n    key: \"signalingStateTransition\",\n    value: function signalingStateTransition(message) {\n      var body = getBody(message); // No body, no session. No, woman, no cry.\n\n      if (!body || body.contentDisposition !== \"session\") {\n        return;\n      } // We've got an existing offer and answer which we may wish to rollback to\n\n\n      if (this._signalingState === SignalingState.Stable) {\n        this._rollbackOffer = this._offer;\n        this._rollbackAnswer = this._answer;\n      } // We're in UAS role, receiving incoming request with session description\n\n\n      if (message instanceof IncomingRequestMessage) {\n        switch (this._signalingState) {\n          case SignalingState.Initial:\n          case SignalingState.Stable:\n            this._signalingState = SignalingState.HaveRemoteOffer;\n            this._offer = body;\n            this._answer = undefined;\n            break;\n\n          case SignalingState.HaveLocalOffer:\n            this._signalingState = SignalingState.Stable;\n            this._answer = body;\n            break;\n\n          case SignalingState.HaveRemoteOffer:\n            // You cannot make a new offer while one is in progress.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            // FIXME: What to do here?\n            break;\n\n          case SignalingState.Closed:\n            break;\n\n          default:\n            throw new Error(\"Unexpected signaling state.\");\n        }\n      } // We're in UAC role, receiving incoming response with session description\n\n\n      if (message instanceof IncomingResponseMessage) {\n        switch (this._signalingState) {\n          case SignalingState.Initial:\n          case SignalingState.Stable:\n            this._signalingState = SignalingState.HaveRemoteOffer;\n            this._offer = body;\n            this._answer = undefined;\n            break;\n\n          case SignalingState.HaveLocalOffer:\n            this._signalingState = SignalingState.Stable;\n            this._answer = body;\n            break;\n\n          case SignalingState.HaveRemoteOffer:\n            // You cannot make a new offer while one is in progress.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            // FIXME: What to do here?\n            break;\n\n          case SignalingState.Closed:\n            break;\n\n          default:\n            throw new Error(\"Unexpected signaling state.\");\n        }\n      } // We're in UAC role, sending outgoing request with session description\n\n\n      if (message instanceof OutgoingRequestMessage) {\n        switch (this._signalingState) {\n          case SignalingState.Initial:\n          case SignalingState.Stable:\n            this._signalingState = SignalingState.HaveLocalOffer;\n            this._offer = body;\n            this._answer = undefined;\n            break;\n\n          case SignalingState.HaveLocalOffer:\n            // You cannot make a new offer while one is in progress.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            // FIXME: What to do here?\n            break;\n\n          case SignalingState.HaveRemoteOffer:\n            this._signalingState = SignalingState.Stable;\n            this._answer = body;\n            break;\n\n          case SignalingState.Closed:\n            break;\n\n          default:\n            throw new Error(\"Unexpected signaling state.\");\n        }\n      } // We're in UAS role, sending outgoing response with session description\n\n\n      if (isBody(message)) {\n        switch (this._signalingState) {\n          case SignalingState.Initial:\n          case SignalingState.Stable:\n            this._signalingState = SignalingState.HaveLocalOffer;\n            this._offer = body;\n            this._answer = undefined;\n            break;\n\n          case SignalingState.HaveLocalOffer:\n            // You cannot make a new offer while one is in progress.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.1\n            // FIXME: What to do here?\n            break;\n\n          case SignalingState.HaveRemoteOffer:\n            this._signalingState = SignalingState.Stable;\n            this._answer = body;\n            break;\n\n          case SignalingState.Closed:\n            break;\n\n          default:\n            throw new Error(\"Unexpected signaling state.\");\n        }\n      }\n    }\n  }, {\n    key: \"start2xxRetransmissionTimer\",\n    value: function start2xxRetransmissionTimer() {\n      var _this3 = this;\n\n      if (this.initialTransaction instanceof InviteServerTransaction) {\n        var transaction = this.initialTransaction; // Once the response has been constructed, it is passed to the INVITE\n        // server transaction.  In order to ensure reliable end-to-end\n        // transport of the response, it is necessary to periodically pass\n        // the response directly to the transport until the ACK arrives.  The\n        // 2xx response is passed to the transport with an interval that\n        // starts at T1 seconds and doubles for each retransmission until it\n        // reaches T2 seconds (T1 and T2 are defined in Section 17).\n        // Response retransmissions cease when an ACK request for the\n        // response is received.  This is independent of whatever transport\n        // protocols are used to send the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.1\n\n        var timeout = Timers.T1;\n\n        var retransmission = function retransmission() {\n          if (!_this3.ackWait) {\n            _this3.invite2xxTimer = undefined;\n            return;\n          }\n\n          _this3.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n\n          transaction.retransmitAcceptedResponse();\n          timeout = Math.min(timeout * 2, Timers.T2);\n          _this3.invite2xxTimer = setTimeout(retransmission, timeout);\n        };\n\n        this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n        // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n        // terminated.  This is accomplished with a BYE, as described in Section 15.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n        var stateChanged = function stateChanged() {\n          if (transaction.state === TransactionState.Terminated) {\n            transaction.removeStateChangeListener(stateChanged);\n\n            if (_this3.invite2xxTimer) {\n              clearTimeout(_this3.invite2xxTimer);\n              _this3.invite2xxTimer = undefined;\n            }\n\n            if (_this3.ackWait) {\n              if (_this3.delegate && _this3.delegate.onAckTimeout) {\n                _this3.delegate.onAckTimeout();\n              } else {\n                _this3.bye();\n              }\n            }\n          }\n        };\n\n        transaction.addStateChangeListener(stateChanged);\n      }\n    } // FIXME: Refactor\n\n  }, {\n    key: \"startReInvite2xxRetransmissionTimer\",\n    value: function startReInvite2xxRetransmissionTimer() {\n      var _this4 = this;\n\n      if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction) {\n        var transaction = this.reinviteUserAgentServer.transaction; // Once the response has been constructed, it is passed to the INVITE\n        // server transaction.  In order to ensure reliable end-to-end\n        // transport of the response, it is necessary to periodically pass\n        // the response directly to the transport until the ACK arrives.  The\n        // 2xx response is passed to the transport with an interval that\n        // starts at T1 seconds and doubles for each retransmission until it\n        // reaches T2 seconds (T1 and T2 are defined in Section 17).\n        // Response retransmissions cease when an ACK request for the\n        // response is received.  This is independent of whatever transport\n        // protocols are used to send the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.1\n\n        var timeout = Timers.T1;\n\n        var retransmission = function retransmission() {\n          if (!_this4.reinviteUserAgentServer) {\n            _this4.invite2xxTimer = undefined;\n            return;\n          }\n\n          _this4.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n\n          transaction.retransmitAcceptedResponse();\n          timeout = Math.min(timeout * 2, Timers.T2);\n          _this4.invite2xxTimer = setTimeout(retransmission, timeout);\n        };\n\n        this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n        // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n        // terminated.  This is accomplished with a BYE, as described in Section 15.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n        var stateChanged = function stateChanged() {\n          if (transaction.state === TransactionState.Terminated) {\n            transaction.removeStateChangeListener(stateChanged);\n\n            if (_this4.invite2xxTimer) {\n              clearTimeout(_this4.invite2xxTimer);\n              _this4.invite2xxTimer = undefined;\n            }\n\n            if (_this4.reinviteUserAgentServer) {// FIXME: TODO: What to do here\n            }\n          }\n        };\n\n        transaction.addStateChangeListener(stateChanged);\n      }\n    }\n  }, {\n    key: \"sessionState\",\n    get: function get() {\n      if (this.early) {\n        return SessionState.Early;\n      } else if (this.ackWait) {\n        return SessionState.AckWait;\n      } else if (this._signalingState === SignalingState.Closed) {\n        return SessionState.Terminated;\n      } else {\n        return SessionState.Confirmed;\n      }\n    }\n    /** The state of the offer/answer exchange. */\n\n  }, {\n    key: \"signalingState\",\n    get: function get() {\n      return this._signalingState;\n    }\n    /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */\n\n  }, {\n    key: \"offer\",\n    get: function get() {\n      return this._offer;\n    }\n    /** The current answer. Undefined unless signaling state Stable. */\n\n  }, {\n    key: \"answer\",\n    get: function get() {\n      return this._answer;\n    }\n  }]);\n\n  return SessionDialog;\n}(Dialog);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/dialogs/session-dialog.js"],"names":["C","getBody","IncomingRequestMessage","IncomingResponseMessage","isBody","NameAddrHeader","OutgoingRequestMessage","SessionState","SignalingState","Timers","InviteClientTransaction","InviteServerTransaction","TransactionState","ByeUserAgentClient","ByeUserAgentServer","InfoUserAgentClient","InfoUserAgentServer","MessageUserAgentClient","MessageUserAgentServer","NotifyUserAgentClient","NotifyUserAgentServer","PrackUserAgentClient","PrackUserAgentServer","ReInviteUserAgentClient","ReInviteUserAgentServer","ReferUserAgentClient","ReferUserAgentServer","Dialog","SessionDialog","initialTransaction","core","state","delegate","_signalingState","Initial","ackWait","ackProcessing","early","start2xxRetransmissionTimer","signalingStateTransition","request","logger","loggerFactory","getLogger","log","id","Closed","_offer","undefined","_answer","invite2xxTimer","clearTimeout","reinviteUserAgentServer","startReInvite2xxRetransmissionTimer","options","transaction","reinviteUserAgentClient","Error","message","createOutgoingRequestMessage","ACK","cseq","extraHeaders","body","ackResponse","Terminated","MESSAGE","method","warn","onAck","promiseOrVoid","Promise","then","catch","sequenceGuard","INVITE","warning","reason","msg","retryAfter","Math","floor","random","replyStateless","statusCode","signalingState","Stable","contact","parseHeader","dialogState","remoteTarget","uri","BYE","uas","onBye","accept","dispose","INFO","onInfo","reject","onInvite","onMessage","NOTIFY","onNotify","PRACK","onPrack","REFER","onRefer","requireHeader","getHeader","rseqHeader","rseq","includes","Number","HaveLocalOffer","HaveRemoteOffer","_rollbackOffer","_rollbackAnswer","contentDisposition","timeout","T1","retransmission","retransmitAcceptedResponse","min","T2","setTimeout","stateChanged","removeStateChangeListener","onAckTimeout","bye","addStateChangeListener","Early","AckWait","Confirmed"],"mappings":"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","sourcesContent":["import { C, getBody, IncomingRequestMessage, IncomingResponseMessage, isBody, NameAddrHeader, OutgoingRequestMessage } from \"../messages\";\nimport { SessionState, SignalingState } from \"../session\";\nimport { Timers } from \"../timers\";\nimport { InviteClientTransaction, InviteServerTransaction, TransactionState } from \"../transactions\";\nimport { ByeUserAgentClient } from \"../user-agents/bye-user-agent-client\";\nimport { ByeUserAgentServer } from \"../user-agents/bye-user-agent-server\";\nimport { InfoUserAgentClient } from \"../user-agents/info-user-agent-client\";\nimport { InfoUserAgentServer } from \"../user-agents/info-user-agent-server\";\nimport { MessageUserAgentClient } from \"../user-agents/message-user-agent-client\";\nimport { MessageUserAgentServer } from \"../user-agents/message-user-agent-server\";\nimport { NotifyUserAgentClient } from \"../user-agents/notify-user-agent-client\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server\";\nimport { PrackUserAgentClient } from \"../user-agents/prack-user-agent-client\";\nimport { PrackUserAgentServer } from \"../user-agents/prack-user-agent-server\";\nimport { ReInviteUserAgentClient } from \"../user-agents/re-invite-user-agent-client\";\nimport { ReInviteUserAgentServer } from \"../user-agents/re-invite-user-agent-server\";\nimport { ReferUserAgentClient } from \"../user-agents/refer-user-agent-client\";\nimport { ReferUserAgentServer } from \"../user-agents/refer-user-agent-server\";\nimport { Dialog } from \"./dialog\";\n/**\n * Session Dialog.\n * @public\n */\nexport class SessionDialog extends Dialog {\n    constructor(initialTransaction, core, state, delegate) {\n        super(core, state);\n        this.initialTransaction = initialTransaction;\n        /** The state of the offer/answer exchange. */\n        this._signalingState = SignalingState.Initial;\n        /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */\n        this.ackWait = false;\n        /** True if processing an ACK to the initial transaction 2xx (UAS only). */\n        this.ackProcessing = false;\n        this.delegate = delegate;\n        if (initialTransaction instanceof InviteServerTransaction) {\n            // If we're created by an invite server transaction, we're\n            // going to be waiting for an ACK if are to be confirmed.\n            this.ackWait = true;\n        }\n        // If we're confirmed upon creation start the retransmitting whatever\n        // the 2xx final response was that confirmed us into existence.\n        if (!this.early) {\n            this.start2xxRetransmissionTimer();\n        }\n        this.signalingStateTransition(initialTransaction.request);\n        this.logger = core.loggerFactory.getLogger(\"sip.invite-dialog\");\n        this.logger.log(`INVITE dialog ${this.id} constructed`);\n    }\n    dispose() {\n        super.dispose();\n        this._signalingState = SignalingState.Closed;\n        this._offer = undefined;\n        this._answer = undefined;\n        if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n        }\n        // The UAS MUST still respond to any pending requests received for that\n        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n        // be generated to those pending requests.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.2\n        // TODO:\n        // this.userAgentServers.forEach((uas) => uas.reply(487));\n        this.logger.log(`INVITE dialog ${this.id} destroyed`);\n    }\n    // FIXME: Need real state machine\n    get sessionState() {\n        if (this.early) {\n            return SessionState.Early;\n        }\n        else if (this.ackWait) {\n            return SessionState.AckWait;\n        }\n        else if (this._signalingState === SignalingState.Closed) {\n            return SessionState.Terminated;\n        }\n        else {\n            return SessionState.Confirmed;\n        }\n    }\n    /** The state of the offer/answer exchange. */\n    get signalingState() {\n        return this._signalingState;\n    }\n    /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */\n    get offer() {\n        return this._offer;\n    }\n    /** The current answer. Undefined unless signaling state Stable. */\n    get answer() {\n        return this._answer;\n    }\n    /** Confirm the dialog. Only matters if dialog is currently early. */\n    confirm() {\n        // When we're confirmed start the retransmitting whatever\n        // the 2xx final response that may have confirmed us.\n        if (this.early) {\n            this.start2xxRetransmissionTimer();\n        }\n        super.confirm();\n    }\n    /** Re-confirm the dialog. Only matters if handling re-INVITE request. */\n    reConfirm() {\n        // When we're confirmed start the retransmitting whatever\n        // the 2xx final response that may have confirmed us.\n        if (this.reinviteUserAgentServer) {\n            this.startReInvite2xxRetransmissionTimer();\n        }\n    }\n    /**\n     * The UAC core MUST generate an ACK request for each 2xx received from\n     * the transaction layer.  The header fields of the ACK are constructed\n     * in the same way as for any request sent within a dialog (see Section\n     * 12) with the exception of the CSeq and the header fields related to\n     * authentication.  The sequence number of the CSeq header field MUST be\n     * the same as the INVITE being acknowledged, but the CSeq method MUST\n     * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n     * the 2xx contains an offer (based on the rules above), the ACK MUST\n     * carry an answer in its body.  If the offer in the 2xx response is not\n     * acceptable, the UAC core MUST generate a valid answer in the ACK and\n     * then send a BYE immediately.\n     * https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n     * @param options - ACK options bucket.\n     */\n    ack(options = {}) {\n        this.logger.log(`INVITE dialog ${this.id} sending ACK request`);\n        let transaction;\n        if (this.reinviteUserAgentClient) {\n            // We're sending ACK for a re-INVITE\n            if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n            transaction = this.reinviteUserAgentClient.transaction;\n            this.reinviteUserAgentClient = undefined;\n        }\n        else {\n            // We're sending ACK for the initial INVITE\n            if (!(this.initialTransaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Initial transaction not instance of InviteClientTransaction.\");\n            }\n            transaction = this.initialTransaction;\n        }\n        const message = this.createOutgoingRequestMessage(C.ACK, {\n            cseq: transaction.request.cseq,\n            extraHeaders: options.extraHeaders,\n            body: options.body\n        });\n        transaction.ackResponse(message); // See InviteClientTransaction for details.\n        this.signalingStateTransition(message);\n        return { message };\n    }\n    /**\n     * Terminating a Session\n     *\n     * This section describes the procedures for terminating a session\n     * established by SIP.  The state of the session and the state of the\n     * dialog are very closely related.  When a session is initiated with an\n     * INVITE, each 1xx or 2xx response from a distinct UAS creates a\n     * dialog, and if that response completes the offer/answer exchange, it\n     * also creates a session.  As a result, each session is \"associated\"\n     * with a single dialog - the one which resulted in its creation.  If an\n     * initial INVITE generates a non-2xx final response, that terminates\n     * all sessions (if any) and all dialogs (if any) that were created\n     * through responses to the request.  By virtue of completing the\n     * transaction, a non-2xx final response also prevents further sessions\n     * from being created as a result of the INVITE.  The BYE request is\n     * used to terminate a specific session or attempted session.  In this\n     * case, the specific session is the one with the peer UA on the other\n     * side of the dialog.  When a BYE is received on a dialog, any session\n     * associated with that dialog SHOULD terminate.  A UA MUST NOT send a\n     * BYE outside of a dialog.  The caller's UA MAY send a BYE for either\n     * confirmed or early dialogs, and the callee's UA MAY send a BYE on\n     * confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n     *\n     * However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n     * until it has received an ACK for its 2xx response or until the server\n     * transaction times out.  If no SIP extensions have defined other\n     * application layer states associated with the dialog, the BYE also\n     * terminates the dialog.\n     *\n     * https://tools.ietf.org/html/rfc3261#section-15\n     * FIXME: Make these proper Exceptions...\n     * @param options - BYE options bucket.\n     * @returns\n     * Throws `Error` if callee's UA attempts a BYE on an early dialog.\n     * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog\n     *                while it's waiting on the ACK for its 2xx response.\n     */\n    bye(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending BYE request`);\n        // The caller's UA MAY send a BYE for either\n        // confirmed or early dialogs, and the callee's UA MAY send a BYE on\n        // confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n        //\n        // However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n        // until it has received an ACK for its 2xx response or until the server\n        // transaction times out.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        if (this.initialTransaction instanceof InviteServerTransaction) {\n            if (this.early) {\n                // FIXME: TODO: This should throw a proper exception.\n                throw new Error(\"UAS MUST NOT send a BYE on early dialogs.\");\n            }\n            if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {\n                // FIXME: TODO: This should throw a proper exception.\n                throw new Error(\"UAS MUST NOT send a BYE on a confirmed dialog \" +\n                    \"until it has received an ACK for its 2xx response \" +\n                    \"or until the server transaction times out.\");\n            }\n        }\n        // A BYE request is constructed as would any other request within a\n        // dialog, as described in Section 12.\n        //\n        // Once the BYE is constructed, the UAC core creates a new non-INVITE\n        // client transaction, and passes it the BYE request.  The UAC MUST\n        // consider the session terminated (and therefore stop sending or\n        // listening for media) as soon as the BYE request is passed to the\n        // client transaction.  If the response for the BYE is a 481\n        // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no\n        // response at all is received for the BYE (that is, a timeout is\n        // returned by the client transaction), the UAC MUST consider the\n        // session and the dialog terminated.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.1\n        return new ByeUserAgentClient(this, delegate, options);\n    }\n    /**\n     * An INFO request can be associated with an Info Package (see\n     * Section 5), or associated with a legacy INFO usage (see Section 2).\n     *\n     * The construction of the INFO request is the same as any other\n     * non-target refresh request within an existing invite dialog usage as\n     * described in Section 12.2 of RFC 3261.\n     * https://tools.ietf.org/html/rfc6086#section-4.2.1\n     * @param options - Options bucket.\n     */\n    info(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending INFO request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        return new InfoUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Modifying an Existing Session\n     *\n     * A successful INVITE request (see Section 13) establishes both a\n     * dialog between two user agents and a session using the offer-answer\n     * model.  Section 12 explains how to modify an existing dialog using a\n     * target refresh request (for example, changing the remote target URI\n     * of the dialog).  This section describes how to modify the actual\n     * session.  This modification can involve changing addresses or ports,\n     * adding a media stream, deleting a media stream, and so on.  This is\n     * accomplished by sending a new INVITE request within the same dialog\n     * that established the session.  An INVITE request sent within an\n     * existing dialog is known as a re-INVITE.\n     *\n     *    Note that a single re-INVITE can modify the dialog and the\n     *    parameters of the session at the same time.\n     *\n     * Either the caller or callee can modify an existing session.\n     * https://tools.ietf.org/html/rfc3261#section-14\n     * @param options - Options bucket\n     */\n    invite(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        // Note that a UAC MUST NOT initiate a new INVITE transaction within a\n        // dialog while another INVITE transaction is in progress in either\n        // direction.\n        //\n        //    1. If there is an ongoing INVITE client transaction, the TU MUST\n        //       wait until the transaction reaches the completed or terminated\n        //       state before initiating the new INVITE.\n        //\n        //    2. If there is an ongoing INVITE server transaction, the TU MUST\n        //       wait until the transaction reaches the confirmed or terminated\n        //       state before initiating the new INVITE.\n        //\n        // However, a UA MAY initiate a regular transaction while an INVITE\n        // transaction is in progress.  A UA MAY also initiate an INVITE\n        // transaction while a regular transaction is in progress.\n        // https://tools.ietf.org/html/rfc3261#section-14.1\n        if (this.reinviteUserAgentClient) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"There is an ongoing re-INVITE client transaction.\");\n        }\n        if (this.reinviteUserAgentServer) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"There is an ongoing re-INVITE server transaction.\");\n        }\n        return new ReInviteUserAgentClient(this, delegate, options);\n    }\n    /**\n     * A UAC MAY associate a MESSAGE request with an existing dialog.  If a\n     * MESSAGE request is sent within a dialog, it is \"associated\" with any\n     * media session or sessions associated with that dialog.\n     * https://tools.ietf.org/html/rfc3428#section-4\n     * @param options - Options bucket.\n     */\n    message(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        const message = this.createOutgoingRequestMessage(C.MESSAGE, options);\n        return new MessageUserAgentClient(this.core, message, delegate);\n    }\n    /**\n     * The NOTIFY mechanism defined in [2] MUST be used to inform the agent\n     * sending the REFER of the status of the reference.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.4\n     * @param options - Options bucket.\n     */\n    notify(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        return new NotifyUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Assuming the response is to be transmitted reliably, the UAC MUST\n     * create a new request with method PRACK.  This request is sent within\n     * the dialog associated with the provisional response (indeed, the\n     * provisional response may have created the dialog).  PRACK requests\n     * MAY contain bodies, which are interpreted according to their type and\n     * disposition.\n     * https://tools.ietf.org/html/rfc3262#section-4\n     * @param options - Options bucket.\n     */\n    prack(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);\n        return new PrackUserAgentClient(this, delegate, options);\n    }\n    /**\n     * REFER is a SIP request and is constructed as defined in [1].  A REFER\n     * request MUST contain exactly one Refer-To header field value.\n     * https://tools.ietf.org/html/rfc3515#section-2.4.1\n     * @param options - Options bucket.\n     */\n    refer(delegate, options) {\n        this.logger.log(`INVITE dialog ${this.id} sending REFER request`);\n        if (this.early) {\n            // FIXME: TODO: This should throw a proper exception.\n            throw new Error(\"Dialog not confirmed.\");\n        }\n        // FIXME: TODO: Validate Refer-To header field value.\n        return new ReferUserAgentClient(this, delegate, options);\n    }\n    /**\n     * Requests sent within a dialog, as any other requests, are atomic.  If\n     * a particular request is accepted by the UAS, all the state changes\n     * associated with it are performed.  If the request is rejected, none\n     * of the state changes are performed.\n     * https://tools.ietf.org/html/rfc3261#section-12.2.2\n     * @param message - Incoming request message within this dialog.\n     */\n    receiveRequest(message) {\n        this.logger.log(`INVITE dialog ${this.id} received ${message.method} request`);\n        // Response retransmissions cease when an ACK request for the\n        // response is received.  This is independent of whatever transport\n        // protocols are used to send the response.\n        // https://tools.ietf.org/html/rfc6026#section-8.1\n        if (message.method === C.ACK) {\n            // If ackWait is true, then this is the ACK to the initial INVITE,\n            // otherwise this is an ACK to an in dialog INVITE. In either case,\n            // guard to make sure the sequence number of the ACK matches the INVITE.\n            if (this.ackWait) {\n                if (this.initialTransaction instanceof InviteClientTransaction) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                if (this.initialTransaction.request.cseq !== message.cseq) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                // Update before the delegate has a chance to handle the\n                // message as delegate may callback into this dialog.\n                this.ackWait = false;\n            }\n            else {\n                if (!this.reinviteUserAgentServer) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {\n                    this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n                    return;\n                }\n                this.reinviteUserAgentServer = undefined;\n            }\n            this.signalingStateTransition(message);\n            if (this.delegate && this.delegate.onAck) {\n                const promiseOrVoid = this.delegate.onAck({ message });\n                if (promiseOrVoid instanceof Promise) {\n                    this.ackProcessing = true; // make sure this is always reset to false\n                    promiseOrVoid.then(() => (this.ackProcessing = false)).catch(() => (this.ackProcessing = false));\n                }\n            }\n            return;\n        }\n        // Request within a dialog out of sequence guard.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        if (!this.sequenceGuard(message)) {\n            this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message.method} request.`);\n            return;\n        }\n        // Request within a dialog common processing.\n        // https://tools.ietf.org/html/rfc3261#section-12.2.2\n        super.receiveRequest(message);\n        // Handle various INVITE related cross-over, glare and race conditions\n        if (message.method === C.INVITE) {\n            // Hopefully this message is helpful...\n            const warning = () => {\n                const reason = this.ackWait ? \"waiting for initial ACK\" : \"processing initial ACK\";\n                this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);\n                let msg = \"RFC 5407 suggests the following to avoid this race condition... \";\n                msg += \" Note: Implementation issues are outside the scope of this document,\";\n                msg += \" but the following tip is provided for avoiding race conditions of\";\n                msg += \" this type.  The caller can delay sending re-INVITE F6 for some period\";\n                msg += \" of time (2 seconds, perhaps), after which the caller can reasonably\";\n                msg += \" assume that its ACK has been received.  Implementors can decouple the\";\n                msg += \" actions of the user (e.g., pressing the hold button) from the actions\";\n                msg += \" of the protocol (the sending of re-INVITE F6), so that the UA can\";\n                msg += \" behave like this.  In this case, it is the implementor's choice as to\";\n                msg += \" how long to wait.  In most cases, such an implementation may be\";\n                msg += \" useful to prevent the type of race condition shown in this section.\";\n                msg += \" This document expresses no preference about whether or not they\";\n                msg += \" should wait for an ACK to be delivered.  After considering the impact\";\n                msg += \" on user experience, implementors should decide whether or not to wait\";\n                msg += \" for a while, because the user experience depends on the\";\n                msg += \" implementation and has no direct bearing on protocol behavior.\";\n                this.logger.warn(msg);\n                return; // drop re-INVITE request message\n            };\n            // A UAS that receives a second INVITE before it sends the final\n            // response to a first INVITE with a lower CSeq sequence number on the\n            // same dialog MUST return a 500 (Server Internal Error) response to the\n            // second INVITE and MUST include a Retry-After header field with a\n            // randomly chosen value of between 0 and 10 seconds.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            const retryAfter = Math.floor(Math.random() * 10) + 1;\n            const extraHeaders = [`Retry-After: ${retryAfter}`];\n            // There may be ONLY ONE offer/answer negotiation in progress for a\n            // single dialog at any point in time.  Section 4 explains how to ensure\n            // this.\n            // https://tools.ietf.org/html/rfc6337#section-2.2\n            if (this.ackProcessing) {\n                // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n                //           transaction associated with an offer/answer is incomplete,\n                //           a UA must reject another INVITE request with a 500\n                //           response.\n                // https://tools.ietf.org/html/rfc6337#section-4.3\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                warning();\n                return;\n            }\n            // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the\n            // Moratorium State (Case 1)\n            // https://tools.ietf.org/html/rfc5407#section-3.1.4\n            // 3.1.5.  Callee Receives re-INVITE (Established State) While in the\n            // Moratorium State (Case 2)\n            // https://tools.ietf.org/html/rfc5407#section-3.1.5\n            if (this.ackWait && this.signalingState !== SignalingState.Stable) {\n                // This scenario is basically the same as that of Section 3.1.4, but\n                // differs in sending an offer in the 200 and an answer in the ACK.  In\n                // contrast to the previous case, the offer in the 200 (F3) and the\n                // offer in the re-INVITE (F6) collide with each other.\n                //\n                // Bob sends a 491 to the re-INVITE (F6) since he is not able to\n                // properly handle a new request until he receives an answer.  (Note:\n                // 500 with a Retry-After header may be returned if the 491 response is\n                // understood to indicate request collision.  However, 491 is\n                // recommended here because 500 applies to so many cases that it is\n                // difficult to determine what the real problem was.)\n                // https://tools.ietf.org/html/rfc5407#section-3.1.5\n                // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n                //           transaction associated with an offer/answer is incomplete,\n                //           a UA must reject another INVITE request with a 500\n                //           response.\n                // https://tools.ietf.org/html/rfc6337#section-4.3\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                warning();\n                return;\n            }\n            // A UAS that receives a second INVITE before it sends the final\n            // response to a first INVITE with a lower CSeq sequence number on the\n            // same dialog MUST return a 500 (Server Internal Error) response to the\n            // second INVITE and MUST include a Retry-After header field with a\n            // randomly chosen value of between 0 and 10 seconds.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            if (this.reinviteUserAgentServer) {\n                this.core.replyStateless(message, { statusCode: 500, extraHeaders });\n                return;\n            }\n            // A UAS that receives an INVITE on a dialog while an INVITE it had sent\n            // on that dialog is in progress MUST return a 491 (Request Pending)\n            // response to the received INVITE.\n            // https://tools.ietf.org/html/rfc3261#section-14.2\n            if (this.reinviteUserAgentClient) {\n                this.core.replyStateless(message, { statusCode: 491 });\n                return;\n            }\n        }\n        // Requests within a dialog MAY contain Record-Route and Contact header\n        // fields.  However, these requests do not cause the dialog's route set\n        // to be modified, although they may modify the remote target URI.\n        // Specifically, requests that are not target refresh requests do not\n        // modify the dialog's remote target URI, and requests that are target\n        // refresh requests do.  For dialogs that have been established with an\n        // INVITE, the only target refresh request defined is re-INVITE (see\n        // Section 14).  Other extensions may define different target refresh\n        // requests for dialogs established in other ways.\n        //\n        //    Note that an ACK is NOT a target refresh request.\n        //\n        // Target refresh requests only update the dialog's remote target URI,\n        // and not the route set formed from the Record-Route.  Updating the\n        // latter would introduce severe backwards compatibility problems with\n        // RFC 2543-compliant systems.\n        // https://tools.ietf.org/html/rfc3261#section-15\n        if (message.method === C.INVITE) {\n            // FIXME: parser needs to be typed...\n            const contact = message.parseHeader(\"contact\");\n            if (!contact) {\n                // TODO: Review to make sure this will never happen\n                throw new Error(\"Contact undefined.\");\n            }\n            if (!(contact instanceof NameAddrHeader)) {\n                throw new Error(\"Contact not instance of NameAddrHeader.\");\n            }\n            this.dialogState.remoteTarget = contact.uri;\n        }\n        // Switch on method and then delegate.\n        switch (message.method) {\n            case C.BYE:\n                // A UAS core receiving a BYE request for an existing dialog MUST follow\n                // the procedures of Section 12.2.2 to process the request.  Once done,\n                // the UAS SHOULD terminate the session (and therefore stop sending and\n                // listening for media).  The only case where it can elect not to are\n                // multicast sessions, where participation is possible even if the other\n                // participant in the dialog has terminated its involvement in the\n                // session.  Whether or not it ends its participation on the session,\n                // the UAS core MUST generate a 2xx response to the BYE, and MUST pass\n                // that to the server transaction for transmission.\n                //\n                // The UAS MUST still respond to any pending requests received for that\n                // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n                // be generated to those pending requests.\n                // https://tools.ietf.org/html/rfc3261#section-15.1.2\n                {\n                    const uas = new ByeUserAgentServer(this, message);\n                    this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();\n                    this.dispose();\n                }\n                break;\n            case C.INFO:\n                // If a UA receives an INFO request associated with an Info Package that\n                // the UA has not indicated willingness to receive, the UA MUST send a\n                // 469 (Bad Info Package) response (see Section 11.6), which contains a\n                // Recv-Info header field with Info Packages for which the UA is willing\n                // to receive INFO requests.\n                {\n                    const uas = new InfoUserAgentServer(this, message);\n                    this.delegate && this.delegate.onInfo\n                        ? this.delegate.onInfo(uas)\n                        : uas.reject({\n                            statusCode: 469,\n                            extraHeaders: [\"Recv-Info :\"]\n                        });\n                }\n                break;\n            case C.INVITE:\n                // If the new session description is not acceptable, the UAS can reject\n                // it by returning a 488 (Not Acceptable Here) response for the re-\n                // INVITE.  This response SHOULD include a Warning header field.\n                // https://tools.ietf.org/html/rfc3261#section-14.2\n                {\n                    const uas = new ReInviteUserAgentServer(this, message);\n                    this.signalingStateTransition(message);\n                    this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({ statusCode: 488 }); // TODO: Warning header field.\n                }\n                break;\n            case C.MESSAGE:\n                {\n                    const uas = new MessageUserAgentServer(this.core, message);\n                    this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n                }\n                break;\n            case C.NOTIFY:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.4\n                {\n                    const uas = new NotifyUserAgentServer(this, message);\n                    this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();\n                }\n                break;\n            case C.PRACK:\n                // https://tools.ietf.org/html/rfc3262#section-4\n                {\n                    const uas = new PrackUserAgentServer(this, message);\n                    this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();\n                }\n                break;\n            case C.REFER:\n                // https://tools.ietf.org/html/rfc3515#section-2.4.2\n                {\n                    const uas = new ReferUserAgentServer(this, message);\n                    this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();\n                }\n                break;\n            default:\n                {\n                    this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message.method} request`);\n                    this.core.replyStateless(message, { statusCode: 501 });\n                }\n                break;\n        }\n    }\n    /**\n     * Guard against out of order reliable provisional responses and retransmissions.\n     * Returns false if the response should be discarded, otherwise true.\n     * @param message - Incoming response message within this dialog.\n     */\n    reliableSequenceGuard(message) {\n        const statusCode = message.statusCode;\n        if (!statusCode) {\n            throw new Error(\"Status code undefined\");\n        }\n        if (statusCode > 100 && statusCode < 200) {\n            // If a provisional response is received for an initial request, and\n            // that response contains a Require header field containing the option\n            // tag 100rel, the response is to be sent reliably.  If the response is\n            // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n            // ignored, and the procedures below MUST NOT be used.\n            // https://tools.ietf.org/html/rfc3262#section-4\n            const requireHeader = message.getHeader(\"require\");\n            const rseqHeader = message.getHeader(\"rseq\");\n            const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n            if (rseq) {\n                // Handling of subsequent reliable provisional responses for the same\n                // initial request follows the same rules as above, with the following\n                // difference: reliable provisional responses are guaranteed to be in\n                // order.  As a result, if the UAC receives another reliable provisional\n                // response to the same request, and its RSeq value is not one higher\n                // than the value of the sequence number, that response MUST NOT be\n                // acknowledged with a PRACK, and MUST NOT be processed further by the\n                // UAC.  An implementation MAY discard the response, or MAY cache the\n                // response in the hopes of receiving the missing responses.\n                // https://tools.ietf.org/html/rfc3262#section-4\n                if (this.rseq && this.rseq + 1 !== rseq) {\n                    return false;\n                }\n                // Once a reliable provisional response is received, retransmissions of\n                // that response MUST be discarded.  A response is a retransmission when\n                // its dialog ID, CSeq, and RSeq match the original response.  The UAC\n                // MUST maintain a sequence number that indicates the most recently\n                // received in-order reliable provisional response for the initial\n                // request.  This sequence number MUST be maintained until a final\n                // response is received for the initial request.  Its value MUST be\n                // initialized to the RSeq header field in the first reliable\n                // provisional response received for the initial request.\n                // https://tools.ietf.org/html/rfc3262#section-4\n                this.rseq = this.rseq ? this.rseq + 1 : rseq;\n            }\n        }\n        return true;\n    }\n    /**\n     * If not in a stable signaling state, rollback to prior stable signaling state.\n     */\n    signalingStateRollback() {\n        if (this._signalingState === SignalingState.HaveLocalOffer ||\n            this.signalingState === SignalingState.HaveRemoteOffer) {\n            if (this._rollbackOffer && this._rollbackAnswer) {\n                this._signalingState = SignalingState.Stable;\n                this._offer = this._rollbackOffer;\n                this._answer = this._rollbackAnswer;\n            }\n        }\n    }\n    /**\n     * Update the signaling state of the dialog.\n     * @param message - The message to base the update off of.\n     */\n    signalingStateTransition(message) {\n        const body = getBody(message);\n        // No body, no session. No, woman, no cry.\n        if (!body || body.contentDisposition !== \"session\") {\n            return;\n        }\n        // We've got an existing offer and answer which we may wish to rollback to\n        if (this._signalingState === SignalingState.Stable) {\n            this._rollbackOffer = this._offer;\n            this._rollbackAnswer = this._answer;\n        }\n        // We're in UAS role, receiving incoming request with session description\n        if (message instanceof IncomingRequestMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveRemoteOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAC role, receiving incoming response with session description\n        if (message instanceof IncomingResponseMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveRemoteOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAC role, sending outgoing request with session description\n        if (message instanceof OutgoingRequestMessage) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveLocalOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n        // We're in UAS role, sending outgoing response with session description\n        if (isBody(message)) {\n            switch (this._signalingState) {\n                case SignalingState.Initial:\n                case SignalingState.Stable:\n                    this._signalingState = SignalingState.HaveLocalOffer;\n                    this._offer = body;\n                    this._answer = undefined;\n                    break;\n                case SignalingState.HaveLocalOffer:\n                    // You cannot make a new offer while one is in progress.\n                    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n                    // FIXME: What to do here?\n                    break;\n                case SignalingState.HaveRemoteOffer:\n                    this._signalingState = SignalingState.Stable;\n                    this._answer = body;\n                    break;\n                case SignalingState.Closed:\n                    break;\n                default:\n                    throw new Error(\"Unexpected signaling state.\");\n            }\n        }\n    }\n    start2xxRetransmissionTimer() {\n        if (this.initialTransaction instanceof InviteServerTransaction) {\n            const transaction = this.initialTransaction;\n            // Once the response has been constructed, it is passed to the INVITE\n            // server transaction.  In order to ensure reliable end-to-end\n            // transport of the response, it is necessary to periodically pass\n            // the response directly to the transport until the ACK arrives.  The\n            // 2xx response is passed to the transport with an interval that\n            // starts at T1 seconds and doubles for each retransmission until it\n            // reaches T2 seconds (T1 and T2 are defined in Section 17).\n            // Response retransmissions cease when an ACK request for the\n            // response is received.  This is independent of whatever transport\n            // protocols are used to send the response.\n            // https://tools.ietf.org/html/rfc6026#section-8.1\n            let timeout = Timers.T1;\n            const retransmission = () => {\n                if (!this.ackWait) {\n                    this.invite2xxTimer = undefined;\n                    return;\n                }\n                this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n                transaction.retransmitAcceptedResponse();\n                timeout = Math.min(timeout * 2, Timers.T2);\n                this.invite2xxTimer = setTimeout(retransmission, timeout);\n            };\n            this.invite2xxTimer = setTimeout(retransmission, timeout);\n            // If the server retransmits the 2xx response for 64*T1 seconds without\n            // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n            // terminated.  This is accomplished with a BYE, as described in Section 15.\n            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n            const stateChanged = () => {\n                if (transaction.state === TransactionState.Terminated) {\n                    transaction.removeStateChangeListener(stateChanged);\n                    if (this.invite2xxTimer) {\n                        clearTimeout(this.invite2xxTimer);\n                        this.invite2xxTimer = undefined;\n                    }\n                    if (this.ackWait) {\n                        if (this.delegate && this.delegate.onAckTimeout) {\n                            this.delegate.onAckTimeout();\n                        }\n                        else {\n                            this.bye();\n                        }\n                    }\n                }\n            };\n            transaction.addStateChangeListener(stateChanged);\n        }\n    }\n    // FIXME: Refactor\n    startReInvite2xxRetransmissionTimer() {\n        if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction) {\n            const transaction = this.reinviteUserAgentServer.transaction;\n            // Once the response has been constructed, it is passed to the INVITE\n            // server transaction.  In order to ensure reliable end-to-end\n            // transport of the response, it is necessary to periodically pass\n            // the response directly to the transport until the ACK arrives.  The\n            // 2xx response is passed to the transport with an interval that\n            // starts at T1 seconds and doubles for each retransmission until it\n            // reaches T2 seconds (T1 and T2 are defined in Section 17).\n            // Response retransmissions cease when an ACK request for the\n            // response is received.  This is independent of whatever transport\n            // protocols are used to send the response.\n            // https://tools.ietf.org/html/rfc6026#section-8.1\n            let timeout = Timers.T1;\n            const retransmission = () => {\n                if (!this.reinviteUserAgentServer) {\n                    this.invite2xxTimer = undefined;\n                    return;\n                }\n                this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n                transaction.retransmitAcceptedResponse();\n                timeout = Math.min(timeout * 2, Timers.T2);\n                this.invite2xxTimer = setTimeout(retransmission, timeout);\n            };\n            this.invite2xxTimer = setTimeout(retransmission, timeout);\n            // If the server retransmits the 2xx response for 64*T1 seconds without\n            // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n            // terminated.  This is accomplished with a BYE, as described in Section 15.\n            // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n            const stateChanged = () => {\n                if (transaction.state === TransactionState.Terminated) {\n                    transaction.removeStateChangeListener(stateChanged);\n                    if (this.invite2xxTimer) {\n                        clearTimeout(this.invite2xxTimer);\n                        this.invite2xxTimer = undefined;\n                    }\n                    if (this.reinviteUserAgentServer) {\n                        // FIXME: TODO: What to do here\n                    }\n                }\n            };\n            transaction.addStateChangeListener(stateChanged);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}