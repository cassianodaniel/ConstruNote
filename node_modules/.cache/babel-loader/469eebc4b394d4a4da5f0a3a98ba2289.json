{"ast":null,"code":"import { hasFormatToParts, hasIntl, padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport Formatter from \"./formatter.js\";\nlet intlDTCache = {};\n\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n\n  return dtf;\n}\n\nlet intlNumCache = {};\n\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n\n  return inf;\n}\n\nlet intlRelCache = {};\n\nfunction getCachedRTF(locString, opts = {}) {\n  const {\n    base,\n    ...cacheKeyOpts\n  } = opts; // exclude `base` from the options\n\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n\n  return inf;\n}\n\nlet sysLocaleCache = null;\n\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else if (hasIntl()) {\n    const computedSys = new Intl.DateTimeFormat().resolvedOptions().locale; // node sometimes defaults to \"und\". Override that because that is dumb\n\n    sysLocaleCache = !computedSys || computedSys === \"und\" ? \"en-US\" : computedSys;\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = \"en-US\";\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n  const uIndex = localeStr.indexOf(\"-u-\");\n\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    const smaller = localeStr.substring(0, uIndex);\n\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n    } catch (e) {\n      options = getCachedDTF(smaller).resolvedOptions();\n    }\n\n    const {\n      numberingSystem,\n      calendar\n    } = options; // return the smaller one so that we can append the calendar and numbering overrides to it\n\n    return [smaller, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (hasIntl()) {\n    if (outputCalendar || numberingSystem) {\n      localeStr += \"-u\";\n\n      if (outputCalendar) {\n        localeStr += `-ca-${outputCalendar}`;\n      }\n\n      if (numberingSystem) {\n        localeStr += `-nu-${numberingSystem}`;\n      }\n\n      return localeStr;\n    } else {\n      return localeStr;\n    }\n  } else {\n    return [];\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return loc.numberingSystem === \"latn\" || !loc.locale || loc.locale.startsWith(\"en\") || hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\";\n  }\n}\n/**\n * @private\n */\n\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    if (!forceSimple && hasIntl()) {\n      const intlOpts = {\n        useGrouping: false\n      };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n\n}\n/**\n * @private\n */\n\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.hasIntl = hasIntl();\n    let z;\n\n    if (dt.zone.universal && this.hasIntl) {\n      // Chromium doesn't support fixed-offset zones like Etc/GMT+8 in its formatter,\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=364374.\n      // So we have to make do. Two cases:\n      // 1. The format options tell us to show the zone. We can't do that, so the best\n      // we can do is format the date in UTC.\n      // 2. The format options don't tell us to show the zone. Then we can adjust them\n      // the time and tell the formatter to show it to us in UTC, so that the time is right\n      // and the bad zone doesn't show up.\n      // We can clean all this up when Chrome fixes this.\n      z = \"UTC\";\n\n      if (opts.timeZoneName) {\n        this.dt = dt;\n      } else {\n        this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n      }\n    } else if (dt.zone.type === \"local\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n\n    if (this.hasIntl) {\n      const intlOpts = Object.assign({}, this.opts);\n\n      if (z) {\n        intlOpts.timeZone = z;\n      }\n\n      this.dtf = getCachedDTF(intl, intlOpts);\n    }\n  }\n\n  format() {\n    if (this.hasIntl) {\n      return this.dtf.format(this.dt.toJSDate());\n    } else {\n      const tokenFormat = English.formatString(this.opts),\n            loc = Locale.create(\"en-US\");\n      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);\n    }\n  }\n\n  formatToParts() {\n    if (this.hasIntl && hasFormatToParts()) {\n      return this.dtf.formatToParts(this.dt.toJSDate());\n    } else {\n      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings\n      // and IMO it's too weird to have an uncanny valley like that\n      return [];\n    }\n  }\n\n  resolvedOptions() {\n    if (this.hasIntl) {\n      return this.dtf.resolvedOptions();\n    } else {\n      return {\n        locale: \"en-US\",\n        numberingSystem: \"latn\",\n        outputCalendar: \"gregory\"\n      };\n    }\n  }\n\n}\n/**\n * @private\n */\n\n\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = Object.assign({\n      style: \"long\"\n    }, opts);\n\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n\n}\n/**\n * @private\n */\n\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale,\n          // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n    localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale()),\n          numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,\n          outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject({\n    locale,\n    numberingSystem,\n    outputCalendar\n  } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n    this.weekdaysCache = {\n      format: {},\n      standalone: {}\n    };\n    this.monthsCache = {\n      format: {},\n      standalone: {}\n    };\n    this.meridiemCache = null;\n    this.eraCache = {};\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode(defaultOK = true) {\n    const intl = hasIntl(),\n          hasFTP = intl && hasFormatToParts(),\n          isActuallyEn = this.isEnglish(),\n          hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === \"latn\") && (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n\n    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {\n      return \"error\";\n    } else if (!hasFTP || isActuallyEn && hasNoWeirdness) {\n      return \"en\";\n    } else {\n      return \"intl\";\n    }\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone(Object.assign({}, alts, {\n      defaultToEN: true\n    }));\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone(Object.assign({}, alts, {\n      defaultToEN: false\n    }));\n  }\n\n  months(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? {\n        month: length,\n        day: \"numeric\"\n      } : {\n        month: length\n      },\n            formatStr = format ? \"format\" : \"standalone\";\n\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, \"month\"));\n      }\n\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format ? {\n        weekday: length,\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n      } : {\n        weekday: length\n      },\n            formatStr = format ? \"format\" : \"standalone\";\n\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays(dt => this.extract(dt, intl, \"weekday\"));\n      }\n\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems(defaultOK = true) {\n    return listStuff(this, undefined, defaultOK, () => English.meridiems, () => {\n      // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n      // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n      if (!this.meridiemCache) {\n        const intl = {\n          hour: \"numeric\",\n          hour12: true\n        };\n        this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(dt => this.extract(dt, intl, \"dayperiod\"));\n      }\n\n      return this.meridiemCache;\n    });\n  }\n\n  eras(length, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = {\n        era: length\n      }; // This is utter bullshit. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt => this.extract(dt, intl, \"era\"));\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n          results = df.formatToParts(),\n          matching = results.find(m => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  isEnglish() {\n    return this.locale === \"en\" || this.locale.toLowerCase() === \"en-us\" || hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\");\n  }\n\n  equals(other) {\n    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/luxon/src/impl/locale.js"],"names":["hasFormatToParts","hasIntl","padStart","roundTo","hasRelative","English","Settings","DateTime","Formatter","intlDTCache","getCachedDTF","locString","opts","key","JSON","stringify","dtf","Intl","DateTimeFormat","intlNumCache","getCachedINF","inf","NumberFormat","intlRelCache","getCachedRTF","base","cacheKeyOpts","RelativeTimeFormat","sysLocaleCache","systemLocale","computedSys","resolvedOptions","locale","parseLocaleString","localeStr","uIndex","indexOf","options","smaller","substring","e","numberingSystem","calendar","intlConfigString","outputCalendar","mapMonths","f","ms","i","dt","utc","push","mapWeekdays","listStuff","loc","length","defaultOK","englishFn","intlFn","mode","listingMode","supportsFastNumbers","startsWith","intl","PolyNumberFormatter","constructor","forceSimple","padTo","floor","intlOpts","useGrouping","minimumIntegerDigits","format","fixed","Math","PolyDateFormatter","z","zone","universal","timeZoneName","offset","fromMillis","ts","type","name","Object","assign","timeZone","toJSDate","tokenFormat","formatString","Locale","create","formatDateTimeFromString","formatToParts","PolyRelFormatter","isEnglish","style","rtf","count","unit","formatRelativeTime","numeric","fromOpts","defaultToEN","specifiedLocale","defaultLocale","localeR","numberingSystemR","defaultNumberingSystem","outputCalendarR","defaultOutputCalendar","resetCache","fromObject","numbering","parsedLocale","parsedNumberingSystem","parsedOutputCalendar","weekdaysCache","standalone","monthsCache","meridiemCache","eraCache","fastNumbersCached","fastNumbers","hasFTP","isActuallyEn","hasNoWeirdness","clone","alts","getOwnPropertyNames","redefaultToEN","redefaultToSystem","months","month","day","formatStr","extract","weekdays","weekday","year","meridiems","undefined","hour","hour12","map","eras","era","field","df","dtFormatter","results","matching","find","m","toLowerCase","value","numberFormatter","relFormatter","equals","other"],"mappings":"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","sourcesContent":["import { hasFormatToParts, hasIntl, padStart, roundTo, hasRelative } from \"./util.js\";\nimport * as English from \"./english.js\";\nimport Settings from \"../settings.js\";\nimport DateTime from \"../datetime.js\";\nimport Formatter from \"./formatter.js\";\n\nlet intlDTCache = {};\nfunction getCachedDTF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let dtf = intlDTCache[key];\n  if (!dtf) {\n    dtf = new Intl.DateTimeFormat(locString, opts);\n    intlDTCache[key] = dtf;\n  }\n  return dtf;\n}\n\nlet intlNumCache = {};\nfunction getCachedINF(locString, opts = {}) {\n  const key = JSON.stringify([locString, opts]);\n  let inf = intlNumCache[key];\n  if (!inf) {\n    inf = new Intl.NumberFormat(locString, opts);\n    intlNumCache[key] = inf;\n  }\n  return inf;\n}\n\nlet intlRelCache = {};\nfunction getCachedRTF(locString, opts = {}) {\n  const { base, ...cacheKeyOpts } = opts; // exclude `base` from the options\n  const key = JSON.stringify([locString, cacheKeyOpts]);\n  let inf = intlRelCache[key];\n  if (!inf) {\n    inf = new Intl.RelativeTimeFormat(locString, opts);\n    intlRelCache[key] = inf;\n  }\n  return inf;\n}\n\nlet sysLocaleCache = null;\nfunction systemLocale() {\n  if (sysLocaleCache) {\n    return sysLocaleCache;\n  } else if (hasIntl()) {\n    const computedSys = new Intl.DateTimeFormat().resolvedOptions().locale;\n    // node sometimes defaults to \"und\". Override that because that is dumb\n    sysLocaleCache = !computedSys || computedSys === \"und\" ? \"en-US\" : computedSys;\n    return sysLocaleCache;\n  } else {\n    sysLocaleCache = \"en-US\";\n    return sysLocaleCache;\n  }\n}\n\nfunction parseLocaleString(localeStr) {\n  // I really want to avoid writing a BCP 47 parser\n  // see, e.g. https://github.com/wooorm/bcp-47\n  // Instead, we'll do this:\n\n  // a) if the string has no -u extensions, just leave it alone\n  // b) if it does, use Intl to resolve everything\n  // c) if Intl fails, try again without the -u\n\n  const uIndex = localeStr.indexOf(\"-u-\");\n  if (uIndex === -1) {\n    return [localeStr];\n  } else {\n    let options;\n    const smaller = localeStr.substring(0, uIndex);\n    try {\n      options = getCachedDTF(localeStr).resolvedOptions();\n    } catch (e) {\n      options = getCachedDTF(smaller).resolvedOptions();\n    }\n\n    const { numberingSystem, calendar } = options;\n    // return the smaller one so that we can append the calendar and numbering overrides to it\n    return [smaller, numberingSystem, calendar];\n  }\n}\n\nfunction intlConfigString(localeStr, numberingSystem, outputCalendar) {\n  if (hasIntl()) {\n    if (outputCalendar || numberingSystem) {\n      localeStr += \"-u\";\n\n      if (outputCalendar) {\n        localeStr += `-ca-${outputCalendar}`;\n      }\n\n      if (numberingSystem) {\n        localeStr += `-nu-${numberingSystem}`;\n      }\n      return localeStr;\n    } else {\n      return localeStr;\n    }\n  } else {\n    return [];\n  }\n}\n\nfunction mapMonths(f) {\n  const ms = [];\n  for (let i = 1; i <= 12; i++) {\n    const dt = DateTime.utc(2016, i, 1);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction mapWeekdays(f) {\n  const ms = [];\n  for (let i = 1; i <= 7; i++) {\n    const dt = DateTime.utc(2016, 11, 13 + i);\n    ms.push(f(dt));\n  }\n  return ms;\n}\n\nfunction listStuff(loc, length, defaultOK, englishFn, intlFn) {\n  const mode = loc.listingMode(defaultOK);\n\n  if (mode === \"error\") {\n    return null;\n  } else if (mode === \"en\") {\n    return englishFn(length);\n  } else {\n    return intlFn(length);\n  }\n}\n\nfunction supportsFastNumbers(loc) {\n  if (loc.numberingSystem && loc.numberingSystem !== \"latn\") {\n    return false;\n  } else {\n    return (\n      loc.numberingSystem === \"latn\" ||\n      !loc.locale ||\n      loc.locale.startsWith(\"en\") ||\n      (hasIntl() && new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === \"latn\")\n    );\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyNumberFormatter {\n  constructor(intl, forceSimple, opts) {\n    this.padTo = opts.padTo || 0;\n    this.floor = opts.floor || false;\n\n    if (!forceSimple && hasIntl()) {\n      const intlOpts = { useGrouping: false };\n      if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;\n      this.inf = getCachedINF(intl, intlOpts);\n    }\n  }\n\n  format(i) {\n    if (this.inf) {\n      const fixed = this.floor ? Math.floor(i) : i;\n      return this.inf.format(fixed);\n    } else {\n      // to match the browser's numberformatter defaults\n      const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);\n      return padStart(fixed, this.padTo);\n    }\n  }\n}\n\n/**\n * @private\n */\n\nclass PolyDateFormatter {\n  constructor(dt, intl, opts) {\n    this.opts = opts;\n    this.hasIntl = hasIntl();\n\n    let z;\n    if (dt.zone.universal && this.hasIntl) {\n      // Chromium doesn't support fixed-offset zones like Etc/GMT+8 in its formatter,\n      // See https://bugs.chromium.org/p/chromium/issues/detail?id=364374.\n      // So we have to make do. Two cases:\n      // 1. The format options tell us to show the zone. We can't do that, so the best\n      // we can do is format the date in UTC.\n      // 2. The format options don't tell us to show the zone. Then we can adjust them\n      // the time and tell the formatter to show it to us in UTC, so that the time is right\n      // and the bad zone doesn't show up.\n      // We can clean all this up when Chrome fixes this.\n      z = \"UTC\";\n      if (opts.timeZoneName) {\n        this.dt = dt;\n      } else {\n        this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);\n      }\n    } else if (dt.zone.type === \"local\") {\n      this.dt = dt;\n    } else {\n      this.dt = dt;\n      z = dt.zone.name;\n    }\n\n    if (this.hasIntl) {\n      const intlOpts = Object.assign({}, this.opts);\n      if (z) {\n        intlOpts.timeZone = z;\n      }\n      this.dtf = getCachedDTF(intl, intlOpts);\n    }\n  }\n\n  format() {\n    if (this.hasIntl) {\n      return this.dtf.format(this.dt.toJSDate());\n    } else {\n      const tokenFormat = English.formatString(this.opts),\n        loc = Locale.create(\"en-US\");\n      return Formatter.create(loc).formatDateTimeFromString(this.dt, tokenFormat);\n    }\n  }\n\n  formatToParts() {\n    if (this.hasIntl && hasFormatToParts()) {\n      return this.dtf.formatToParts(this.dt.toJSDate());\n    } else {\n      // This is kind of a cop out. We actually could do this for English. However, we couldn't do it for intl strings\n      // and IMO it's too weird to have an uncanny valley like that\n      return [];\n    }\n  }\n\n  resolvedOptions() {\n    if (this.hasIntl) {\n      return this.dtf.resolvedOptions();\n    } else {\n      return {\n        locale: \"en-US\",\n        numberingSystem: \"latn\",\n        outputCalendar: \"gregory\"\n      };\n    }\n  }\n}\n\n/**\n * @private\n */\nclass PolyRelFormatter {\n  constructor(intl, isEnglish, opts) {\n    this.opts = Object.assign({ style: \"long\" }, opts);\n    if (!isEnglish && hasRelative()) {\n      this.rtf = getCachedRTF(intl, opts);\n    }\n  }\n\n  format(count, unit) {\n    if (this.rtf) {\n      return this.rtf.format(count, unit);\n    } else {\n      return English.formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== \"long\");\n    }\n  }\n\n  formatToParts(count, unit) {\n    if (this.rtf) {\n      return this.rtf.formatToParts(count, unit);\n    } else {\n      return [];\n    }\n  }\n}\n\n/**\n * @private\n */\n\nexport default class Locale {\n  static fromOpts(opts) {\n    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);\n  }\n\n  static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {\n    const specifiedLocale = locale || Settings.defaultLocale,\n      // the system locale is useful for human readable strings but annoying for parsing/formatting known formats\n      localeR = specifiedLocale || (defaultToEN ? \"en-US\" : systemLocale()),\n      numberingSystemR = numberingSystem || Settings.defaultNumberingSystem,\n      outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;\n    return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);\n  }\n\n  static resetCache() {\n    sysLocaleCache = null;\n    intlDTCache = {};\n    intlNumCache = {};\n    intlRelCache = {};\n  }\n\n  static fromObject({ locale, numberingSystem, outputCalendar } = {}) {\n    return Locale.create(locale, numberingSystem, outputCalendar);\n  }\n\n  constructor(locale, numbering, outputCalendar, specifiedLocale) {\n    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);\n\n    this.locale = parsedLocale;\n    this.numberingSystem = numbering || parsedNumberingSystem || null;\n    this.outputCalendar = outputCalendar || parsedOutputCalendar || null;\n    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);\n\n    this.weekdaysCache = { format: {}, standalone: {} };\n    this.monthsCache = { format: {}, standalone: {} };\n    this.meridiemCache = null;\n    this.eraCache = {};\n\n    this.specifiedLocale = specifiedLocale;\n    this.fastNumbersCached = null;\n  }\n\n  get fastNumbers() {\n    if (this.fastNumbersCached == null) {\n      this.fastNumbersCached = supportsFastNumbers(this);\n    }\n\n    return this.fastNumbersCached;\n  }\n\n  listingMode(defaultOK = true) {\n    const intl = hasIntl(),\n      hasFTP = intl && hasFormatToParts(),\n      isActuallyEn = this.isEnglish(),\n      hasNoWeirdness =\n        (this.numberingSystem === null || this.numberingSystem === \"latn\") &&\n        (this.outputCalendar === null || this.outputCalendar === \"gregory\");\n\n    if (!hasFTP && !(isActuallyEn && hasNoWeirdness) && !defaultOK) {\n      return \"error\";\n    } else if (!hasFTP || (isActuallyEn && hasNoWeirdness)) {\n      return \"en\";\n    } else {\n      return \"intl\";\n    }\n  }\n\n  clone(alts) {\n    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {\n      return this;\n    } else {\n      return Locale.create(\n        alts.locale || this.specifiedLocale,\n        alts.numberingSystem || this.numberingSystem,\n        alts.outputCalendar || this.outputCalendar,\n        alts.defaultToEN || false\n      );\n    }\n  }\n\n  redefaultToEN(alts = {}) {\n    return this.clone(Object.assign({}, alts, { defaultToEN: true }));\n  }\n\n  redefaultToSystem(alts = {}) {\n    return this.clone(Object.assign({}, alts, { defaultToEN: false }));\n  }\n\n  months(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.months, () => {\n      const intl = format ? { month: length, day: \"numeric\" } : { month: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.monthsCache[formatStr][length]) {\n        this.monthsCache[formatStr][length] = mapMonths(dt => this.extract(dt, intl, \"month\"));\n      }\n      return this.monthsCache[formatStr][length];\n    });\n  }\n\n  weekdays(length, format = false, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.weekdays, () => {\n      const intl = format\n          ? { weekday: length, year: \"numeric\", month: \"long\", day: \"numeric\" }\n          : { weekday: length },\n        formatStr = format ? \"format\" : \"standalone\";\n      if (!this.weekdaysCache[formatStr][length]) {\n        this.weekdaysCache[formatStr][length] = mapWeekdays(dt =>\n          this.extract(dt, intl, \"weekday\")\n        );\n      }\n      return this.weekdaysCache[formatStr][length];\n    });\n  }\n\n  meridiems(defaultOK = true) {\n    return listStuff(\n      this,\n      undefined,\n      defaultOK,\n      () => English.meridiems,\n      () => {\n        // In theory there could be aribitrary day periods. We're gonna assume there are exactly two\n        // for AM and PM. This is probably wrong, but it's makes parsing way easier.\n        if (!this.meridiemCache) {\n          const intl = { hour: \"numeric\", hour12: true };\n          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(\n            dt => this.extract(dt, intl, \"dayperiod\")\n          );\n        }\n\n        return this.meridiemCache;\n      }\n    );\n  }\n\n  eras(length, defaultOK = true) {\n    return listStuff(this, length, defaultOK, English.eras, () => {\n      const intl = { era: length };\n\n      // This is utter bullshit. Different calendars are going to define eras totally differently. What I need is the minimum set of dates\n      // to definitely enumerate them.\n      if (!this.eraCache[length]) {\n        this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(dt =>\n          this.extract(dt, intl, \"era\")\n        );\n      }\n\n      return this.eraCache[length];\n    });\n  }\n\n  extract(dt, intlOpts, field) {\n    const df = this.dtFormatter(dt, intlOpts),\n      results = df.formatToParts(),\n      matching = results.find(m => m.type.toLowerCase() === field);\n    return matching ? matching.value : null;\n  }\n\n  numberFormatter(opts = {}) {\n    // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)\n    // (in contrast, the rest of the condition is used heavily)\n    return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);\n  }\n\n  dtFormatter(dt, intlOpts = {}) {\n    return new PolyDateFormatter(dt, this.intl, intlOpts);\n  }\n\n  relFormatter(opts = {}) {\n    return new PolyRelFormatter(this.intl, this.isEnglish(), opts);\n  }\n\n  isEnglish() {\n    return (\n      this.locale === \"en\" ||\n      this.locale.toLowerCase() === \"en-us\" ||\n      (hasIntl() && new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith(\"en-us\"))\n    );\n  }\n\n  equals(other) {\n    return (\n      this.locale === other.locale &&\n      this.numberingSystem === other.numberingSystem &&\n      this.outputCalendar === other.outputCalendar\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}