{"ast":null,"code":"import { EmitterImpl } from \"../../../api/emitter\";\nimport { StateTransitionError } from \"../../../api/exceptions\";\nimport { TransportState } from \"../../../api/transport-state\";\nimport { Grammar } from \"../../../core\";\n/**\n * Transport for SIP over secure WebSocket (WSS).\n * @public\n */\n\nexport class Transport {\n  constructor(logger, options) {\n    this._state = TransportState.Disconnected;\n    this.transitioningState = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // logger\n\n    this.logger = logger; // guard deprecated options (remove this in version 16.x)\n\n    if (options) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const optionsDeprecated = options;\n      const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;\n      const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;\n\n      if (wsServersDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"wsServers\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      } // hack\n\n\n      if (wsServersDeprecated && !options.server) {\n        if (typeof wsServersDeprecated === \"string\") {\n          options.server = wsServersDeprecated;\n        }\n\n        if (wsServersDeprecated instanceof Array) {\n          options.server = wsServersDeprecated[0];\n        }\n      }\n    } // initialize configuration\n\n\n    this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options); // validate server URL\n\n    const url = this.configuration.server;\n    const parsed = Grammar.parse(url, \"absoluteURI\");\n\n    if (parsed === -1) {\n      this.logger.error(`Invalid WebSocket Server URL \"${url}\"`);\n      throw new Error(\"Invalid WebSocket Server URL\");\n    }\n\n    if (![\"wss\", \"ws\", \"udp\"].includes(parsed.scheme)) {\n      this.logger.error(`Invalid scheme in WebSocket Server URL \"${url}\"`);\n      throw new Error(\"Invalid scheme in WebSocket Server URL\");\n    }\n\n    this._protocol = parsed.scheme.toUpperCase();\n  }\n\n  dispose() {\n    return this.disconnect();\n  }\n  /**\n   * The protocol.\n   *\n   * @remarks\n   * Formatted as defined for the Via header sent-protocol transport.\n   * https://tools.ietf.org/html/rfc3261#section-20.42\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * The URL of the WebSocket Server.\n   */\n\n\n  get server() {\n    return this.configuration.server;\n  }\n  /**\n   * Transport state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * Transport state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * The WebSocket.\n   */\n\n\n  get ws() {\n    return this._ws;\n  }\n  /**\n   * Connect to network.\n   * Resolves once connected. Otherwise rejects with an Error.\n   */\n\n\n  connect() {\n    return this._connect();\n  }\n  /**\n   * Disconnect from network.\n   * Resolves once disconnected. Otherwise rejects with an Error.\n   */\n\n\n  disconnect() {\n    return this._disconnect();\n  }\n  /**\n   * Returns true if the `state` equals \"Connected\".\n   * @remarks\n   * This is equivalent to `state === TransportState.Connected`.\n   */\n\n\n  isConnected() {\n    return this.state === TransportState.Connected;\n  }\n  /**\n   * Sends a message.\n   * Resolves once message is sent. Otherwise rejects with an Error.\n   * @param message - Message to send.\n   */\n\n\n  send(message) {\n    // Error handling is independent of whether the message was a request or\n    // response.\n    //\n    // If the transport user asks for a message to be sent over an\n    // unreliable transport, and the result is an ICMP error, the behavior\n    // depends on the type of ICMP error.  Host, network, port or protocol\n    // unreachable errors, or parameter problem errors SHOULD cause the\n    // transport layer to inform the transport user of a failure in sending.\n    // Source quench and TTL exceeded ICMP errors SHOULD be ignored.\n    //\n    // If the transport user asks for a request to be sent over a reliable\n    // transport, and the result is a connection failure, the transport\n    // layer SHOULD inform the transport user of a failure in sending.\n    // https://tools.ietf.org/html/rfc3261#section-18.4\n    return this._send(message);\n  }\n\n  _connect() {\n    this.logger.log(`Connecting ${this.server}`);\n\n    switch (this.state) {\n      case TransportState.Connecting:\n        // If `state` is \"Connecting\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n        }\n\n        if (!this.connectPromise) {\n          throw new Error(\"Connect promise must be defined.\");\n        }\n\n        return this.connectPromise;\n      // Already connecting\n\n      case TransportState.Connected:\n        // If `state` is \"Connected\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n        }\n\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        return Promise.resolve();\n      // Already connected\n\n      case TransportState.Disconnecting:\n        // If `state` is \"Disconnecting\", `state` MUST transition to \"Connecting\" before returning\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Connecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Disconnected:\n        // If `state` is \"Disconnected\" `state` MUST transition to \"Connecting\" before returning\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Connecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    let ws;\n\n    try {\n      // WebSocket()\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket\n      ws = new WebSocket(this.server, \"sip\");\n      ws.binaryType = \"arraybuffer\"; // set data type of received binary messages\n\n      ws.addEventListener(\"close\", ev => this.onWebSocketClose(ev, ws));\n      ws.addEventListener(\"error\", ev => this.onWebSocketError(ev, ws));\n      ws.addEventListener(\"open\", ev => this.onWebSocketOpen(ev, ws));\n      ws.addEventListener(\"message\", ev => this.onWebSocketMessage(ev, ws));\n      this._ws = ws;\n    } catch (error) {\n      this._ws = undefined;\n      this.logger.error(\"WebSocket construction failed.\");\n      this.logger.error(error);\n      return new Promise((resolve, reject) => {\n        this.connectResolve = resolve;\n        this.connectReject = reject; // The `state` MUST transition to \"Disconnecting\" or \"Disconnected\" before rejecting\n\n        this.transitionState(TransportState.Disconnected, error);\n      });\n    }\n\n    this.connectPromise = new Promise((resolve, reject) => {\n      this.connectResolve = resolve;\n      this.connectReject = reject;\n      this.connectTimeout = setTimeout(() => {\n        this.logger.warn(\"Connect timed out. \" + \"Exceeded time set in configuration.connectionTimeout: \" + this.configuration.connectionTimeout + \"s.\");\n        ws.close(1000); // careful here to use a local reference instead of this._ws\n      }, this.configuration.connectionTimeout * 1000);\n    });\n    return this.connectPromise;\n  }\n\n  _disconnect() {\n    this.logger.log(`Disconnecting ${this.server}`);\n\n    switch (this.state) {\n      case TransportState.Connecting:\n        // If `state` is \"Connecting\", `state` MUST transition to \"Disconnecting\" before returning.\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Disconnecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Connected:\n        // If `state` is \"Connected\", `state` MUST transition to \"Disconnecting\" before returning.\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Disconnecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Disconnecting:\n        // If `state` is \"Disconnecting\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n        }\n\n        if (!this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must be defined.\");\n        }\n\n        return this.disconnectPromise;\n      // Already disconnecting\n\n      case TransportState.Disconnected:\n        // If `state` is \"Disconnected\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n        }\n\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        return Promise.resolve();\n      // Already disconnected\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    if (!this._ws) {\n      throw new Error(\"WebSocket must be defined.\");\n    }\n\n    const ws = this._ws;\n    this.disconnectPromise = new Promise((resolve, reject) => {\n      this.disconnectResolve = resolve;\n      this.disconnectReject = reject;\n\n      try {\n        // WebSocket.close()\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n        ws.close(1000); // careful here to use a local reference instead of this._ws\n      } catch (error) {\n        // Treating this as a coding error as it apparently can only happen\n        // if you pass close() invalid parameters (so it should never happen)\n        this.logger.error(\"WebSocket close failed.\");\n        this.logger.error(error);\n        throw error;\n      }\n    });\n    return this.disconnectPromise;\n  }\n\n  _send(message) {\n    if (this.configuration.traceSip === true) {\n      this.logger.log(\"Sending WebSocket message:\\n\\n\" + message + \"\\n\");\n    }\n\n    if (this._state !== TransportState.Connected) {\n      return Promise.reject(new Error(\"Not connected.\"));\n    }\n\n    if (!this._ws) {\n      throw new Error(\"WebSocket undefined.\");\n    }\n\n    try {\n      // WebSocket.send()\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n      this._ws.send(message);\n    } catch (error) {\n      if (error instanceof Error) {\n        return Promise.reject(error);\n      }\n\n      return Promise.reject(new Error(\"WebSocket send failed.\"));\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * WebSocket \"onclose\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketClose(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    const message = `WebSocket closed ${this.server} (code: ${ev.code})`;\n    const error = !this.disconnectPromise ? new Error(message) : undefined;\n\n    if (error) {\n      this.logger.warn(\"WebSocket closed unexpectedly\");\n    }\n\n    this.logger.log(message); // We are about to transition to disconnected, so clear our web socket\n\n    this._ws = undefined; // The `state` MUST transition to \"Disconnected\" before resolving (assuming `state` is not already \"Disconnected\").\n\n    this.transitionState(TransportState.Disconnected, error);\n  }\n  /**\n   * WebSocket \"onerror\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketError(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    this.logger.error(\"WebSocket error occurred.\");\n  }\n  /**\n   * WebSocket \"onmessage\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketMessage(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    const data = ev.data;\n    let finishedData; // CRLF Keep Alive response from server. Clear our keep alive timeout.\n\n    if (/^(\\r\\n)+$/.test(data)) {\n      this.clearKeepAliveTimeout();\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket message with CRLF Keep Alive response\");\n      }\n\n      return;\n    }\n\n    if (!data) {\n      this.logger.warn(\"Received empty message, discarding...\");\n      return;\n    }\n\n    if (typeof data !== \"string\") {\n      // WebSocket binary message.\n      try {\n        finishedData = new TextDecoder().decode(new Uint8Array(data)); // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.\n        // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.\n        // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.\n        // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));\n      } catch (err) {\n        this.logger.error(err);\n        this.logger.error(\"Received WebSocket binary message failed to be converted into string, message discarded\");\n        return;\n      }\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket binary message:\\n\\n\" + finishedData + \"\\n\");\n      }\n    } else {\n      // WebSocket text message.\n      finishedData = data;\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket text message:\\n\\n\" + finishedData + \"\\n\");\n      }\n    }\n\n    if (this.state !== TransportState.Connected) {\n      this.logger.warn(\"Received message while not connected, discarding...\");\n      return;\n    }\n\n    if (this.onMessage) {\n      try {\n        this.onMessage(finishedData);\n      } catch (e) {\n        this.logger.error(e);\n        this.logger.error(\"Exception thrown by onMessage callback\");\n        throw e; // rethrow unhandled exception\n      }\n    }\n  }\n  /**\n   * WebSocket \"onopen\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketOpen(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    if (this._state === TransportState.Connecting) {\n      this.logger.log(`WebSocket opened ${this.server}`);\n      this.transitionState(TransportState.Connected);\n    }\n  }\n  /**\n   * Helper function to generate an Error.\n   * @param state - State transitioning to.\n   */\n\n\n  transitionLoopDetectedError(state) {\n    let message = `A state transition loop has been detected.`;\n    message += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;\n    message += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;\n    this.logger.error(message);\n    return new StateTransitionError(\"Loop detected.\");\n  }\n  /**\n   * Transition transport state.\n   * @internal\n   */\n\n\n  transitionState(newState, error) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    };\n\n    if (this.transitioningState) {\n      throw this.transitionLoopDetectedError(newState);\n    }\n\n    this.transitioningState = true; // Validate state transition\n\n    switch (this._state) {\n      case TransportState.Connecting:\n        if (newState !== TransportState.Connected && newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Connected:\n        if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Disconnecting:\n        if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Disconnected:\n        if (newState !== TransportState.Connecting) {\n          invalidTransition();\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    } // Update state\n\n\n    const oldState = this._state;\n    this._state = newState; // Local copies of connect promises (guarding against callbacks changing them indirectly)\n    // const connectPromise = this.connectPromise;\n\n    const connectResolve = this.connectResolve;\n    const connectReject = this.connectReject; // Reset connect promises if no longer connecting\n\n    if (oldState === TransportState.Connecting) {\n      this.connectPromise = undefined;\n      this.connectResolve = undefined;\n      this.connectReject = undefined;\n    } // Local copies of disconnect promises (guarding against callbacks changing them indirectly)\n    // const disconnectPromise = this.disconnectPromise;\n\n\n    const disconnectResolve = this.disconnectResolve;\n    const disconnectReject = this.disconnectReject; // Reset disconnect promises if no longer disconnecting\n\n    if (oldState === TransportState.Disconnecting) {\n      this.disconnectPromise = undefined;\n      this.disconnectResolve = undefined;\n      this.disconnectReject = undefined;\n    } // Clear any outstanding connect timeout\n\n\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = undefined;\n    }\n\n    this.logger.log(`Transitioned from ${oldState} to ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); //  Transition to Connected\n\n\n    if (newState === TransportState.Connected) {\n      this.startSendingKeepAlives();\n\n      if (this.onConnect) {\n        try {\n          this.onConnect();\n        } catch (e) {\n          this.logger.error(e);\n          this.logger.error(\"Exception thrown by onConnect callback\");\n          throw e; // rethrow unhandled exception\n        }\n      }\n    } //  Transition from Connected\n\n\n    if (oldState === TransportState.Connected) {\n      this.stopSendingKeepAlives();\n\n      if (this.onDisconnect) {\n        try {\n          if (error) {\n            this.onDisconnect(error);\n          } else {\n            this.onDisconnect();\n          }\n        } catch (e) {\n          this.logger.error(e);\n          this.logger.error(\"Exception thrown by onDisconnect callback\");\n          throw e; // rethrow unhandled exception\n        }\n      }\n    } // Complete connect promise\n\n\n    if (oldState === TransportState.Connecting) {\n      if (!connectResolve) {\n        throw new Error(\"Connect resolve undefined.\");\n      }\n\n      if (!connectReject) {\n        throw new Error(\"Connect reject undefined.\");\n      }\n\n      newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error(\"Connect aborted.\"));\n    } // Complete disconnect promise\n\n\n    if (oldState === TransportState.Disconnecting) {\n      if (!disconnectResolve) {\n        throw new Error(\"Disconnect resolve undefined.\");\n      }\n\n      if (!disconnectReject) {\n        throw new Error(\"Disconnect reject undefined.\");\n      }\n\n      newState === TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error(\"Disconnect aborted.\"));\n    }\n\n    this.transitioningState = false;\n  } // TODO: Review \"KeepAlive Stuff\".\n  // It is not clear if it works and there are no tests for it.\n  // It was blindly lifted the keep alive code unchanged from earlier transport code.\n  //\n  // From the RFC...\n  //\n  // SIP WebSocket Clients and Servers may keep their WebSocket\n  // connections open by sending periodic WebSocket \"Ping\" frames as\n  // described in [RFC6455], Section 5.5.2.\n  // ...\n  // The indication and use of the CRLF NAT keep-alive mechanism defined\n  // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or\n  // [RFC6223] are, of course, usable over the transport defined in this\n  // specification.\n  // https://tools.ietf.org/html/rfc7118#section-6\n  //\n  // and...\n  //\n  // The Ping frame contains an opcode of 0x9.\n  // https://tools.ietf.org/html/rfc6455#section-5.5.2\n  //\n  // ==============================\n  // KeepAlive Stuff\n  // ==============================\n\n\n  clearKeepAliveTimeout() {\n    if (this.keepAliveDebounceTimeout) {\n      clearTimeout(this.keepAliveDebounceTimeout);\n    }\n\n    this.keepAliveDebounceTimeout = undefined;\n  }\n  /**\n   * Send a keep-alive (a double-CRLF sequence).\n   */\n\n\n  sendKeepAlive() {\n    if (this.keepAliveDebounceTimeout) {\n      // We already have an outstanding keep alive, do not send another.\n      return Promise.resolve();\n    }\n\n    this.keepAliveDebounceTimeout = setTimeout(() => {\n      this.clearKeepAliveTimeout();\n    }, this.configuration.keepAliveDebounce * 1000);\n    return this.send(\"\\r\\n\\r\\n\");\n  }\n  /**\n   * Start sending keep-alives.\n   */\n\n\n  startSendingKeepAlives() {\n    // Compute an amount of time in seconds to wait before sending another keep-alive.\n    const computeKeepAliveTimeout = upperBound => {\n      const lowerBound = upperBound * 0.8;\n      return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n    };\n\n    if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n      this.keepAliveInterval = setInterval(() => {\n        this.sendKeepAlive();\n        this.startSendingKeepAlives();\n      }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n    }\n  }\n  /**\n   * Stop sending keep-alives.\n   */\n\n\n  stopSendingKeepAlives() {\n    if (this.keepAliveInterval) {\n      clearInterval(this.keepAliveInterval);\n    }\n\n    if (this.keepAliveDebounceTimeout) {\n      clearTimeout(this.keepAliveDebounceTimeout);\n    }\n\n    this.keepAliveInterval = undefined;\n    this.keepAliveDebounceTimeout = undefined;\n  }\n\n}\nTransport.defaultOptions = {\n  server: \"\",\n  connectionTimeout: 5,\n  keepAliveInterval: 0,\n  keepAliveDebounce: 10,\n  traceSip: true\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/platform/web/transport/transport.js"],"names":["EmitterImpl","StateTransitionError","TransportState","Grammar","Transport","constructor","logger","options","_state","Disconnected","transitioningState","_stateEventEmitter","optionsDeprecated","wsServersDeprecated","wsServers","maxReconnectionAttemptsDeprecated","maxReconnectionAttempts","undefined","deprecatedMessage","warn","server","Array","configuration","Object","assign","defaultOptions","url","parsed","parse","error","Error","includes","scheme","_protocol","toUpperCase","dispose","disconnect","protocol","state","stateChange","ws","_ws","connect","_connect","_disconnect","isConnected","Connected","send","message","_send","log","Connecting","Promise","reject","transitionLoopDetectedError","connectPromise","resolve","Disconnecting","transitionState","e","WebSocket","binaryType","addEventListener","ev","onWebSocketClose","onWebSocketError","onWebSocketOpen","onWebSocketMessage","connectResolve","connectReject","connectTimeout","setTimeout","connectionTimeout","close","disconnectPromise","disconnectResolve","disconnectReject","traceSip","code","data","finishedData","test","clearKeepAliveTimeout","TextDecoder","decode","Uint8Array","err","onMessage","newState","invalidTransition","oldState","clearTimeout","emit","startSendingKeepAlives","onConnect","stopSendingKeepAlives","onDisconnect","keepAliveDebounceTimeout","sendKeepAlive","keepAliveDebounce","computeKeepAliveTimeout","upperBound","lowerBound","Math","random","keepAliveInterval","setInterval","clearInterval"],"mappings":"AAAA,SAASA,WAAT,QAA4B,sBAA5B;AACA,SAASC,oBAAT,QAAqC,yBAArC;AACA,SAASC,cAAT,QAA+B,8BAA/B;AACA,SAASC,OAAT,QAAwB,eAAxB;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,SAAN,CAAgB;AACnBC,EAAAA,WAAW,CAACC,MAAD,EAASC,OAAT,EAAkB;AACzB,SAAKC,MAAL,GAAcN,cAAc,CAACO,YAA7B;AACA,SAAKC,kBAAL,GAA0B,KAA1B,CAFyB,CAGzB;;AACA,SAAKC,kBAAL,GAA0B,IAAIX,WAAJ,EAA1B,CAJyB,CAKzB;;AACA,SAAKM,MAAL,GAAcA,MAAd,CANyB,CAOzB;;AACA,QAAIC,OAAJ,EAAa;AACT;AACA,YAAMK,iBAAiB,GAAGL,OAA1B;AACA,YAAMM,mBAAmB,GAAGD,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAK,KAAK,CAAzD,GAA6D,KAAK,CAAlE,GAAsEA,iBAAiB,CAACE,SAApH;AACA,YAAMC,iCAAiC,GAAGH,iBAAiB,KAAK,IAAtB,IAA8BA,iBAAiB,KAAK,KAAK,CAAzD,GAA6D,KAAK,CAAlE,GAAsEA,iBAAiB,CAACI,uBAAlI;;AACA,UAAIH,mBAAmB,KAAKI,SAA5B,EAAuC;AACnC,cAAMC,iBAAiB,GAAI,6FAAD,GACtB,gGADJ;AAEA,aAAKZ,MAAL,CAAYa,IAAZ,CAAiBD,iBAAjB;AACH;;AACD,UAAIH,iCAAiC,KAAKE,SAA1C,EAAqD;AACjD,cAAMC,iBAAiB,GAAI,2GAAD,GACtB,gGADJ;AAEA,aAAKZ,MAAL,CAAYa,IAAZ,CAAiBD,iBAAjB;AACH,OAdQ,CAeT;;;AACA,UAAIL,mBAAmB,IAAI,CAACN,OAAO,CAACa,MAApC,EAA4C;AACxC,YAAI,OAAOP,mBAAP,KAA+B,QAAnC,EAA6C;AACzCN,UAAAA,OAAO,CAACa,MAAR,GAAiBP,mBAAjB;AACH;;AACD,YAAIA,mBAAmB,YAAYQ,KAAnC,EAA0C;AACtCd,UAAAA,OAAO,CAACa,MAAR,GAAiBP,mBAAmB,CAAC,CAAD,CAApC;AACH;AACJ;AACJ,KAhCwB,CAiCzB;;;AACA,SAAKS,aAAL,GAAqBC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBpB,SAAS,CAACqB,cAA5B,CAAd,EAA2DlB,OAA3D,CAArB,CAlCyB,CAmCzB;;AACA,UAAMmB,GAAG,GAAG,KAAKJ,aAAL,CAAmBF,MAA/B;AACA,UAAMO,MAAM,GAAGxB,OAAO,CAACyB,KAAR,CAAcF,GAAd,EAAmB,aAAnB,CAAf;;AACA,QAAIC,MAAM,KAAK,CAAC,CAAhB,EAAmB;AACf,WAAKrB,MAAL,CAAYuB,KAAZ,CAAmB,iCAAgCH,GAAI,GAAvD;AACA,YAAM,IAAII,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACD,QAAI,CAAC,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,EAAqBC,QAArB,CAA8BJ,MAAM,CAACK,MAArC,CAAL,EAAmD;AAC/C,WAAK1B,MAAL,CAAYuB,KAAZ,CAAmB,2CAA0CH,GAAI,GAAjE;AACA,YAAM,IAAII,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,SAAKG,SAAL,GAAiBN,MAAM,CAACK,MAAP,CAAcE,WAAd,EAAjB;AACH;;AACDC,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKC,UAAL,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACI,MAAIC,QAAJ,GAAe;AACX,WAAO,KAAKJ,SAAZ;AACH;AACD;AACJ;AACA;;;AACI,MAAIb,MAAJ,GAAa;AACT,WAAO,KAAKE,aAAL,CAAmBF,MAA1B;AACH;AACD;AACJ;AACA;;;AACI,MAAIkB,KAAJ,GAAY;AACR,WAAO,KAAK9B,MAAZ;AACH;AACD;AACJ;AACA;;;AACI,MAAI+B,WAAJ,GAAkB;AACd,WAAO,KAAK5B,kBAAZ;AACH;AACD;AACJ;AACA;;;AACI,MAAI6B,EAAJ,GAAS;AACL,WAAO,KAAKC,GAAZ;AACH;AACD;AACJ;AACA;AACA;;;AACIC,EAAAA,OAAO,GAAG;AACN,WAAO,KAAKC,QAAL,EAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIP,EAAAA,UAAU,GAAG;AACT,WAAO,KAAKQ,WAAL,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,GAAG;AACV,WAAO,KAAKP,KAAL,KAAepC,cAAc,CAAC4C,SAArC;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIC,EAAAA,IAAI,CAACC,OAAD,EAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,KAAKC,KAAL,CAAWD,OAAX,CAAP;AACH;;AACDL,EAAAA,QAAQ,GAAG;AACP,SAAKrC,MAAL,CAAY4C,GAAZ,CAAiB,cAAa,KAAK9B,MAAO,EAA1C;;AACA,YAAQ,KAAKkB,KAAb;AACI,WAAKpC,cAAc,CAACiD,UAApB;AACI;AACA,YAAI,KAAKzC,kBAAT,EAA6B;AACzB,iBAAO0C,OAAO,CAACC,MAAR,CAAe,KAAKC,2BAAL,CAAiCpD,cAAc,CAACiD,UAAhD,CAAf,CAAP;AACH;;AACD,YAAI,CAAC,KAAKI,cAAV,EAA0B;AACtB,gBAAM,IAAIzB,KAAJ,CAAU,kCAAV,CAAN;AACH;;AACD,eAAO,KAAKyB,cAAZ;AAA4B;;AAChC,WAAKrD,cAAc,CAAC4C,SAApB;AACI;AACA,YAAI,KAAKpC,kBAAT,EAA6B;AACzB,iBAAO0C,OAAO,CAACC,MAAR,CAAe,KAAKC,2BAAL,CAAiCpD,cAAc,CAACiD,UAAhD,CAAf,CAAP;AACH;;AACD,YAAI,KAAKI,cAAT,EAAyB;AACrB,gBAAM,IAAIzB,KAAJ,CAAU,sCAAV,CAAN;AACH;;AACD,eAAOsB,OAAO,CAACI,OAAR,EAAP;AAA0B;;AAC9B,WAAKtD,cAAc,CAACuD,aAApB;AACI;AACA,YAAI,KAAKF,cAAT,EAAyB;AACrB,gBAAM,IAAIzB,KAAJ,CAAU,sCAAV,CAAN;AACH;;AACD,YAAI;AACA,eAAK4B,eAAL,CAAqBxD,cAAc,CAACiD,UAApC;AACH,SAFD,CAGA,OAAOQ,CAAP,EAAU;AACN,cAAIA,CAAC,YAAY1D,oBAAjB,EAAuC;AACnC,mBAAOmD,OAAO,CAACC,MAAR,CAAeM,CAAf,CAAP,CADmC,CACT;AAC7B;;AACD,gBAAMA,CAAN;AACH;;AACD;;AACJ,WAAKzD,cAAc,CAACO,YAApB;AACI;AACA,YAAI,KAAK8C,cAAT,EAAyB;AACrB,gBAAM,IAAIzB,KAAJ,CAAU,sCAAV,CAAN;AACH;;AACD,YAAI;AACA,eAAK4B,eAAL,CAAqBxD,cAAc,CAACiD,UAApC;AACH,SAFD,CAGA,OAAOQ,CAAP,EAAU;AACN,cAAIA,CAAC,YAAY1D,oBAAjB,EAAuC;AACnC,mBAAOmD,OAAO,CAACC,MAAR,CAAeM,CAAf,CAAP,CADmC,CACT;AAC7B;;AACD,gBAAMA,CAAN;AACH;;AACD;;AACJ;AACI,cAAM,IAAI7B,KAAJ,CAAU,eAAV,CAAN;AAlDR;;AAoDA,QAAIU,EAAJ;;AACA,QAAI;AACA;AACA;AACAA,MAAAA,EAAE,GAAG,IAAIoB,SAAJ,CAAc,KAAKxC,MAAnB,EAA2B,KAA3B,CAAL;AACAoB,MAAAA,EAAE,CAACqB,UAAH,GAAgB,aAAhB,CAJA,CAI+B;;AAC/BrB,MAAAA,EAAE,CAACsB,gBAAH,CAAoB,OAApB,EAA8BC,EAAD,IAAQ,KAAKC,gBAAL,CAAsBD,EAAtB,EAA0BvB,EAA1B,CAArC;AACAA,MAAAA,EAAE,CAACsB,gBAAH,CAAoB,OAApB,EAA8BC,EAAD,IAAQ,KAAKE,gBAAL,CAAsBF,EAAtB,EAA0BvB,EAA1B,CAArC;AACAA,MAAAA,EAAE,CAACsB,gBAAH,CAAoB,MAApB,EAA6BC,EAAD,IAAQ,KAAKG,eAAL,CAAqBH,EAArB,EAAyBvB,EAAzB,CAApC;AACAA,MAAAA,EAAE,CAACsB,gBAAH,CAAoB,SAApB,EAAgCC,EAAD,IAAQ,KAAKI,kBAAL,CAAwBJ,EAAxB,EAA4BvB,EAA5B,CAAvC;AACA,WAAKC,GAAL,GAAWD,EAAX;AACH,KAVD,CAWA,OAAOX,KAAP,EAAc;AACV,WAAKY,GAAL,GAAWxB,SAAX;AACA,WAAKX,MAAL,CAAYuB,KAAZ,CAAkB,gCAAlB;AACA,WAAKvB,MAAL,CAAYuB,KAAZ,CAAkBA,KAAlB;AACA,aAAO,IAAIuB,OAAJ,CAAY,CAACI,OAAD,EAAUH,MAAV,KAAqB;AACpC,aAAKe,cAAL,GAAsBZ,OAAtB;AACA,aAAKa,aAAL,GAAqBhB,MAArB,CAFoC,CAGpC;;AACA,aAAKK,eAAL,CAAqBxD,cAAc,CAACO,YAApC,EAAkDoB,KAAlD;AACH,OALM,CAAP;AAMH;;AACD,SAAK0B,cAAL,GAAsB,IAAIH,OAAJ,CAAY,CAACI,OAAD,EAAUH,MAAV,KAAqB;AACnD,WAAKe,cAAL,GAAsBZ,OAAtB;AACA,WAAKa,aAAL,GAAqBhB,MAArB;AACA,WAAKiB,cAAL,GAAsBC,UAAU,CAAC,MAAM;AACnC,aAAKjE,MAAL,CAAYa,IAAZ,CAAiB,wBACb,wDADa,GAEb,KAAKG,aAAL,CAAmBkD,iBAFN,GAGb,IAHJ;AAIAhC,QAAAA,EAAE,CAACiC,KAAH,CAAS,IAAT,EALmC,CAKnB;AACnB,OAN+B,EAM7B,KAAKnD,aAAL,CAAmBkD,iBAAnB,GAAuC,IANV,CAAhC;AAOH,KAVqB,CAAtB;AAWA,WAAO,KAAKjB,cAAZ;AACH;;AACDX,EAAAA,WAAW,GAAG;AACV,SAAKtC,MAAL,CAAY4C,GAAZ,CAAiB,iBAAgB,KAAK9B,MAAO,EAA7C;;AACA,YAAQ,KAAKkB,KAAb;AACI,WAAKpC,cAAc,CAACiD,UAApB;AACI;AACA,YAAI,KAAKuB,iBAAT,EAA4B;AACxB,gBAAM,IAAI5C,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,YAAI;AACA,eAAK4B,eAAL,CAAqBxD,cAAc,CAACuD,aAApC;AACH,SAFD,CAGA,OAAOE,CAAP,EAAU;AACN,cAAIA,CAAC,YAAY1D,oBAAjB,EAAuC;AACnC,mBAAOmD,OAAO,CAACC,MAAR,CAAeM,CAAf,CAAP,CADmC,CACT;AAC7B;;AACD,gBAAMA,CAAN;AACH;;AACD;;AACJ,WAAKzD,cAAc,CAAC4C,SAApB;AACI;AACA,YAAI,KAAK4B,iBAAT,EAA4B;AACxB,gBAAM,IAAI5C,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,YAAI;AACA,eAAK4B,eAAL,CAAqBxD,cAAc,CAACuD,aAApC;AACH,SAFD,CAGA,OAAOE,CAAP,EAAU;AACN,cAAIA,CAAC,YAAY1D,oBAAjB,EAAuC;AACnC,mBAAOmD,OAAO,CAACC,MAAR,CAAeM,CAAf,CAAP,CADmC,CACT;AAC7B;;AACD,gBAAMA,CAAN;AACH;;AACD;;AACJ,WAAKzD,cAAc,CAACuD,aAApB;AACI;AACA,YAAI,KAAK/C,kBAAT,EAA6B;AACzB,iBAAO0C,OAAO,CAACC,MAAR,CAAe,KAAKC,2BAAL,CAAiCpD,cAAc,CAACuD,aAAhD,CAAf,CAAP;AACH;;AACD,YAAI,CAAC,KAAKiB,iBAAV,EAA6B;AACzB,gBAAM,IAAI5C,KAAJ,CAAU,qCAAV,CAAN;AACH;;AACD,eAAO,KAAK4C,iBAAZ;AAA+B;;AACnC,WAAKxE,cAAc,CAACO,YAApB;AACI;AACA,YAAI,KAAKC,kBAAT,EAA6B;AACzB,iBAAO0C,OAAO,CAACC,MAAR,CAAe,KAAKC,2BAAL,CAAiCpD,cAAc,CAACuD,aAAhD,CAAf,CAAP;AACH;;AACD,YAAI,KAAKiB,iBAAT,EAA4B;AACxB,gBAAM,IAAI5C,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,eAAOsB,OAAO,CAACI,OAAR,EAAP;AAA0B;;AAC9B;AACI,cAAM,IAAI1B,KAAJ,CAAU,eAAV,CAAN;AAlDR;;AAoDA,QAAI,CAAC,KAAKW,GAAV,EAAe;AACX,YAAM,IAAIX,KAAJ,CAAU,4BAAV,CAAN;AACH;;AACD,UAAMU,EAAE,GAAG,KAAKC,GAAhB;AACA,SAAKiC,iBAAL,GAAyB,IAAItB,OAAJ,CAAY,CAACI,OAAD,EAAUH,MAAV,KAAqB;AACtD,WAAKsB,iBAAL,GAAyBnB,OAAzB;AACA,WAAKoB,gBAAL,GAAwBvB,MAAxB;;AACA,UAAI;AACA;AACA;AACAb,QAAAA,EAAE,CAACiC,KAAH,CAAS,IAAT,EAHA,CAGgB;AACnB,OAJD,CAKA,OAAO5C,KAAP,EAAc;AACV;AACA;AACA,aAAKvB,MAAL,CAAYuB,KAAZ,CAAkB,yBAAlB;AACA,aAAKvB,MAAL,CAAYuB,KAAZ,CAAkBA,KAAlB;AACA,cAAMA,KAAN;AACH;AACJ,KAfwB,CAAzB;AAgBA,WAAO,KAAK6C,iBAAZ;AACH;;AACDzB,EAAAA,KAAK,CAACD,OAAD,EAAU;AACX,QAAI,KAAK1B,aAAL,CAAmBuD,QAAnB,KAAgC,IAApC,EAA0C;AACtC,WAAKvE,MAAL,CAAY4C,GAAZ,CAAgB,mCAAmCF,OAAnC,GAA6C,IAA7D;AACH;;AACD,QAAI,KAAKxC,MAAL,KAAgBN,cAAc,CAAC4C,SAAnC,EAA8C;AAC1C,aAAOM,OAAO,CAACC,MAAR,CAAe,IAAIvB,KAAJ,CAAU,gBAAV,CAAf,CAAP;AACH;;AACD,QAAI,CAAC,KAAKW,GAAV,EAAe;AACX,YAAM,IAAIX,KAAJ,CAAU,sBAAV,CAAN;AACH;;AACD,QAAI;AACA;AACA;AACA,WAAKW,GAAL,CAASM,IAAT,CAAcC,OAAd;AACH,KAJD,CAKA,OAAOnB,KAAP,EAAc;AACV,UAAIA,KAAK,YAAYC,KAArB,EAA4B;AACxB,eAAOsB,OAAO,CAACC,MAAR,CAAexB,KAAf,CAAP;AACH;;AACD,aAAOuB,OAAO,CAACC,MAAR,CAAe,IAAIvB,KAAJ,CAAU,wBAAV,CAAf,CAAP;AACH;;AACD,WAAOsB,OAAO,CAACI,OAAR,EAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIQ,EAAAA,gBAAgB,CAACD,EAAD,EAAKvB,EAAL,EAAS;AACrB,QAAIA,EAAE,KAAK,KAAKC,GAAhB,EAAqB;AACjB;AACH;;AACD,UAAMO,OAAO,GAAI,oBAAmB,KAAK5B,MAAO,WAAU2C,EAAE,CAACe,IAAK,GAAlE;AACA,UAAMjD,KAAK,GAAG,CAAC,KAAK6C,iBAAN,GAA0B,IAAI5C,KAAJ,CAAUkB,OAAV,CAA1B,GAA+C/B,SAA7D;;AACA,QAAIY,KAAJ,EAAW;AACP,WAAKvB,MAAL,CAAYa,IAAZ,CAAiB,+BAAjB;AACH;;AACD,SAAKb,MAAL,CAAY4C,GAAZ,CAAgBF,OAAhB,EATqB,CAUrB;;AACA,SAAKP,GAAL,GAAWxB,SAAX,CAXqB,CAYrB;;AACA,SAAKyC,eAAL,CAAqBxD,cAAc,CAACO,YAApC,EAAkDoB,KAAlD;AACH;AACD;AACJ;AACA;AACA;;;AACIoC,EAAAA,gBAAgB,CAACF,EAAD,EAAKvB,EAAL,EAAS;AACrB,QAAIA,EAAE,KAAK,KAAKC,GAAhB,EAAqB;AACjB;AACH;;AACD,SAAKnC,MAAL,CAAYuB,KAAZ,CAAkB,2BAAlB;AACH;AACD;AACJ;AACA;AACA;;;AACIsC,EAAAA,kBAAkB,CAACJ,EAAD,EAAKvB,EAAL,EAAS;AACvB,QAAIA,EAAE,KAAK,KAAKC,GAAhB,EAAqB;AACjB;AACH;;AACD,UAAMsC,IAAI,GAAGhB,EAAE,CAACgB,IAAhB;AACA,QAAIC,YAAJ,CALuB,CAMvB;;AACA,QAAI,YAAYC,IAAZ,CAAiBF,IAAjB,CAAJ,EAA4B;AACxB,WAAKG,qBAAL;;AACA,UAAI,KAAK5D,aAAL,CAAmBuD,QAAnB,KAAgC,IAApC,EAA0C;AACtC,aAAKvE,MAAL,CAAY4C,GAAZ,CAAgB,0DAAhB;AACH;;AACD;AACH;;AACD,QAAI,CAAC6B,IAAL,EAAW;AACP,WAAKzE,MAAL,CAAYa,IAAZ,CAAiB,uCAAjB;AACA;AACH;;AACD,QAAI,OAAO4D,IAAP,KAAgB,QAApB,EAA8B;AAC1B;AACA,UAAI;AACAC,QAAAA,YAAY,GAAG,IAAIG,WAAJ,GAAkBC,MAAlB,CAAyB,IAAIC,UAAJ,CAAeN,IAAf,CAAzB,CAAf,CADA,CAEA;AACA;AACA;AACA;AACH,OAND,CAOA,OAAOO,GAAP,EAAY;AACR,aAAKhF,MAAL,CAAYuB,KAAZ,CAAkByD,GAAlB;AACA,aAAKhF,MAAL,CAAYuB,KAAZ,CAAkB,yFAAlB;AACA;AACH;;AACD,UAAI,KAAKP,aAAL,CAAmBuD,QAAnB,KAAgC,IAApC,EAA0C;AACtC,aAAKvE,MAAL,CAAY4C,GAAZ,CAAgB,2CAA2C8B,YAA3C,GAA0D,IAA1E;AACH;AACJ,KAjBD,MAkBK;AACD;AACAA,MAAAA,YAAY,GAAGD,IAAf;;AACA,UAAI,KAAKzD,aAAL,CAAmBuD,QAAnB,KAAgC,IAApC,EAA0C;AACtC,aAAKvE,MAAL,CAAY4C,GAAZ,CAAgB,yCAAyC8B,YAAzC,GAAwD,IAAxE;AACH;AACJ;;AACD,QAAI,KAAK1C,KAAL,KAAepC,cAAc,CAAC4C,SAAlC,EAA6C;AACzC,WAAKxC,MAAL,CAAYa,IAAZ,CAAiB,qDAAjB;AACA;AACH;;AACD,QAAI,KAAKoE,SAAT,EAAoB;AAChB,UAAI;AACA,aAAKA,SAAL,CAAeP,YAAf;AACH,OAFD,CAGA,OAAOrB,CAAP,EAAU;AACN,aAAKrD,MAAL,CAAYuB,KAAZ,CAAkB8B,CAAlB;AACA,aAAKrD,MAAL,CAAYuB,KAAZ,CAAkB,wCAAlB;AACA,cAAM8B,CAAN,CAHM,CAGG;AACZ;AACJ;AACJ;AACD;AACJ;AACA;AACA;;;AACIO,EAAAA,eAAe,CAACH,EAAD,EAAKvB,EAAL,EAAS;AACpB,QAAIA,EAAE,KAAK,KAAKC,GAAhB,EAAqB;AACjB;AACH;;AACD,QAAI,KAAKjC,MAAL,KAAgBN,cAAc,CAACiD,UAAnC,EAA+C;AAC3C,WAAK7C,MAAL,CAAY4C,GAAZ,CAAiB,oBAAmB,KAAK9B,MAAO,EAAhD;AACA,WAAKsC,eAAL,CAAqBxD,cAAc,CAAC4C,SAApC;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACIQ,EAAAA,2BAA2B,CAAChB,KAAD,EAAQ;AAC/B,QAAIU,OAAO,GAAI,4CAAf;AACAA,IAAAA,OAAO,IAAK,kCAAiC,KAAKxC,MAAO,OAAM8B,KAAM,yCAArE;AACAU,IAAAA,OAAO,IAAK,2GAAZ;AACA,SAAK1C,MAAL,CAAYuB,KAAZ,CAAkBmB,OAAlB;AACA,WAAO,IAAI/C,oBAAJ,CAAyB,gBAAzB,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIyD,EAAAA,eAAe,CAAC8B,QAAD,EAAW3D,KAAX,EAAkB;AAC7B,UAAM4D,iBAAiB,GAAG,MAAM;AAC5B,YAAM,IAAI3D,KAAJ,CAAW,iCAAgC,KAAKtB,MAAO,OAAMgF,QAAS,EAAtE,CAAN;AACH,KAFD;;AAGA,QAAI,KAAK9E,kBAAT,EAA6B;AACzB,YAAM,KAAK4C,2BAAL,CAAiCkC,QAAjC,CAAN;AACH;;AACD,SAAK9E,kBAAL,GAA0B,IAA1B,CAP6B,CAQ7B;;AACA,YAAQ,KAAKF,MAAb;AACI,WAAKN,cAAc,CAACiD,UAApB;AACI,YAAIqC,QAAQ,KAAKtF,cAAc,CAAC4C,SAA5B,IACA0C,QAAQ,KAAKtF,cAAc,CAACuD,aAD5B,IAEA+B,QAAQ,KAAKtF,cAAc,CAACO,YAFhC,EAE8C;AAC1CgF,UAAAA,iBAAiB;AACpB;;AACD;;AACJ,WAAKvF,cAAc,CAAC4C,SAApB;AACI,YAAI0C,QAAQ,KAAKtF,cAAc,CAACuD,aAA5B,IAA6C+B,QAAQ,KAAKtF,cAAc,CAACO,YAA7E,EAA2F;AACvFgF,UAAAA,iBAAiB;AACpB;;AACD;;AACJ,WAAKvF,cAAc,CAACuD,aAApB;AACI,YAAI+B,QAAQ,KAAKtF,cAAc,CAACiD,UAA5B,IAA0CqC,QAAQ,KAAKtF,cAAc,CAACO,YAA1E,EAAwF;AACpFgF,UAAAA,iBAAiB;AACpB;;AACD;;AACJ,WAAKvF,cAAc,CAACO,YAApB;AACI,YAAI+E,QAAQ,KAAKtF,cAAc,CAACiD,UAAhC,EAA4C;AACxCsC,UAAAA,iBAAiB;AACpB;;AACD;;AACJ;AACI,cAAM,IAAI3D,KAAJ,CAAU,gBAAV,CAAN;AAxBR,KAT6B,CAmC7B;;;AACA,UAAM4D,QAAQ,GAAG,KAAKlF,MAAtB;AACA,SAAKA,MAAL,GAAcgF,QAAd,CArC6B,CAsC7B;AACA;;AACA,UAAMpB,cAAc,GAAG,KAAKA,cAA5B;AACA,UAAMC,aAAa,GAAG,KAAKA,aAA3B,CAzC6B,CA0C7B;;AACA,QAAIqB,QAAQ,KAAKxF,cAAc,CAACiD,UAAhC,EAA4C;AACxC,WAAKI,cAAL,GAAsBtC,SAAtB;AACA,WAAKmD,cAAL,GAAsBnD,SAAtB;AACA,WAAKoD,aAAL,GAAqBpD,SAArB;AACH,KA/C4B,CAgD7B;AACA;;;AACA,UAAM0D,iBAAiB,GAAG,KAAKA,iBAA/B;AACA,UAAMC,gBAAgB,GAAG,KAAKA,gBAA9B,CAnD6B,CAoD7B;;AACA,QAAIc,QAAQ,KAAKxF,cAAc,CAACuD,aAAhC,EAA+C;AAC3C,WAAKiB,iBAAL,GAAyBzD,SAAzB;AACA,WAAK0D,iBAAL,GAAyB1D,SAAzB;AACA,WAAK2D,gBAAL,GAAwB3D,SAAxB;AACH,KAzD4B,CA0D7B;;;AACA,QAAI,KAAKqD,cAAT,EAAyB;AACrBqB,MAAAA,YAAY,CAAC,KAAKrB,cAAN,CAAZ;AACA,WAAKA,cAAL,GAAsBrD,SAAtB;AACH;;AACD,SAAKX,MAAL,CAAY4C,GAAZ,CAAiB,qBAAoBwC,QAAS,OAAM,KAAKlF,MAAO,EAAhE;;AACA,SAAKG,kBAAL,CAAwBiF,IAAxB,CAA6B,KAAKpF,MAAlC,EAhE6B,CAiE7B;;;AACA,QAAIgF,QAAQ,KAAKtF,cAAc,CAAC4C,SAAhC,EAA2C;AACvC,WAAK+C,sBAAL;;AACA,UAAI,KAAKC,SAAT,EAAoB;AAChB,YAAI;AACA,eAAKA,SAAL;AACH,SAFD,CAGA,OAAOnC,CAAP,EAAU;AACN,eAAKrD,MAAL,CAAYuB,KAAZ,CAAkB8B,CAAlB;AACA,eAAKrD,MAAL,CAAYuB,KAAZ,CAAkB,wCAAlB;AACA,gBAAM8B,CAAN,CAHM,CAGG;AACZ;AACJ;AACJ,KA9E4B,CA+E7B;;;AACA,QAAI+B,QAAQ,KAAKxF,cAAc,CAAC4C,SAAhC,EAA2C;AACvC,WAAKiD,qBAAL;;AACA,UAAI,KAAKC,YAAT,EAAuB;AACnB,YAAI;AACA,cAAInE,KAAJ,EAAW;AACP,iBAAKmE,YAAL,CAAkBnE,KAAlB;AACH,WAFD,MAGK;AACD,iBAAKmE,YAAL;AACH;AACJ,SAPD,CAQA,OAAOrC,CAAP,EAAU;AACN,eAAKrD,MAAL,CAAYuB,KAAZ,CAAkB8B,CAAlB;AACA,eAAKrD,MAAL,CAAYuB,KAAZ,CAAkB,2CAAlB;AACA,gBAAM8B,CAAN,CAHM,CAGG;AACZ;AACJ;AACJ,KAjG4B,CAkG7B;;;AACA,QAAI+B,QAAQ,KAAKxF,cAAc,CAACiD,UAAhC,EAA4C;AACxC,UAAI,CAACiB,cAAL,EAAqB;AACjB,cAAM,IAAItC,KAAJ,CAAU,4BAAV,CAAN;AACH;;AACD,UAAI,CAACuC,aAAL,EAAoB;AAChB,cAAM,IAAIvC,KAAJ,CAAU,2BAAV,CAAN;AACH;;AACD0D,MAAAA,QAAQ,KAAKtF,cAAc,CAAC4C,SAA5B,GAAwCsB,cAAc,EAAtD,GAA2DC,aAAa,CAACxC,KAAK,IAAI,IAAIC,KAAJ,CAAU,kBAAV,CAAV,CAAxE;AACH,KA3G4B,CA4G7B;;;AACA,QAAI4D,QAAQ,KAAKxF,cAAc,CAACuD,aAAhC,EAA+C;AAC3C,UAAI,CAACkB,iBAAL,EAAwB;AACpB,cAAM,IAAI7C,KAAJ,CAAU,+BAAV,CAAN;AACH;;AACD,UAAI,CAAC8C,gBAAL,EAAuB;AACnB,cAAM,IAAI9C,KAAJ,CAAU,8BAAV,CAAN;AACH;;AACD0D,MAAAA,QAAQ,KAAKtF,cAAc,CAACO,YAA5B,GACMkE,iBAAiB,EADvB,GAEMC,gBAAgB,CAAC/C,KAAK,IAAI,IAAIC,KAAJ,CAAU,qBAAV,CAAV,CAFtB;AAGH;;AACD,SAAKpB,kBAAL,GAA0B,KAA1B;AACH,GA/iBkB,CAgjBnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAwE,EAAAA,qBAAqB,GAAG;AACpB,QAAI,KAAKe,wBAAT,EAAmC;AAC/BN,MAAAA,YAAY,CAAC,KAAKM,wBAAN,CAAZ;AACH;;AACD,SAAKA,wBAAL,GAAgChF,SAAhC;AACH;AACD;AACJ;AACA;;;AACIiF,EAAAA,aAAa,GAAG;AACZ,QAAI,KAAKD,wBAAT,EAAmC;AAC/B;AACA,aAAO7C,OAAO,CAACI,OAAR,EAAP;AACH;;AACD,SAAKyC,wBAAL,GAAgC1B,UAAU,CAAC,MAAM;AAC7C,WAAKW,qBAAL;AACH,KAFyC,EAEvC,KAAK5D,aAAL,CAAmB6E,iBAAnB,GAAuC,IAFA,CAA1C;AAGA,WAAO,KAAKpD,IAAL,CAAU,UAAV,CAAP;AACH;AACD;AACJ;AACA;;;AACI8C,EAAAA,sBAAsB,GAAG;AACrB;AACA,UAAMO,uBAAuB,GAAIC,UAAD,IAAgB;AAC5C,YAAMC,UAAU,GAAGD,UAAU,GAAG,GAAhC;AACA,aAAO,QAAQE,IAAI,CAACC,MAAL,MAAiBH,UAAU,GAAGC,UAA9B,IAA4CA,UAApD,CAAP;AACH,KAHD;;AAIA,QAAI,KAAKhF,aAAL,CAAmBmF,iBAAnB,IAAwC,CAAC,KAAKA,iBAAlD,EAAqE;AACjE,WAAKA,iBAAL,GAAyBC,WAAW,CAAC,MAAM;AACvC,aAAKR,aAAL;AACA,aAAKL,sBAAL;AACH,OAHmC,EAGjCO,uBAAuB,CAAC,KAAK9E,aAAL,CAAmBmF,iBAApB,CAHU,CAApC;AAIH;AACJ;AACD;AACJ;AACA;;;AACIV,EAAAA,qBAAqB,GAAG;AACpB,QAAI,KAAKU,iBAAT,EAA4B;AACxBE,MAAAA,aAAa,CAAC,KAAKF,iBAAN,CAAb;AACH;;AACD,QAAI,KAAKR,wBAAT,EAAmC;AAC/BN,MAAAA,YAAY,CAAC,KAAKM,wBAAN,CAAZ;AACH;;AACD,SAAKQ,iBAAL,GAAyBxF,SAAzB;AACA,SAAKgF,wBAAL,GAAgChF,SAAhC;AACH;;AAvnBkB;AAynBvBb,SAAS,CAACqB,cAAV,GAA2B;AACvBL,EAAAA,MAAM,EAAE,EADe;AAEvBoD,EAAAA,iBAAiB,EAAE,CAFI;AAGvBiC,EAAAA,iBAAiB,EAAE,CAHI;AAIvBN,EAAAA,iBAAiB,EAAE,EAJI;AAKvBtB,EAAAA,QAAQ,EAAE;AALa,CAA3B","sourcesContent":["import { EmitterImpl } from \"../../../api/emitter\";\nimport { StateTransitionError } from \"../../../api/exceptions\";\nimport { TransportState } from \"../../../api/transport-state\";\nimport { Grammar } from \"../../../core\";\n/**\n * Transport for SIP over secure WebSocket (WSS).\n * @public\n */\nexport class Transport {\n    constructor(logger, options) {\n        this._state = TransportState.Disconnected;\n        this.transitioningState = false;\n        // state emitter\n        this._stateEventEmitter = new EmitterImpl();\n        // logger\n        this.logger = logger;\n        // guard deprecated options (remove this in version 16.x)\n        if (options) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const optionsDeprecated = options;\n            const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;\n            const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;\n            if (wsServersDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"wsServers\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            if (maxReconnectionAttemptsDeprecated !== undefined) {\n                const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` +\n                    \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n                this.logger.warn(deprecatedMessage);\n            }\n            // hack\n            if (wsServersDeprecated && !options.server) {\n                if (typeof wsServersDeprecated === \"string\") {\n                    options.server = wsServersDeprecated;\n                }\n                if (wsServersDeprecated instanceof Array) {\n                    options.server = wsServersDeprecated[0];\n                }\n            }\n        }\n        // initialize configuration\n        this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options);\n        // validate server URL\n        const url = this.configuration.server;\n        const parsed = Grammar.parse(url, \"absoluteURI\");\n        if (parsed === -1) {\n            this.logger.error(`Invalid WebSocket Server URL \"${url}\"`);\n            throw new Error(\"Invalid WebSocket Server URL\");\n        }\n        if (![\"wss\", \"ws\", \"udp\"].includes(parsed.scheme)) {\n            this.logger.error(`Invalid scheme in WebSocket Server URL \"${url}\"`);\n            throw new Error(\"Invalid scheme in WebSocket Server URL\");\n        }\n        this._protocol = parsed.scheme.toUpperCase();\n    }\n    dispose() {\n        return this.disconnect();\n    }\n    /**\n     * The protocol.\n     *\n     * @remarks\n     * Formatted as defined for the Via header sent-protocol transport.\n     * https://tools.ietf.org/html/rfc3261#section-20.42\n     */\n    get protocol() {\n        return this._protocol;\n    }\n    /**\n     * The URL of the WebSocket Server.\n     */\n    get server() {\n        return this.configuration.server;\n    }\n    /**\n     * Transport state.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Transport state change emitter.\n     */\n    get stateChange() {\n        return this._stateEventEmitter;\n    }\n    /**\n     * The WebSocket.\n     */\n    get ws() {\n        return this._ws;\n    }\n    /**\n     * Connect to network.\n     * Resolves once connected. Otherwise rejects with an Error.\n     */\n    connect() {\n        return this._connect();\n    }\n    /**\n     * Disconnect from network.\n     * Resolves once disconnected. Otherwise rejects with an Error.\n     */\n    disconnect() {\n        return this._disconnect();\n    }\n    /**\n     * Returns true if the `state` equals \"Connected\".\n     * @remarks\n     * This is equivalent to `state === TransportState.Connected`.\n     */\n    isConnected() {\n        return this.state === TransportState.Connected;\n    }\n    /**\n     * Sends a message.\n     * Resolves once message is sent. Otherwise rejects with an Error.\n     * @param message - Message to send.\n     */\n    send(message) {\n        // Error handling is independent of whether the message was a request or\n        // response.\n        //\n        // If the transport user asks for a message to be sent over an\n        // unreliable transport, and the result is an ICMP error, the behavior\n        // depends on the type of ICMP error.  Host, network, port or protocol\n        // unreachable errors, or parameter problem errors SHOULD cause the\n        // transport layer to inform the transport user of a failure in sending.\n        // Source quench and TTL exceeded ICMP errors SHOULD be ignored.\n        //\n        // If the transport user asks for a request to be sent over a reliable\n        // transport, and the result is a connection failure, the transport\n        // layer SHOULD inform the transport user of a failure in sending.\n        // https://tools.ietf.org/html/rfc3261#section-18.4\n        return this._send(message);\n    }\n    _connect() {\n        this.logger.log(`Connecting ${this.server}`);\n        switch (this.state) {\n            case TransportState.Connecting:\n                // If `state` is \"Connecting\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n                }\n                if (!this.connectPromise) {\n                    throw new Error(\"Connect promise must be defined.\");\n                }\n                return this.connectPromise; // Already connecting\n            case TransportState.Connected:\n                // If `state` is \"Connected\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n                }\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                return Promise.resolve(); // Already connected\n            case TransportState.Disconnecting:\n                // If `state` is \"Disconnecting\", `state` MUST transition to \"Connecting\" before returning\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Connecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Disconnected:\n                // If `state` is \"Disconnected\" `state` MUST transition to \"Connecting\" before returning\n                if (this.connectPromise) {\n                    throw new Error(\"Connect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Connecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        let ws;\n        try {\n            // WebSocket()\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket\n            ws = new WebSocket(this.server, \"sip\");\n            ws.binaryType = \"arraybuffer\"; // set data type of received binary messages\n            ws.addEventListener(\"close\", (ev) => this.onWebSocketClose(ev, ws));\n            ws.addEventListener(\"error\", (ev) => this.onWebSocketError(ev, ws));\n            ws.addEventListener(\"open\", (ev) => this.onWebSocketOpen(ev, ws));\n            ws.addEventListener(\"message\", (ev) => this.onWebSocketMessage(ev, ws));\n            this._ws = ws;\n        }\n        catch (error) {\n            this._ws = undefined;\n            this.logger.error(\"WebSocket construction failed.\");\n            this.logger.error(error);\n            return new Promise((resolve, reject) => {\n                this.connectResolve = resolve;\n                this.connectReject = reject;\n                // The `state` MUST transition to \"Disconnecting\" or \"Disconnected\" before rejecting\n                this.transitionState(TransportState.Disconnected, error);\n            });\n        }\n        this.connectPromise = new Promise((resolve, reject) => {\n            this.connectResolve = resolve;\n            this.connectReject = reject;\n            this.connectTimeout = setTimeout(() => {\n                this.logger.warn(\"Connect timed out. \" +\n                    \"Exceeded time set in configuration.connectionTimeout: \" +\n                    this.configuration.connectionTimeout +\n                    \"s.\");\n                ws.close(1000); // careful here to use a local reference instead of this._ws\n            }, this.configuration.connectionTimeout * 1000);\n        });\n        return this.connectPromise;\n    }\n    _disconnect() {\n        this.logger.log(`Disconnecting ${this.server}`);\n        switch (this.state) {\n            case TransportState.Connecting:\n                // If `state` is \"Connecting\", `state` MUST transition to \"Disconnecting\" before returning.\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Disconnecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Connected:\n                // If `state` is \"Connected\", `state` MUST transition to \"Disconnecting\" before returning.\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                try {\n                    this.transitionState(TransportState.Disconnecting);\n                }\n                catch (e) {\n                    if (e instanceof StateTransitionError) {\n                        return Promise.reject(e); // Loop detected\n                    }\n                    throw e;\n                }\n                break;\n            case TransportState.Disconnecting:\n                // If `state` is \"Disconnecting\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n                }\n                if (!this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must be defined.\");\n                }\n                return this.disconnectPromise; // Already disconnecting\n            case TransportState.Disconnected:\n                // If `state` is \"Disconnected\", `state` MUST NOT transition before returning.\n                if (this.transitioningState) {\n                    return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n                }\n                if (this.disconnectPromise) {\n                    throw new Error(\"Disconnect promise must not be defined.\");\n                }\n                return Promise.resolve(); // Already disconnected\n            default:\n                throw new Error(\"Unknown state\");\n        }\n        if (!this._ws) {\n            throw new Error(\"WebSocket must be defined.\");\n        }\n        const ws = this._ws;\n        this.disconnectPromise = new Promise((resolve, reject) => {\n            this.disconnectResolve = resolve;\n            this.disconnectReject = reject;\n            try {\n                // WebSocket.close()\n                // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n                ws.close(1000); // careful here to use a local reference instead of this._ws\n            }\n            catch (error) {\n                // Treating this as a coding error as it apparently can only happen\n                // if you pass close() invalid parameters (so it should never happen)\n                this.logger.error(\"WebSocket close failed.\");\n                this.logger.error(error);\n                throw error;\n            }\n        });\n        return this.disconnectPromise;\n    }\n    _send(message) {\n        if (this.configuration.traceSip === true) {\n            this.logger.log(\"Sending WebSocket message:\\n\\n\" + message + \"\\n\");\n        }\n        if (this._state !== TransportState.Connected) {\n            return Promise.reject(new Error(\"Not connected.\"));\n        }\n        if (!this._ws) {\n            throw new Error(\"WebSocket undefined.\");\n        }\n        try {\n            // WebSocket.send()\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n            this._ws.send(message);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                return Promise.reject(error);\n            }\n            return Promise.reject(new Error(\"WebSocket send failed.\"));\n        }\n        return Promise.resolve();\n    }\n    /**\n     * WebSocket \"onclose\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketClose(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        const message = `WebSocket closed ${this.server} (code: ${ev.code})`;\n        const error = !this.disconnectPromise ? new Error(message) : undefined;\n        if (error) {\n            this.logger.warn(\"WebSocket closed unexpectedly\");\n        }\n        this.logger.log(message);\n        // We are about to transition to disconnected, so clear our web socket\n        this._ws = undefined;\n        // The `state` MUST transition to \"Disconnected\" before resolving (assuming `state` is not already \"Disconnected\").\n        this.transitionState(TransportState.Disconnected, error);\n    }\n    /**\n     * WebSocket \"onerror\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketError(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        this.logger.error(\"WebSocket error occurred.\");\n    }\n    /**\n     * WebSocket \"onmessage\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketMessage(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        const data = ev.data;\n        let finishedData;\n        // CRLF Keep Alive response from server. Clear our keep alive timeout.\n        if (/^(\\r\\n)+$/.test(data)) {\n            this.clearKeepAliveTimeout();\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket message with CRLF Keep Alive response\");\n            }\n            return;\n        }\n        if (!data) {\n            this.logger.warn(\"Received empty message, discarding...\");\n            return;\n        }\n        if (typeof data !== \"string\") {\n            // WebSocket binary message.\n            try {\n                finishedData = new TextDecoder().decode(new Uint8Array(data));\n                // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.\n                // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.\n                // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.\n                // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));\n            }\n            catch (err) {\n                this.logger.error(err);\n                this.logger.error(\"Received WebSocket binary message failed to be converted into string, message discarded\");\n                return;\n            }\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket binary message:\\n\\n\" + finishedData + \"\\n\");\n            }\n        }\n        else {\n            // WebSocket text message.\n            finishedData = data;\n            if (this.configuration.traceSip === true) {\n                this.logger.log(\"Received WebSocket text message:\\n\\n\" + finishedData + \"\\n\");\n            }\n        }\n        if (this.state !== TransportState.Connected) {\n            this.logger.warn(\"Received message while not connected, discarding...\");\n            return;\n        }\n        if (this.onMessage) {\n            try {\n                this.onMessage(finishedData);\n            }\n            catch (e) {\n                this.logger.error(e);\n                this.logger.error(\"Exception thrown by onMessage callback\");\n                throw e; // rethrow unhandled exception\n            }\n        }\n    }\n    /**\n     * WebSocket \"onopen\" event handler.\n     * @param ev - Event.\n     */\n    onWebSocketOpen(ev, ws) {\n        if (ws !== this._ws) {\n            return;\n        }\n        if (this._state === TransportState.Connecting) {\n            this.logger.log(`WebSocket opened ${this.server}`);\n            this.transitionState(TransportState.Connected);\n        }\n    }\n    /**\n     * Helper function to generate an Error.\n     * @param state - State transitioning to.\n     */\n    transitionLoopDetectedError(state) {\n        let message = `A state transition loop has been detected.`;\n        message += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;\n        message += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;\n        this.logger.error(message);\n        return new StateTransitionError(\"Loop detected.\");\n    }\n    /**\n     * Transition transport state.\n     * @internal\n     */\n    transitionState(newState, error) {\n        const invalidTransition = () => {\n            throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n        };\n        if (this.transitioningState) {\n            throw this.transitionLoopDetectedError(newState);\n        }\n        this.transitioningState = true;\n        // Validate state transition\n        switch (this._state) {\n            case TransportState.Connecting:\n                if (newState !== TransportState.Connected &&\n                    newState !== TransportState.Disconnecting &&\n                    newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Connected:\n                if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Disconnecting:\n                if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {\n                    invalidTransition();\n                }\n                break;\n            case TransportState.Disconnected:\n                if (newState !== TransportState.Connecting) {\n                    invalidTransition();\n                }\n                break;\n            default:\n                throw new Error(\"Unknown state.\");\n        }\n        // Update state\n        const oldState = this._state;\n        this._state = newState;\n        // Local copies of connect promises (guarding against callbacks changing them indirectly)\n        // const connectPromise = this.connectPromise;\n        const connectResolve = this.connectResolve;\n        const connectReject = this.connectReject;\n        // Reset connect promises if no longer connecting\n        if (oldState === TransportState.Connecting) {\n            this.connectPromise = undefined;\n            this.connectResolve = undefined;\n            this.connectReject = undefined;\n        }\n        // Local copies of disconnect promises (guarding against callbacks changing them indirectly)\n        // const disconnectPromise = this.disconnectPromise;\n        const disconnectResolve = this.disconnectResolve;\n        const disconnectReject = this.disconnectReject;\n        // Reset disconnect promises if no longer disconnecting\n        if (oldState === TransportState.Disconnecting) {\n            this.disconnectPromise = undefined;\n            this.disconnectResolve = undefined;\n            this.disconnectReject = undefined;\n        }\n        // Clear any outstanding connect timeout\n        if (this.connectTimeout) {\n            clearTimeout(this.connectTimeout);\n            this.connectTimeout = undefined;\n        }\n        this.logger.log(`Transitioned from ${oldState} to ${this._state}`);\n        this._stateEventEmitter.emit(this._state);\n        //  Transition to Connected\n        if (newState === TransportState.Connected) {\n            this.startSendingKeepAlives();\n            if (this.onConnect) {\n                try {\n                    this.onConnect();\n                }\n                catch (e) {\n                    this.logger.error(e);\n                    this.logger.error(\"Exception thrown by onConnect callback\");\n                    throw e; // rethrow unhandled exception\n                }\n            }\n        }\n        //  Transition from Connected\n        if (oldState === TransportState.Connected) {\n            this.stopSendingKeepAlives();\n            if (this.onDisconnect) {\n                try {\n                    if (error) {\n                        this.onDisconnect(error);\n                    }\n                    else {\n                        this.onDisconnect();\n                    }\n                }\n                catch (e) {\n                    this.logger.error(e);\n                    this.logger.error(\"Exception thrown by onDisconnect callback\");\n                    throw e; // rethrow unhandled exception\n                }\n            }\n        }\n        // Complete connect promise\n        if (oldState === TransportState.Connecting) {\n            if (!connectResolve) {\n                throw new Error(\"Connect resolve undefined.\");\n            }\n            if (!connectReject) {\n                throw new Error(\"Connect reject undefined.\");\n            }\n            newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error(\"Connect aborted.\"));\n        }\n        // Complete disconnect promise\n        if (oldState === TransportState.Disconnecting) {\n            if (!disconnectResolve) {\n                throw new Error(\"Disconnect resolve undefined.\");\n            }\n            if (!disconnectReject) {\n                throw new Error(\"Disconnect reject undefined.\");\n            }\n            newState === TransportState.Disconnected\n                ? disconnectResolve()\n                : disconnectReject(error || new Error(\"Disconnect aborted.\"));\n        }\n        this.transitioningState = false;\n    }\n    // TODO: Review \"KeepAlive Stuff\".\n    // It is not clear if it works and there are no tests for it.\n    // It was blindly lifted the keep alive code unchanged from earlier transport code.\n    //\n    // From the RFC...\n    //\n    // SIP WebSocket Clients and Servers may keep their WebSocket\n    // connections open by sending periodic WebSocket \"Ping\" frames as\n    // described in [RFC6455], Section 5.5.2.\n    // ...\n    // The indication and use of the CRLF NAT keep-alive mechanism defined\n    // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or\n    // [RFC6223] are, of course, usable over the transport defined in this\n    // specification.\n    // https://tools.ietf.org/html/rfc7118#section-6\n    //\n    // and...\n    //\n    // The Ping frame contains an opcode of 0x9.\n    // https://tools.ietf.org/html/rfc6455#section-5.5.2\n    //\n    // ==============================\n    // KeepAlive Stuff\n    // ==============================\n    clearKeepAliveTimeout() {\n        if (this.keepAliveDebounceTimeout) {\n            clearTimeout(this.keepAliveDebounceTimeout);\n        }\n        this.keepAliveDebounceTimeout = undefined;\n    }\n    /**\n     * Send a keep-alive (a double-CRLF sequence).\n     */\n    sendKeepAlive() {\n        if (this.keepAliveDebounceTimeout) {\n            // We already have an outstanding keep alive, do not send another.\n            return Promise.resolve();\n        }\n        this.keepAliveDebounceTimeout = setTimeout(() => {\n            this.clearKeepAliveTimeout();\n        }, this.configuration.keepAliveDebounce * 1000);\n        return this.send(\"\\r\\n\\r\\n\");\n    }\n    /**\n     * Start sending keep-alives.\n     */\n    startSendingKeepAlives() {\n        // Compute an amount of time in seconds to wait before sending another keep-alive.\n        const computeKeepAliveTimeout = (upperBound) => {\n            const lowerBound = upperBound * 0.8;\n            return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n        };\n        if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n            this.keepAliveInterval = setInterval(() => {\n                this.sendKeepAlive();\n                this.startSendingKeepAlives();\n            }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n        }\n    }\n    /**\n     * Stop sending keep-alives.\n     */\n    stopSendingKeepAlives() {\n        if (this.keepAliveInterval) {\n            clearInterval(this.keepAliveInterval);\n        }\n        if (this.keepAliveDebounceTimeout) {\n            clearTimeout(this.keepAliveDebounceTimeout);\n        }\n        this.keepAliveInterval = undefined;\n        this.keepAliveDebounceTimeout = undefined;\n    }\n}\nTransport.defaultOptions = {\n    server: \"\",\n    connectionTimeout: 5,\n    keepAliveInterval: 0,\n    keepAliveDebounce: 10,\n    traceSip: true\n};\n"]},"metadata":{},"sourceType":"module"}