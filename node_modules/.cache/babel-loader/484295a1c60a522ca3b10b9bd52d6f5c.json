{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { C, IncomingResponseMessage } from \"../messages\";\nimport { NonInviteClientTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Client (UAC).\n * @remarks\n * A user agent client is a logical entity\n * that creates a new request, and then uses the client\n * transaction state machinery to send it.  The role of UAC lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software initiates a request, it acts as a UAC for\n * the duration of that transaction.  If it receives a request\n * later, it assumes the role of a user agent server for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport var UserAgentClient = /*#__PURE__*/function () {\n  function UserAgentClient(transactionConstructor, core, message, delegate) {\n    _classCallCheck(this, UserAgentClient);\n\n    this.transactionConstructor = transactionConstructor;\n    this.core = core;\n    this.message = message;\n    this.delegate = delegate;\n    this.challenged = false;\n    this.stale = false;\n    this.logger = this.loggerFactory.getLogger(\"sip.user-agent-client\");\n    this.init();\n  }\n\n  _createClass(UserAgentClient, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.transaction.dispose();\n    }\n  }, {\n    key: \"cancel\",\n\n    /**\n     * Since requests other than INVITE are responded to immediately, sending a\n     * CANCEL for a non-INVITE request would always create a race condition.\n     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-9.1\n     * @param options - Cancel options bucket.\n     */\n    value: function cancel(reason) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.transaction) {\n        throw new Error(\"Transaction undefined.\");\n      }\n\n      if (!this.message.to) {\n        throw new Error(\"To undefined.\");\n      }\n\n      if (!this.message.from) {\n        throw new Error(\"From undefined.\");\n      } // The following procedures are used to construct a CANCEL request.  The\n      // Request-URI, Call-ID, To, the numeric part of CSeq, and From header\n      // fields in the CANCEL request MUST be identical to those in the\n      // request being cancelled, including tags.  A CANCEL constructed by a\n      // client MUST have only a single Via header field value matching the\n      // top Via value in the request being cancelled.  Using the same values\n      // for these header fields allows the CANCEL to be matched with the\n      // request it cancels (Section 9.2 indicates how such matching occurs).\n      // However, the method part of the CSeq header field MUST have a value\n      // of CANCEL.  This allows it to be identified and processed as a\n      // transaction in its own right (See Section 17).\n      // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n      var message = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {\n        toTag: this.message.toTag,\n        fromTag: this.message.fromTag,\n        callId: this.message.callId,\n        cseq: this.message.cseq\n      }, options.extraHeaders); // TODO: Revisit this.\n      // The CANCEL needs to use the same branch parameter so that\n      // it matches the INVITE transaction, but this is a hacky way to do this.\n      // Or at the very least not well documented. If the the branch parameter\n      // is set on the outgoing request, the transaction will use it.\n      // Otherwise the transaction will make a new one.\n\n      message.branch = this.message.branch;\n\n      if (this.message.headers.Route) {\n        message.headers.Route = this.message.headers.Route;\n      }\n\n      if (reason) {\n        message.setHeader(\"Reason\", reason);\n      } // If no provisional response has been received, the CANCEL request MUST\n      // NOT be sent; rather, the client MUST wait for the arrival of a\n      // provisional response before sending the request. If the original\n      // request has generated a final response, the CANCEL SHOULD NOT be\n      // sent, as it is an effective no-op, since CANCEL has no effect on\n      // requests that have already generated a final response.\n      // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n      if (this.transaction.state === TransactionState.Proceeding) {\n        new UserAgentClient(NonInviteClientTransaction, this.core, message);\n      } else {\n        this.transaction.addStateChangeListener(function () {\n          if (_this.transaction && _this.transaction.state === TransactionState.Proceeding) {\n            new UserAgentClient(NonInviteClientTransaction, _this.core, message);\n          }\n        }, {\n          once: true\n        });\n      }\n\n      return message;\n    }\n    /**\n     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n     * response is received, the UAC SHOULD follow the authorization\n     * procedures of Section 22.2 and Section 22.3 to retry the request with\n     * credentials.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n     * 22 Usage of HTTP Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22\n     * 22.1 Framework\n     * https://tools.ietf.org/html/rfc3261#section-22.1\n     * 22.2 User-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.2\n     * 22.3 Proxy-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.3\n     *\n     * FIXME: This \"guard for and retry the request with credentials\"\n     * implementation is not complete and at best minimally passable.\n     * @param response - The incoming response to guard.\n     * @param dialog - If defined, the dialog within which the response was received.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise the request is retried with credentials and current request processing must stop.\n     */\n\n  }, {\n    key: \"authenticationGuard\",\n    value: function authenticationGuard(message, dialog) {\n      var statusCode = message.statusCode;\n\n      if (!statusCode) {\n        throw new Error(\"Response status code undefined.\");\n      } // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n      // response is received, the UAC SHOULD follow the authorization\n      // procedures of Section 22.2 and Section 22.3 to retry the request with\n      // credentials.\n      // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n\n\n      if (statusCode !== 401 && statusCode !== 407) {\n        return true;\n      } // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      var challenge;\n      var authorizationHeaderName;\n\n      if (statusCode === 401) {\n        challenge = message.parseHeader(\"www-authenticate\");\n        authorizationHeaderName = \"authorization\";\n      } else {\n        challenge = message.parseHeader(\"proxy-authenticate\");\n        authorizationHeaderName = \"proxy-authorization\";\n      } // Verify it seems a valid challenge.\n\n\n      if (!challenge) {\n        this.logger.warn(statusCode + \" with wrong or missing challenge, cannot authenticate\");\n        return true;\n      } // Avoid infinite authentications.\n\n\n      if (this.challenged && (this.stale || challenge.stale !== true)) {\n        this.logger.warn(statusCode + \" apparently in authentication loop, cannot authenticate\");\n        return true;\n      } // Get credentials.\n\n\n      if (!this.credentials) {\n        this.credentials = this.core.configuration.authenticationFactory();\n\n        if (!this.credentials) {\n          this.logger.warn(\"Unable to obtain credentials, cannot authenticate\");\n          return true;\n        }\n      } // Verify that the challenge is really valid.\n\n\n      if (!this.credentials.authenticate(this.message, challenge)) {\n        return true;\n      }\n\n      this.challenged = true;\n\n      if (challenge.stale) {\n        this.stale = true;\n      } // If response to out of dialog request, assume incrementing the CSeq will suffice.\n\n\n      var cseq = this.message.cseq += 1; // If response to in dialog request, get a valid next CSeq number.\n\n      if (dialog && dialog.localSequenceNumber) {\n        dialog.incrementLocalSequenceNumber();\n        cseq = this.message.cseq = dialog.localSequenceNumber;\n      }\n\n      this.message.setHeader(\"cseq\", cseq + \" \" + this.message.method);\n      this.message.setHeader(authorizationHeaderName, this.credentials.toString()); // Calling init (again) will swap out our existing client transaction with a new one.\n      // FIXME: HACK: An assumption is being made here that there is nothing that needs to\n      // be cleaned up beyond the client transaction which is being replaced. For example,\n      // it is assumed that no early dialogs have been created.\n\n      this.init();\n      return false;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     */\n\n  }, {\n    key: \"onRequestTimeout\",\n    value: function onRequestTimeout() {\n      this.logger.warn(\"User agent client request timed out. Generating internal 408 Request Timeout.\");\n      var message = new IncomingResponseMessage();\n      message.statusCode = 408;\n      message.reasonPhrase = \"Request Timeout\";\n      this.receiveResponse(message);\n      return;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     * @param error - Transport error\n     */\n\n  }, {\n    key: \"onTransportError\",\n    value: function onTransportError(error) {\n      this.logger.error(error.message);\n      this.logger.error(\"User agent client request transport error. Generating internal 503 Service Unavailable.\");\n      var message = new IncomingResponseMessage();\n      message.statusCode = 503;\n      message.reasonPhrase = \"Service Unavailable\";\n      this.receiveResponse(message);\n    }\n    /**\n     * Receive a response from the transaction layer.\n     * @param message - Incoming response message.\n     */\n\n  }, {\n    key: \"receiveResponse\",\n    value: function receiveResponse(message) {\n      if (!this.authenticationGuard(message)) {\n        return;\n      }\n\n      var statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n      if (!statusCode) {\n        throw new Error(\"Response status code undefined.\");\n      }\n\n      switch (true) {\n        case /^100$/.test(statusCode):\n          if (this.delegate && this.delegate.onTrying) {\n            this.delegate.onTrying({\n              message: message\n            });\n          }\n\n          break;\n\n        case /^1[0-9]{2}$/.test(statusCode):\n          if (this.delegate && this.delegate.onProgress) {\n            this.delegate.onProgress({\n              message: message\n            });\n          }\n\n          break;\n\n        case /^2[0-9]{2}$/.test(statusCode):\n          if (this.delegate && this.delegate.onAccept) {\n            this.delegate.onAccept({\n              message: message\n            });\n          }\n\n          break;\n\n        case /^3[0-9]{2}$/.test(statusCode):\n          if (this.delegate && this.delegate.onRedirect) {\n            this.delegate.onRedirect({\n              message: message\n            });\n          }\n\n          break;\n\n        case /^[4-6][0-9]{2}$/.test(statusCode):\n          if (this.delegate && this.delegate.onReject) {\n            this.delegate.onReject({\n              message: message\n            });\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Invalid status code \".concat(statusCode));\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      // We are the transaction user.\n      var user = {\n        loggerFactory: this.loggerFactory,\n        onRequestTimeout: function onRequestTimeout() {\n          return _this2.onRequestTimeout();\n        },\n        onStateChange: function onStateChange(newState) {\n          if (newState === TransactionState.Terminated) {\n            // Remove the terminated transaction from the core.\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            _this2.core.userAgentClients.delete(userAgentClientId); // FIXME: HACK: Our transaction may have been swapped out with a new one\n            // post authentication (see above), so make sure to only to dispose of\n            // ourselves if this terminating transaction is our current transaction.\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n            if (transaction === _this2._transaction) {\n              _this2.dispose();\n            }\n          }\n        },\n        onTransportError: function onTransportError(error) {\n          return _this2.onTransportError(error);\n        },\n        receiveResponse: function receiveResponse(message) {\n          return _this2.receiveResponse(message);\n        }\n      }; // Create a new transaction with us as the user.\n\n      var transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n      this._transaction = transaction; // Add the new transaction to the core.\n\n      var userAgentClientId = transaction.id + transaction.request.method;\n      this.core.userAgentClients.set(userAgentClientId, this);\n    }\n  }, {\n    key: \"loggerFactory\",\n    get: function get() {\n      return this.core.loggerFactory;\n    }\n    /** The transaction associated with this request. */\n\n  }, {\n    key: \"transaction\",\n    get: function get() {\n      if (!this._transaction) {\n        throw new Error(\"Transaction undefined.\");\n      }\n\n      return this._transaction;\n    }\n  }]);\n\n  return UserAgentClient;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/user-agents/user-agent-client.js"],"names":["C","IncomingResponseMessage","NonInviteClientTransaction","TransactionState","UserAgentClient","transactionConstructor","core","message","delegate","challenged","stale","logger","loggerFactory","getLogger","init","transaction","dispose","reason","options","Error","to","from","makeOutgoingRequestMessage","CANCEL","ruri","uri","toTag","fromTag","callId","cseq","extraHeaders","branch","headers","Route","setHeader","state","Proceeding","addStateChangeListener","once","dialog","statusCode","challenge","authorizationHeaderName","parseHeader","warn","credentials","configuration","authenticationFactory","authenticate","localSequenceNumber","incrementLocalSequenceNumber","method","toString","reasonPhrase","receiveResponse","error","authenticationGuard","test","onTrying","onProgress","onAccept","onRedirect","onReject","user","onRequestTimeout","onStateChange","newState","Terminated","userAgentClients","delete","userAgentClientId","_transaction","onTransportError","transport","id","request","set"],"mappings":"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","sourcesContent":["import { C, IncomingResponseMessage } from \"../messages\";\nimport { NonInviteClientTransaction, TransactionState } from \"../transactions\";\n/**\n * User Agent Client (UAC).\n * @remarks\n * A user agent client is a logical entity\n * that creates a new request, and then uses the client\n * transaction state machinery to send it.  The role of UAC lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software initiates a request, it acts as a UAC for\n * the duration of that transaction.  If it receives a request\n * later, it assumes the role of a user agent server for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\nexport class UserAgentClient {\n    constructor(transactionConstructor, core, message, delegate) {\n        this.transactionConstructor = transactionConstructor;\n        this.core = core;\n        this.message = message;\n        this.delegate = delegate;\n        this.challenged = false;\n        this.stale = false;\n        this.logger = this.loggerFactory.getLogger(\"sip.user-agent-client\");\n        this.init();\n    }\n    dispose() {\n        this.transaction.dispose();\n    }\n    get loggerFactory() {\n        return this.core.loggerFactory;\n    }\n    /** The transaction associated with this request. */\n    get transaction() {\n        if (!this._transaction) {\n            throw new Error(\"Transaction undefined.\");\n        }\n        return this._transaction;\n    }\n    /**\n     * Since requests other than INVITE are responded to immediately, sending a\n     * CANCEL for a non-INVITE request would always create a race condition.\n     * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.\n     * https://tools.ietf.org/html/rfc3261#section-9.1\n     * @param options - Cancel options bucket.\n     */\n    cancel(reason, options = {}) {\n        if (!this.transaction) {\n            throw new Error(\"Transaction undefined.\");\n        }\n        if (!this.message.to) {\n            throw new Error(\"To undefined.\");\n        }\n        if (!this.message.from) {\n            throw new Error(\"From undefined.\");\n        }\n        // The following procedures are used to construct a CANCEL request.  The\n        // Request-URI, Call-ID, To, the numeric part of CSeq, and From header\n        // fields in the CANCEL request MUST be identical to those in the\n        // request being cancelled, including tags.  A CANCEL constructed by a\n        // client MUST have only a single Via header field value matching the\n        // top Via value in the request being cancelled.  Using the same values\n        // for these header fields allows the CANCEL to be matched with the\n        // request it cancels (Section 9.2 indicates how such matching occurs).\n        // However, the method part of the CSeq header field MUST have a value\n        // of CANCEL.  This allows it to be identified and processed as a\n        // transaction in its own right (See Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-9.1\n        const message = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {\n            toTag: this.message.toTag,\n            fromTag: this.message.fromTag,\n            callId: this.message.callId,\n            cseq: this.message.cseq\n        }, options.extraHeaders);\n        // TODO: Revisit this.\n        // The CANCEL needs to use the same branch parameter so that\n        // it matches the INVITE transaction, but this is a hacky way to do this.\n        // Or at the very least not well documented. If the the branch parameter\n        // is set on the outgoing request, the transaction will use it.\n        // Otherwise the transaction will make a new one.\n        message.branch = this.message.branch;\n        if (this.message.headers.Route) {\n            message.headers.Route = this.message.headers.Route;\n        }\n        if (reason) {\n            message.setHeader(\"Reason\", reason);\n        }\n        // If no provisional response has been received, the CANCEL request MUST\n        // NOT be sent; rather, the client MUST wait for the arrival of a\n        // provisional response before sending the request. If the original\n        // request has generated a final response, the CANCEL SHOULD NOT be\n        // sent, as it is an effective no-op, since CANCEL has no effect on\n        // requests that have already generated a final response.\n        // https://tools.ietf.org/html/rfc3261#section-9.1\n        if (this.transaction.state === TransactionState.Proceeding) {\n            new UserAgentClient(NonInviteClientTransaction, this.core, message);\n        }\n        else {\n            this.transaction.addStateChangeListener(() => {\n                if (this.transaction && this.transaction.state === TransactionState.Proceeding) {\n                    new UserAgentClient(NonInviteClientTransaction, this.core, message);\n                }\n            }, { once: true });\n        }\n        return message;\n    }\n    /**\n     * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n     * response is received, the UAC SHOULD follow the authorization\n     * procedures of Section 22.2 and Section 22.3 to retry the request with\n     * credentials.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n     * 22 Usage of HTTP Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22\n     * 22.1 Framework\n     * https://tools.ietf.org/html/rfc3261#section-22.1\n     * 22.2 User-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.2\n     * 22.3 Proxy-to-User Authentication\n     * https://tools.ietf.org/html/rfc3261#section-22.3\n     *\n     * FIXME: This \"guard for and retry the request with credentials\"\n     * implementation is not complete and at best minimally passable.\n     * @param response - The incoming response to guard.\n     * @param dialog - If defined, the dialog within which the response was received.\n     * @returns True if the program execution is to continue in the branch in question.\n     *          Otherwise the request is retried with credentials and current request processing must stop.\n     */\n    authenticationGuard(message, dialog) {\n        const statusCode = message.statusCode;\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n        // response is received, the UAC SHOULD follow the authorization\n        // procedures of Section 22.2 and Section 22.3 to retry the request with\n        // credentials.\n        // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n        if (statusCode !== 401 && statusCode !== 407) {\n            return true;\n        }\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let challenge;\n        let authorizationHeaderName;\n        if (statusCode === 401) {\n            challenge = message.parseHeader(\"www-authenticate\");\n            authorizationHeaderName = \"authorization\";\n        }\n        else {\n            challenge = message.parseHeader(\"proxy-authenticate\");\n            authorizationHeaderName = \"proxy-authorization\";\n        }\n        // Verify it seems a valid challenge.\n        if (!challenge) {\n            this.logger.warn(statusCode + \" with wrong or missing challenge, cannot authenticate\");\n            return true;\n        }\n        // Avoid infinite authentications.\n        if (this.challenged && (this.stale || challenge.stale !== true)) {\n            this.logger.warn(statusCode + \" apparently in authentication loop, cannot authenticate\");\n            return true;\n        }\n        // Get credentials.\n        if (!this.credentials) {\n            this.credentials = this.core.configuration.authenticationFactory();\n            if (!this.credentials) {\n                this.logger.warn(\"Unable to obtain credentials, cannot authenticate\");\n                return true;\n            }\n        }\n        // Verify that the challenge is really valid.\n        if (!this.credentials.authenticate(this.message, challenge)) {\n            return true;\n        }\n        this.challenged = true;\n        if (challenge.stale) {\n            this.stale = true;\n        }\n        // If response to out of dialog request, assume incrementing the CSeq will suffice.\n        let cseq = (this.message.cseq += 1);\n        // If response to in dialog request, get a valid next CSeq number.\n        if (dialog && dialog.localSequenceNumber) {\n            dialog.incrementLocalSequenceNumber();\n            cseq = this.message.cseq = dialog.localSequenceNumber;\n        }\n        this.message.setHeader(\"cseq\", cseq + \" \" + this.message.method);\n        this.message.setHeader(authorizationHeaderName, this.credentials.toString());\n        // Calling init (again) will swap out our existing client transaction with a new one.\n        // FIXME: HACK: An assumption is being made here that there is nothing that needs to\n        // be cleaned up beyond the client transaction which is being replaced. For example,\n        // it is assumed that no early dialogs have been created.\n        this.init();\n        return false;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     */\n    onRequestTimeout() {\n        this.logger.warn(\"User agent client request timed out. Generating internal 408 Request Timeout.\");\n        const message = new IncomingResponseMessage();\n        message.statusCode = 408;\n        message.reasonPhrase = \"Request Timeout\";\n        this.receiveResponse(message);\n        return;\n    }\n    /**\n     * 8.1.3.1 Transaction Layer Errors\n     * In some cases, the response returned by the transaction layer will\n     * not be a SIP message, but rather a transaction layer error.  When a\n     * timeout error is received from the transaction layer, it MUST be\n     * treated as if a 408 (Request Timeout) status code has been received.\n     * If a fatal transport error is reported by the transport layer\n     * (generally, due to fatal ICMP errors in UDP or connection failures in\n     * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n     * status code.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n     * @param error - Transport error\n     */\n    onTransportError(error) {\n        this.logger.error(error.message);\n        this.logger.error(\"User agent client request transport error. Generating internal 503 Service Unavailable.\");\n        const message = new IncomingResponseMessage();\n        message.statusCode = 503;\n        message.reasonPhrase = \"Service Unavailable\";\n        this.receiveResponse(message);\n    }\n    /**\n     * Receive a response from the transaction layer.\n     * @param message - Incoming response message.\n     */\n    receiveResponse(message) {\n        if (!this.authenticationGuard(message)) {\n            return;\n        }\n        const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n        if (!statusCode) {\n            throw new Error(\"Response status code undefined.\");\n        }\n        switch (true) {\n            case /^100$/.test(statusCode):\n                if (this.delegate && this.delegate.onTrying) {\n                    this.delegate.onTrying({ message });\n                }\n                break;\n            case /^1[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onProgress) {\n                    this.delegate.onProgress({ message });\n                }\n                break;\n            case /^2[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onAccept) {\n                    this.delegate.onAccept({ message });\n                }\n                break;\n            case /^3[0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onRedirect) {\n                    this.delegate.onRedirect({ message });\n                }\n                break;\n            case /^[4-6][0-9]{2}$/.test(statusCode):\n                if (this.delegate && this.delegate.onReject) {\n                    this.delegate.onReject({ message });\n                }\n                break;\n            default:\n                throw new Error(`Invalid status code ${statusCode}`);\n        }\n    }\n    init() {\n        // We are the transaction user.\n        const user = {\n            loggerFactory: this.loggerFactory,\n            onRequestTimeout: () => this.onRequestTimeout(),\n            onStateChange: (newState) => {\n                if (newState === TransactionState.Terminated) {\n                    // Remove the terminated transaction from the core.\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    this.core.userAgentClients.delete(userAgentClientId);\n                    // FIXME: HACK: Our transaction may have been swapped out with a new one\n                    // post authentication (see above), so make sure to only to dispose of\n                    // ourselves if this terminating transaction is our current transaction.\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    if (transaction === this._transaction) {\n                        this.dispose();\n                    }\n                }\n            },\n            onTransportError: (error) => this.onTransportError(error),\n            receiveResponse: (message) => this.receiveResponse(message)\n        };\n        // Create a new transaction with us as the user.\n        const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n        this._transaction = transaction;\n        // Add the new transaction to the core.\n        const userAgentClientId = transaction.id + transaction.request.method;\n        this.core.userAgentClients.set(userAgentClientId, this);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}