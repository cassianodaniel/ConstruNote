{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport _get from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createSuper\";\nimport { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * Non-INVITE Client Transaction.\n * @remarks\n * Non-INVITE transactions do not make use of ACK.\n * They are simple request-response interactions.\n * https://tools.ietf.org/html/rfc3261#section-17.1.2\n * @public\n */\n\nexport var NonInviteClientTransaction = /*#__PURE__*/function (_ClientTransaction) {\n  _inherits(NonInviteClientTransaction, _ClientTransaction);\n\n  var _super = _createSuper(NonInviteClientTransaction);\n\n  /**\n   * Constructor\n   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n   * Then `toString` is called on the outgoing request and the message is sent via the transport.\n   * After construction the transaction will be in the \"calling\" state and the transaction id\n   * will equal the branch parameter set in the Via header of the outgoing request.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.2\n   * @param request - The outgoing Non-INVITE request.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  function NonInviteClientTransaction(request, transport, user) {\n    var _this;\n\n    _classCallCheck(this, NonInviteClientTransaction);\n\n    _this = _super.call(this, request, transport, user, TransactionState.Trying, \"sip.transaction.nict\"); // FIXME: Timer E for unreliable transports not implemented.\n    //\n    // The \"Trying\" state is entered when the TU initiates a new client\n    // transaction with a request.  When entering this state, the client\n    // transaction SHOULD set timer F to fire in 64*T1 seconds. The request\n    // MUST be passed to the transport layer for transmission.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n    _this.F = setTimeout(function () {\n      return _this.timerF();\n    }, Timers.TIMER_F);\n\n    _this.send(request.toString()).catch(function (error) {\n      _this.logTransportError(error, \"Failed to send initial outgoing request.\");\n    });\n\n    return _this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  _createClass(NonInviteClientTransaction, [{\n    key: \"dispose\",\n    value: function dispose() {\n      if (this.F) {\n        clearTimeout(this.F);\n        this.F = undefined;\n      }\n\n      if (this.K) {\n        clearTimeout(this.K);\n        this.K = undefined;\n      }\n\n      _get(_getPrototypeOf(NonInviteClientTransaction.prototype), \"dispose\", this).call(this);\n    }\n    /** Transaction kind. Deprecated. */\n\n  }, {\n    key: \"receiveResponse\",\n\n    /**\n     * Handler for incoming responses from the transport which match this transaction.\n     * @param response - The incoming response.\n     */\n    value: function receiveResponse(response) {\n      var statusCode = response.statusCode;\n\n      if (!statusCode || statusCode < 100 || statusCode > 699) {\n        throw new Error(\"Invalid status code \".concat(statusCode));\n      }\n\n      switch (this.state) {\n        case TransactionState.Trying:\n          // If a provisional response is received while in the \"Trying\" state, the\n          // response MUST be passed to the TU, and then the client transaction\n          // SHOULD move to the \"Proceeding\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n          if (statusCode >= 100 && statusCode <= 199) {\n            this.stateTransition(TransactionState.Proceeding);\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // If a final response (status codes 200-699) is received while in the\n          // \"Trying\" state, the response MUST be passed to the TU, and the\n          // client transaction MUST transition to the \"Completed\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n          if (statusCode >= 200 && statusCode <= 699) {\n            this.stateTransition(TransactionState.Completed);\n\n            if (statusCode === 408) {\n              this.onRequestTimeout();\n              return;\n            }\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Proceeding:\n          // If a provisional response is received while in the \"Proceeding\" state,\n          // the response MUST be passed to the TU. (From Figure 6)\n          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n          if (statusCode >= 100 && statusCode <= 199) {\n            if (this.user.receiveResponse) {\n              return this.user.receiveResponse(response);\n            }\n          } // If a final response (status codes 200-699) is received while in the\n          // \"Proceeding\" state, the response MUST be passed to the TU, and the\n          // client transaction MUST transition to the \"Completed\" state.\n          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n          if (statusCode >= 200 && statusCode <= 699) {\n            this.stateTransition(TransactionState.Completed);\n\n            if (statusCode === 408) {\n              this.onRequestTimeout();\n              return;\n            }\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          }\n\n          break;\n\n        case TransactionState.Completed:\n          // The \"Completed\" state exists to buffer any additional response\n          // retransmissions that may be received (which is why the client\n          // transaction remains there only for unreliable transports).\n          // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n          return;\n\n        case TransactionState.Terminated:\n          // For good measure just absorb additional response retransmissions.\n          return;\n\n        default:\n          throw new Error(\"Invalid state \".concat(this.state));\n      }\n\n      var message = \"Non-INVITE client transaction received unexpected \".concat(statusCode, \" response while in state \").concat(this.state, \".\");\n      this.logger.warn(message);\n      return;\n    }\n    /**\n     * The client transaction SHOULD inform the TU that a transport failure has occurred,\n     * and the client transaction SHOULD transition directly to the \"Terminated\" state.\n     * The TU will handle the fail over mechanisms described in [4].\n     * https://tools.ietf.org/html/rfc3261#section-17.1.4\n     * @param error - Transport error\n     */\n\n  }, {\n    key: \"onTransportError\",\n    value: function onTransportError(error) {\n      if (this.user.onTransportError) {\n        this.user.onTransportError(error);\n      }\n\n      this.stateTransition(TransactionState.Terminated, true);\n    }\n    /** For logging. */\n\n  }, {\n    key: \"typeToString\",\n    value: function typeToString() {\n      return \"non-INVITE client transaction\";\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n\n  }, {\n    key: \"stateTransition\",\n    value: function stateTransition(newState) {\n      var _this2 = this;\n\n      var dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Assert valid state transitions.\n      var invalidStateTransition = function invalidStateTransition() {\n        throw new Error(\"Invalid state transition from \".concat(_this2.state, \" to \").concat(newState));\n      };\n\n      switch (newState) {\n        case TransactionState.Trying:\n          invalidStateTransition();\n          break;\n\n        case TransactionState.Proceeding:\n          if (this.state !== TransactionState.Trying) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Completed:\n          if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {\n            invalidStateTransition();\n          }\n\n          break;\n\n        case TransactionState.Terminated:\n          if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {\n            if (!dueToTransportError) {\n              invalidStateTransition();\n            }\n          }\n\n          break;\n\n        default:\n          invalidStateTransition();\n      } // Once the client transaction enters the \"Completed\" state, it MUST set\n      // Timer K to fire in T4 seconds for unreliable transports, and zero\n      // seconds for reliable transports  The \"Completed\" state exists to\n      // buffer any additional response retransmissions that may be received\n      // (which is why the client transaction remains there only for unreliable transports).\n      // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n      if (newState === TransactionState.Completed) {\n        if (this.F) {\n          clearTimeout(this.F);\n          this.F = undefined;\n        }\n\n        this.K = setTimeout(function () {\n          return _this2.timerK();\n        }, Timers.TIMER_K);\n      } // Once the transaction is in the terminated state, it MUST be destroyed immediately.\n      // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n      if (newState === TransactionState.Terminated) {\n        this.dispose();\n      } // Update state.\n\n\n      this.setState(newState);\n    }\n    /**\n     * If Timer F fires while the client transaction is still in the\n     * \"Trying\" state, the client transaction SHOULD inform the TU about the\n     * timeout, and then it SHOULD enter the \"Terminated\" state.\n     * If timer F fires while in the \"Proceeding\" state, the TU MUST be informed of\n     * a timeout, and the client transaction MUST transition to the terminated state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n     */\n\n  }, {\n    key: \"timerF\",\n    value: function timerF() {\n      this.logger.debug(\"Timer F expired for non-INVITE client transaction \".concat(this.id, \".\"));\n\n      if (this.state === TransactionState.Trying || this.state === TransactionState.Proceeding) {\n        this.onRequestTimeout();\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n    /**\n     * If Timer K fires while in this (COMPLETED) state, the client transaction\n     * MUST transition to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n     */\n\n  }, {\n    key: \"timerK\",\n    value: function timerK() {\n      if (this.state === TransactionState.Completed) {\n        this.stateTransition(TransactionState.Terminated);\n      }\n    }\n  }, {\n    key: \"kind\",\n    get: function get() {\n      return \"nict\";\n    }\n  }]);\n\n  return NonInviteClientTransaction;\n}(ClientTransaction);","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/transactions/non-invite-client-transaction.js"],"names":["Timers","ClientTransaction","TransactionState","NonInviteClientTransaction","request","transport","user","Trying","F","setTimeout","timerF","TIMER_F","send","toString","catch","error","logTransportError","clearTimeout","undefined","K","response","statusCode","Error","state","stateTransition","Proceeding","receiveResponse","Completed","onRequestTimeout","Terminated","message","logger","warn","onTransportError","newState","dueToTransportError","invalidStateTransition","timerK","TIMER_K","dispose","setState","debug","id"],"mappings":"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","sourcesContent":["import { Timers } from \"../timers\";\nimport { ClientTransaction } from \"./client-transaction\";\nimport { TransactionState } from \"./transaction-state\";\n/**\n * Non-INVITE Client Transaction.\n * @remarks\n * Non-INVITE transactions do not make use of ACK.\n * They are simple request-response interactions.\n * https://tools.ietf.org/html/rfc3261#section-17.1.2\n * @public\n */\nexport class NonInviteClientTransaction extends ClientTransaction {\n    /**\n     * Constructor\n     * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n     * Then `toString` is called on the outgoing request and the message is sent via the transport.\n     * After construction the transaction will be in the \"calling\" state and the transaction id\n     * will equal the branch parameter set in the Via header of the outgoing request.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.2\n     * @param request - The outgoing Non-INVITE request.\n     * @param transport - The transport.\n     * @param user - The transaction user.\n     */\n    constructor(request, transport, user) {\n        super(request, transport, user, TransactionState.Trying, \"sip.transaction.nict\");\n        // FIXME: Timer E for unreliable transports not implemented.\n        //\n        // The \"Trying\" state is entered when the TU initiates a new client\n        // transaction with a request.  When entering this state, the client\n        // transaction SHOULD set timer F to fire in 64*T1 seconds. The request\n        // MUST be passed to the transport layer for transmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        this.F = setTimeout(() => this.timerF(), Timers.TIMER_F);\n        this.send(request.toString()).catch((error) => {\n            this.logTransportError(error, \"Failed to send initial outgoing request.\");\n        });\n    }\n    /**\n     * Destructor.\n     */\n    dispose() {\n        if (this.F) {\n            clearTimeout(this.F);\n            this.F = undefined;\n        }\n        if (this.K) {\n            clearTimeout(this.K);\n            this.K = undefined;\n        }\n        super.dispose();\n    }\n    /** Transaction kind. Deprecated. */\n    get kind() {\n        return \"nict\";\n    }\n    /**\n     * Handler for incoming responses from the transport which match this transaction.\n     * @param response - The incoming response.\n     */\n    receiveResponse(response) {\n        const statusCode = response.statusCode;\n        if (!statusCode || statusCode < 100 || statusCode > 699) {\n            throw new Error(`Invalid status code ${statusCode}`);\n        }\n        switch (this.state) {\n            case TransactionState.Trying:\n                // If a provisional response is received while in the \"Trying\" state, the\n                // response MUST be passed to the TU, and then the client transaction\n                // SHOULD move to the \"Proceeding\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    this.stateTransition(TransactionState.Proceeding);\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                // If a final response (status codes 200-699) is received while in the\n                // \"Trying\" state, the response MUST be passed to the TU, and the\n                // client transaction MUST transition to the \"Completed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n                if (statusCode >= 200 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    if (statusCode === 408) {\n                        this.onRequestTimeout();\n                        return;\n                    }\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Proceeding:\n                // If a provisional response is received while in the \"Proceeding\" state,\n                // the response MUST be passed to the TU. (From Figure 6)\n                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n                if (statusCode >= 100 && statusCode <= 199) {\n                    if (this.user.receiveResponse) {\n                        return this.user.receiveResponse(response);\n                    }\n                }\n                // If a final response (status codes 200-699) is received while in the\n                // \"Proceeding\" state, the response MUST be passed to the TU, and the\n                // client transaction MUST transition to the \"Completed\" state.\n                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n                if (statusCode >= 200 && statusCode <= 699) {\n                    this.stateTransition(TransactionState.Completed);\n                    if (statusCode === 408) {\n                        this.onRequestTimeout();\n                        return;\n                    }\n                    if (this.user.receiveResponse) {\n                        this.user.receiveResponse(response);\n                    }\n                    return;\n                }\n                break;\n            case TransactionState.Completed:\n                // The \"Completed\" state exists to buffer any additional response\n                // retransmissions that may be received (which is why the client\n                // transaction remains there only for unreliable transports).\n                // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n                return;\n            case TransactionState.Terminated:\n                // For good measure just absorb additional response retransmissions.\n                return;\n            default:\n                throw new Error(`Invalid state ${this.state}`);\n        }\n        const message = `Non-INVITE client transaction received unexpected ${statusCode} response while in state ${this.state}.`;\n        this.logger.warn(message);\n        return;\n    }\n    /**\n     * The client transaction SHOULD inform the TU that a transport failure has occurred,\n     * and the client transaction SHOULD transition directly to the \"Terminated\" state.\n     * The TU will handle the fail over mechanisms described in [4].\n     * https://tools.ietf.org/html/rfc3261#section-17.1.4\n     * @param error - Transport error\n     */\n    onTransportError(error) {\n        if (this.user.onTransportError) {\n            this.user.onTransportError(error);\n        }\n        this.stateTransition(TransactionState.Terminated, true);\n    }\n    /** For logging. */\n    typeToString() {\n        return \"non-INVITE client transaction\";\n    }\n    /**\n     * Execute a state transition.\n     * @param newState - New state.\n     */\n    stateTransition(newState, dueToTransportError = false) {\n        // Assert valid state transitions.\n        const invalidStateTransition = () => {\n            throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n        };\n        switch (newState) {\n            case TransactionState.Trying:\n                invalidStateTransition();\n                break;\n            case TransactionState.Proceeding:\n                if (this.state !== TransactionState.Trying) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Completed:\n                if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {\n                    invalidStateTransition();\n                }\n                break;\n            case TransactionState.Terminated:\n                if (this.state !== TransactionState.Trying &&\n                    this.state !== TransactionState.Proceeding &&\n                    this.state !== TransactionState.Completed) {\n                    if (!dueToTransportError) {\n                        invalidStateTransition();\n                    }\n                }\n                break;\n            default:\n                invalidStateTransition();\n        }\n        // Once the client transaction enters the \"Completed\" state, it MUST set\n        // Timer K to fire in T4 seconds for unreliable transports, and zero\n        // seconds for reliable transports  The \"Completed\" state exists to\n        // buffer any additional response retransmissions that may be received\n        // (which is why the client transaction remains there only for unreliable transports).\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        if (newState === TransactionState.Completed) {\n            if (this.F) {\n                clearTimeout(this.F);\n                this.F = undefined;\n            }\n            this.K = setTimeout(() => this.timerK(), Timers.TIMER_K);\n        }\n        // Once the transaction is in the terminated state, it MUST be destroyed immediately.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        if (newState === TransactionState.Terminated) {\n            this.dispose();\n        }\n        // Update state.\n        this.setState(newState);\n    }\n    /**\n     * If Timer F fires while the client transaction is still in the\n     * \"Trying\" state, the client transaction SHOULD inform the TU about the\n     * timeout, and then it SHOULD enter the \"Terminated\" state.\n     * If timer F fires while in the \"Proceeding\" state, the TU MUST be informed of\n     * a timeout, and the client transaction MUST transition to the terminated state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n     */\n    timerF() {\n        this.logger.debug(`Timer F expired for non-INVITE client transaction ${this.id}.`);\n        if (this.state === TransactionState.Trying || this.state === TransactionState.Proceeding) {\n            this.onRequestTimeout();\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n    /**\n     * If Timer K fires while in this (COMPLETED) state, the client transaction\n     * MUST transition to the \"Terminated\" state.\n     * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n     */\n    timerK() {\n        if (this.state === TransactionState.Completed) {\n            this.stateTransition(TransactionState.Terminated);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}