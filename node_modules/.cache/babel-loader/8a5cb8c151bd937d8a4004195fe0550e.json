{"ast":null,"code":"'use strict';\n\nconst xml = require('@xmpp/xml'); // https://xmpp.org/extensions/xep-0198.html\n\n\nconst NS = 'urn:xmpp:sm:3';\n\nasync function enable(entity, resume, max) {\n  entity.send(xml('enable', {\n    xmlns: NS,\n    max,\n    resume: resume ? 'true' : undefined\n  }));\n  return new Promise((resolve, reject) => {\n    function listener(nonza) {\n      if (nonza.is('enabled', NS)) {\n        resolve(nonza);\n      } else if (nonza.is('failed', NS)) {\n        reject(nonza);\n      } else {\n        return;\n      }\n\n      entity.removeListener('nonza', listener);\n    }\n\n    entity.on('nonza', listener);\n  });\n}\n\nasync function resume(entity, h, previd) {\n  const response = await entity.sendReceive(xml('resume', {\n    xmlns: NS,\n    h,\n    previd\n  }));\n\n  if (!response.is('resumed', NS)) {\n    throw response;\n  }\n\n  return response;\n}\n\nmodule.exports = function ({\n  streamFeatures,\n  entity,\n  middleware\n}) {\n  let address = null;\n  const sm = {\n    allowResume: true,\n    preferredMaximum: null,\n    enabled: false,\n    id: '',\n    outbound: 0,\n    inbound: 0,\n    max: null\n  };\n  entity.on('online', jid => {\n    address = jid;\n    sm.outbound = 0;\n    sm.inbound = 0;\n  });\n  entity.on('offline', () => {\n    sm.outbound = 0;\n    sm.inbound = 0;\n    sm.enabled = false;\n    sm.id = '';\n  });\n  middleware.use((context, next) => {\n    const {\n      stanza\n    } = context;\n\n    if (['presence', 'message', 'iq'].includes(stanza.name)) {\n      sm.inbound += 1;\n    } else if (stanza.is('r', NS)) {\n      // > When an <r/> element (\"request\") is received, the recipient MUST acknowledge it by sending an <a/> element to the sender containing a value of 'h' that is equal to the number of stanzas handled by the recipient of the <r/> element.\n      entity.send(xml('a', {\n        xmlns: NS,\n        h: sm.inbound\n      })).catch(() => {});\n    } else if (stanza.is('a', NS)) {\n      // > When a party receives an <a/> element, it SHOULD keep a record of the 'h' value returned as the sequence number of the last handled outbound stanza for the current stream (and discard the previous value).\n      sm.outbound = stanza.attrs.h;\n    }\n\n    return next();\n  }); // https://xmpp.org/extensions/xep-0198.html#enable\n  // For client-to-server connections, the client MUST NOT attempt to enable stream management until after it has completed Resource Binding unless it is resuming a previous session\n\n  streamFeatures.use('sm', NS, async (context, next) => {\n    // Resuming\n    if (sm.id) {\n      try {\n        await resume(entity, sm.inbound, sm.id);\n        sm.enabled = true;\n        entity.jid = address;\n        entity.status = 'online';\n        return true; // If resumption fails, continue with session establishment\n        // eslint-disable-next-line no-unused-vars\n      } catch (err) {\n        sm.id = '';\n        sm.enabled = false;\n        sm.outbound = 0;\n      }\n    } // Enabling\n    // Resource binding first\n\n\n    await next();\n    const promiseEnable = enable(entity, sm.allowResume, sm.preferredMaximum); // > The counter for an entity's own sent stanzas is set to zero and started after sending either <enable/> or <enabled/>.\n\n    sm.outbound = 0;\n\n    try {\n      const response = await promiseEnable;\n      sm.enabled = true;\n      sm.id = response.attrs.id;\n      sm.max = response.attrs.max; // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      sm.enabled = false;\n    }\n\n    sm.inbound = 0;\n  });\n  return sm;\n};","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/@xmpp/stream-management/index.js"],"names":["xml","require","NS","enable","entity","resume","max","send","xmlns","undefined","Promise","resolve","reject","listener","nonza","is","removeListener","on","h","previd","response","sendReceive","module","exports","streamFeatures","middleware","address","sm","allowResume","preferredMaximum","enabled","id","outbound","inbound","jid","use","context","next","stanza","includes","name","catch","attrs","status","err","promiseEnable"],"mappings":"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","sourcesContent":["'use strict'\n\nconst xml = require('@xmpp/xml')\n\n// https://xmpp.org/extensions/xep-0198.html\n\nconst NS = 'urn:xmpp:sm:3'\n\nasync function enable(entity, resume, max) {\n  entity.send(\n    xml('enable', {xmlns: NS, max, resume: resume ? 'true' : undefined})\n  )\n\n  return new Promise((resolve, reject) => {\n    function listener(nonza) {\n      if (nonza.is('enabled', NS)) {\n        resolve(nonza)\n      } else if (nonza.is('failed', NS)) {\n        reject(nonza)\n      } else {\n        return\n      }\n\n      entity.removeListener('nonza', listener)\n    }\n\n    entity.on('nonza', listener)\n  })\n}\n\nasync function resume(entity, h, previd) {\n  const response = await entity.sendReceive(\n    xml('resume', {xmlns: NS, h, previd})\n  )\n\n  if (!response.is('resumed', NS)) {\n    throw response\n  }\n\n  return response\n}\n\nmodule.exports = function({streamFeatures, entity, middleware}) {\n  let address = null\n\n  const sm = {\n    allowResume: true,\n    preferredMaximum: null,\n    enabled: false,\n    id: '',\n    outbound: 0,\n    inbound: 0,\n    max: null,\n  }\n\n  entity.on('online', jid => {\n    address = jid\n    sm.outbound = 0\n    sm.inbound = 0\n  })\n\n  entity.on('offline', () => {\n    sm.outbound = 0\n    sm.inbound = 0\n    sm.enabled = false\n    sm.id = ''\n  })\n\n  middleware.use((context, next) => {\n    const {stanza} = context\n    if (['presence', 'message', 'iq'].includes(stanza.name)) {\n      sm.inbound += 1\n    } else if (stanza.is('r', NS)) {\n      // > When an <r/> element (\"request\") is received, the recipient MUST acknowledge it by sending an <a/> element to the sender containing a value of 'h' that is equal to the number of stanzas handled by the recipient of the <r/> element.\n      entity.send(xml('a', {xmlns: NS, h: sm.inbound})).catch(() => {})\n    } else if (stanza.is('a', NS)) {\n      // > When a party receives an <a/> element, it SHOULD keep a record of the 'h' value returned as the sequence number of the last handled outbound stanza for the current stream (and discard the previous value).\n      sm.outbound = stanza.attrs.h\n    }\n\n    return next()\n  })\n\n  // https://xmpp.org/extensions/xep-0198.html#enable\n  // For client-to-server connections, the client MUST NOT attempt to enable stream management until after it has completed Resource Binding unless it is resuming a previous session\n\n  streamFeatures.use('sm', NS, async (context, next) => {\n    // Resuming\n    if (sm.id) {\n      try {\n        await resume(entity, sm.inbound, sm.id)\n        sm.enabled = true\n        entity.jid = address\n        entity.status = 'online'\n        return true\n        // If resumption fails, continue with session establishment\n        // eslint-disable-next-line no-unused-vars\n      } catch (err) {\n        sm.id = ''\n        sm.enabled = false\n        sm.outbound = 0\n      }\n    }\n\n    // Enabling\n\n    // Resource binding first\n    await next()\n\n    const promiseEnable = enable(entity, sm.allowResume, sm.preferredMaximum)\n\n    // > The counter for an entity's own sent stanzas is set to zero and started after sending either <enable/> or <enabled/>.\n    sm.outbound = 0\n\n    try {\n      const response = await promiseEnable\n      sm.enabled = true\n      sm.id = response.attrs.id\n      sm.max = response.attrs.max\n      // eslint-disable-next-line no-unused-vars\n    } catch (err) {\n      sm.enabled = false\n    }\n\n    sm.inbound = 0\n  })\n\n  return sm\n}\n"]},"metadata":{},"sourceType":"script"}