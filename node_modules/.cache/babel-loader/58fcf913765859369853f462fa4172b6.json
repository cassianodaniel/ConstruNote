{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { Grammar } from \"../../grammar\";\nimport { headerize } from \"./utils\";\n/**\n * Incoming message.\n * @public\n */\n\nexport var IncomingMessage = /*#__PURE__*/function () {\n  function IncomingMessage() {\n    _classCallCheck(this, IncomingMessage);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.headers = {};\n  }\n  /**\n   * Insert a header of the given name and value into the last position of the\n   * header array.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  _createClass(IncomingMessage, [{\n    key: \"addHeader\",\n    value: function addHeader(name, value) {\n      var header = {\n        raw: value\n      };\n      name = headerize(name);\n\n      if (this.headers[name]) {\n        this.headers[name].push(header);\n      } else {\n        this.headers[name] = [header];\n      }\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n\n  }, {\n    key: \"getHeader\",\n    value: function getHeader(name) {\n      var header = this.headers[headerize(name)];\n\n      if (header) {\n        if (header[0]) {\n          return header[0].raw;\n        }\n      } else {\n        return;\n      }\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array - with all the headers of the specified name.\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders(name) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      var header = this.headers[headerize(name)];\n      var result = [];\n\n      if (!header) {\n        return [];\n      }\n\n      var _iterator = _createForOfIteratorHelper(header),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var headerPart = _step.value;\n          result.push(headerPart.raw);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n\n  }, {\n    key: \"hasHeader\",\n    value: function hasHeader(name) {\n      return !!this.headers[headerize(name)];\n    }\n    /**\n     * Parse the given header on the given index.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"parseHeader\",\n    value: function parseHeader(name) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      name = headerize(name);\n\n      if (!this.headers[name]) {\n        // this.logger.log(\"header '\" + name + \"' not present\");\n        return;\n      } else if (idx >= this.headers[name].length) {\n        // this.logger.log(\"not so many '\" + name + \"' headers present\");\n        return;\n      }\n\n      var header = this.headers[name][idx];\n      var value = header.raw;\n\n      if (header.parsed) {\n        return header.parsed;\n      } // substitute '-' by '_' for grammar rule matching.\n\n\n      var parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n\n      if (parsed === -1) {\n        this.headers[name].splice(idx, 1); // delete from headers\n        // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\n        return;\n      } else {\n        header.parsed = parsed;\n        return parsed;\n      }\n    }\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     *\n     * @example\n     * message.s('via',3).port\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"s\",\n    value: function s(name) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.parseHeader(name, idx);\n    }\n    /**\n     * Replace the value of the given header by the value.\n     * @param name - header name\n     * @param value - header value\n     */\n\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(name, value) {\n      this.headers[headerize(name)] = [{\n        raw: value\n      }];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data;\n    }\n  }]);\n\n  return IncomingMessage;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/incoming-message.js"],"names":["Grammar","headerize","IncomingMessage","headers","name","value","header","raw","push","result","headerPart","idx","length","parsed","parse","replace","splice","parseHeader","data"],"mappings":"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","sourcesContent":["import { Grammar } from \"../../grammar\";\nimport { headerize } from \"./utils\";\n/**\n * Incoming message.\n * @public\n */\nexport class IncomingMessage {\n    constructor() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.headers = {};\n    }\n    /**\n     * Insert a header of the given name and value into the last position of the\n     * header array.\n     * @param name - header name\n     * @param value - header value\n     */\n    addHeader(name, value) {\n        const header = { raw: value };\n        name = headerize(name);\n        if (this.headers[name]) {\n            this.headers[name].push(header);\n        }\n        else {\n            this.headers[name] = [header];\n        }\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0].raw;\n            }\n        }\n        else {\n            return;\n        }\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array - with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const header = this.headers[headerize(name)];\n        const result = [];\n        if (!header) {\n            return [];\n        }\n        for (const headerPart of header) {\n            result.push(headerPart.raw);\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        return !!this.headers[headerize(name)];\n    }\n    /**\n     * Parse the given header on the given index.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parseHeader(name, idx = 0) {\n        name = headerize(name);\n        if (!this.headers[name]) {\n            // this.logger.log(\"header '\" + name + \"' not present\");\n            return;\n        }\n        else if (idx >= this.headers[name].length) {\n            // this.logger.log(\"not so many '\" + name + \"' headers present\");\n            return;\n        }\n        const header = this.headers[name][idx];\n        const value = header.raw;\n        if (header.parsed) {\n            return header.parsed;\n        }\n        // substitute '-' by '_' for grammar rule matching.\n        const parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n        if (parsed === -1) {\n            this.headers[name].splice(idx, 1); // delete from headers\n            // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n            return;\n        }\n        else {\n            header.parsed = parsed;\n            return parsed;\n        }\n    }\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * @param name - header name\n     * @param idx - header index\n     * @returns Parsed header object, undefined if the\n     *   header is not present or in case of a parsing error.\n     *\n     * @example\n     * message.s('via',3).port\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    s(name, idx = 0) {\n        return this.parseHeader(name, idx);\n    }\n    /**\n     * Replace the value of the given header by the value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = [{ raw: value }];\n    }\n    toString() {\n        return this.data;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}