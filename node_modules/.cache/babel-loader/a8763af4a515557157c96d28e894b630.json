{"ast":null,"code":"import { formatOffset, parseZoneInfo, isUndefined, ianaRegex, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\nconst matchingRegex = RegExp(`^${ianaRegex.source}$`);\nlet dtfCache = {};\n\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  }\n\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n        parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n        [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date),\n        filled = [];\n\n  for (let i = 0; i < formatted.length; i++) {\n    const {\n      type,\n      value\n    } = formatted[i],\n          pos = typeToPos[type];\n\n    if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\n\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n\n    return ianaZoneCache[name];\n  }\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n\n\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n\n\n  static isValidSpecifier(s) {\n    return !!(s && s.match(matchingRegex));\n  }\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n\n\n  static isValidZone(zone) {\n    try {\n      new Intl.DateTimeFormat(\"en-US\", {\n        timeZone: zone\n      }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  } // Etc/GMT+8 -> -480\n\n  /** @ignore */\n\n\n  static parseGMTOffset(specifier) {\n    if (specifier) {\n      const match = specifier.match(/^Etc\\/GMT([+-]\\d{1,2})$/i);\n\n      if (match) {\n        return -60 * parseInt(match[1]);\n      }\n    }\n\n    return null;\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n\n    this.zoneName = name;\n    /** @private **/\n\n    this.valid = IANAZone.isValidZone(name);\n  }\n  /** @override **/\n\n\n  get type() {\n    return \"iana\";\n  }\n  /** @override **/\n\n\n  get name() {\n    return this.zoneName;\n  }\n  /** @override **/\n\n\n  get universal() {\n    return false;\n  }\n  /** @override **/\n\n\n  offsetName(ts, {\n    format,\n    locale\n  }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n  /** @override **/\n\n\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n  /** @override **/\n\n\n  offset(ts) {\n    const date = new Date(ts),\n          dtf = makeDTF(this.name),\n          [year, month, day, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),\n          // work around https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n    adjustedHour = hour === 24 ? 0 : hour;\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n  /** @override **/\n\n\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n  /** @override **/\n\n\n  get isValid() {\n    return this.valid;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/luxon/src/zones/IANAZone.js"],"names":["formatOffset","parseZoneInfo","isUndefined","ianaRegex","objToLocalTS","Zone","matchingRegex","RegExp","source","dtfCache","makeDTF","zone","Intl","DateTimeFormat","hour12","timeZone","year","month","day","hour","minute","second","typeToPos","hackyOffset","dtf","date","formatted","format","replace","parsed","exec","fMonth","fDay","fYear","fHour","fMinute","fSecond","partsOffset","formatToParts","filled","i","length","type","value","pos","parseInt","ianaZoneCache","IANAZone","create","name","resetCache","isValidSpecifier","s","match","isValidZone","e","parseGMTOffset","specifier","constructor","zoneName","valid","universal","offsetName","ts","locale","offset","Date","adjustedHour","asUTC","millisecond","asTS","over","equals","otherZone","isValid"],"mappings":"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","sourcesContent":["import { formatOffset, parseZoneInfo, isUndefined, ianaRegex, objToLocalTS } from \"../impl/util.js\";\nimport Zone from \"../zone.js\";\n\nconst matchingRegex = RegExp(`^${ianaRegex.source}$`);\n\nlet dtfCache = {};\nfunction makeDTF(zone) {\n  if (!dtfCache[zone]) {\n    dtfCache[zone] = new Intl.DateTimeFormat(\"en-US\", {\n      hour12: false,\n      timeZone: zone,\n      year: \"numeric\",\n      month: \"2-digit\",\n      day: \"2-digit\",\n      hour: \"2-digit\",\n      minute: \"2-digit\",\n      second: \"2-digit\"\n    });\n  }\n  return dtfCache[zone];\n}\n\nconst typeToPos = {\n  year: 0,\n  month: 1,\n  day: 2,\n  hour: 3,\n  minute: 4,\n  second: 5\n};\n\nfunction hackyOffset(dtf, date) {\n  const formatted = dtf.format(date).replace(/\\u200E/g, \"\"),\n    parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted),\n    [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed;\n  return [fYear, fMonth, fDay, fHour, fMinute, fSecond];\n}\n\nfunction partsOffset(dtf, date) {\n  const formatted = dtf.formatToParts(date),\n    filled = [];\n  for (let i = 0; i < formatted.length; i++) {\n    const { type, value } = formatted[i],\n      pos = typeToPos[type];\n\n    if (!isUndefined(pos)) {\n      filled[pos] = parseInt(value, 10);\n    }\n  }\n  return filled;\n}\n\nlet ianaZoneCache = {};\n/**\n * A zone identified by an IANA identifier, like America/New_York\n * @implements {Zone}\n */\nexport default class IANAZone extends Zone {\n  /**\n   * @param {string} name - Zone name\n   * @return {IANAZone}\n   */\n  static create(name) {\n    if (!ianaZoneCache[name]) {\n      ianaZoneCache[name] = new IANAZone(name);\n    }\n    return ianaZoneCache[name];\n  }\n\n  /**\n   * Reset local caches. Should only be necessary in testing scenarios.\n   * @return {void}\n   */\n  static resetCache() {\n    ianaZoneCache = {};\n    dtfCache = {};\n  }\n\n  /**\n   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.\n   * @param {string} s - The string to check validity on\n   * @example IANAZone.isValidSpecifier(\"America/New_York\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Fantasia/Castle\") //=> true\n   * @example IANAZone.isValidSpecifier(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidSpecifier(s) {\n    return !!(s && s.match(matchingRegex));\n  }\n\n  /**\n   * Returns whether the provided string identifies a real zone\n   * @param {string} zone - The string to check\n   * @example IANAZone.isValidZone(\"America/New_York\") //=> true\n   * @example IANAZone.isValidZone(\"Fantasia/Castle\") //=> false\n   * @example IANAZone.isValidZone(\"Sport~~blorp\") //=> false\n   * @return {boolean}\n   */\n  static isValidZone(zone) {\n    try {\n      new Intl.DateTimeFormat(\"en-US\", { timeZone: zone }).format();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  // Etc/GMT+8 -> -480\n  /** @ignore */\n  static parseGMTOffset(specifier) {\n    if (specifier) {\n      const match = specifier.match(/^Etc\\/GMT([+-]\\d{1,2})$/i);\n      if (match) {\n        return -60 * parseInt(match[1]);\n      }\n    }\n    return null;\n  }\n\n  constructor(name) {\n    super();\n    /** @private **/\n    this.zoneName = name;\n    /** @private **/\n    this.valid = IANAZone.isValidZone(name);\n  }\n\n  /** @override **/\n  get type() {\n    return \"iana\";\n  }\n\n  /** @override **/\n  get name() {\n    return this.zoneName;\n  }\n\n  /** @override **/\n  get universal() {\n    return false;\n  }\n\n  /** @override **/\n  offsetName(ts, { format, locale }) {\n    return parseZoneInfo(ts, format, locale, this.name);\n  }\n\n  /** @override **/\n  formatOffset(ts, format) {\n    return formatOffset(this.offset(ts), format);\n  }\n\n  /** @override **/\n  offset(ts) {\n    const date = new Date(ts),\n      dtf = makeDTF(this.name),\n      [year, month, day, hour, minute, second] = dtf.formatToParts\n        ? partsOffset(dtf, date)\n        : hackyOffset(dtf, date),\n      // work around https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat\n      adjustedHour = hour === 24 ? 0 : hour;\n\n    const asUTC = objToLocalTS({\n      year,\n      month,\n      day,\n      hour: adjustedHour,\n      minute,\n      second,\n      millisecond: 0\n    });\n\n    let asTS = +date;\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return (asUTC - asTS) / (60 * 1000);\n  }\n\n  /** @override **/\n  equals(otherZone) {\n    return otherZone.type === \"iana\" && otherZone.name === this.name;\n  }\n\n  /** @override **/\n  get isValid() {\n    return this.valid;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}