{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\Users\\\\Digivox\\\\dev\\\\Digivox\\\\Refatoracao\\\\squad\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\nimport { NameAddrHeader } from \"../../grammar\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils\";\n/**\n * Outgoing SIP request message.\n * @public\n */\n\nexport var OutgoingRequestMessage = /*#__PURE__*/function () {\n  function OutgoingRequestMessage(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n    _classCallCheck(this, OutgoingRequestMessage);\n\n    this.headers = {};\n    this.extraHeaders = []; // Initialize default options\n\n    this.options = OutgoingRequestMessage.getDefaultOptions(); // Options - merge a deep copy\n\n    if (options) {\n      this.options = Object.assign(Object.assign({}, this.options), options);\n\n      if (this.options.optionTags && this.options.optionTags.length) {\n        this.options.optionTags = this.options.optionTags.slice();\n      }\n\n      if (this.options.routeSet && this.options.routeSet.length) {\n        this.options.routeSet = this.options.routeSet.slice();\n      }\n    } // Extra headers - deep copy\n\n\n    if (extraHeaders && extraHeaders.length) {\n      this.extraHeaders = extraHeaders.slice();\n    } // Body - deep copy\n\n\n    if (body) {\n      // TODO: internal representation should be Body\n      // this.body = { ...body };\n      this.body = {\n        body: body.content,\n        contentType: body.contentType\n      };\n    } // Method\n\n\n    this.method = method; // RURI\n\n    this.ruri = ruri.clone(); // From\n\n    this.fromURI = fromURI.clone();\n    this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n    this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag); // To\n\n    this.toURI = toURI.clone();\n    this.toTag = this.options.toTag;\n    this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag); // Call-ID\n\n    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15); // CSeq\n\n    this.cseq = this.options.cseq; // The relative order of header fields with different field names is not\n    // significant.  However, it is RECOMMENDED that header fields which are\n    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n    // Max-Forwards, and Proxy-Authorization, for example) appear towards\n    // the top of the message to facilitate rapid parsing.\n    // https://tools.ietf.org/html/rfc3261#section-7.3.1\n\n    this.setHeader(\"route\", this.options.routeSet);\n    this.setHeader(\"via\", \"\");\n    this.setHeader(\"to\", this.to.toString());\n    this.setHeader(\"from\", this.from.toString());\n    this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n    this.setHeader(\"call-id\", this.callId);\n    this.setHeader(\"max-forwards\", \"70\");\n  }\n  /** Get a copy of the default options. */\n\n\n  _createClass(OutgoingRequestMessage, [{\n    key: \"getHeader\",\n\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    value: function getHeader(name) {\n      var header = this.headers[headerize(name)];\n\n      if (header) {\n        if (header[0]) {\n          return header[0];\n        }\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n        var _iterator = _createForOfIteratorHelper(this.extraHeaders),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var exHeader = _step.value;\n\n            if (regexp.test(exHeader)) {\n              return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return;\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array with all the headers of the specified name.\n     */\n\n  }, {\n    key: \"getHeaders\",\n    value: function getHeaders(name) {\n      var result = [];\n      var headerArray = this.headers[headerize(name)];\n\n      if (headerArray) {\n        var _iterator2 = _createForOfIteratorHelper(headerArray),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var headerPart = _step2.value;\n            result.push(headerPart);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n        var _iterator3 = _createForOfIteratorHelper(this.extraHeaders),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var exHeader = _step3.value;\n\n            if (regexp.test(exHeader)) {\n              result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n\n  }, {\n    key: \"hasHeader\",\n    value: function hasHeader(name) {\n      if (this.headers[headerize(name)]) {\n        return true;\n      } else {\n        var regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n        var _iterator4 = _createForOfIteratorHelper(this.extraHeaders),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var extraHeader = _step4.value;\n\n            if (regexp.test(extraHeader)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Replace the the given header by the given value.\n     * @param name - header name\n     * @param value - header value\n     */\n\n  }, {\n    key: \"setHeader\",\n    value: function setHeader(name, value) {\n      this.headers[headerize(name)] = value instanceof Array ? value : [value];\n    }\n    /**\n     * The Via header field indicates the transport used for the transaction\n     * and identifies the location where the response is to be sent.  A Via\n     * header field value is added only after the transport that will be\n     * used to reach the next hop has been selected (which may involve the\n     * usage of the procedures in [4]).\n     *\n     * When the UAC creates a request, it MUST insert a Via into that\n     * request.  The protocol name and protocol version in the header field\n     * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n     * contain a branch parameter.  This parameter is used to identify the\n     * transaction created by that request.  This parameter is used by both\n     * the client and the server.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n     * @param branchParameter - The branch parameter.\n     * @param transport - The sent protocol transport.\n     */\n\n  }, {\n    key: \"setViaHeader\",\n    value: function setViaHeader(branch, transport) {\n      // FIXME: Hack\n      if (this.options.hackViaTcp) {\n        transport = \"TCP\";\n      }\n\n      var via = \"SIP/2.0/\" + transport;\n      via += \" \" + this.options.viaHost + \";branch=\" + branch;\n\n      if (this.options.forceRport) {\n        via += \";rport\";\n      }\n\n      this.setHeader(\"via\", via);\n      this.branch = branch;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var msg = \"\";\n      msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n\n      for (var header in this.headers) {\n        if (this.headers[header]) {\n          var _iterator5 = _createForOfIteratorHelper(this.headers[header]),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var headerPart = _step5.value;\n              msg += header + \": \" + headerPart + \"\\r\\n\";\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this.extraHeaders),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _header = _step6.value;\n          msg += _header.trim() + \"\\r\\n\";\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n      msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n\n      if (this.body) {\n        if (typeof this.body === \"string\") {\n          msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n          msg += this.body;\n        } else {\n          if (this.body.body && this.body.contentType) {\n            msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n            msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n            msg += this.body.body;\n          } else {\n            msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n          }\n        }\n      } else {\n        msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n      }\n\n      return msg;\n    }\n  }], [{\n    key: \"getDefaultOptions\",\n    value: function getDefaultOptions() {\n      return {\n        callId: \"\",\n        callIdPrefix: \"\",\n        cseq: 1,\n        toDisplayName: \"\",\n        toTag: \"\",\n        fromDisplayName: \"\",\n        fromTag: \"\",\n        forceRport: false,\n        hackViaTcp: false,\n        optionTags: [\"outbound\"],\n        routeSet: [],\n        userAgentString: \"sip.js\",\n        viaHost: \"\"\n      };\n    }\n  }, {\n    key: \"makeNameAddrHeader\",\n    value: function makeNameAddrHeader(uri, displayName, tag) {\n      var parameters = {};\n\n      if (tag) {\n        parameters.tag = tag;\n      }\n\n      return new NameAddrHeader(uri, displayName, parameters);\n    }\n  }]);\n\n  return OutgoingRequestMessage;\n}();","map":{"version":3,"sources":["C:/Users/Digivox/dev/Digivox/Refatoracao/squad/node_modules/sip.js/lib/core/messages/outgoing-request-message.js"],"names":["NameAddrHeader","createRandomToken","headerize","newTag","utf8Length","OutgoingRequestMessage","method","ruri","fromURI","toURI","options","extraHeaders","body","headers","getDefaultOptions","Object","assign","optionTags","length","slice","routeSet","content","contentType","clone","fromTag","from","makeNameAddrHeader","fromDisplayName","toTag","to","toDisplayName","callId","callIdPrefix","cseq","setHeader","toString","name","header","regexp","RegExp","exHeader","test","substring","indexOf","trim","result","headerArray","headerPart","push","extraHeader","value","Array","branch","transport","hackViaTcp","via","viaHost","forceRport","msg","toRaw","join","userAgentString","uri","displayName","tag","parameters"],"mappings":"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","sourcesContent":["import { NameAddrHeader } from \"../../grammar\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils\";\n/**\n * Outgoing SIP request message.\n * @public\n */\nexport class OutgoingRequestMessage {\n    constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n        this.headers = {};\n        this.extraHeaders = [];\n        // Initialize default options\n        this.options = OutgoingRequestMessage.getDefaultOptions();\n        // Options - merge a deep copy\n        if (options) {\n            this.options = Object.assign(Object.assign({}, this.options), options);\n            if (this.options.optionTags && this.options.optionTags.length) {\n                this.options.optionTags = this.options.optionTags.slice();\n            }\n            if (this.options.routeSet && this.options.routeSet.length) {\n                this.options.routeSet = this.options.routeSet.slice();\n            }\n        }\n        // Extra headers - deep copy\n        if (extraHeaders && extraHeaders.length) {\n            this.extraHeaders = extraHeaders.slice();\n        }\n        // Body - deep copy\n        if (body) {\n            // TODO: internal representation should be Body\n            // this.body = { ...body };\n            this.body = {\n                body: body.content,\n                contentType: body.contentType\n            };\n        }\n        // Method\n        this.method = method;\n        // RURI\n        this.ruri = ruri.clone();\n        // From\n        this.fromURI = fromURI.clone();\n        this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n        this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag);\n        // To\n        this.toURI = toURI.clone();\n        this.toTag = this.options.toTag;\n        this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag);\n        // Call-ID\n        this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15);\n        // CSeq\n        this.cseq = this.options.cseq;\n        // The relative order of header fields with different field names is not\n        // significant.  However, it is RECOMMENDED that header fields which are\n        // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n        // Max-Forwards, and Proxy-Authorization, for example) appear towards\n        // the top of the message to facilitate rapid parsing.\n        // https://tools.ietf.org/html/rfc3261#section-7.3.1\n        this.setHeader(\"route\", this.options.routeSet);\n        this.setHeader(\"via\", \"\");\n        this.setHeader(\"to\", this.to.toString());\n        this.setHeader(\"from\", this.from.toString());\n        this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n        this.setHeader(\"call-id\", this.callId);\n        this.setHeader(\"max-forwards\", \"70\");\n    }\n    /** Get a copy of the default options. */\n    static getDefaultOptions() {\n        return {\n            callId: \"\",\n            callIdPrefix: \"\",\n            cseq: 1,\n            toDisplayName: \"\",\n            toTag: \"\",\n            fromDisplayName: \"\",\n            fromTag: \"\",\n            forceRport: false,\n            hackViaTcp: false,\n            optionTags: [\"outbound\"],\n            routeSet: [],\n            userAgentString: \"sip.js\",\n            viaHost: \"\"\n        };\n    }\n    static makeNameAddrHeader(uri, displayName, tag) {\n        const parameters = {};\n        if (tag) {\n            parameters.tag = tag;\n        }\n        return new NameAddrHeader(uri, displayName, parameters);\n    }\n    /**\n     * Get the value of the given header name at the given position.\n     * @param name - header name\n     * @returns Returns the specified header, undefined if header doesn't exist.\n     */\n    getHeader(name) {\n        const header = this.headers[headerize(name)];\n        if (header) {\n            if (header[0]) {\n                return header[0];\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Get the header/s of the given name.\n     * @param name - header name\n     * @returns Array with all the headers of the specified name.\n     */\n    getHeaders(name) {\n        const result = [];\n        const headerArray = this.headers[headerize(name)];\n        if (headerArray) {\n            for (const headerPart of headerArray) {\n                result.push(headerPart);\n            }\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const exHeader of this.extraHeaders) {\n                if (regexp.test(exHeader)) {\n                    result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Verify the existence of the given header.\n     * @param name - header name\n     * @returns true if header with given name exists, false otherwise\n     */\n    hasHeader(name) {\n        if (this.headers[headerize(name)]) {\n            return true;\n        }\n        else {\n            const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n            for (const extraHeader of this.extraHeaders) {\n                if (regexp.test(extraHeader)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Replace the the given header by the given value.\n     * @param name - header name\n     * @param value - header value\n     */\n    setHeader(name, value) {\n        this.headers[headerize(name)] = value instanceof Array ? value : [value];\n    }\n    /**\n     * The Via header field indicates the transport used for the transaction\n     * and identifies the location where the response is to be sent.  A Via\n     * header field value is added only after the transport that will be\n     * used to reach the next hop has been selected (which may involve the\n     * usage of the procedures in [4]).\n     *\n     * When the UAC creates a request, it MUST insert a Via into that\n     * request.  The protocol name and protocol version in the header field\n     * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n     * contain a branch parameter.  This parameter is used to identify the\n     * transaction created by that request.  This parameter is used by both\n     * the client and the server.\n     * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n     * @param branchParameter - The branch parameter.\n     * @param transport - The sent protocol transport.\n     */\n    setViaHeader(branch, transport) {\n        // FIXME: Hack\n        if (this.options.hackViaTcp) {\n            transport = \"TCP\";\n        }\n        let via = \"SIP/2.0/\" + transport;\n        via += \" \" + this.options.viaHost + \";branch=\" + branch;\n        if (this.options.forceRport) {\n            via += \";rport\";\n        }\n        this.setHeader(\"via\", via);\n        this.branch = branch;\n    }\n    toString() {\n        let msg = \"\";\n        msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n        for (const header in this.headers) {\n            if (this.headers[header]) {\n                for (const headerPart of this.headers[header]) {\n                    msg += header + \": \" + headerPart + \"\\r\\n\";\n                }\n            }\n        }\n        for (const header of this.extraHeaders) {\n            msg += header.trim() + \"\\r\\n\";\n        }\n        msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n        msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n        if (this.body) {\n            if (typeof this.body === \"string\") {\n                msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n                msg += this.body;\n            }\n            else {\n                if (this.body.body && this.body.contentType) {\n                    msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n                    msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n                    msg += this.body.body;\n                }\n                else {\n                    msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n                }\n            }\n        }\n        else {\n            msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n        }\n        return msg;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}